This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.devcontainer/
  devcontainer.json
  Dockerfile
  post-attach.sh
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    code-quality.yml
    golangci-lint.yml
    link-check.yml
    metrics.yml
    publish.yml
    release-please.yml
    stale.yaml
    test.yml
    testacc.yml
  FUNDING.yml
  PULL_REQUEST_TEMPLATE.md
  renovate.json5
  SECURITY.md
docs/
  data-sources/
    virtual_environment_acme_account.md
    virtual_environment_acme_accounts.md
    virtual_environment_acme_plugin.md
    virtual_environment_acme_plugins.md
    virtual_environment_apt_repository.md
    virtual_environment_apt_standard_repository.md
    virtual_environment_container.md
    virtual_environment_datastores.md
    virtual_environment_dns.md
    virtual_environment_group.md
    virtual_environment_groups.md
    virtual_environment_hagroup.md
    virtual_environment_hagroups.md
    virtual_environment_hardware_mapping_dir.md
    virtual_environment_hardware_mapping_pci.md
    virtual_environment_hardware_mapping_usb.md
    virtual_environment_hardware_mappings.md
    virtual_environment_haresource.md
    virtual_environment_haresources.md
    virtual_environment_hosts.md
    virtual_environment_metrics_server.md
    virtual_environment_node.md
    virtual_environment_nodes.md
    virtual_environment_pool.md
    virtual_environment_pools.md
    virtual_environment_role.md
    virtual_environment_roles.md
    virtual_environment_time.md
    virtual_environment_user.md
    virtual_environment_users.md
    virtual_environment_version.md
    virtual_environment_vm.md
    virtual_environment_vm2.md
    virtual_environment_vms.md
  guides/
    clone-vm.md
    cloud-image.md
    cloud-init.md
    setup-proxmox-for-tests.md
  resources/
    virtual_environment_acl.md
    virtual_environment_acme_account.md
    virtual_environment_acme_dns_plugin.md
    virtual_environment_apt_repository.md
    virtual_environment_apt_standard_repository.md
    virtual_environment_certificate.md
    virtual_environment_cluster_firewall_security_group.md
    virtual_environment_cluster_firewall.md
    virtual_environment_cluster_options.md
    virtual_environment_container.md
    virtual_environment_dns.md
    virtual_environment_download_file.md
    virtual_environment_file.md
    virtual_environment_firewall_alias.md
    virtual_environment_firewall_ipset.md
    virtual_environment_firewall_options.md
    virtual_environment_firewall_rules.md
    virtual_environment_group.md
    virtual_environment_hagroup.md
    virtual_environment_hardware_mapping_dir.md
    virtual_environment_hardware_mapping_pci.md
    virtual_environment_hardware_mapping_usb.md
    virtual_environment_haresource.md
    virtual_environment_hosts.md
    virtual_environment_metrics_server.md
    virtual_environment_network_linux_bridge.md
    virtual_environment_network_linux_vlan.md
    virtual_environment_pool.md
    virtual_environment_role.md
    virtual_environment_time.md
    virtual_environment_user_token.md
    virtual_environment_user.md
    virtual_environment_vm.md
    virtual_environment_vm2.md
  index.md
example/
  test-api-creds-auth/
    .gitignore
    api-creds-tester.sh
    data_object.tf
    example.tfrc
    main.tf
    variables.tf
    versions.tf
  data_source_virtual_environment_container.tf
  data_source_virtual_environment_datastores.tf
  data_source_virtual_environment_dns.tf
  data_source_virtual_environment_group.tf
  data_source_virtual_environment_groups.tf
  data_source_virtual_environment_hosts.tf
  data_source_virtual_environment_metrics_server.tf
  data_source_virtual_environment_node.tf
  data_source_virtual_environment_nodes.tf
  data_source_virtual_environment_pool.tf
  data_source_virtual_environment_pools.tf
  data_source_virtual_environment_role.tf
  data_source_virtual_environment_roles.tf
  data_source_virtual_environment_time.tf
  data_source_virtual_environment_user.tf
  data_source_virtual_environment_users.tf
  data_source_virtual_environment_vm.tf
  data_source_virtual_environment_vms.tf
  main.tf
  resource_virtual_environment_cluster_firewall_security_group.tf
  resource_virtual_environment_cluster_options.tf
  resource_virtual_environment_container.tf
  resource_virtual_environment_dns.tf
  resource_virtual_environment_download_file.tf
  resource_virtual_environment_file.tf
  resource_virtual_environment_firewall_alias.tf
  resource_virtual_environment_firewall_ipset.tf
  resource_virtual_environment_firewall_options.tf
  resource_virtual_environment_firewall_rules.tf
  resource_virtual_environment_group.tf
  resource_virtual_environment_hosts.tf
  resource_virtual_environment_metrics_server.tf
  resource_virtual_environment_pool.tf
  resource_virtual_environment_role.tf
  resource_virtual_environment_time.tf
  resource_virtual_environment_trunks.tf
  resource_virtual_environment_user.tf
  resource_virtual_environment_vm.tf
  ssh.tf
  variables.tf
  versions.tf
examples/
  data-sources/
    proxmox_virtual_environment_acme_account/
      data-source.tf
    proxmox_virtual_environment_acme_accounts/
      data-source.tf
    proxmox_virtual_environment_acme_plugin/
      data-source.tf
    proxmox_virtual_environment_acme_plugins/
      data-source.tf
    proxmox_virtual_environment_apt_repository/
      data-source.tf
    proxmox_virtual_environment_apt_standard_repository/
      data-source.tf
    proxmox_virtual_environment_hagroup/
      data-source.tf
    proxmox_virtual_environment_hagroups/
      data-source.tf
    proxmox_virtual_environment_hardware_mapping_dir/
      data-source.tf
    proxmox_virtual_environment_hardware_mapping_pci/
      data-source.tf
    proxmox_virtual_environment_hardware_mapping_usb/
      data-source.tf
    proxmox_virtual_environment_hardware_mappings/
      data-source.tf
    proxmox_virtual_environment_haresource/
      data-source.tf
    proxmox_virtual_environment_haresources/
      data-source.tf
    proxmox_virtual_environment_metrics_server/
      data-source.tf
    proxmox_virtual_environment_version/
      data-source.tf
  guides/
    clone-vm/
      clone.tf
      cloud-config.tf
      provider.tf
      template.tf
      variables.tf
    cloud-image/
      centos-qcow2/
        main.tf
        provider.tf
        variables.tf
      debian-from-storage/
        main.tf
        provider.tf
        variables.tf
      ubuntu-img/
        main.tf
        provider.tf
        variables.tf
    cloud-init/
      custom/
        cloud-config.tf
        main.tf
        provider.tf
        variables.tf
      native/
        main.tf
        provider.tf
        variables.tf
  provider/
    provider.tf
    variables.tf
  resources/
    proxmox_virtual_environment_acl/
      import.sh
      resource.tf
    proxmox_virtual_environment_acme_account/
      import.sh
      resource.tf
    proxmox_virtual_environment_acme_dns_plugin/
      import.sh
      resource.tf
    proxmox_virtual_environment_apt_repository/
      import.sh
      resource.tf
    proxmox_virtual_environment_apt_standard_repository/
      import.sh
      resource.tf
    proxmox_virtual_environment_cluster_options/
      import.sh
      resource.tf
    proxmox_virtual_environment_download_file/
      resource.tf
    proxmox_virtual_environment_hagroup/
      import.sh
      resource.tf
    proxmox_virtual_environment_hardware_mapping_dir/
      import.sh
      resource.tf
    proxmox_virtual_environment_hardware_mapping_pci/
      import.sh
      resource.tf
    proxmox_virtual_environment_hardware_mapping_usb/
      import.sh
      resource.tf
    proxmox_virtual_environment_haresource/
      import.sh
      resource.tf
    proxmox_virtual_environment_metrics_server/
      import.sh
      resource.tf
    proxmox_virtual_environment_network_linux_bridge/
      import.sh
      resource.tf
    proxmox_virtual_environment_network_linux_vlan/
      import.sh
      resource.tf
    proxmox_virtual_environment_user_token/
      import.sh
      resource.tf
  README.md
fwprovider/
  access/
    resource_acl_model.go
    resource_acl_test.go
    resource_acl.go
    resource_user_test.go
    resource_user_token.go
  attribute/
    attribute.go
  cluster/
    acme/
      datasource_acme_account.go
      datasource_acme_accounts.go
      datasource_acme_plugin.go
      datasource_acme_plugins.go
      plugin_model.go
      resource_acme_account.go
      resource_acme_dns_plugin.go
    ha/
      datasource_hagroup.go
      datasource_hagroups.go
      datasource_haresource.go
      datasource_haresources.go
      hagroup_model.go
      haresource_model.go
      resource_hagroup.go
      resource_haresource.go
      validators.go
    hardwaremapping/
      datasource_dir.go
      datasource_pci.go
      datasource_usb.go
      datasource.go
      errors.go
      models.go
      resource_dir.go
      resource_hardware_mapping_test.go
      resource_pci.go
      resource_usb.go
      shared.go
    metrics/
      datasource_metrics_server.go
      metrics_server_model.go
      resource_metrics_server_test.go
      resource_metrics_server.go
    options/
      resource_options_test.go
      resource_options.go
  config/
    datasource.go
    doc.go
    resource.go
  nodes/
    apt/
      datasource_repo.go
      datasource_standard_repo.go
      models.go
      repo_test.go
      resource_repo.go
      resource_standard_repo.go
    datastores/
      datasource_schema.go
      datasource_test.go
      datasource.go
      model.go
    network/
      resource_linux_bridge_test.go
      resource_linux_bridge.go
      resource_linux_vlan_test.go
      resource_linux_vlan.go
    vm/
      cdrom/
        model.go
        resource_schema.go
        resource_test.go
        resource.go
      cpu/
        datasource_schema.go
        model.go
        resource_schema.go
        resource_test.go
        resource.go
      rng/
        datasource_schema.go
        model.go
        resource_schema.go
        resource_test.go
        resource.go
      vga/
        datasource_schema.go
        model.go
        resource_schema.go
        resource_test.go
        resource.go
      concurrency_test.go
      datasource_schema.go
      datasource.go
      model.go
      resource_schema.go
      resource_test.go
      resource.go
    resource_download_file_test.go
    resource_download_file.go
  test/
    datasource_node_test.go
    datasource_version_test.go
    resource_container_test.go
    resource_file_test.go
    resource_firewall_test.go
    resource_time_test.go
    resource_vm_cdrom_test.go
    resource_vm_disks_test.go
    resource_vm_test.go
    test_environment.go
    test_support.go
  types/
    hardwaremapping/
      path_test.go
      path.go
    nodes/
      apt/
        errors.go
        standard_repo_handle_test.go
        standard_repo_handle.go
    stringset/
      attribute.go
      options.go
      type.go
      value.go
    ip_addr_test.go
    ip_addr_value.go
    ip_addr.go
    ip_cidr_test.go
    ip_cidr_value.go
    ip_cidr.go
  validators/
    file.go
    hardware_mapping.go
    i18n.go
    parse_validator.go
    strings.go
  datasource_version.go
  provider_test.go
  provider.go
proxmox/
  access/
    acl_types.go
    acl.go
    client.go
    groups_types.go
    groups.go
    roles_types.go
    roles.go
    user_token_types.go
    user_token.go
    users_types.go
    users.go
  api/
    authenticator.go
    client_test.go
    client_types.go
    client.go
    credentials.go
    errors.go
    ticket_auth_types.go
    ticket_auth.go
    token_auth.go
    user_auth.go
  cluster/
    acme/
      account/
        acme_account_types.go
        acme_account.go
        client.go
      plugins/
        acme_plugins_types.go
        acme_plugins.go
        client.go
      client.go
    firewall/
      client.go
      options_types.go
      options.go
      security_groups_types.go
      security_groups.go
    ha/
      groups/
        client.go
        hagroups_types.go
        hagroups.go
      resources/
        api.http
        client.go
        http-client.env.json
        http-client.private.env.json
        resources_types.go
        resources.go
      client.go
    mapping/
      client.go
      mapping.go
      types.go
    metrics/
      client.go
      server_types.go
      server.go
    client.go
    cluster_types.go
    cluster.go
    id_generator.go
    options_types.go
    options.go
  firewall/
    aliases_types.go
    aliases.go
    client.go
    ipset_types.go
    ipset.go
    options_types.go
    options.go
    rules_types.go
    rules.go
  helpers/
    ptr/
      ptr.go
  nodes/
    apt/
      repositories/
        repositories.go
        types.go
      client.go
    containers/
      firewall/
        client.go
      client.go
      containers_types.go
      containers.go
    storage/
      client.go
      content_types.go
      content.go
      download_url_types.go
      download_url.go
      status_types.go
      status.go
      storage_types.go
      storage.go
      upload_types.go
      upload.go
    tasks/
      client.go
      tasks_types_test.go
      tasks_types.go
      tasks.go
    vms/
      firewall/
        client.go
      client.go
      custom_agent.go
      custom_amdsev.go
      custom_audio_device.go
      custom_boot.go
      custom_cloud_init.go
      custom_cpu_emulation.go
      custom_efi_disk.go
      custom_network_device.go
      custom_numa_device_test.go
      custom_numa_device.go
      custom_pci_device_test.go
      custom_pci_device.go
      custom_rng_device_test.go
      custom_rng_device.go
      custom_serial_device.go
      custom_shared_memory.go
      custom_smbios.go
      custom_spice_enhancements.go
      custom_startup_order.go
      custom_storage_device_test.go
      custom_storage_device.go
      custom_tpm_state.go
      custom_usb_device_test.go
      custom_usb_device.go
      custom_vga_device.go
      custom_virtiofs_share_test.go
      custom_virtiofs_share.go
      custom_virtualio_device.go
      custom_watchdog_device.go
      vms_types_test.go
      vms_types.go
      vms.go
    certificate_types.go
    certificate.go
    client.go
    config_types_test.go
    config_types.go
    config.go
    dns_types.go
    dns.go
    hosts_types.go
    hosts.go
    network_types.go
    network.go
    nodes_types.go
    nodes.go
    query_url_metadata_types.go
    query_url_metadata.go
  pools/
    client.go
    pool_types.go
    pool.go
  ssh/
    client_notwindows.go
    client_windows.go
    client.go
    resolver.go
  storage/
    client.go
    storage_types.go
    storage.go
  types/
    hardwaremapping/
      device_id.go
      errors.go
      id.go
      map.go
      type.go
    nodes/
      apt/
        repositories/
          ceph_version_name.go
          errors.go
          standard_repo_file_path.go
          standard_repo_handle_kind.go
    common_types.go
    disk_size_test.go
    disk_size.go
    ha_resource_id_test.go
    ha_resource_id.go
    ha_resource_state_test.go
    ha_resource_state.go
    ha_resource_type_test.go
    ha_resource_type.go
  version/
    client.go
    version_types.go
    version.go
  client.go
proxmoxtf/
  datasource/
    container_test.go
    container.go
    dns_test.go
    dns.go
    group_test.go
    group.go
    groups_test.go
    groups.go
    hosts_test.go
    hosts.go
    node.go
    nodes_test.go
    nodes.go
    pool_test.go
    pool.go
    pools_test.go
    pools.go
    role_test.go
    role.go
    roles_test.go
    roles.go
    time_test.go
    time.go
    user_test.go
    user.go
    users_test.go
    users.go
    vm_test.go
    vm.go
    vms_test.go
    vms.go
  provider/
    datasources.go
    provider_test.go
    provider.go
    resources.go
    schema.go
  resource/
    cluster/
      firewall/
        firewall.go
        security_group_test.go
        security_group.go
    container/
      container_test.go
      container.go
      validators.go
    firewall/
      alias_test.go
      alias.go
      ipset_test.go
      ipset.go
      options_test.go
      options.go
      rules_test.go
      rules.go
      selector.go
    validators/
      file_test.go
      file.go
      firewall.go
      network_test.go
      network.go
    vm/
      disk/
        disk.go
        schema_test.go
        schema.go
      network/
        network.go
        schema_test.go
        schema.go
      validators_test.go
      validators.go
      vm_test.go
      vm.go
    certificate_test.go
    certificate.go
    dns_test.go
    dns.go
    file_test.go
    file.go
    group_test.go
    group.go
    hosts_test.go
    hosts.go
    pool_test.go
    pool.go
    role_test.go
    role.go
    time_test.go
    time.go
    user_test.go
    user.go
  structure/
    schema.go
  test/
    utils.go
  config.go
templates/
  data-sources/
    virtual_environment_vm2.md.tmpl
  guides/
    clone-vm.md.tmpl
    cloud-image.md.tmpl
    cloud-init.md.tmpl
    setup-proxmox-for-tests.md.tmpl
  resources/
    virtual_environment_download_file.md.tmpl
    virtual_environment_vm2.md.tmpl
  data-sources.md.tmpl
  resources.md.tmpl
utils/
  env.go
  io_test.go
  io.go
  maps_test.go
  maps.go
  sets_test.go
  sets.go
  strings.go
.all-contributorsrc
.gitignore
.golangci.yml
.goreleaser.yaml
.lycheeignore
.markdownlint.json
.markdownlintignore
.release-please-manifest.json
CHANGELOG.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
CONTRIBUTORS.md
example.tfrc
go.mod
HISTORY.md
LICENSE
main.go
Makefile
qodana.yaml
README.md
release-please-config.json
terraform-registry-manifest.json
testacc
```

# Files

## File: .devcontainer/devcontainer.json
`````json
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/universal
{
	"name": "Default Linux Universal",
	// Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
	"dockerFile": "Dockerfile",
    
	// Features to add to the dev container. More info: https://containers.dev/features.
	"features": {
		"ghcr.io/devcontainers/features/terraform:1": {}
	},

	"mounts": [
        // Zsh commands history persistence
        {
            "source": "${localEnv:HOME}/.zsh_history",
            "target": "/root/.zsh_history",
            "type": "bind"
        },
        // Git configuration file
        {
            "source": "${localEnv:HOME}/.gitconfig",
            "target": "/root/.gitconfig",
            "type": "bind"
        },
        // SSH directory for Linux, OSX and WSL
        // On Linux and OSX, a symlink /mnt/ssh <-> ~/.ssh is
        // created in the container. On Windows, files are copied
        // from /mnt/ssh to ~/.ssh to fix permissions.
        {
            "source": "${localEnv:HOME}/.ssh",
            "target": "/mnt/ssh",
            "type": "bind"
        },
        // Docker socket to access the host Docker server
        {
            "source": "/var/run/docker.sock",
            "target": "/var/run/docker.sock",
            "type": "bind"
        }
    ],

	// Use 'forwardPorts' to make a list of ports inside the container available locally.
	// "forwardPorts": [],

	// Configure tool-specific properties.
    "customizations": {
        // Configure properties specific to VS Code.
        "vscode": {
            // Set *default* container specific settings.json values on container create.
            "settings": {
                "go.toolsManagement.checkForUpdates": "local",
                "go.useLanguageServer": true
            },
            // Add the IDs of extensions you want installed when the container is created.
            "extensions": [
                "britesnow.vscode-toggle-quotes",
                "davidanson.vscode-markdownlint",
                "EditorConfig.editorconfig",
                "golang.go",
                "hashicorp.terraform",
                "joshbolduc.commitlint",
                "ms-azuretools.vscode-docker",
                "ms-vscode.makefile-tools",
                "psioniq.psi-header"
            ]
        }
    },
	
	// Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
	"remoteUser": "root",

    "postAttachCommand": ["bash", "./.devcontainer/post-attach.sh"],
		
	// Use 'postCreateCommand' to run commands after the container is created.
	"postCreateCommand": "make build"
}
`````

## File: .devcontainer/Dockerfile
`````
FROM golang:1.24.4@sha256:db5d0afbfb4ab648af2393b92e87eaae9ad5e01132803d80caef91b5752d289c

ARG GOLANGCI_LINT_VERSION=2.1.6 # renovate: depName=golangci/golangci-lint datasource=github-releases

RUN apt update && apt upgrade -y && \
    apt-get install --no-install-recommends -y ca-certificates curl gnupg lsb-release jq zsh neovim gh && \
    chsh -s $(which zsh) && \
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" && \
    rm -rf /var/lib/apt/lists/*

RUN curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/HEAD/install.sh | sh -s -- -b $(go env GOPATH)/bin v${GOLANGCI_LINT_VERSION}


RUN  curl --proto '=https' --tlsv1.2 -fsSL https://get.opentofu.org/install-opentofu.sh -o install-opentofu.sh && \
     chmod +x install-opentofu.sh && \
     ./install-opentofu.sh --install-method deb && \
    rm -f install-opentofu.sh
`````

## File: .devcontainer/post-attach.sh
`````bash
#!/usr/bin/env bash

# Display welcome banner
echo -e "\033[1;36m"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo 
echo "  üöÄ Terraform Provider For Proxmox Development Environment"
echo 
echo "  ‚ö†Ô∏è EXPERIMENTAL"
echo "     Use at your own risk! Some tools may be missing or not work as expected."
echo 
echo "  ‚Ä¢ Go Version: $(go version | cut -d' ' -f3 | sed 's/^go//')"
echo "  ‚Ä¢ Terraform Version: $(terraform version -json | jq -r '.terraform_version')"
echo "  ‚Ä¢ OpenTofu Version: $(tofu version -json | jq -r '.terraform_version')"
echo "  ‚Ä¢ Working Directory: $(pwd)"
echo 
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo -e "\033[0m"

# Workaround for https://github.com/orgs/community/discussions/75161
unset GIT_COMMITTER_NAME
unset GIT_COMMITTER_EMAIL

cat <<EOF > ~/.terraformrc
provider_installation {

  dev_overrides {
      "bpg/proxmox" = "${GOPATH}/bin/"
  }

  # For all other providers, install them directly from their origin provider
  # registries as normal. If you omit this, Terraform will _only_ use
  # the dev_overrides block, and so no other providers will be available.
  direct {}
}
EOF
`````

## File: .github/ISSUE_TEMPLATE/bug_report.md
`````markdown
---
name: Bug report
about: Create a report to help us improve
title: ""
labels: ':bug: bug'
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:

1. Create a resource '....'
2. Run '....'
3. See error
4. Modify the resource '....'
5. Run '....'
6. See error

Please also provide a minimal Terraform configuration that reproduces the issue.

```hcl

# >>> put your example here <<< #

```

and the output of `terraform|tofu apply`.
```text

```


**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Additional context**
Add any other context about the problem here.

- Single or clustered Proxmox:
- Proxmox version:
- Provider version (ideally it should be the latest version):
- Terraform/OpenTofu version:
- OS (where you run Terraform/OpenTofu from):
- Debug logs (`TF_LOG=DEBUG terraform apply`):
`````

## File: .github/ISSUE_TEMPLATE/feature_request.md
`````markdown
---
name: Feature request
about: Suggest an idea for this project
title: ""
labels: ':sparkles: enhancement'
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when <...>

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
`````

## File: .github/workflows/code-quality.yml
`````yaml
name: Qodana
on:
  workflow_dispatch:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize]

jobs:
  qodana:
    runs-on: ubuntu-24.04
    if: github.event.pull_request.head.repo.owner.login == 'bpg' || github.event.ref == 'refs/heads/main'
    permissions:
      contents: write
      pull-requests: write
      checks: write
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}  # to check out the actual pull request commit, not the merge commit
          fetch-depth: 0  # a full history is required for pull request analysis
      - name: 'Qodana Scan'
        uses: JetBrains/qodana-action@e14351bdf4707c4cecc25a86a9190745b7b40de8 # v2025.1.1
        with:
          post-pr-comment: false
        env:
          QODANA_TOKEN: ${{ secrets.QODANA_TOKEN }}
`````

## File: .github/workflows/golangci-lint.yml
`````yaml
name: Linter

on:
  push:
    tags:
      - v*
    branches:
      - main
  pull_request:
permissions:
  contents: read
  pull-requests: read

jobs:
  golangci-lint:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 0

      - name: Filter paths
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: filter
        with:
          filters: |
            go:
              - '**/*.go'
            linter:
              - .github/workflows/golangci-lint.yml

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        if: ${{ steps.filter.outputs.go == 'true' || steps.filter.outputs.linter == 'true'}}
        with:
          go-version-file: "go.mod"
          cache-dependency-path: |
            go.sum

      - name: Lint code
        if: ${{ steps.filter.outputs.go == 'true' || steps.filter.outputs.linter == 'true'}}
        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8
        with: 
          version: v2.1.6 # renovate: depName=golangci/golangci-lint datasource=github-releases
          skip-cache: true
          args: -v --timeout=10m
`````

## File: .github/workflows/link-check.yml
`````yaml
name: "Link Check"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 0"

jobs:
  link-check:
    runs-on: ubuntu-24.04
    steps:
      - name: Generate Short Lived OAuth App Token
        uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2.0.6
        id: app-token
        with:
          app-id: "${{ secrets.BOT_APP_ID }}"
          private-key: "${{ secrets.BOT_APP_PRIVATE_KEY }}"
          owner: "${{ github.repository_owner }}"
          repositories: "${{ github.event.repository.name }}"

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Link Checker
        uses: lycheeverse/lychee-action@82202e5e9c2f4ef1a55a3d02563e1cb6041e5332 # v2.4.1
        id: lychee
        env:
          GITHUB_TOKEN: "${{ steps.app-token.outputs.token }}"
        with:
          args: --base . --verbose --no-progress './**/*.md' './**/*.html' --exclude-path ./CONTRIBUTORS.md --exclude-path ./CHANGELOG.md

      - name: Find Link Checker Issue
        id: link-checker-issue
        uses: micalevisk/last-issue-action@0d40124cc99ac8601c2516007f0c98ef3d27537b # v2.3.0
        if: steps.lychee.outputs.exit_code != 0
        with:
          state: open
          labels: |
            broken-links

      - name: Update Issue
        uses: peter-evans/create-issue-from-file@e8ef132d6df98ed982188e460ebb3b5d4ef3a9cd # v5.0.1
        if: steps.lychee.outputs.exit_code != 0
        with:
          title: Broken links detected üîó
          issue-number: "${{ steps.link-checker-issue.outputs.issue-number }}"
          content-filepath: ./lychee/out.md
          token: "${{ steps.app-token.outputs.token }}"
          labels: |
            broken-links
`````

## File: .github/workflows/metrics.yml
`````yaml
name: Publish Metrics

on:
  schedule:
    - cron: "0 0 * * *" # every day at 00:00 UTC (8pm EST)
  workflow_dispatch:
  push:
    branches:
      - "main"

jobs:
  github-metrics:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - name: Generate Metrics
        uses: lowlighter/metrics@65836723097537a54cd8eb90f61839426b4266b6 # v3.34
        with:
          template: repository
          filename: metrics.svg
          user: bpg
          repo: terraform-provider-proxmox
          token: "${{ secrets.METRICS_TOKEN }}"
          output_action: gist
          committer_gist: 2cc44ead81225542ed1ef0303d8f9eb9
          plugin_lines: yes
          plugin_followup: yes
          plugin_stargazers: yes
          plugin_stargazers_days: 365
          plugin_stargazers_charts_type: graph
`````

## File: .github/workflows/publish.yml
`````yaml
# This GitHub action can publish assets for release when a tag is created.
# Currently its setup to run on any tag that matches the pattern "v*" (ie. v0.1.0).
#
# This uses an action (crazy-max/ghaction-import-gpg) that assumes you set your
# private key in the `GPG_PRIVATE_KEY` secret and passphrase in the `PASSPHRASE`
# secret. If you would rather own your own GPG handling, please fork this action
# or use an alternative one for key handling.
#
name: Publish Release

on:
  push:
    tags:
      - "v*"

permissions:
  id-token: write
  contents: read
  attestations: write

jobs:
  goreleaser:
    runs-on: ubuntu-24.04
    steps:
      - name: Generate Short Lived OAuth App Token
        uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2.0.6
        id: app-token
        with:
          app-id: "${{ secrets.BOT_APP_ID }}"
          private-key: "${{ secrets.BOT_APP_PRIVATE_KEY }}"
          owner: "${{ github.repository_owner }}"
          repositories: "${{ github.event.repository.name }}"

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 0

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6.3.0
        with:
          gpg_private_key: "${{ secrets.GPG_PRIVATE_KEY }}"
          passphrase: "${{ secrets.PASSPHRASE }}"

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@9c156ee8a17a598857849441385a2041ef570552 # v6.3.0
        with:
          version: '~> v2'
          args: release --clean
        env:
          GPG_FINGERPRINT: "${{ steps.import_gpg.outputs.fingerprint }}"
          GITHUB_TOKEN: "${{ steps.app-token.outputs.token }}"

      - name: Attest
        uses: actions/attest-build-provenance@db473fddc028af60658334401dc6fa3ffd8669fd # v2
        with:
          subject-path: ./dist/*.zip
        env:
          GITHUB_TOKEN: "${{ steps.app-token.outputs.token }}"
`````

## File: .github/workflows/release-please.yml
`````yaml
name: Release Please

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

jobs:
  release-please:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    steps:
      - name: Generate Short Lived OAuth App Token
        uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2.0.6
        id: app-token
        with:
          app-id: "${{ secrets.BOT_APP_ID }}"
          private-key: "${{ secrets.BOT_APP_PRIVATE_KEY }}"
          owner: "${{ github.repository_owner }}"
          repositories: "${{ github.event.repository.name }}"

      - name: Create / Update Release PR
        uses: googleapis/release-please-action@a02a34c4d625f9be7cb89156071d8567266a2445 # v4.2.0
        with:
          token: "${{ steps.app-token.outputs.token }}"
`````

## File: .github/workflows/stale.yaml
`````yaml
name: Manage Stale Items

on:
  schedule:
    - cron: 00 00 * * *

jobs:
  stale:
    runs-on: ubuntu-24.04
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Generate Short Lived OAuth App Token
        uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2.0.6
        id: app-token
        with:
          app-id: "${{ secrets.BOT_APP_ID }}"
          private-key: "${{ secrets.BOT_APP_PRIVATE_KEY }}"
          owner: "${{ github.repository_owner }}"
          repositories: "${{ github.event.repository.name }}"

      - name: Stale Issues and Pull Requests
        uses: actions/stale@5bef64f19d7facfb25b37b414482c7164d639639 # v9
        with:
          repo-token: "${{ steps.app-token.outputs.token }}"
          days-before-stale: 180
          days-before-close: 30
          exempt-issue-labels: "needs-triage, acknowledged, in-progress"
          exempt-pr-labels: "needs-review, under-review, acknowledged, planned"
          remove-stale-when-updated: true
          delete-branch: false
          stale-issue-label: stale
          stale-issue-message: >
            Marking this issue as stale due to inactivity in the past 180 days.
            This helps us focus on the active issues. If this issue is
            reproducible with the [latest](https://github.com/bpg/terraform-provider-proxmox/releases/latest)
            version of the provider, please comment. If this issue receives no
            comments in the next 30 days it will automatically be closed.
            If this issue was automatically closed and you feel this issue
            should be reopened, we encourage creating a new issue linking back
            to this one for added context. Thank you!
          stale-pr-label: stale
          stale-pr-message: >
            Marking this pull request as stale due to inactivity in the past
            180 days. This helps us focus on the active pull requests. If this
            pull request receives no comments in the next 30 days it will 
            automatically be closed.
            If this pull request was automatically closed and you feel this
            pull request should be reopened, we encourage creating a new pull
            request linking back to this one for added context. Thank you!
`````

## File: .github/workflows/test.yml
`````yaml
name: Tests

on:
  pull_request: {}
  push:
    branches:
      - main

jobs:
  build:
    name: Build
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 1

      - name: Filter paths
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: filter
        with:
          filters: |
            go:
              - '**/*.go'

      - name: Setup Go
        if: ${{ steps.filter.outputs.go == 'true' }}
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "**/*.sum"

      - name: Get dependencies
        if: ${{ steps.filter.outputs.go == 'true' }}
        run: go mod download

      - name: Build
        if: ${{ steps.filter.outputs.go == 'true' }}
        run: go vet . && go build -v .

  test:
    name: Unit Tests
    needs: build
    runs-on: ubuntu-24.04
    steps:
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "$GITHUB_CONTEXT"

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 1

      - name: Filter paths
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: filter
        with:
          filters: |
            go:
              - '**/*.go'

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "**/*.sum"

      - name: Get dependencies
        if: ${{ steps.filter.outputs.go == 'true' }}
        run: go mod download

      - name: Set up gotestfmt
        run: go install github.com/gotesttools/gotestfmt/v2/cmd/gotestfmt@latest

      - name: Unit tests
        if: ${{ steps.filter.outputs.go == 'true' }}
        timeout-minutes: 10
        run: go test -json -v ./... 2>&1 | tee /tmp/gotest.log | gotestfmt -hide empty-packages

      - name: Upload test log
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        if: ${{ steps.filter.outputs.go == 'true' }}
        with:
          name: test-log
          path: /tmp/gotest.log

      - uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3

      - name: Check for uncommitted changes in generated docs
        run: make docs && git diff --exit-code
`````

## File: .github/workflows/testacc.yml
`````yaml
name: Acceptance Tests

on:
  workflow_dispatch:
    inputs:
      ref:
        description: 'Branch or tag to run tests against'
        required: true
        default: 'main'

jobs:
  acceptance:
    strategy:
      fail-fast: false
      matrix:
        terraform: [ 1.6 ]
        os: [ ubuntu-24.04, windows-latest, macos-latest ]
        include:
          - os: ubuntu-24.04
            node: pve1
            port: 13451
          - os: windows-latest
            node: pve2
            port: 13452
          - os: macos-latest
            node: pve3
            port: 13453
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    environment: pve-acc
    steps:
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "$GITHUB_CONTEXT"

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 1
          ref: ${{ github.event.inputs.ref || github.ref}}

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "**/*.sum"

      - name: Get dependencies
        run: go mod download

      - name: Set up gotestfmt
        run: go install github.com/gotesttools/gotestfmt/v2/cmd/gotestfmt@latest

      - uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3.1.2
        with:
          terraform_version: ${{ matrix.terraform }}.*
          terraform_wrapper: false

      - name: Acceptance tests
        timeout-minutes: 30
        env:
          TF_ACC: 1
          PROXMOX_VE_INSECURE: false
          PROXMOX_VE_API_TOKEN: "${{ secrets.PROXMOX_VE_API_TOKEN }}"
          PROXMOX_VE_ENDPOINT: "https://${{ secrets.PROXMOX_VE_HOST }}:8006/"
          PROXMOX_VE_SSH_AGENT: false
          PROXMOX_VE_SSH_USERNAME: "terraform"
          PROXMOX_VE_SSH_PRIVATE_KEY: "${{ secrets.PROXMOX_VE_SSH_PRIVATE_KEY }}"
          PROXMOX_VE_ACC_NODE_NAME: ${{ matrix.node }}
          PROXMOX_VE_ACC_NODE_SSH_ADDRESS: ${{ secrets.PROXMOX_VE_HOST }}
          PROXMOX_VE_ACC_NODE_SSH_PORT: ${{ matrix.port }}
          PROXMOX_VE_ACC_CLOUD_IMAGES_SERVER: ${{ secrets.PROXMOX_VE_ACC_CLOUD_IMAGES_SERVER }}
          PROXMOX_VE_ACC_CONTAINER_IMAGES_SERVER: ${{ secrets.PROXMOX_VE_ACC_CONTAINER_IMAGES_SERVER }}
        run:
          go test -json --timeout=30m --tags=acceptance -count=1 -v github.com/bpg/terraform-provider-proxmox/fwprovider/... 2>&1 | tee ${{ runner.temp }}/gotest-${{ matrix.os }}.log | gotestfmt -hide empty-packages

      - name: Upload test log
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        if: always()
        with:
          name: test-log-${{ matrix.os }}
          path: ${{ runner.temp }}/gotest-${{ matrix.os }}.log
`````

## File: .github/FUNDING.yml
`````yaml
# These are supported funding model platforms

github: bpg
`````

## File: .github/PULL_REQUEST_TEMPLATE.md
`````markdown
### Contributor's Note
<!--- 
Please mark the following items with an [x] if they apply to your PR.
Leave the [ ] if they are not applicable, or if you have not completed the item.
--->
- [ ] I have added / updated documentation in `/docs` for any user-facing features or additions.
- [ ] I have added / updated acceptance tests in `/fwprovider/tests` for any new or updated resources / data sources.
- [ ] I have ran `make example` to verify that the change works as expected.

<!---
You can find more information about coding conventions and local testing in the [CONTRIBUTING.md](https://github.com/bpg/terraform-provider-proxmox/blob/main/CONTRIBUTING.md) file.

If you are unsure how to run `make example`, see [Deploying the example resources](https://github.com/bpg/terraform-provider-proxmox?tab=readme-ov-file#deploying-the-example-resources) section in README.
--->

<!--
*IF* your code contains breaking changes make sure to add `!` to the end of commit type, e.g.:
```
    feat(vm)!: add support for new feature 
```
Also, uncomment the section just below, and add a description of the breaking change. 
--->

<!---
#### ‚ö† BREAKING CHANGES

>>> Put your description here <<<
--->

### Proof of Work
<!--- 
Please add screenshots, logs, or other relevant information that demonstrates the change works as expected.
--->

<!--- Please keep this note for the community --->
### Community Note

- Please vote on this pull request by adding a üëç [reaction](https://blog.github.com/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/) to the original pull request comment to help the community and maintainers prioritize this request
- Please do not leave "+1" or other comments that do not add relevant new information or questions, they generate extra noise for pull request followers and do not help prioritize the request
<!--- Thank you for keeping this note for the community --->

<!--- If your PR fully resolves and should automatically close the linked issue, use Closes. Otherwise, use Relates --->
Closes #0000 | Relates #0000

<!--- Release note for [CHANGELOG](https://github.com/bpg/terraform-provider-proxmox/blob/main/CHANGELOG.md) will be created automatically using the PR's title, update it accordingly. --->
`````

## File: .github/renovate.json5
`````json5
{
  $schema: 'https://docs.renovatebot.com/renovate-schema.json',
  extends: [
    'github>bpg/renovate-config',
    'github>bpg/renovate-config:automerge-github-actions',
    ':semanticCommitTypeAll(chore)',
  ],
  postUpdateOptions: [
    'gomodTidy',
    'gomodUpdateImportPaths',
  ],
  ignorePaths: [
    'howtos/**',
  ],
  rebaseWhen: 'behind-base-branch',
  packageRules: [
    {
      semanticCommitScope: 'deps',
      matchPackageNames: [
        '*',
      ],
    },
    {
      groupName: 'github.com/hashicorp/terraform-plugin-*',
      matchPackageNames: [
        'github.com/hashicorp/terraform-plugin-{/,}**',
      ],
    },
    {
      matchFileNames: [
        'examples/**',
        'example/**',
        'docs/**',
      ],
      semanticCommitScope: 'docs',
      automerge: true,
      automergeType: 'branch',
      matchUpdateTypes: [
        'minor',
        'patch',
      ],
    },
    {
      matchManagers: [
        'github-actions',
      ],
      semanticCommitScope: 'ci',
    },
    {
      matchUpdateTypes: [
        'major',
      ],
      commitMessagePrefix: '{{semanticCommitType}}({{semanticCommitScope}}):',
    },
  ],
}
`````

## File: .github/SECURITY.md
`````markdown
# Security Policy

## Supported Versions

We release patches for security vulnerabilities for the following versions:

| Version                           | Supported          |
|-----------------------------------|--------------------|
| Latest release                    | :white_check_mark: |
| Previous minor release            | :white_check_mark: |
| Older than previous minor release | :x:                |

## Reporting a Vulnerability

We take the security of the Terraform Provider for Proxmox and its users seriously. If you believe you have found a security vulnerability, please report it to us privately.

**Please do not report security vulnerabilities through public GitHub issues, discussions, or pull requests.**

Instead, please send an email to [bpg.github.com.tn75g@passmail.net](mailto:bpg.github.com.tn75g@passmail.net) or report it through GitHub's Security Advisory feature:

1. Go to <https://github.com/bpg/terraform-provider-proxmox/security/advisories/new>
2. Provide a descriptive title
3. Fill in a detailed description of the issue
4. Click "Submit report"

Please include the following information in your report:

- Description of the vulnerability
- Steps to reproduce the issue
- Potential impact of the vulnerability
- Suggested fix if possible
- Your name/handle for credit (optional)

## What to Expect

When you submit a vulnerability report, you can expect:

- Acknowledgment of your report within 48 hours
- Regular updates about our progress
- Credit for discovering the vulnerability (if desired)

## Disclosure Policy

When we receive a security bug report, we will:

1. Confirm the problem and determine the affected versions
2. Audit code to find any potential similar problems
3. Prepare fixes for all supported versions
4. Release new versions and notify users

## Security-Related Configuration

When using this provider, please follow these security best practices:

1. **API Credentials**:
   - Use environment variables or encrypted credential files to store sensitive information
   - Never commit API tokens or credentials to version control
   - Use the most restrictive permissions possible for API users

2. **Network Security**:
   - Use HTTPS/TLS for all API connections
   - Configure appropriate firewall rules
   - Use private networks where possible

3. **State File Security**:
   - Encrypt your Terraform state files
   - Use remote state with appropriate access controls
   - Be cautious with state file contents as they may contain sensitive information
`````

## File: docs/data-sources/virtual_environment_acme_account.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acme_account
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves information about a specific ACME account.
---

# Data Source: proxmox_virtual_environment_acme_account

Retrieves information about a specific ACME account.

## Example Usage

```terraform
// This will fetch all ACME accounts...
data "proxmox_virtual_environment_acme_accounts" "all" {}

// ...which we will go through in order to fetch the whole data on each account.
data "proxmox_virtual_environment_acme_account" "example" {
  for_each = data.proxmox_virtual_environment_acme_accounts.all.accounts
  name     = each.value
}

output "data_proxmox_virtual_environment_acme_account" {
  value = data.proxmox_virtual_environment_acme_account.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `name` (String) The identifier of the ACME account to read.

### Read-Only

- `account` (Attributes) The ACME account information. (see [below for nested schema](#nestedatt--account))
- `directory` (String) The directory URL of the ACME account.
- `location` (String) The location URL of the ACME account.
- `tos` (String) The URL of the terms of service of the ACME account.

<a id="nestedatt--account"></a>
### Nested Schema for `account`

Read-Only:

- `contact` (List of String) An array of contact email addresses.
- `created_at` (String) The timestamp of the account creation.
- `status` (String) The status of the account. Can be one of `valid`, `deactivated` or `revoked`.
`````

## File: docs/data-sources/virtual_environment_acme_accounts.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acme_accounts
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves the list of ACME accounts.
---

# Data Source: proxmox_virtual_environment_acme_accounts

Retrieves the list of ACME accounts.

## Example Usage

```terraform
data "proxmox_virtual_environment_acme_accounts" "example" {}

output "data_proxmox_virtual_environment_acme_accounts" {
  value = data.proxmox_virtual_environment_acme_accounts.example.accounts
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Read-Only

- `accounts` (Set of String) The identifiers of the ACME accounts.
`````

## File: docs/data-sources/virtual_environment_acme_plugin.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acme_plugin
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves a single ACME plugin by plugin ID name.
---

# Data Source: proxmox_virtual_environment_acme_plugin

Retrieves a single ACME plugin by plugin ID name.

## Example Usage

```terraform
data "proxmox_virtual_environment_acme_plugin" "example" {
  plugin = "standalone"
}

output "data_proxmox_virtual_environment_acme_plugin" {
  value = data.proxmox_virtual_environment_acme_plugin.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `plugin` (String) ACME Plugin ID name.

### Read-Only

- `api` (String) API plugin name.
- `data` (Map of String) DNS plugin data.
- `digest` (String) Prevent changes if current configuration file has a different digest. This can be used to prevent concurrent modifications.
- `type` (String) ACME challenge type (dns, standalone).
- `validation_delay` (Number) Extra delay in seconds to wait before requesting validation. Allows to cope with a long TTL of DNS records (0 - 172800).
`````

## File: docs/data-sources/virtual_environment_acme_plugins.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acme_plugins
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves the list of ACME plugins.
---

# Data Source: proxmox_virtual_environment_acme_plugins

Retrieves the list of ACME plugins.

## Example Usage

```terraform
data "proxmox_virtual_environment_acme_plugins" "example" {}

output "data_proxmox_virtual_environment_acme_plugins" {
  value = data.proxmox_virtual_environment_acme_plugins.example.plugins
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Read-Only

- `plugins` (Attributes List) List of ACME plugins (see [below for nested schema](#nestedatt--plugins))

<a id="nestedatt--plugins"></a>
### Nested Schema for `plugins`

Read-Only:

- `api` (String) API plugin name.
- `data` (Map of String) DNS plugin data.
- `digest` (String) Prevent changes if current configuration file has a different digest. This can be used to prevent concurrent modifications.
- `plugin` (String) ACME Plugin ID name.
- `type` (String) ACME challenge type (dns, standalone).
- `validation_delay` (Number) Extra delay in seconds to wait before requesting validation. Allows to cope with a long TTL of DNS records (0 - 172800).
`````

## File: docs/data-sources/virtual_environment_apt_repository.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_apt_repository
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves an APT repository from a Proxmox VE cluster.
---

# Data Source: proxmox_virtual_environment_apt_repository

Retrieves an APT repository from a Proxmox VE cluster.

## Example Usage

```terraform
data "proxmox_virtual_environment_apt_repository" "example" {
  file_path = "/etc/apt/sources.list"
  index     = 0
  node      = "pve"
}

output "proxmox_virtual_environment_apt_repository" {
  value = data.proxmox_virtual_environment_apt_repository.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `file_path` (String) The absolute path of the source list file that contains this repository.
- `index` (Number) The index within the defining source list file.
- `node` (String) The name of the target Proxmox VE node.

### Read-Only

- `comment` (String) The associated comment.
- `components` (List of String) The list of components.
- `enabled` (Boolean) Indicates the activation status.
- `file_type` (String) The format of the defining source list file.
- `id` (String) The unique identifier of this APT repository data source.
- `package_types` (List of String) The list of package types.
- `suites` (List of String) The list of package distributions.
- `uris` (List of String) The list of repository URIs.
`````

## File: docs/data-sources/virtual_environment_apt_standard_repository.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_apt_standard_repository
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves an APT standard repository from a Proxmox VE cluster.
---

# Data Source: proxmox_virtual_environment_apt_standard_repository

Retrieves an APT standard repository from a Proxmox VE cluster.

## Example Usage

```terraform
data "proxmox_virtual_environment_apt_standard_repository" "example" {
  handle = "no-subscription"
  node   = "pve"
}

output "proxmox_virtual_environment_apt_standard_repository" {
  value = data.proxmox_virtual_environment_apt_standard_repository.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `handle` (String) The handle of the APT standard repository.
- `node` (String) The name of the target Proxmox VE node.

### Read-Only

- `description` (String) The description of the APT standard repository.
- `file_path` (String) The absolute path of the source list file that contains this standard repository.
- `id` (String) The unique identifier of this APT standard repository data source.
- `index` (Number) The index within the defining source list file.
- `name` (String) The name of the APT standard repository.
- `status` (Number) Indicates the activation status.
`````

## File: docs/data-sources/virtual_environment_container.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_container
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_container

Retrieves information about a specific Container.

## Example Usage

```hcl
data "proxmox_virtual_environment_container" "test_container" {
    node_name = "test"
    vm_id = 100
}
```

## Argument Reference

- `node_name` - (Required) The node name.
- `vm_id` - (Required) The container identifier.

## Attribute Reference

- `name` - The container name.
- `tags` - A list of tags of the container.
- `status` - Status of the container
- `template` - Is container a template (true) or a regular container (false)
`````

## File: docs/data-sources/virtual_environment_datastores.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_datastores
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves information about all the datastores available to a specific node.
---

# Data Source: proxmox_virtual_environment_datastores

Retrieves information about all the datastores available to a specific node.



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `node_name` (String) The name of the node to retrieve the stores from.

### Optional

- `datastores` (Attributes List) The list of datastores. (see [below for nested schema](#nestedatt--datastores))
- `filters` (Attributes) The filters to apply to the stores. (see [below for nested schema](#nestedatt--filters))

<a id="nestedatt--datastores"></a>
### Nested Schema for `datastores`

Required:

- `content_types` (Set of String) Allowed store content types.
- `id` (String) The ID of the store.
- `node_name` (String) The name of the node the store is on.
- `type` (String) Store type.

Optional:

- `active` (Boolean) Whether the store is active.
- `enabled` (Boolean) Whether the store is enabled.
- `shared` (Boolean) Shared flag from store configuration.
- `space_available` (Number) Available store space in bytes.
- `space_total` (Number) Total store space in bytes.
- `space_used` (Number) Used store space in bytes.
- `space_used_fraction` (Number) Used fraction (used/total).


<a id="nestedatt--filters"></a>
### Nested Schema for `filters`

Optional:

- `content_types` (Set of String) Only list stores with the given content types.
- `id` (String) Only list stores with the given ID.
- `target` (String) If `target` is different to `node_name`, then only lists shared stores which content is accessible on this node and the specified `target` node.
`````

## File: docs/data-sources/virtual_environment_dns.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_dns
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_dns

Retrieves the DNS configuration for a specific node.

## Example Usage

```hcl
data "proxmox_virtual_environment_dns" "first_node" {
  node_name = "first-node"
}
```

## Argument Reference

- `node_name` - (Required) A node name.

## Attribute Reference

- `domain` - The DNS search domain.
- `servers` - The DNS servers.
`````

## File: docs/data-sources/virtual_environment_group.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_group
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_group

Retrieves information about a specific user group.

## Example Usage

```hcl
data "proxmox_virtual_environment_group" "operations_team" {
  group_id = "operations-team"
}
```

## Argument Reference

- `group_id` - (Required) The group identifier.

## Attribute Reference

- `acl` - The access control list.
    - `path` - The path.
    - `propagate` - Whether to propagate to child paths.
    - `role_id` - The role identifier.
- `comment` - The group comment.
- `members` - The group members as a list with `username@realm` entries.
`````

## File: docs/data-sources/virtual_environment_groups.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_groups
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_groups

Retrieves basic information about all available user groups.

## Example Usage

```hcl
data "proxmox_virtual_environment_groups" "available_groups" {}
```

## Argument Reference

There are no arguments available for this data source.

## Attribute Reference

- `comments` - The group comments.
- `group_ids` - The group identifiers.
`````

## File: docs/data-sources/virtual_environment_hagroup.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hagroup
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves information about a specific High Availability group.
---

# Data Source: proxmox_virtual_environment_hagroup

Retrieves information about a specific High Availability group.

## Example Usage

```terraform
// This will fetch the set of HA group identifiers...
data "proxmox_virtual_environment_hagroups" "all" {}

// ...which we will go through in order to fetch the whole data on each group.
data "proxmox_virtual_environment_hagroup" "example" {
  for_each = data.proxmox_virtual_environment_hagroups.all.group_ids
  group    = each.value
}

output "proxmox_virtual_environment_hagroups_full" {
  value = data.proxmox_virtual_environment_hagroup.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `group` (String) The identifier of the High Availability group to read.

### Read-Only

- `comment` (String) The comment associated with this group
- `id` (String) The unique identifier of this resource.
- `no_failback` (Boolean) A flag that indicates that failing back to a higher priority node is disabled for this HA group.
- `nodes` (Map of Number) The member nodes for this group. They are provided as a map, where the keys are the node names and the values represent their priority: integers for known priorities or `null` for unset priorities.
- `restricted` (Boolean) A flag that indicates that other nodes may not be used to run resources associated to this HA group.
`````

## File: docs/data-sources/virtual_environment_hagroups.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hagroups
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves the list of High Availability groups.
---

# Data Source: proxmox_virtual_environment_hagroups

Retrieves the list of High Availability groups.

## Example Usage

```terraform
data "proxmox_virtual_environment_hagroups" "example" {}

output "data_proxmox_virtual_environment_hagroups" {
  value = data.proxmox_virtual_environment_hagroups.example.group_ids
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Read-Only

- `group_ids` (Set of String) The identifiers of the High Availability groups.
- `id` (String) The unique identifier of this resource.
`````

## File: docs/data-sources/virtual_environment_hardware_mapping_dir.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mapping_dir
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves a directory mapping from a Proxmox VE cluster.
---

# Data Source: proxmox_virtual_environment_hardware_mapping_dir

Retrieves a directory mapping from a Proxmox VE cluster.

## Example Usage

```terraform
data "proxmox_virtual_environment_hardware_mapping_dir" "example" {
  name = "example"
}

output "data_proxmox_virtual_environment_hardware_mapping_dir" {
  value = data.proxmox_virtual_environment_hardware_mapping_dir.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The name of this directory mapping.

### Read-Only

- `comment` (String) The comment of this directory mapping.
- `id` (String) The unique identifier of this directory mapping data source.
- `map` (Attributes Set) The actual map of devices for the directory mapping. (see [below for nested schema](#nestedatt--map))

<a id="nestedatt--map"></a>
### Nested Schema for `map`

Read-Only:

- `node` (String) The node name attribute of the map.
- `path` (String) The path attribute of the map.
`````

## File: docs/data-sources/virtual_environment_hardware_mapping_pci.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mapping_pci
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves a PCI hardware mapping from a Proxmox VE cluster.
---

# Data Source: proxmox_virtual_environment_hardware_mapping_pci

Retrieves a PCI hardware mapping from a Proxmox VE cluster.

## Example Usage

```terraform
data "proxmox_virtual_environment_hardware_mapping_pci" "example" {
  name = "example"
}

output "data_proxmox_virtual_environment_hardware_mapping_pci" {
  value = data.proxmox_virtual_environment_hardware_mapping_pci.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The name of this PCI hardware mapping.

### Read-Only

- `comment` (String) The comment of this PCI hardware mapping.
- `id` (String) The unique identifier of this PCI hardware mapping data source.
- `map` (Attributes Set) The actual map of devices for the hardware mapping. (see [below for nested schema](#nestedatt--map))
- `mediated_devices` (Boolean) Indicates whether to use with mediated devices.

<a id="nestedatt--map"></a>
### Nested Schema for `map`

Read-Only:

- `comment` (String) The comment of the mapped PCI device.
- `id` (String) The ID attribute of the map.
- `iommu_group` (Number) The IOMMU group attribute of the map.
- `node` (String) The node name attribute of the map.
- `path` (String) The path attribute of the map.
- `subsystem_id` (String) The subsystem ID attribute of the map.Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set.
`````

## File: docs/data-sources/virtual_environment_hardware_mapping_usb.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mapping_usb
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves a USB hardware mapping from a Proxmox VE cluster.
---

# Data Source: proxmox_virtual_environment_hardware_mapping_usb

Retrieves a USB hardware mapping from a Proxmox VE cluster.

## Example Usage

```terraform
data "proxmox_virtual_environment_hardware_mapping_usb" "example" {
  name = "example"
}

output "data_proxmox_virtual_environment_hardware_mapping_usb" {
  value = data.proxmox_virtual_environment_hardware_mapping_usb.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The name of this USB hardware mapping.

### Read-Only

- `comment` (String) The comment of this USB hardware mapping.
- `id` (String) The unique identifier of this USB hardware mapping data source.
- `map` (Attributes Set) The actual map of devices for the hardware mapping. (see [below for nested schema](#nestedatt--map))

<a id="nestedatt--map"></a>
### Nested Schema for `map`

Read-Only:

- `comment` (String) The comment of the mapped USB device.
- `id` (String) The ID attribute of the map.
- `node` (String) The node name attribute of the map.
- `path` (String) The path attribute of the map.
`````

## File: docs/data-sources/virtual_environment_hardware_mappings.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mappings
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves a list of hardware mapping resources.
---

# Data Source: proxmox_virtual_environment_hardware_mappings

Retrieves a list of hardware mapping resources.

## Example Usage

```terraform
data "proxmox_virtual_environment_hardware_mappings" "example-dir" {
  check_node = "pve"
  type       = "dir"
}

data "proxmox_virtual_environment_hardware_mappings" "example-pci" {
  check_node = "pve"
  type       = "pci"
}

data "proxmox_virtual_environment_hardware_mappings" "example-usb" {
  check_node = "pve"
  type       = "usb"
}

output "data_proxmox_virtual_environment_hardware_mappings_pci" {
  value = data.proxmox_virtual_environment_hardware_mappings.example-pci
}

output "data_proxmox_virtual_environment_hardware_mappings_usb" {
  value = data.proxmox_virtual_environment_hardware_mappings.example-usb
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `type` (String) The type of the hardware mappings.

### Optional

- `check_node` (String) The name of the node whose configurations should be checked for correctness.

### Read-Only

- `checks` (Attributes List) Might contain relevant diagnostics about incorrect configurations. (see [below for nested schema](#nestedatt--checks))
- `id` (String) The unique identifier of this hardware mappings data source.
- `ids` (Set of String) The identifiers of the hardware mappings.

<a id="nestedatt--checks"></a>
### Nested Schema for `checks`

Read-Only:

- `mapping_id` (String) The corresponding hardware mapping ID of the node check diagnostic entry.
- `message` (String) The message of the node check diagnostic entry.
- `severity` (String) The severity of the node check diagnostic entry.
`````

## File: docs/data-sources/virtual_environment_haresource.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_haresource
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves the list of High Availability resources.
---

# Data Source: proxmox_virtual_environment_haresource

Retrieves the list of High Availability resources.

## Example Usage

```terraform
// This will fetch the set of all HA resource identifiers...
data "proxmox_virtual_environment_haresources" "all" {}

// ...which we will go through in order to fetch the whole record for each resource.
data "proxmox_virtual_environment_haresource" "example" {
  for_each    = data.proxmox_virtual_environment_haresources.all.resource_ids
  resource_id = each.value
}

output "proxmox_virtual_environment_haresources_full" {
  value = data.proxmox_virtual_environment_haresource.example
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `resource_id` (String) The identifier of the Proxmox HA resource to read.

### Read-Only

- `comment` (String) The comment associated with this resource.
- `group` (String) The identifier of the High Availability group this resource is a member of.
- `id` (String) The unique identifier of this resource.
- `max_relocate` (Number) The maximal number of relocation attempts.
- `max_restart` (Number) The maximal number of restart attempts.
- `state` (String) The desired state of the resource.
- `type` (String) The type of High Availability resource (`vm` or `ct`).
`````

## File: docs/data-sources/virtual_environment_haresources.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_haresources
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves the list of High Availability resources.
---

# Data Source: proxmox_virtual_environment_haresources

Retrieves the list of High Availability resources.

## Example Usage

```terraform
// This will fetch the set of all HA resource identifiers.
data "proxmox_virtual_environment_haresources" "example_all" {}

// This will fetch the set of HA resource identifiers that correspond to virtual machines.
data "proxmox_virtual_environment_haresources" "example_vm" {
  type = "vm"
}

output "data_proxmox_virtual_environment_haresources" {
  value = {
    all = data.proxmox_virtual_environment_haresources.example_all.resource_ids
    vms = data.proxmox_virtual_environment_haresources.example_vm.resource_ids
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `type` (String) The type of High Availability resources to fetch (`vm` or `ct`). All resources will be fetched if this option is unset.

### Read-Only

- `id` (String) The unique identifier of this resource.
- `resource_ids` (Set of String) The identifiers of the High Availability resources.
`````

## File: docs/data-sources/virtual_environment_hosts.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hosts
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_hosts

Retrieves all the host entries from a specific node.

## Example Usage

```hcl
data "proxmox_virtual_environment_hosts" "first_node_host_entries" {
  node_name = "first-node"
}
```

## Argument Reference

- `node_name` - (Required) A node name.

## Attribute Reference

- `addresses` - The IP addresses.
- `digest` - The SHA1 digest.
- `entries` - The host entries (conversion of `addresses` and `hostnames` into
  objects).
- `hostnames` - The hostnames associated with each of the IP addresses.
`````

## File: docs/data-sources/virtual_environment_metrics_server.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_metrics_server
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves information about a specific PVE metric server.
---

# Data Source: proxmox_virtual_environment_metrics_server

Retrieves information about a specific PVE metric server.

## Example Usage

```terraform
data "proxmox_virtual_environment_metrics_server" "example" {
  name = "example_influxdb"
}

output "data_proxmox_virtual_environment_metrics_server" {
  value = {
    server = data.proxmox_virtual_environment_metrics_server.example.server
    port   = data.proxmox_virtual_environment_metrics_server.example.port
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) Unique name that will be ID of this metric server in PVE.

### Read-Only

- `disable` (Boolean) Indicates if the metric server is disabled.
- `id` (String) The unique identifier of this resource.
- `port` (Number) Server network port.
- `server` (String) Server dns name or IP address.
- `type` (String) Plugin type. Either `graphite` or `influxdb`.
`````

## File: docs/data-sources/virtual_environment_node.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_node
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_node

Retrieves information about node.

## Example Usage

```hcl
data "proxmox_virtual_environment_node" "node" {}
```

## Argument Reference

- `node_name` - (Required) The node name.

## Attribute Reference

- `cpu_count` - The CPU count on the node.
- `cpu_sockets` - The CPU utilization on the node.
- `cpu_model` - The CPU model on the node.
- `memory_available` - The memory available on the node.
- `memory_used` - The memory used on the node.
- `memory_total` - The total memory on the node.
- `uptime` - The uptime in seconds on the node.
`````

## File: docs/data-sources/virtual_environment_nodes.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_nodes
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_nodes

Retrieves information about all available nodes.

## Example Usage

```hcl
data "proxmox_virtual_environment_nodes" "available_nodes" {}
```

## Argument Reference

There are no arguments available for this data source.

## Attribute Reference

- `cpu_count` - The CPU count for each node.
- `cpu_utilization` - The CPU utilization on each node.
- `memory_available` - The memory available on each node.
- `memory_used` - The memory used on each node.
- `names` - The node names.
- `online` - Whether a node is online.
- `ssl_fingerprints` - The SSL fingerprint for each node.
- `support_levels` - The support level for each node.
- `uptime` - The uptime in seconds for each node.
`````

## File: docs/data-sources/virtual_environment_pool.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_pool
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_pool

Retrieves information about a specific resource pool.

## Example Usage

```hcl
data "proxmox_virtual_environment_pool" "operations_pool" {
  pool_id = "operations"
}
```

## Argument Reference

- `pool_id` - (Required) The pool identifier.

## Attribute Reference

- `comment` - The pool comment.
- `members` - The pool members.
    - `datastore_id` - The datastore identifier.
    - `id` - The member identifier.
    - `node_name` - The node name.
    - `type` - The member type.
    - `vm_id` - The virtual machine identifier.
`````

## File: docs/data-sources/virtual_environment_pools.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_pools
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_pools

Retrieves the identifiers for all the available resource pools.

## Example Usage

```hcl
data "proxmox_virtual_environment_pools" "available_pools" {}
```

## Argument Reference

There are no arguments available for this data source.

## Attribute Reference

- `pool_ids` - The pool identifiers.
`````

## File: docs/data-sources/virtual_environment_role.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_role
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_role

Retrieves information about a specific role.

## Example Usage

```hcl
data "proxmox_virtual_environment_role" "operations_role" {
  role_id = "operations"
}
```

## Argument Reference

- `role_id` - (Required) The role identifier.

## Attribute Reference

- `privileges` - The role privileges
`````

## File: docs/data-sources/virtual_environment_roles.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_roles
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_roles

Retrieves information about all the available roles.

## Example Usage

```hcl
data "proxmox_virtual_environment_roles" "available_roles" {}
```

## Argument Reference

There are no arguments available for this data source.

## Attribute Reference

- `privileges` - The role privileges.
- `role_ids` - The role identifiers.
- `special` - Whether the role is special (built-in).
`````

## File: docs/data-sources/virtual_environment_time.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_time
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_time

Retrieves the current time for a specific node.

## Example Usage

```hcl
data "proxmox_virtual_environment_time" "first_node_time" {
  node_name = "first-node"
}
```

## Argument Reference

- `node_name` - (Required) A node name.

## Attribute Reference

- `local_time` - The node's local time.
- `time_zone` - The node's time zone.
- `utc_time` - The node's local time formatted as UTC.
`````

## File: docs/data-sources/virtual_environment_user.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_user
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_user

Retrieves information about a specific user.

## Example Usage

```hcl
data "proxmox_virtual_environment_user" "operations_user" {
  user_id = "operation@pam"
}
```

## Argument Reference

- `user_id` - (Required) The user identifier.

## Attribute Reference

- `acl` - The access control list.
    - `path` - The path.
    - `propagate` - Whether to propagate to child paths.
    - `role_id` - The role identifier.
- `comment` - The user comment.
- `email` - The user's email address.
- `enabled` - Whether the user account is enabled.
- `expiration_date` - The user account's expiration date (RFC 3339).
- `first_name` - The user's first name.
- `groups` - The user's groups.
- `keys` - The user's keys.
- `last_name` - The user's last name.
`````

## File: docs/data-sources/virtual_environment_users.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_users
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_users

Retrieves information about all the available users.

## Example Usage

```hcl
data "proxmox_virtual_environment_users" "available_users" {}
```

## Argument Reference

There are no arguments available for this data source.

## Attribute Reference

- `comments` - The user comments.
- `emails` - The users' email addresses.
- `enabled` - Whether a user account is enabled.
- `expiration_dates` - The user accounts' expiration dates (RFC 3339).
- `first_names` - The users' first names.
- `groups` - The users' groups.
- `keys` - The users' keys.
- `last_names` - The users' last names.
- `user_ids` - The user identifiers.
`````

## File: docs/data-sources/virtual_environment_version.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_version
parent: Data Sources
subcategory: Virtual Environment
description: |-
  Retrieves API version details.
---

# Data Source: proxmox_virtual_environment_version

Retrieves API version details.

## Example Usage

```terraform
data "proxmox_virtual_environment_version" "example" {}

output "data_proxmox_virtual_environment_version" {
  value = {
    release       = data.proxmox_virtual_environment_version.example.release
    repository_id = data.proxmox_virtual_environment_version.example.repository_id
    version       = data.proxmox_virtual_environment_version.example.version
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Read-Only

- `id` (String) Placeholder identifier attribute.
- `release` (String) The current Proxmox VE point release in `x.y` format.
- `repository_id` (String) The short git revision from which this version was build.
- `version` (String) The full pve-manager package version of this node.
`````

## File: docs/data-sources/virtual_environment_vm.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_vm
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_vm

Retrieves information about a specific VM.

## Example Usage

```hcl
data "proxmox_virtual_environment_vm" "test_vm" {
    node_name = "test"
    vm_id = 100
}
```

## Argument Reference

- `node_name` - (Required) The node name.
- `vm_id` - (Required) The VM identifier.

## Attribute Reference

- `name` - The virtual machine name.
- `tags` - A list of tags of the VM.
- `status` - Status of the VM
- `template` - Is VM a template (true) or a regular VM (false)
`````

## File: docs/data-sources/virtual_environment_vm2.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_vm2
parent: Data Sources
subcategory: Virtual Environment
description: |-
  This is an experimental implementation of a Proxmox VM datasource using Plugin Framework.
---

# Data Source: proxmox_virtual_environment_vm2

!> **DO NOT USE**
This is an experimental implementation of a Proxmox VM datasource using Plugin Framework.



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `id` (Number) The unique identifier of the VM in the Proxmox cluster.
- `node_name` (String) The name of the node where the VM is provisioned.

### Optional

- `clone` (Attributes) The cloning configuration. (see [below for nested schema](#nestedatt--clone))
- `cpu` (Attributes) The CPU configuration. (see [below for nested schema](#nestedatt--cpu))
- `description` (String) The description of the VM.
- `name` (String) The name of the VM.
- `rng` (Attributes) The RNG (Random Number Generator) configuration. (see [below for nested schema](#nestedatt--rng))
- `tags` (Set of String) The tags assigned to the VM.
- `template` (Boolean) Whether the VM is a template.
- `timeouts` (Attributes) (see [below for nested schema](#nestedatt--timeouts))
- `vga` (Attributes) The VGA configuration. (see [below for nested schema](#nestedatt--vga))

<a id="nestedatt--clone"></a>
### Nested Schema for `clone`

Required:

- `id` (Number) The ID of the VM to clone.

Optional:

- `retries` (Number) The number of retries to perform when cloning the VM (default: 3).


<a id="nestedatt--cpu"></a>
### Nested Schema for `cpu`

Optional:

- `affinity` (String) List of host cores used to execute guest processes, for example: '0,5,8-11'
- `architecture` (String) The CPU architecture.
- `cores` (Number) The number of CPU cores per socket.
- `flags` (Set of String) Set of additional CPU flags.
- `hotplugged` (Number) The number of hotplugged vCPUs.
- `limit` (Number) Limit of CPU usage.
- `numa` (Boolean) Enable NUMA.
- `sockets` (Number) The number of CPU sockets.
- `type` (String) Emulated CPU type.
- `units` (Number) CPU weight for a VM


<a id="nestedatt--rng"></a>
### Nested Schema for `rng`

Optional:

- `max_bytes` (Number) Maximum bytes of entropy allowed to get injected into the guest every period.
- `period` (Number) Period in milliseconds to limit entropy injection to the guest.
- `source` (String) The entropy source for the RNG device.


<a id="nestedatt--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `read` (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.


<a id="nestedatt--vga"></a>
### Nested Schema for `vga`

Optional:

- `clipboard` (String) Enable a specific clipboard.
- `memory` (Number) The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
- `type` (String) The VGA type.
`````

## File: docs/data-sources/virtual_environment_vms.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_vms
parent: Data Sources
subcategory: Virtual Environment
---

# Data Source: proxmox_virtual_environment_vms

Retrieves information about all VMs in the Proxmox cluster.

## Example Usage

```hcl
data "proxmox_virtual_environment_vms" "ubuntu_vms" {
  tags      = ["ubuntu"]
}

data "proxmox_virtual_environment_vms" "ubuntu_templates" {
  tags      = ["template", "latest"]

  filter {
    name   = "template"
    values = [true]
  }

  filter {
    name   = "status"
    values = ["stopped"]
  }

  filter {
    name   = "name"
    regex  = true
    values = ["^ubuntu-20.*$"]
  }

  filter {
    name   = "node_name"
    regex  = true
    values = ["node_us_[1-3]", "node_eu_[1-3]"]
  }
}
```

## Argument Reference

- `node_name` - (Optional) The node name. All cluster nodes will be queried in case this is omitted
- `tags` - (Optional) A list of tags to filter the VMs. The VM must have all
  the tags to be included in the result.
- `filter` - (Optional) Filter blocks. The VM must satisfy all filter blocks to be included in the result.
    - `name` - Name of the VM attribute to filter on. One of [`name`, `template`, `status`, `node_name`]
    - `values` - List of values to pass the filter. VM's attribute should match at least one value in the list.

## Attribute Reference

- `vms` - The VMs list.
    - `name` - The virtual machine name.
    - `node_name` - The node name.
    - `tags` - A list of tags of the VM.
    - `vm_id` - The VM identifier.
    - `status` - Status of the VM
    - `template` - Is VM a template (true) or a regular VM (false)
`````

## File: docs/guides/clone-vm.md
`````markdown
---
layout: page
page_title: "Clone a VM"
subcategory: Guides
description: |-
    This guide explains how to create a VM template and then clone it to another VM.
---

# Clone a VM

## Create a VM template

VM templates in Proxmox provide an efficient way to create multiple identical VMs. Templates act as a base image that can be cloned to create new VMs, ensuring consistency and reducing the time needed to provision new instances. When a VM is created as a template, it is read-only and can't be started, but can be cloned multiple times to create new VMs.

You can create a template directly in Proxmox by setting the `template` attribute to `true` when creating the VM resource:

```terraform
resource "proxmox_virtual_environment_vm" "ubuntu_template" {
  name      = "ubuntu-template"
  node_name = "pve"

  template = true
  started  = false

  machine     = "q35"
  bios        = "ovmf"
  description = "Managed by Terraform"

  cpu {
    cores = 2
  }

  memory {
    dedicated = 2048
  }

  efi_disk {
    datastore_id = "local"
    type         = "4m"
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }

  initialization {
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_data_file_id = proxmox_virtual_environment_file.user_data_cloud_config.id
  }

  network_device {
    bridge = "vmbr0"
  }

}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}
```

Once you have a template, you can clone it to create new VMs. The cloned VMs will inherit all the configuration from the template but can be customized further as needed.

```terraform
resource "proxmox_virtual_environment_vm" "ubuntu_clone" {
  name      = "ubuntu-clone"
  node_name = "pve"

  clone {
    vm_id = proxmox_virtual_environment_vm.ubuntu_template.id
  }

  agent {
    # NOTE: The agent is installed and enabled as part of the cloud-init configuration in the template VM, see cloud-config.tf
    # The working agent is *required* to retrieve the VM IP addresses.
    # If you are using a different cloud-init configuration, or a different clone source
    # that does not have the qemu-guest-agent installed, you may need to disable the `agent` below and remove the `vm_ipv4_address` output.
    # See https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_vm#qemu-guest-agent for more details.
    enabled = true
  }

  memory {
    dedicated = 768
  }

  initialization {
    dns {
      servers = ["1.1.1.1"]
    }
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }
  }
}

output "vm_ipv4_address" {
  value = proxmox_virtual_environment_vm.ubuntu_clone.ipv4_addresses[1][0]
}
```
`````

## File: docs/guides/cloud-image.md
`````markdown
---
layout: page
page_title: "Create a VM from a Cloud Image"
subcategory: Guides
description: |-
    This guide explains how to create a VM from a cloud image.
---

# Create a VM from a Cloud Image

## Download a public cloud image from URL

Proxmox does not natively support QCOW2 images, but provider can do the conversion for you.

Example of how to create a CentOS 8 VM from a "generic cloud" `qcow2` image. CentOS 8 images are available at [cloud.centos.org](https://cloud.centos.org/centos/8-stream/x86_64/images/):

```terraform
resource "proxmox_virtual_environment_vm" "centos_vm" {
  name      = "test-centos"
  node_name = "pve"

  # should be true if qemu agent is not installed / enabled on the VM
  stop_on_destroy = true

  initialization {
    user_account {
      # do not use this in production, configure your own ssh key instead!
      username = "user"
      password = "password"
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.centos_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }
}

resource "proxmox_virtual_environment_download_file" "centos_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud.centos.org/centos/8-stream/x86_64/images/CentOS-Stream-GenericCloud-8-latest.x86_64.qcow2"
  file_name    = "centos8.img"
}
```

Ubuntu cloud images are available at [cloud-images.ubuntu.com](https://cloud-images.ubuntu.com/). Ubuntu cloud images are in `qcow2` format as well, but stored with `.img` extension, so they can be directly uploaded to Proxmox without renaming.

```terraform
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name      = "test-ubuntu"
  node_name = "pve"

  # should be true if qemu agent is not installed / enabled on the VM
  stop_on_destroy = true

  initialization {
    user_account {
      # do not use this in production, configure your own ssh key instead!
      username = "user"
      password = "password"
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }
}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}
```

For [large images](https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_file#important-notes), you may want to use a dedicated temporary directory [configured](https://registry.terraform.io/providers/bpg/proxmox/latest/docs#tmp_dir) for provider via `tmp_dir` attribute, instead of system's default temporary directory. This is especially useful if you are deploying from a container with limited disk space.

## Create a VM from an existing image on Proxmox

If you already have a cloud image on Proxmox, you can use it to create a VM:

```terraform
resource "proxmox_virtual_environment_vm" "debian_vm" {
  name      = "test-debian"
  node_name = "pve"

  # should be true if qemu agent is not installed / enabled on the VM
  stop_on_destroy = true

  initialization {
    user_account {
      # do not use this in production, configure your own ssh key instead!
      username = "user"
      password = "password"
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = "local:iso/debian-12-genericcloud-amd64.img"
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }
}
```
`````

## File: docs/guides/cloud-init.md
`````markdown
---
layout: page
page_title: "Configure a VM with Cloud-Init"
subcategory: Guides
description: |-
    This guide explains how to use the Proxmox provider to create and manage virtual machines using cloud-init.
---

# Configure a VM with Cloud-Init

## Native Proxmox Cloud-Init Support

Proxmox supports cloud-init natively, so you can use the `initialization` block to configure your VM:

```terraform
data "local_file" "ssh_public_key" {
  filename = "./id_rsa.pub"
}

resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name      = "test-ubuntu"
  node_name = "pve"

  initialization {
    ip_config {
      ipv4 {
        address = "192.168.3.233/24"
        gateway = "192.168.3.1"
      }
    }

    user_account {
      username = "ubuntu"
      keys     = [trimspace(data.local_file.ssh_public_key.content)]
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }

  network_device {
    bridge = "vmbr0"
  }
}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}
```

Note that many cloud images do not have `qemu-guest-agent` installed by default, so you won't be able to retrieve the dynamic IP address of the VM from Proxmox, as this is agent's responsibility. You can use the `ip_config` block to configure a static IP address instead.

## Custom Cloud-Init Configuration

Due to several limitations of the native Proxmox cloud-init support, you may want to use a custom Cloud-Init configuration instead. This allows you to adjust the VM configuration to your needs and install the `qemu-guest-agent` and additional packages.

To use a custom cloud-init configuration, create a cloud-config snippet file and pass it to the VM as a `user_data_file_id` parameter. Use the `proxmox_virtual_environment_file` resource to create the file. Ensure the "Snippets" content type is enabled on the target datastore in Proxmox before applying the configuration below.

Note that you need to explicitly set the `hostname` in the provided cloud-init configuration, as the custom user data cloud-init config overwrites the config set by Proxmox, as shown in the example below.

```terraform
data "local_file" "ssh_public_key" {
  filename = "./id_rsa.pub"
}

resource "proxmox_virtual_environment_file" "user_data_cloud_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"

  source_raw {
    data = <<-EOF
    #cloud-config
    hostname: test-ubuntu
    timezone: America/Toronto
    users:
      - default
      - name: ubuntu
        groups:
          - sudo
        shell: /bin/bash
        ssh_authorized_keys:
          - ${trimspace(data.local_file.ssh_public_key.content)}
        sudo: ALL=(ALL) NOPASSWD:ALL
    package_update: true
    packages:
      - qemu-guest-agent
      - net-tools
      - curl
    runcmd:
      - systemctl enable qemu-guest-agent
      - systemctl start qemu-guest-agent
      - echo "done" > /tmp/cloud-config.done
    EOF

    file_name = "user-data-cloud-config.yaml"
  }
}
```

```terraform
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name      = "test-ubuntu"
  node_name = "pve"

  agent {
    enabled = true
  }

  cpu {
    cores = 2
  }

  memory {
    dedicated = 2048
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }

  initialization {
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_data_file_id = proxmox_virtual_environment_file.user_data_cloud_config.id
  }

  network_device {
    bridge = "vmbr0"
  }

}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}

output "vm_ipv4_address" {
  value = proxmox_virtual_environment_vm.ubuntu_vm.ipv4_addresses[1][0]
}
```

If you wish to keep the user data cloud-init config generic, for example, when deploying multiple VMs for a Kubernetes cluster, you can use a separate snippet with the metadata cloud-init config to set the hostname. Note that it uses the `local-hostname` configuration parameter. See more details in the [cloud-init documentation](https://docs.cloud-init.io/en/latest/reference/yaml_examples/update_hostname.html).

```terraform
resource "proxmox_virtual_environment_file" "meta_data_cloud_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"

  source_raw {
    data = <<-EOF
    #cloud-config
    local-hostname: test-ubuntu
    EOF

    file_name = "meta-data-cloud-config.yaml"
  }
}
```

```terraform
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  # ...

  initialization {
    # ...
    user_data_file_id = proxmox_virtual_environment_file.user_data_cloud_config.id
    meta_data_file_id = proxmox_virtual_environment_file.meta_data_cloud_config.id
  }

  # ...
}
```
`````

## File: docs/guides/setup-proxmox-for-tests.md
`````markdown
---
layout: page
page_title: "Setup a VM with Proxmox"
subcategory: Guides
description: |-
  This guide will help you setup a proxmox node in VM using virt-manager for a job.
---

# Setup VM with Proxmox to run examples and acceptance tests

## Who

Contributors

## Motivation

To test changes, it's best to try it on real proxmox cluster. There is dedicated `make example` command that will try to apply changes defined in `example` directory. Most resources have its examples declarations there. For example, if you add new resource, you could add new file with example resource there (ideally after adding tests). If nothing breaks, apply works fine, new resource is created and all other resources are fine, then likely change is safe.

But, proxmox node setup can be tricky task for some contributors.

## Preconditions

Be sure to install `go` and `terraform` on your system first.

## Linux (Debian/Ubuntu) with virt-manager

Goal is to have a proxmox node in VM using <https://virt-manager.org/> for a job. This text assumes some linux knowledge. Tested on Debian 12 bookworm and proxmox VE 8.1. For other distros, with any luck steps should be similar.

1. `sudo apt-get install virt-manager`.

2. Download some proxmox image from <http://download.proxmox.com/iso/>, currently latest is `proxmox-ve_8.1-1.iso`.

3. Run `virt-manager` and "create a new virtual machine", use a file you just downloaded, choose debian as a operating system, leave default network settings.

4. Give it enough RAM and disk size (required minimum is unknown for make example though I used 4GB on my 8GB laptop and 30GB disk size with success).

5. Proceed forward with installation, choose whatever you want for timezone, country, password, domain, email. Don't change other default settings.

6. After installation, log in using password from previous step and `root` username (it's proxmox default). Run: `ip a` to get assigned ip (this also appears during installation). In my case it is `192.168.122.43`.

   It may look like this:

   ```txt
   root@proxmox:~# ip a
   1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
       link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
       inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
       inet6 ::1/128 scope host noprefixroute
       valid_lft forever preferred_lft forever
   2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master vmbr0 state UP group default qlen 1000
       link/ether 52:54:00:b3:22:f5 brd ff:ff:ff:ff:ff:ff
   3: vmbr0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
       link/ether 52:54:00:b3:22:f5 brd ff:ff:ff:ff:ff:ff
       inet 192.168.122.43/24 scope global vmbr0
       valid_lft forever preferred_lft forever
       inet6 fe80::5054:ff:feb3:22f5/64 scope link
       valid_lft forever preferred_lft forever
   ```

7. (Optional) On **your** computer, there should be new interface created mapped to that one you see on proxmox. Again `ip a`:

   ```txt
   ...

   8: virbr0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
       link/ether 52:54:00:ca:65:49 brd ff:ff:ff:ff:ff:ff
       inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever

   ...

   ```

8. (Optional) You can SSH into proxmox node:

   ```bash
   ssh root@192.168.122.43
   ```

   You can also use browser and visit console at <https://192.168.122.43:8006>.

9. Create `terraform.tfvars` file (it will be git ignored file) in `example` folder with credentials for you new proxmox node.

   ```txt
   # example/terraform.tfvars
   virtual_environment_username = "root@pam"
   virtual_environment_endpoint = "https://192.168.122.43:8006/"
   virtual_environment_password = "your password from step 5"

   ```

10. Now you can run `make example`.

11. If you see error with proxmox_virtual_environment_file: the datastore "local" does not support content type "snippets"; supported content types are: `[backup, iso, vztmpl]`, you need to enable them, see <https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_file#snippets>.
`````

## File: docs/resources/virtual_environment_acl.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acl
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages ACLs on the Proxmox cluster.
  ACLs are used to control access to resources in the Proxmox cluster.
  Each ACL consists of a path, a user, group or token, a role, and a flag to allow propagation of permissions.
---

# Resource: proxmox_virtual_environment_acl

Manages ACLs on the Proxmox cluster.

ACLs are used to control access to resources in the Proxmox cluster.
Each ACL consists of a path, a user, group or token, a role, and a flag to allow propagation of permissions.

## Example Usage

```terraform
resource "proxmox_virtual_environment_user" "operations_automation" {
  comment  = "Managed by Terraform"
  password = "a-strong-password"
  user_id  = "operations-automation@pve"
}

resource "proxmox_virtual_environment_role" "operations_monitoring" {
  role_id = "operations-monitoring"

  privileges = [
    "VM.Monitor",
  ]
}

resource "proxmox_virtual_environment_acl" "operations_automation_monitoring" {
  user_id = proxmox_virtual_environment_user.operations_automation.user_id
  role_id = proxmox_virtual_environment_role.operations_monitoring.role_id

  path      = "/vms/1234"
  propagate = true
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `path` (String) Access control path
- `role_id` (String) The role to apply

### Optional

- `group_id` (String) The group the ACL should apply to (mutually exclusive with `token_id` and `user_id`)
- `propagate` (Boolean) Allow to propagate (inherit) permissions.
- `token_id` (String) The token the ACL should apply to (mutually exclusive with `group_id` and `user_id`)
- `user_id` (String) The user the ACL should apply to (mutually exclusive with `group_id` and `token_id`)

### Read-Only

- `id` (String) The unique identifier of this resource.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# ACL can be imported using its unique identifier, e.g.: {path}?{group|user@realm|user@realm!token}?{role}
terraform import proxmox_virtual_environment_acl.operations_automation_monitoring /?monitor@pve?operations-monitoring
```
`````

## File: docs/resources/virtual_environment_acme_account.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acme_account
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages an ACME account in a Proxmox VE cluster.
  ~> This resource requires root@pam authentication.
---

# Resource: proxmox_virtual_environment_acme_account

Manages an ACME account in a Proxmox VE cluster.

~> This resource requires `root@pam` authentication.

## Example Usage

```terraform
resource "proxmox_virtual_environment_acme_account" "example" {
  name      = "example"
  contact   = "example@email.com"
  directory = "https://acme-staging-v02.api.letsencrypt.org/directory"
  tos       = "https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `contact` (String) The contact email addresses.

### Optional

- `directory` (String) The URL of the ACME CA directory endpoint.
- `eab_hmac_key` (String) The HMAC key for External Account Binding.
- `eab_kid` (String) The Key Identifier for External Account Binding.
- `name` (String) The ACME account config file name.
- `tos` (String) The URL of CA TermsOfService - setting this indicates agreement.

### Read-Only

- `created_at` (String) The timestamp of the ACME account creation.
- `location` (String) The location of the ACME account.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# ACME accounts can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_acme_account.example example
```
`````

## File: docs/resources/virtual_environment_acme_dns_plugin.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_acme_dns_plugin
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages an ACME plugin in a Proxmox VE cluster.
---

# Resource: proxmox_virtual_environment_acme_dns_plugin

Manages an ACME plugin in a Proxmox VE cluster.

## Example Usage

```terraform
resource "proxmox_virtual_environment_acme_dns_plugin" "example" {
  plugin = "test"
  api    = "aws"
  data = {
    AWS_ACCESS_KEY_ID     = "EXAMPLE"
    AWS_SECRET_ACCESS_KEY = "EXAMPLE"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `api` (String) API plugin name.
- `plugin` (String) ACME Plugin ID name.

### Optional

- `data` (Map of String) DNS plugin data.
- `digest` (String) SHA1 digest of the current configuration. Prevent changes if current configuration file has a different digest. This can be used to prevent concurrent modifications.
- `disable` (Boolean) Flag to disable the config.
- `validation_delay` (Number) Extra delay in seconds to wait before requesting validation. Allows to cope with a long TTL of DNS records (0 - 172800).

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# ACME accounts can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_acme_dns_plugin.example test
```
`````

## File: docs/resources/virtual_environment_apt_repository.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_apt_repository
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages an APT repository of a Proxmox VE node.
---

# Resource: proxmox_virtual_environment_apt_repository

Manages an APT repository of a Proxmox VE node.

## Example Usage

```terraform
resource "proxmox_virtual_environment_apt_repository" "example" {
  enabled   = true
  file_path = "/etc/apt/sources.list"
  index     = 0
  node      = "pve"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `file_path` (String) The absolute path of the source list file that contains this repository.
- `index` (Number) The index within the defining source list file.
- `node` (String) The name of the target Proxmox VE node.

### Optional

- `enabled` (Boolean) Indicates the activation status.

### Read-Only

- `comment` (String) The associated comment.
- `components` (List of String) The list of components.
- `file_type` (String) The format of the defining source list file.
- `id` (String) The unique identifier of this APT repository resource.
- `package_types` (List of String) The list of package types.
- `suites` (List of String) The list of package distributions.
- `uris` (List of String) The list of repository URIs.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# An APT repository can be imported using a comma-separated list consisting of the name of the Proxmox VE node,
# the absolute source list file path, and the index in the exact same order, e.g.:
terraform import proxmox_virtual_environment_apt_repository.example pve,/etc/apt/sources.list,0
```
`````

## File: docs/resources/virtual_environment_apt_standard_repository.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_apt_standard_repository
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages an APT standard repository of a Proxmox VE node.
---

# Resource: proxmox_virtual_environment_apt_standard_repository

Manages an APT standard repository of a Proxmox VE node.

## Example Usage

```terraform
resource "proxmox_virtual_environment_apt_standard_repository" "example" {
  handle = "no-subscription"
  node   = "pve"
}

resource "proxmox_virtual_environment_apt_repository" "example" {
  enabled   = true
  file_path = proxmox_virtual_environment_apt_standard_repository.example.file_path
  index     = proxmox_virtual_environment_apt_standard_repository.example.index
  node      = proxmox_virtual_environment_apt_standard_repository.example.node
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `handle` (String) The handle of the APT standard repository. Must be `ceph-quincy-enterprise` | `ceph-quincy-no-subscription` | `ceph-quincy-test` | `ceph-reef-enterprise` | `ceph-reef-no-subscription` | `ceph-reef-test` | `enterprise` | `no-subscription` | `test`.
- `node` (String) The name of the target Proxmox VE node.

### Read-Only

- `description` (String) The description of the APT standard repository.
- `file_path` (String) The absolute path of the source list file that contains this standard repository.
- `id` (String) The unique identifier of this APT standard repository resource.
- `index` (Number) The index within the defining source list file.
- `name` (String) The name of the APT standard repository.
- `status` (Number) Indicates the activation status.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# An APT standard repository can be imported using a comma-separated list consisting of the name of the Proxmox VE node,
# and the standard repository handle in the exact same order, e.g.:
terraform import proxmox_virtual_environment_apt_standard_repository.example pve,no-subscription
```
`````

## File: docs/resources/virtual_environment_certificate.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_certificate
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_certificate

Manages the custom SSL/TLS certificate for a specific node.

## Example Usage

```hcl
resource "proxmox_virtual_environment_certificate" "example" {
  certificate = tls_self_signed_cert.proxmox_virtual_environment_certificate.cert_pem
  node_name   = "first-node"
  private_key = tls_private_key.proxmox_virtual_environment_certificate.private_key_pem
}

resource "tls_private_key" "proxmox_virtual_environment_certificate" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

resource "tls_self_signed_cert" "proxmox_virtual_environment_certificate" {
  key_algorithm   = tls_private_key.proxmox_virtual_environment_certificate.algorithm
  private_key_pem = tls_private_key.proxmox_virtual_environment_certificate.private_key_pem

  subject {
    common_name  = "example.com"
    organization = "Terraform Provider for Proxmox"
  }

  validity_period_hours = 8760

  allowed_uses = [
    "key_encipherment",
    "digital_signature",
    "server_auth",
  ]
}
```

## Argument Reference

- `certificate` - (Required) The PEM encoded certificate.
- `certificate_chain` - (Optional) The PEM encoded certificate chain.
- `node_name` - (Required) A node name.
- `private_key` - (Required) The PEM encoded private key.

## Attribute Reference

- `expiration_date` - The expiration date (RFC 3339).
- `file_name` - The file name.
- `issuer` - The issuer.
- `public_key_size` - The public key size.
- `public_key_type` - The public key type.
- `ssl_fingerprint` - The SSL fingerprint.
- `start_date` - The start date (RFC 3339).
- `subject` - The subject.
- `subject_alternative_names` - The subject alternative names.
`````

## File: docs/resources/virtual_environment_cluster_firewall_security_group.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_cluster_firewall_security_group
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_cluster_firewall_security_group

A security group is a collection of rules, defined at cluster level, which can
be used in all VMs' rules. For example, you can define a group named ‚Äúwebserver‚Äù
with rules to open the http and https ports.

## Example Usage

```hcl
resource "proxmox_virtual_environment_cluster_firewall_security_group" "webserver" {
  name    = "webserver"
  comment = "Managed by Terraform"

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow HTTP"
    dest    = "192.168.1.5"
    dport   = "80"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow HTTPS"
    dest    = "192.168.1.5"
    dport   = "443"
    proto   = "tcp"
    log     = "info"
  }
}
```

## Argument Reference

- `name` - (Required) Security group name.
- `comment` - (Optional) Security group comment.
- `rule` - (Optional) Firewall rule block (multiple blocks supported).
    - `action` - (Required) Rule action (`ACCEPT`, `DROP`, `REJECT`).
    - `type` - (Required) Rule type (`in`, `out`).
    - `comment` - (Optional) Rule comment.
    - `dest` - (Optional) Restrict packet destination address. This can refer to
          a single IP address, an IP set ('+ipsetname') or an IP alias
          definition. You can also specify an address range like
          `20.34.101.207-201.3.9.99`, or a list of IP addresses and networks
          (entries are separated by comma). Please do not mix IPv4 and IPv6
          addresses inside such lists.
    - `dport` - (Optional) Restrict TCP/UDP destination port. You can use
        service names or simple numbers (0-65535), as defined in '/etc/
        services'. Port ranges can be specified with '\d+:\d+', for example
        `80:85`, and you can use comma separated list to match several ports or
        ranges.
    - `enable` - (Optional) Enable this rule. Defaults to `true`.
    - `iface` - (Optional) Network interface name. You have to use network
        configuration key names for VMs and containers ('net\d+'). Host related
        rules can use arbitrary strings.
    - `log` - (Optional) Log level for this rule (`emerg`, `alert`, `crit`,
        `err`, `warning`, `notice`, `info`, `debug`, `nolog`).
    - `macro`- (Optional) Macro name. Use predefined standard macro
        from <https://pve.proxmox.com/pve-docs/pve-admin-guide.html#_firewall_macro_definitions>
    - `proto` - (Optional) Restrict packet protocol. You can use protocol names
        as defined in '/etc/protocols'.
    - `source` - (Optional) Restrict packet source address. This can refer
        to a single IP address, an IP set ('+ipsetname') or an IP alias
        definition. You can also specify an address range like
        `20.34.101.207-201.3.9.99`, or a list of IP addresses and networks (
        entries are separated by comma). Please do not mix IPv4 and IPv6
        addresses inside such lists.
    - `sport` - (Optional) Restrict TCP/UDP source port. You can use
        service names or simple numbers (0-65535), as defined in '/etc/
        services'. Port ranges can be specified with '\d+:\d+', for example
        `80:85`, and you can use comma separated list to match several ports or
        ranges.

## Attribute Reference

- `rule`
    - `pos` - Position of the rule in the list.

There are no attribute references available for this resource.

## Import

Instances can be imported using the `name`, e.g.,

```bash
terraform import proxmox_virtual_environment_cluster_firewall_security_group.webserver webserver
```
`````

## File: docs/resources/virtual_environment_cluster_firewall.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_cluster_firewall
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_cluster_firewall

Manages firewall options on the cluster level.

## Example Usage

```hcl
resource "proxmox_virtual_environment_cluster_firewall" "example" {
  enabled = false

  ebtables      = false
  input_policy  = "DROP"
  output_policy = "ACCEPT"
  log_ratelimit {
    enabled = false
    burst   = 10
    rate    = "5/second"
  }
}
```

## Argument Reference

- `enabled` - (Optional) Enable or disable the firewall cluster wide.
- `ebtables` - (Optional) Enable ebtables rules cluster wide.
- `input_policy` - (Optional) The default input policy (`ACCEPT`, `DROP`, `REJECT`).
- `output_policy` - (Optional) The default output policy (`ACCEPT`, `DROP`, `REJECT`).
- `log_ratelimit` - (Optional) The log rate limit.
    - `enabled` - (Optional) Enable or disable the log rate limit.
    - `burst` - (Optional) Initial burst of packages which will always get
        logged before the rate is applied (defaults to `5`).
    - `rate` - (Optional) Frequency with which the burst bucket gets refilled
        (defaults to `1/second`).

## Attribute Reference

There are no additional attributes available for this resource.

## Important Notes

Be careful not to use this resource multiple times for the same node.

## Import

Instances can be imported without an ID, but you still need to pass one, e.g.,

```bash
terraform import proxmox_virtual_environment_cluster_firewall.example example
```
`````

## File: docs/resources/virtual_environment_cluster_options.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_cluster_options
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages Proxmox VE Cluster Datacenter options.
---

# Resource: proxmox_virtual_environment_cluster_options

Manages Proxmox VE Cluster Datacenter options.

## Example Usage

```terraform
resource "proxmox_virtual_environment_cluster_options" "options" {
  language                  = "en"
  keyboard                  = "pl"
  email_from                = "ged@gont.earthsea"
  bandwidth_limit_migration = 555555
  bandwidth_limit_default   = 666666
  max_workers               = 5
  migration_cidr            = "10.0.0.0/8"
  migration_type            = "secure"
  next_id = {
    lower = 100
    upper = 999999999
  }
  notify = {
    ha_fencing_mode            = "never"
    ha_fencing_target          = "default-matcher"
    package_updates            = "always"
    package_updates_target     = "default-matcher"
    package_replication        = "always"
    package_replication_target = "default-matcher"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `bandwidth_limit_clone` (Number) Clone I/O bandwidth limit in KiB/s.
- `bandwidth_limit_default` (Number) Default I/O bandwidth limit in KiB/s.
- `bandwidth_limit_migration` (Number) Migration I/O bandwidth limit in KiB/s.
- `bandwidth_limit_move` (Number) Move I/O bandwidth limit in KiB/s.
- `bandwidth_limit_restore` (Number) Restore I/O bandwidth limit in KiB/s.
- `console` (String) Select the default Console viewer. Must be `applet` | `vv`| `html5` | `xtermjs`. You can either use the builtin java applet (VNC; deprecated and maps to html5), an external virt-viewer compatible application (SPICE), an HTML5 based vnc viewer (noVNC), or an HTML5 based console client (xtermjs). If the selected viewer is not available (e.g. SPICE not activated for the VM), the fallback is noVNC.
- `crs_ha` (String) Cluster resource scheduling setting for HA. Must be `static` | `basic` (default is `basic`).
- `crs_ha_rebalance_on_start` (Boolean) Cluster resource scheduling setting for HA rebalance on start.
- `description` (String) Datacenter description. Shown in the web-interface datacenter notes panel. This is saved as comment inside the configuration file.
- `email_from` (String) email address to send notification from (default is root@$hostname).
- `ha_shutdown_policy` (String) Cluster wide HA shutdown policy (). Must be `freeze` | `failover` | `migrate` | `conditional` (default is `conditional`).
- `http_proxy` (String) Specify external http proxy which is used for downloads (example: `http://username:password@host:port/`).
- `keyboard` (String) Default keyboard layout for vnc server. Must be `de` | `de-ch` | `da` | `en-gb` | `en-us` | `es` | `fi` | `fr` | `fr-be` | `fr-ca` | `fr-ch` | `hu` | `is` | `it` | `ja` | `lt` | `mk` | `nl` | `no` | `pl` | `pt` | `pt-br` | `sv` | `sl` | `tr`.
- `language` (String) Default GUI language. Must be `ca` | `da` | `de` | `en` | `es` | `eu` | `fa` | `fr` | `he` | `it` | `ja` | `nb` | `nn` | `pl` | `pt_BR` | `ru` | `sl` | `sv` | `tr` | `zh_CN` | `zh_TW`.
- `mac_prefix` (String) Prefix for autogenerated MAC addresses.
- `max_workers` (Number) Defines how many workers (per node) are maximal started on actions like 'stopall VMs' or task from the ha-manager.
- `migration_cidr` (String) Cluster wide migration network CIDR.
- `migration_type` (String) Cluster wide migration type. Must be `secure` | `insecure` (default is `secure`).
- `next_id` (Attributes) The ranges for the next free VM ID auto-selection pool. (see [below for nested schema](#nestedatt--next_id))
- `notify` (Attributes) Cluster-wide notification settings. (see [below for nested schema](#nestedatt--notify))

### Read-Only

- `id` (String) The unique identifier of this resource.

<a id="nestedatt--next_id"></a>
### Nested Schema for `next_id`

Optional:

- `lower` (Number) The minimum number for the next free VM ID. Must be higher or equal to 100
- `upper` (Number) The maximum number for the next free VM ID. Must be less or equal to 999999999


<a id="nestedatt--notify"></a>
### Nested Schema for `notify`

Optional:

- `ha_fencing_mode` (String) Cluster-wide notification settings for the HA fencing mode. Must be `always` | `never`.
- `ha_fencing_target` (String) Cluster-wide notification settings for the HA fencing target.
- `package_updates` (String) Cluster-wide notification settings for package updates. Must be `auto` | `always` | `never`.
- `package_updates_target` (String) Cluster-wide notification settings for the package updates target.
- `replication` (String) Cluster-wide notification settings for replication. Must be `always` | `never`.
- `replication_target` (String) Cluster-wide notification settings for the replication target.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# Cluster options are global and can be imported using e.g.:
terraform import proxmox_virtual_environment_cluster_options.options cluster
```
`````

## File: docs/resources/virtual_environment_container.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_container
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_container

Manages a container.

## Example Usage

```hcl
resource "proxmox_virtual_environment_container" "ubuntu_container" {
  description = "Managed by Terraform"

  node_name = "first-node"
  vm_id     = 1234

  initialization {
    hostname = "terraform-provider-proxmox-ubuntu-container"

    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_account {
      keys = [
        trimspace(tls_private_key.ubuntu_container_key.public_key_openssh)
      ]
      password = random_password.ubuntu_container_password.result
    }
  }

  network_interface {
    name = "veth0"
  }

  disk {
    datastore_id = "local-lvm"
    size         = 4
  }
  
  operating_system {
    template_file_id = proxmox_virtual_environment_download_file.latest_ubuntu_22_jammy_lxc_img.id
    # Or you can use a volume ID, as obtained from a "pvesm list <storage>"
    # template_file_id = "local:vztmpl/jammy-server-cloudimg-amd64.tar.gz"
    type             = "ubuntu"
  }

  mount_point {
    # bind mount, *requires* root@pam authentication
    volume = "/mnt/bindmounts/shared"
    path   = "/mnt/shared"
  }

  mount_point {
    # volume mount, a new volume will be created by PVE
    volume = "local-lvm"
    size   = "10G"
    path   = "/mnt/volume"
  }

  startup {
    order      = "3"
    up_delay   = "60"
    down_delay = "60"
  }
}

resource "proxmox_virtual_environment_download_file" "latest_ubuntu_22_jammy_lxc_img" {
  content_type = "vztmpl"
  datastore_id = "local"
  node_name    = "first-node"
  url          = "http://download.proxmox.com/images/system/ubuntu-20.04-standard_20.04-1_amd64.tar.gz"
}

resource "random_password" "ubuntu_container_password" {
  length           = 16
  override_special = "_%@"
  special          = true
}

resource "tls_private_key" "ubuntu_container_key" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

output "ubuntu_container_password" {
  value     = random_password.ubuntu_container_password.result
  sensitive = true
}

output "ubuntu_container_private_key" {
  value     = tls_private_key.ubuntu_container_key.private_key_pem
  sensitive = true
}

output "ubuntu_container_public_key" {
  value = tls_private_key.ubuntu_container_key.public_key_openssh
}
```

## Argument Reference

- `clone` - (Optional) The cloning configuration.
    - `datastore_id` - (Optional) The identifier for the target datastore.
    - `node_name` - (Optional) The name of the source node (leave blank, if
        equal to the `node_name` argument).
    - `vm_id` - (Required) The identifier for the source container.
- `console` - (Optional) The console configuration.
    - `enabled` - (Optional) Whether to enable the console device (defaults
        to `true`).
    - `type` - (Optional) The console mode (defaults to `tty`).
        - `console` - Console.
        - `shell` - Shell.
        - `tty` - TTY.
    - `tty_count` - (Optional) The number of available TTY (defaults to `2`).
- `cpu` - (Optional) The CPU configuration.
    - `architecture` - (Optional) The CPU architecture (defaults to `amd64`).
        - `amd64` - x86 (64 bit).
        - `arm64` - ARM (64-bit).
        - `armhf` - ARM (32 bit).
        - `i386` - x86 (32 bit).
    - `cores` - (Optional) The number of CPU cores (defaults to `1`).
    - `units` - (Optional) The CPU units (defaults to `1024`).
- `description` - (Optional) The description.
- `disk` - (Optional) The disk configuration.
    - `datastore_id` - (Optional) The identifier for the datastore to create the
        disk in (defaults to `local`).
    - `size` - (Optional) The size of the root filesystem in gigabytes (defaults
        to `4`). When set to 0 a directory or zfs/btrfs subvolume will be created.
        Requires `datastore_id` to be set.
- `initialization` - (Optional) The initialization configuration.
    - `dns` - (Optional) The DNS configuration.
        - `domain` - (Optional) The DNS search domain.
        - `server` - (Optional) The DNS server. The `server` attribute is
            deprecated and will be removed in a future release. Please use
            the `servers` attribute instead.
        - `servers` - (Optional) The list of DNS servers.
    - `hostname` - (Optional) The hostname.
    - `ip_config` - (Optional) The IP configuration (one block per network
        device).
        - `ipv4` - (Optional) The IPv4 configuration.
            - `address` - (Optional) The IPv4 address (use `dhcp` for auto-discovery).
            - `gateway` - (Optional) The IPv4 gateway (must be omitted
                when `dhcp` is used as the address).
        - `ipv6` - (Optional) The IPv4 configuration.
            - `address` - (Optional) The IPv6 address (use `dhcp` for auto-discovery).
            - `gateway` - (Optional) The IPv6 gateway (must be omitted
                when `dhcp` is used as the address).
    - `user_account` - (Optional) The user account configuration.
        - `keys` - (Optional) The SSH keys for the root account.
        - `password` - (Optional) The password for the root account.
- `memory` - (Optional) The memory configuration.
    - `dedicated` - (Optional) The dedicated memory in megabytes (defaults
        to `512`).
    - `swap` - (Optional) The swap size in megabytes (defaults to `0`).
- `mount_point`
    - `acl` (Optional) Explicitly enable or disable ACL support.
    - `backup` (Optional) Whether to include the mount point in backups (only
        used for volume mount points, defaults to `false`).
    - `mount_options` (Optional) List of extra mount options.
    - `path` (Required) Path to the mount point as seen from inside the
        container.
    - `quota` (Optional) Enable user quotas inside the container (not supported
        with ZFS subvolumes).
    - `read_only` (Optional) Read-only mount point.
    - `replicate` (Optional) Will include this volume to a storage replica job.
    - `shared` (Optional) Mark this non-volume mount point as available on all
        nodes.
    - `size` (Optional) Volume size (only for volume mount points).
        Can be specified with a unit suffix (e.g. `10G`).
    - `volume` (Required) Volume, device or directory to mount into the
        container.
- `device_passthrough` - (Optional) Device to pass through to the container (multiple blocks supported).
    - `deny_write` - (Optional) Deny the container to write to the device (defaults to `false`).
    - `gid` - (Optional) Group ID to be assigned to the device node.
    - `mode` - (Optional) Access mode to be set on the device node. Must be a
        4-digit octal number.
    - `path` - (Required) Device to pass through to the container (e.g. `/dev/sda`).
    - `uid` - (Optional) User ID to be assigned to the device node.
- `network_interface` - (Optional) A network interface (multiple blocks
    supported).
    - `bridge` - (Optional) The name of the network bridge (defaults
        to `vmbr0`).
    - `enabled` - (Optional) Whether to enable the network device (defaults
        to `true`).
    - `firewall` - (Optional) Whether this interface's firewall rules should be
        used (defaults to `false`).
    - `mac_address` - (Optional) The MAC address.
    - `mtu` - (Optional) Maximum transfer unit of the interface. Cannot be
        larger than the bridge's MTU.
    - `name` - (Required) The network interface name.
    - `rate_limit` - (Optional) The rate limit in megabytes per second.
    - `vlan_id` - (Optional) The VLAN identifier.
- `node_name` - (Required) The name of the node to assign the container to.
- `operating_system` - (Required) The Operating System configuration.
    - `template_file_id` - (Required) The identifier for an OS template file.
       The ID format is `<datastore_id>:<content_type>/<file_name>`, for example `local:iso/jammy-server-cloudimg-amd64.tar.gz`.
       Can be also taken from `proxmox_virtual_environment_download_file` resource, or from the output of `pvesm list <storage>`.
    - `type` - (Optional) The type (defaults to `unmanaged`).
        - `alpine` - Alpine.
        - `archlinux` - Arch Linux.
        - `centos` - CentOS.
        - `debian` - Debian.
        - `devuan` - Devuan.
        - `fedora` - Fedora.
        - `gentoo` - Gentoo.
        - `nixos` - NixOS.
        - `opensuse` - openSUSE.
        - `ubuntu` - Ubuntu.
        - `unmanaged` - Unmanaged.
- `pool_id` - (Optional) The identifier for a pool to assign the container to.
- `protection` - (Optional) Whether to set the protection flag of the container (defaults to `false`). This will prevent the container itself and its disk for remove/update operations.
- `started` - (Optional) Whether to start the container (defaults to `true`).
- `startup` - (Optional) Defines startup and shutdown behavior of the container.
    - `order` - (Required) A non-negative number defining the general startup
        order.
    - `up_delay` - (Optional) A non-negative number defining the delay in
        seconds before the next container is started.
    - `down_delay` - (Optional) A non-negative number defining the delay in
        seconds before the next container is shut down.
- `start_on_boot` - (Optional) Automatically start container when the host
  system boots (defaults to `true`).
- `tags` - (Optional) A list of tags the container tags. This is only meta
  information (defaults to `[]`). Note: Proxmox always sorts the container tags and set them to lowercase.
  If tag contains capital letters, then Proxmox will always report a
  difference on the resource. You may use the `ignore_changes` lifecycle
  meta-argument to ignore changes to this attribute.
- `template` - (Optional) Whether to create a template (defaults to `false`).
- `timeout_create` - (Optional) Timeout for creating a container in seconds (defaults to 1800).
- `timeout_clone` - (Optional) Timeout for cloning a container in seconds (defaults to 1800).
- `timeout_delete` - (Optional) Timeout for deleting a container in seconds (defaults to 60).
- `timeout_update` - (Optional) Timeout for updating a container in seconds (defaults to 1800).
- `unprivileged` - (Optional) Whether the container runs as unprivileged on
  the host (defaults to `false`).
- `vm_id` - (Optional) The container identifier
- `features` - (Optional) The container feature flags. Changing flags (except nesting) is only allowed for `root@pam` authenticated user.
    - `nesting` - (Optional) Whether the container is nested (defaults
        to `false`)
    - `fuse` - (Optional) Whether the container supports FUSE mounts (defaults
        to `false`)
    - `keyctl` - (Optional) Whether the container supports `keyctl()` system
      call (defaults to `false`)
    - `mount` - (Optional) List of allowed mount types (`cifs` or `nfs`)
- `hook_script_file_id` - (Optional) The identifier for a file containing a hook script (needs to be executable, e.g. by using the `proxmox_virtual_environment_file.file_mode` attribute).

## Attribute Reference

There are no additional attributes available for this resource.

## Import

Instances can be imported using the `node_name` and the `vm_id`, e.g.,

```bash
terraform import proxmox_virtual_environment_container.ubuntu_container first-node/1234
```
`````

## File: docs/resources/virtual_environment_dns.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_dns
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_dns

Manages the DNS configuration for a specific node.

## Example Usage

```hcl
resource "proxmox_virtual_environment_dns" "first_node_dns_configuration" {
  domain    = data.proxmox_virtual_environment_dns.first_node_dns_configuration.domain
  node_name = data.proxmox_virtual_environment_dns.first_node_dns_configuration.node_name

  servers = [
    "1.1.1.1",
    "1.0.0.1",
  ]
}

data "proxmox_virtual_environment_dns" "first_node_dns_configuration" {
  node_name = "first-node"
}
```

## Argument Reference

- `domain` - (Required) The DNS search domain.
- `node_name` - (Required) A node name.
- `servers` - (Optional) The DNS servers.

## Attribute Reference

There are no additional attributes available for this resource.

## Important Notes

Be careful not to use this resource multiple times for the same node.

## Import

Instances can be imported using the `node_name`, e.g.,

```bash
terraform import proxmox_virtual_environment_dns.first_node first-node
```
`````

## File: docs/resources/virtual_environment_download_file.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_download_file
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages files upload using PVE download-url API. It can be fully compatible and faster replacement for image files created using proxmox_virtual_environment_file. Supports images for VMs (ISO images) and LXC (CT Templates).
---

# Resource: proxmox_virtual_environment_download_file

Manages files upload using PVE download-url API. It can be fully compatible and faster replacement for image files created using `proxmox_virtual_environment_file`. Supports images for VMs (ISO images) and LXC (CT Templates).

~> Besides the `Datastore.AllocateTemplate` privilege, this resource requires both the `Sys.Audit` and `Sys.Modify` privileges.<br><br>
For more details, see the [`download-url`](https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/storage/{storage}/download-url) API documentation under the "Required permissions" section.

## Example Usage

```terraform
resource "proxmox_virtual_environment_download_file" "release_20231228_debian_12_bookworm_qcow2_img" {
  content_type       = "iso"
  datastore_id       = "local"
  file_name          = "debian-12-generic-amd64-20231228-1609.img"
  node_name          = "pve"
  url                = "https://cloud.debian.org/images/cloud/bookworm/20231228-1609/debian-12-generic-amd64-20231228-1609.qcow2"
  checksum           = "d2fbcf11fb28795842e91364d8c7b69f1870db09ff299eb94e4fbbfa510eb78d141e74c1f4bf6dfa0b7e33d0c3b66e6751886feadb4e9916f778bab1776bdf1b"
  checksum_algorithm = "sha512"
}

resource "proxmox_virtual_environment_download_file" "latest_debian_12_bookworm_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  file_name    = "debian-12-generic-amd64.qcow2.img"
  node_name    = "pve"
  url          = "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
}

resource "proxmox_virtual_environment_download_file" "latest_ubuntu_22_jammy_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}

resource "proxmox_virtual_environment_download_file" "latest_static_ubuntu_24_noble_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"
  overwrite    = false
}

resource "proxmox_virtual_environment_download_file" "release_20231211_ubuntu_22_jammy_lxc_img" {
  content_type       = "vztmpl"
  datastore_id       = "local"
  node_name          = "pve"
  url                = "https://cloud-images.ubuntu.com/releases/22.04/release-20231211/ubuntu-22.04-server-cloudimg-amd64-root.tar.xz"
  checksum           = "c9997dcfea5d826fd04871f960c513665f2e87dd7450bba99f68a97e60e4586e"
  checksum_algorithm = "sha256"
  upload_timeout     = 4444
}

resource "proxmox_virtual_environment_download_file" "latest_ubuntu_22_jammy_lxc_img" {
  content_type = "vztmpl"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.tar.gz"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `content_type` (String) The file content type. Must be `iso` for VM images or `vztmpl` for LXC images.
- `datastore_id` (String) The identifier for the target datastore.
- `node_name` (String) The node name.
- `url` (String) The URL to download the file from. Must match regex: `https?://.*`.

### Optional

- `checksum` (String) The expected checksum of the file.
- `checksum_algorithm` (String) The algorithm to calculate the checksum of the file. Must be `md5` | `sha1` | `sha224` | `sha256` | `sha384` | `sha512`.
- `decompression_algorithm` (String) Decompress the downloaded file using the specified compression algorithm. Must be one of `gz` | `lzo` | `zst` | `bz2`.
- `file_name` (String) The file name. If not provided, it is calculated using `url`. PVE will raise 'wrong file extension' error for some popular extensions file `.raw` or `.qcow2`. Workaround is to use e.g. `.img` instead.
- `overwrite` (Boolean) By default `true`. If `true` and file size has changed in the datastore, it will be replaced. If `false`, there will be no check.
- `overwrite_unmanaged` (Boolean) If `true` and a file with the same name already exists in the datastore, it will be deleted and the new file will be downloaded. If `false` and the file already exists, an error will be returned.
- `upload_timeout` (Number) The file download timeout seconds. Default is 600 (10min).
- `verify` (Boolean) By default `true`. If `false`, no SSL/TLS certificates will be verified.

### Read-Only

- `id` (String) The unique identifier of this resource.
- `size` (Number) The file size in PVE.
`````

## File: docs/resources/virtual_environment_file.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_file
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_file

Use this resource to upload files to a Proxmox VE node. The file can be a backup, an ISO image, a snippet, or a container template depending on the `content_type` attribute.

## Example Usage

### Backups (`backup`)

-> The resource with this content type uses SSH access to the node. You might need to configure the [`ssh` option in the `provider` section](../index.md#node-ip-address-used-for-ssh-connection).

~> The provider currently does not support restoring backups. You can use the Proxmox VE web interface or the `qmrestore` / `pct restore` command to restore VM / Container from a backup.

```hcl
resource "proxmox_virtual_environment_file" "backup" {
  content_type = "backup"
  datastore_id = "local"
  node_name    = "pve"

  source_file {
    path = "vzdump-lxc-100-2023_11_08-23_10_05.tar.zst"
  }
}
```

### Images

-> Consider using `proxmox_virtual_environment_download_file` resource instead. Using this resource for images is less efficient (requires to transfer uploaded image to node) though still supported.

```hcl
resource "proxmox_virtual_environment_file" "ubuntu_container_template" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  source_file {
    path = "https://cloud-images.ubuntu.com/jammy/20230929/jammy-server-cloudimg-amd64-disk-kvm.img"
  }
}
```

### Snippets

-> Snippets are not enabled by default in new Proxmox installations. You need to enable them in the 'Datacenter>Storage' section of the proxmox interface before first using this resource.

-> The resource with this content type uses SSH access to the node. You might need to configure the [`ssh` option in the `provider` section](../index.md#node-ip-address-used-for-ssh-connection).

```hcl
resource "proxmox_virtual_environment_file" "cloud_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"

  source_raw {
    data = <<-EOF
    #cloud-config
    chpasswd:
      list: |
        ubuntu:example
      expire: false
    hostname: example-hostname
    packages:
      - qemu-guest-agent
    users:
      - default
      - name: ubuntu
        groups: sudo
        shell: /bin/bash
        ssh-authorized-keys:
          - ${trimspace(tls_private_key.example.public_key_openssh)}
        sudo: ALL=(ALL) NOPASSWD:ALL
    EOF

    file_name = "example.cloud-config.yaml"
  }
}
```

The `file_mode` attribute can be used to make a script file executable, e.g. when referencing the file in the `hook_script_file_id` attribute of [a container](https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_container#hook_script_file_id) or [a VM](https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_vm#hook_script_file_id) resource which is a requirement enforced by the Proxmox VE API.

```hcl
resource "proxmox_virtual_environment_file" "hook_script" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"
  # Hook scripts must be executable, otherwise the Proxmox VE API will reject the configuration for the VM/CT.
  file_mode    = "0700"

  source_raw {
    data      = <<-EOF
      #!/usr/bin/env bash

      echo "Running hook script"
      EOF
    file_name = "prepare-hook.sh"
  }
}
```

### Container Template (`vztmpl`)

-> Consider using `proxmox_virtual_environment_download_file` resource instead. Using this resource for container images is less efficient (requires to transfer uploaded image to node) though still supported.

```hcl
resource "proxmox_virtual_environment_file" "ubuntu_container_template" {
  content_type = "vztmpl"
  datastore_id = "local"
  node_name    = "first-node"

  source_file {
    path = "https://download.proxmox.com/images/system/ubuntu-20.04-standard_20.04-1_amd64.tar.gz"
  }
}
```

## Argument Reference

- `content_type` - (Optional) The content type. If not specified, the content
    type will be inferred from the file extension. Valid values are:
    - `backup` (allowed extensions: `.vzdump`, `.tar.gz`, `.tar.xz`, `tar.zst`)
    - `iso` (allowed extensions: `.iso`, `.img`)
    - `snippets` (allowed extensions: any)
    - `vztmpl` (allowed extensions: `.tar.gz`, `.tar.xz`, `tar.zst`)
- `datastore_id` - (Required) The datastore id.
- `file_mode` - The file mode in octal format, e.g. `0700` or `600`. Note that the prefixes `0o` and `0x` is not supported! Setting this attribute is also only allowed for `root@pam` authenticated user.
- `node_name` - (Required) The node name.
- `overwrite` - (Optional) Whether to overwrite an existing file (defaults to
    `true`).
- `source_file` - (Optional) The source file (conflicts with `source_raw`),
    could be a local file or a URL. If the source file is a URL, the file will
    be downloaded and stored locally before uploading it to Proxmox VE.
    - `checksum` - (Optional) The SHA256 checksum of the source file.
    - `file_name` - (Optional) The file name to use instead of the source file
        name. Useful when the source file does not have a valid file extension,
        for example when the source file is a URL referencing a `.qcow2` image.
    - `insecure` - (Optional) Whether to skip the TLS verification step for
        HTTPS sources (defaults to `false`).
    - `min_tls` - (Optional) The minimum required TLS version for HTTPS
        sources. "Supported values: `1.0|1.1|1.2|1.3` (defaults to `1.3`).
    - `path` - (Required) A path to a local file or a URL.
- `source_raw` - (Optional) The raw source (conflicts with `source_file`).
    - `data` - (Required) The raw data.
    - `file_name` - (Required) The file name.
    - `resize` - (Optional) The number of bytes to resize the file to.
- `timeout_upload` - (Optional) Timeout for uploading ISO/VSTMPL files in
    seconds (defaults to 1800).

## Attribute Reference

- `file_modification_date` - The file modification date (RFC 3339).
- `file_name` - The file name.
- `file_size` - The file size in bytes.
- `file_tag` - The file tag.

## Important Notes

The Proxmox VE API endpoint for file uploads does not support chunked transfer
encoding, which means that we must first store the source file as a temporary
file locally before uploading it.

You must ensure that you have at least `Size-in-MB * 2 + 1` MB of storage space
available (twice the size plus overhead because a multipart payload needs to be
created as another temporary file).

By default, if the specified file already exists, the resource will
unconditionally replace it and take ownership of the resource. On destruction,
the file will be deleted as if it did not exist before. If you want to prevent
the resource from replacing the file, set `overwrite` to `false`.

## Import

Instances can be imported using the `node_name`, `datastore_id`, `content_type`
and the `file_name` in the following format:

```text
node_name:datastore_id/content_type/file_name
```

Example:

```bash
terraform import proxmox_virtual_environment_file.cloud_config pve/local:snippets/example.cloud-config.yaml
```
`````

## File: docs/resources/virtual_environment_firewall_alias.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_firewall_alias
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_firewall_alias

Aliases are used to see what devices or group of devices are affected by a rule.
We can create aliases to identify an IP address or a network. Aliases can be
created on the cluster level, on VM / Container level.

## Example Usage

```hcl
resource "proxmox_virtual_environment_firewall_alias" "local_network" {
  depends_on = [proxmox_virtual_environment_vm.example]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  name    = "local_network"
  cidr    = "192.168.0.0/23"
  comment = "Managed by Terraform"
}

resource "proxmox_virtual_environment_firewall_alias" "ubuntu_vm" {
  name    = "ubuntu"
  cidr    = "192.168.0.1"
  comment = "Managed by Terraform"
}
```

## Argument Reference

- `node_name` - (Optional) Node name. Leave empty for cluster level aliases.
- `vm_id` - (Optional) VM ID. Leave empty for cluster level aliases.
- `container_id` - (Optional) Container ID. Leave empty for cluster level aliases.
- `name` - (Required) Alias name.
- `cidr` - (Required) Network/IP specification in CIDR format.
- `comment` - (Optional) Alias comment.

## Attribute Reference

There are no attribute references available for this resource.
`````

## File: docs/resources/virtual_environment_firewall_ipset.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_firewall_ipset
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_firewall_ipset

An IPSet allows us to group multiple IP addresses, IP subnets and aliases. Aliases can be
created on the cluster level, on VM / Container level.

## Example Usage

```hcl
resource "proxmox_virtual_environment_firewall_ipset" "ipset" {
  depends_on = [proxmox_virtual_environment_vm.example]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  name    = "local_network"
  comment = "Managed by Terraform"

  cidr {
    name    = "192.168.0.0/23"
    comment = "Local network 1"
  }

  cidr {
    name    = "192.168.0.1"
    comment = "Server 1"
    nomatch = true
  }

  cidr {
    name    = "192.168.2.1"
    comment = "Server 1"
  }
}
```

## Argument Reference

- `node_name` - (Optional) Node name. Leave empty for cluster level aliases.
- `vm_id` - (Optional) VM ID. Leave empty for cluster level aliases.
- `container_id` - (Optional) Container ID. Leave empty for cluster level aliases.
- `name` - (Required) IPSet name.
- `comment` - (Optional) IPSet comment.
- `cidr` - (Optional) IP/CIDR block (multiple blocks supported).
    - `name` - Network/IP specification in CIDR format.
    - `comment` - (Optional) Arbitrary string annotation.
    - `nomatch` - (Optional) Entries marked as `nomatch` are skipped as if those
        were not added to the set.

## Attribute Reference

There are no attribute references available for this resource.
`````

## File: docs/resources/virtual_environment_firewall_options.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_firewall_options
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_firewall_options

Manages firewall options on VM / Container level.

## Example Usage

```hcl
resource "proxmox_virtual_environment_firewall_options" "example" {
  depends_on = [proxmox_virtual_environment_vm.example]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  dhcp          = true
  enabled       = false
  ipfilter      = true
  log_level_in  = "info"
  log_level_out = "info"
  macfilter     = false
  ndp           = true
  input_policy  = "ACCEPT"
  output_policy = "ACCEPT"
  radv          = true
}
```

## Argument Reference

- `node_name` - (Required) Node name.
- `vm_id` - (Optional) VM ID. Leave empty for cluster level aliases.
- `container_id` - (Optional) Container ID. Leave empty for cluster level aliases.
- `dhcp` - (Optional)Enable DHCP.
- `enabled` - (Optional) Enable or disable the firewall.
- `ipfilter` - (Optional) Enable default IP filters. This is equivalent to
    adding an empty `ipfilter-net<id>` ipset for every interface. Such ipsets
    implicitly contain sane default restrictions such as restricting IPv6 link
    local addresses to the one derived from the interface's MAC address. For
    containers the configured IP addresses will be implicitly added.
- `log_level_in` - (Optional) Log level for incoming
    packets (`emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info`,
    `debug`, `nolog`).
- `log_level_out` - (Optional) Log level for outgoing
    packets (`emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info`,
    `debug`, `nolog`).
- `macfilter` - (Optional) Enable/disable MAC address filter.
- `ndp` - (Optional) Enable NDP (Neighbor Discovery Protocol).
- `input_policy` - (Optional) The default input
    policy (`ACCEPT`, `DROP`, `REJECT`).
- `output_policy` - (Optional) The default output
    policy (`ACCEPT`, `DROP`, `REJECT`).
- `radv` - (Optional) Enable Router Advertisement.

## Attribute Reference

There are no additional attributes available for this resource.
`````

## File: docs/resources/virtual_environment_firewall_rules.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_firewall_rules
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_firewall_rules

A security group is a collection of rules, defined at cluster level, which can
be used in all VMs' rules. For example, you can define a group named ‚Äúwebserver‚Äù
with rules to open the http and https ports. Rules can be created on the cluster
level, on VM / Container level.

## Example Usage

```hcl
resource "proxmox_virtual_environment_firewall_rules" "inbound" {
  depends_on = [
    proxmox_virtual_environment_vm.example,
    proxmox_virtual_environment_cluster_firewall_security_group.example,
  ]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow HTTP"
    dest    = "192.168.1.5"
    dport   = "80"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow HTTPS"
    dest    = "192.168.1.5"
    dport   = "443"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    security_group = proxmox_virtual_environment_cluster_firewall_security_group.example.name
    comment        = "From security group"
    iface          = "net0"
  }
}
```

## Argument Reference

- `node_name` - (Optional) Node name. Leave empty for cluster level rules.
- `vm_id` - (Optional) VM ID. Leave empty for cluster level rules.
- `container_id` - (Optional) Container ID. Leave empty for cluster level
    rules.
- `rule` - (Optional) Firewall rule block (multiple blocks supported).
    The provider supports two types of the `rule` blocks:
    - A rule definition block, which includes the following arguments:
        - `action` - (Required) Rule action (`ACCEPT`, `DROP`, `REJECT`).
        - `type` - (Required) Rule type (`in`, `out`).
        - `comment` - (Optional) Rule comment.
        - `dest` - (Optional) Restrict packet destination address. This can
            refer to a single IP address, an IP set ('+ipsetname') or an IP
            alias definition. You can also specify an address range
            like `20.34.101.207-201.3.9.99`, or a list of IP addresses and
            networks (entries are separated by comma). Please do not mix IPv4
            and IPv6 addresses inside such lists.
        - `dport` - (Optional) Restrict TCP/UDP destination port. You can use
            service names or simple numbers (0-65535), as defined
            in `/etc/services`. Port ranges can be specified with '\d+:\d+', for
            example `80:85`, and you can use comma separated list to match
            several ports or ranges.
        - `enabled` - (Optional) Enable this rule. Defaults to `true`.
        - `iface` - (Optional) Network interface name. You have to use network
            configuration key names for VMs and containers ('net\d+'). Host
            related rules can use arbitrary strings.
        - `log` - (Optional) Log level for this rule (`emerg`, `alert`, `crit`,
            `err`, `warning`, `notice`, `info`, `debug`, `nolog`).
        - `macro`- (Optional) Macro name. Use predefined standard macro
            from <https://pve.proxmox.com/pve-docs/pve-admin-guide.html#_firewall_macro_definitions>
        - `proto` - (Optional) Restrict packet protocol. You can use protocol
            names as defined in '/etc/protocols'.
        - `source` - (Optional) Restrict packet source address. This can refer
            to a single IP address, an IP set ('+ipsetname') or an IP alias
            definition. You can also specify an address range
            like `20.34.101.207-201.3.9.99`, or a list of IP addresses and
            networks (entries are separated by comma). Please do not mix IPv4
            and IPv6 addresses inside such lists.
        - `sport` - (Optional) Restrict TCP/UDP source port. You can use
            service names or simple numbers (0-65535), as defined
            in `/etc/services`. Port ranges can be specified with '\d+:\d+', for
            example `80:85`, and you can use comma separated list to match
            several ports or ranges.
    - a security group insertion block, which includes the following arguments:
        - `comment` - (Optional) Rule comment.
        - `enabled` - (Optional) Enable this rule. Defaults to `true`.
        - `iface` - (Optional) Network interface name. You have to use network
            configuration key names for VMs and containers ('net\d+'). Host
            related rules can use arbitrary strings.
        - `security_group` - (Required) Security group name.

## Attribute Reference

- `rule`
    - `pos` - Position of the rule in the list.
`````

## File: docs/resources/virtual_environment_group.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_group
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_group

Manages a user group.

## Example Usage

```hcl
resource "proxmox_virtual_environment_group" "operations_team" {
  comment  = "Managed by Terraform"
  group_id = "operations-team"
}
```

## Argument Reference

- `acl` - (Optional) The access control list (multiple blocks supported).
    - `path` - The path.
    - `propagate` - Whether to propagate to child paths.
    - `role_id` - The role identifier.
- `comment` - (Optional) The group comment.
- `group_id` - (Required) The group identifier.

## Attribute Reference

- `members` - The group members as a list of `username@realm` entries

## Import

Instances can be imported using the `group_id`, e.g.,

```bash
terraform import proxmox_virtual_environment_group.operations_team operations-team
```
`````

## File: docs/resources/virtual_environment_hagroup.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hagroup
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages a High Availability group in a Proxmox VE cluster.
---

# Resource: proxmox_virtual_environment_hagroup

Manages a High Availability group in a Proxmox VE cluster.

## Example Usage

```terraform
resource "proxmox_virtual_environment_hagroup" "example" {
  group   = "example"
  comment = "This is a comment."

  # Member nodes, with or without priority.
  nodes = {
    node1 = null
    node2 = 2
    node3 = 1
  }

  restricted  = true
  no_failback = false
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `group` (String) The identifier of the High Availability group to manage.
- `nodes` (Map of Number) The member nodes for this group. They are provided as a map, where the keys are the node names and the values represent their priority: integers for known priorities or `null` for unset priorities.

### Optional

- `comment` (String) The comment associated with this group
- `no_failback` (Boolean) A flag that indicates that failing back to a higher priority node is disabled for this HA group. Defaults to `false`.
- `restricted` (Boolean) A flag that indicates that other nodes may not be used to run resources associated to this HA group. Defaults to `false`.

### Read-Only

- `id` (String) The unique identifier of this resource.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# HA groups can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hagroup.example example
```
`````

## File: docs/resources/virtual_environment_hardware_mapping_dir.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mapping_dir
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages a directory mapping in a Proxmox VE cluster.
---

# Resource: proxmox_virtual_environment_hardware_mapping_dir

Manages a directory mapping in a Proxmox VE cluster.

## Example Usage

```terraform
resource "proxmox_virtual_environment_hardware_mapping_dir" "example" {
  comment = "This is a comment"
  name    = "example"
  # The actual map of devices.
  map = [
    {
      node = "pve"
      path = "/mnt/data"
    },
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `map` (Attributes Set) The actual map of devices for the hardware mapping. (see [below for nested schema](#nestedatt--map))
- `name` (String) The name of this directory mapping.

### Optional

- `comment` (String) The comment of this directory mapping.

### Read-Only

- `id` (String) The unique identifier of this directory mapping resource.

<a id="nestedatt--map"></a>
### Nested Schema for `map`

Required:

- `node` (String) The node this mapping applies to.
- `path` (String) The path of the map. For directory mappings the path is required and refers to the POSIX path of the directory as visible from the node.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# A directory mapping can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hardware_mapping_dir.example example
```
`````

## File: docs/resources/virtual_environment_hardware_mapping_pci.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mapping_pci
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages a PCI hardware mapping in a Proxmox VE cluster.
---

# Resource: proxmox_virtual_environment_hardware_mapping_pci

Manages a PCI hardware mapping in a Proxmox VE cluster.

## Example Usage

```terraform
resource "proxmox_virtual_environment_hardware_mapping_pci" "example" {
  comment = "This is a comment"
  name    = "example"
  # The actual map of devices.
  map = [
    {
      comment = "This is a device specific comment"
      id      = "8086:5916"
      # This is an optional attribute, but causes a mapping to be incomplete when not defined.
      iommu_group = 0
      node        = "pve"
      path        = "0000:00:02.0"
      # This is an optional attribute, but causes a mapping to be incomplete when not defined.
      subsystem_id = "8086:2068"
    },
  ]
  mediated_devices = true
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `map` (Attributes Set) The actual map of devices for the PCI hardware mapping. (see [below for nested schema](#nestedatt--map))
- `name` (String) The name of this PCI hardware mapping.

### Optional

- `comment` (String) The comment of this PCI hardware mapping.
- `mediated_devices` (Boolean) Indicates whether to enable mediated devices.

### Read-Only

- `id` (String) The unique identifier of this PCI hardware mapping resource.

<a id="nestedatt--map"></a>
### Nested Schema for `map`

Required:

- `id` (String) The ID of the map.
- `node` (String) The node name of the map.
- `path` (String) The path of the map.

Optional:

- `comment` (String) The comment of the mapped PCI device.
- `iommu_group` (Number) The IOMMU group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
- `subsystem_id` (String) The subsystem ID group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# A PCI hardware mapping can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hardware_mapping_pci.example example
```
`````

## File: docs/resources/virtual_environment_hardware_mapping_usb.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hardware_mapping_usb
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages a USB hardware mapping in a Proxmox VE cluster.
---

# Resource: proxmox_virtual_environment_hardware_mapping_usb

Manages a USB hardware mapping in a Proxmox VE cluster.

## Example Usage

```terraform
resource "proxmox_virtual_environment_hardware_mapping_usb" "example" {
  comment = "This is a comment"
  name    = "example"
  # The actual map of devices.
  map = [
    {
      comment = "This is a device specific comment"
      id      = "8087:0a2b"
      node    = "pve"
      # This attribute is optional, but can be used to map the device based on its port instead of only the device ID.
      path = "1-8.2"
    },
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `map` (Attributes Set) The actual map of devices for the hardware mapping. (see [below for nested schema](#nestedatt--map))
- `name` (String) The name of this hardware mapping.

### Optional

- `comment` (String) The comment of this USB hardware mapping.

### Read-Only

- `id` (String) The unique identifier of this USB hardware mapping resource.

<a id="nestedatt--map"></a>
### Nested Schema for `map`

Required:

- `id` (String) The ID of the map.
- `node` (String) The node name of the map.

Optional:

- `comment` (String) The comment of the mapped USB device.
- `path` (String) The path of the map. For hardware mappings of type USB the path is optional and indicates that the device is mapped through the device ID instead of ports.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# A USB hardware mapping can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hardware_mapping_usb.example example
```
`````

## File: docs/resources/virtual_environment_haresource.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_haresource
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages Proxmox HA resources.
---

# Resource: proxmox_virtual_environment_haresource

Manages Proxmox HA resources.

## Example Usage

```terraform
resource "proxmox_virtual_environment_haresource" "example" {
  depends_on = [
    proxmox_virtual_environment_hagroup.example
  ]
  resource_id = "vm:123"
  state       = "started"
  group       = "example"
  comment     = "Managed by Terraform"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `resource_id` (String) The Proxmox HA resource identifier

### Optional

- `comment` (String) The comment associated with this resource.
- `group` (String) The identifier of the High Availability group this resource is a member of.
- `max_relocate` (Number) The maximal number of relocation attempts.
- `max_restart` (Number) The maximal number of restart attempts.
- `state` (String) The desired state of the resource.
- `type` (String) The type of HA resources to create. If unset, it will be deduced from the `resource_id`.

### Read-Only

- `id` (String) The unique identifier of this resource.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
# HA resources can be imported using their identifiers, e.g.:
terraform import proxmox_virtual_environment_haresource.example vm:123
```
`````

## File: docs/resources/virtual_environment_hosts.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_hosts
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_hosts

Manages the host entries on a specific node.

## Example Usage

```hcl
resource "proxmox_virtual_environment_hosts" "first_node_host_entries" {
  node_name = "first-node"

  entry {
    address = "127.0.0.1"

    hostnames = [
      "localhost",
      "localhost.localdomain",
    ]
  }
}
```

## Argument Reference

- `node_name` - (Required) A node name.
- `entry` - (Required) A host entry (multiple blocks supported).
    - `address` - (Required) The IP address.
    - `hostnames` - (Required) The hostnames.

## Attribute Reference

- `addresses` - The IP addresses.
- `digest` - The SHA1 digest.
- `entries` - The host entries (conversion of `addresses` and `hostnames` into
    objects).
- `hostnames` - The hostnames associated with each of the IP addresses.

## Important Notes

Be careful not to use this resource multiple times for the same node.

## Import

Instances can be imported using the `node_name`, e.g.,

```bash
terraform import proxmox_virtual_environment_hosts.first_node_host_entries first-node
```
`````

## File: docs/resources/virtual_environment_metrics_server.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_metrics_server
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages PVE metrics server.
---

# Resource: proxmox_virtual_environment_metrics_server

Manages PVE metrics server.

## Example Usage

```terraform
resource "proxmox_virtual_environment_metrics_server" "influxdb_server" {
  name   = "example_influxdb_server"
  server = "192.168.3.2"
  port   = 8089
  type   = "influxdb"
}

resource "proxmox_virtual_environment_metrics_server" "graphite_server" {
  name   = "example_graphite_server"
  server = "192.168.4.2"
  port   = 2003
  type   = "graphite"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) Unique name that will be ID of this metric server in PVE.
- `port` (Number) Server network port.
- `server` (String) Server dns name or IP address.
- `type` (String) Plugin type. Choice is between `graphite` | `influxdb`.

### Optional

- `disable` (Boolean) Set this to `true` to disable this metric server.
- `graphite_path` (String) Root graphite path (ex: `proxmox.mycluster.mykey`).
- `graphite_proto` (String) Protocol to send graphite data. Choice is between `udp` | `tcp`. If not set, PVE default is `udp`.
- `influx_api_path_prefix` (String) An API path prefix inserted between `<host>:<port>/` and `/api2/`. Can be useful if the InfluxDB service runs behind a reverse proxy.
- `influx_bucket` (String) The InfluxDB bucket/db. Only necessary when using the http v2 api.
- `influx_db_proto` (String) Protocol for InfluxDB. Choice is between `udp` | `http` | `https`. If not set, PVE default is `udp`.
- `influx_max_body_size` (Number) InfluxDB max-body-size in bytes. Requests are batched up to this size. If not set, PVE default is `25000000`.
- `influx_organization` (String) The InfluxDB organization. Only necessary when using the http v2 api. Has no meaning when using v2 compatibility api.
- `influx_token` (String, Sensitive) The InfluxDB access token. Only necessary when using the http v2 api. If the v2 compatibility api is used, use `user:password` instead.
- `influx_verify` (Boolean) Set to `false` to disable certificate verification for https endpoints.
- `mtu` (Number) MTU (maximum transmission unit) for metrics transmission over UDP. If not set, PVE default is `1500` (allowed `512` - `65536`).
- `timeout` (Number) TCP socket timeout in seconds. If not set, PVE default is `1`.

### Read-Only

- `id` (String) The unique identifier of this resource.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
terraform import proxmox_virtual_environment_metrics_server.example example
```
`````

## File: docs/resources/virtual_environment_network_linux_bridge.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_network_linux_bridge
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages a Linux Bridge network interface in a Proxmox VE node.
---

# Resource: proxmox_virtual_environment_network_linux_bridge

Manages a Linux Bridge network interface in a Proxmox VE node.

## Example Usage

```terraform
resource "proxmox_virtual_environment_network_linux_bridge" "vmbr99" {
  depends_on = [
    proxmox_virtual_environment_network_linux_vlan.vlan99
  ]

  node_name = "pve"
  name      = "vmbr99"

  address = "99.99.99.99/16"

  comment = "vmbr99 comment"

  ports = [
    # Network (or VLAN) interfaces to attach to the bridge, specified by their interface name
    # (e.g. "ens18.99" for VLAN 99 on interface ens18).
    # For VLAN interfaces with custom names, use the interface name without the VLAN tag, e.g. "vlan_lab"
    "ens18.99"
  ]
}

resource "proxmox_virtual_environment_network_linux_vlan" "vlan99" {
  node_name = "pve"
  name      = "ens18.99"

  ## or alternatively, use custom name:
  # name      = "vlan_lab"
  # interface = "eno0"
  # vlan      = 98
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The interface name. Commonly vmbr[N], where 0 ‚â§ N ‚â§ 4094 (vmbr0 - vmbr4094), but can be any alphanumeric string that starts with a character and is at most 10 characters long.
- `node_name` (String) The name of the node.

### Optional

- `address` (String) The interface IPv4/CIDR address.
- `address6` (String) The interface IPv6/CIDR address.
- `autostart` (Boolean) Automatically start interface on boot (defaults to `true`).
- `comment` (String) Comment for the interface.
- `gateway` (String) Default gateway address.
- `gateway6` (String) Default IPv6 gateway address.
- `mtu` (Number) The interface MTU.
- `ports` (List of String) The interface bridge ports.
- `vlan_aware` (Boolean) Whether the interface bridge is VLAN aware (defaults to `false`).

### Read-Only

- `id` (String) A unique identifier with format `<node name>:<iface>`

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
#Interfaces can be imported using the `node_name:iface` format, e.g.
terraform import proxmox_virtual_environment_network_linux_bridge.vmbr99 pve:vmbr99
```
`````

## File: docs/resources/virtual_environment_network_linux_vlan.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_network_linux_vlan
parent: Resources
subcategory: Virtual Environment
description: |-
  Manages a Linux VLAN network interface in a Proxmox VE node.
---

# Resource: proxmox_virtual_environment_network_linux_vlan

Manages a Linux VLAN network interface in a Proxmox VE node.

## Example Usage

```terraform
# using VLAN tag
resource "proxmox_virtual_environment_network_linux_vlan" "vlan99" {
  node_name = "pve"
  name      = "eno0.99"

  comment = "VLAN 99"
}

# using custom network interface name
resource "proxmox_virtual_environment_network_linux_vlan" "vlan98" {
  node_name = "pve"
  name      = "vlan_lab"

  interface = "eno0"
  vlan      = 98
  comment   = "VLAN 98"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The interface name. Either add the VLAN tag number to an existing interface name, e.g. `ens18.21` (and do not set `interface` and `vlan`), or use custom name, e.g. `vlan_lab` (`interface` and `vlan` are then required).
- `node_name` (String) The name of the node.

### Optional

- `address` (String) The interface IPv4/CIDR address.
- `address6` (String) The interface IPv6/CIDR address.
- `autostart` (Boolean) Automatically start interface on boot (defaults to `true`).
- `comment` (String) Comment for the interface.
- `gateway` (String) Default gateway address.
- `gateway6` (String) Default IPv6 gateway address.
- `interface` (String) The VLAN raw device. See also `name`.
- `mtu` (Number) The interface MTU.
- `vlan` (Number) The VLAN tag. See also `name`.

### Read-Only

- `id` (String) A unique identifier with format `<node name>:<iface>`.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
#Interfaces can be imported using the `node_name:iface` format, e.g.
terraform import proxmox_virtual_environment_network_linux_vlan.vlan99 pve:vlan99
```
`````

## File: docs/resources/virtual_environment_pool.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_pool
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_pool

Manages a resource pool.

## Example Usage

```hcl
resource "proxmox_virtual_environment_pool" "operations_pool" {
  comment = "Managed by Terraform"
  pool_id = "operations-pool"
}
```

## Argument Reference

- `comment` - (Optional) The pool comment.
- `pool_id` - (Required) The pool identifier.

## Attribute Reference

- `members` - The pool members.
    - `datastore_id` - The datastore identifier.
    - `id` - The member identifier.
    - `node_name` - The node name.
    - `type` - The member type.
    - `vm_id` - The virtual machine identifier.

## Import

Instances can be imported using the `pool_id`, e.g.,

```bash
terraform import proxmox_virtual_environment_pool.operations_pool operations-pool
```
`````

## File: docs/resources/virtual_environment_role.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_role
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_role

Manages a role.

## Example Usage

```hcl
resource "proxmox_virtual_environment_role" "operations_monitoring" {
  role_id = "operations-monitoring"

  privileges = [
    "VM.Monitor",
  ]
}
```

## Argument Reference

- `privileges` - (Required) The role privileges.
- `role_id` - (Required) The role identifier.

## Attribute Reference

There are no additional attributes available for this resource.

## Import

Instances can be imported using the `role_id`, e.g.,

```bash
terraform import proxmox_virtual_environment_role.operations_monitoring operations-monitoring
```
`````

## File: docs/resources/virtual_environment_time.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_time
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_time

Manages the time for a specific node.

## Example Usage

```hcl
resource "proxmox_virtual_environment_time" "first_node_time" {
  node_name = "first-node"
  time_zone = "UTC"
}
```

## Argument Reference

- `node_name` - (Required) A node name.
- `time_zone` - (Required) The node's time zone.

## Attribute Reference

- `local_time` - The node's local time.
- `utc_time` - The node's local time formatted as UTC.

## Import

Instances can be imported using the `node_name`, e.g.,

```bash
terraform import proxmox_virtual_environment_dns.first_node first-node
```
`````

## File: docs/resources/virtual_environment_user_token.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_user_token
parent: Resources
subcategory: Virtual Environment
description: |-
  User API tokens.
---

# Resource: proxmox_virtual_environment_user_token

User API tokens.

## Example Usage

```terraform
# if creating a user token, the user must be created first
resource "proxmox_virtual_environment_user" "user" {
  comment         = "Managed by Terraform"
  email           = "user@pve"
  enabled         = true
  expiration_date = "2034-01-01T22:00:00Z"
  user_id         = "user@pve"
}

resource "proxmox_virtual_environment_user_token" "user_token" {
  comment         = "Managed by Terraform"
  expiration_date = "2033-01-01T22:00:00Z"
  token_name      = "tk1"
  user_id         = proxmox_virtual_environment_user.user.user_id
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `token_name` (String) User-specific token identifier.
- `user_id` (String) User identifier.

### Optional

- `comment` (String) Comment for the token.
- `expiration_date` (String) Expiration date for the token.
- `privileges_separation` (Boolean) Restrict API token privileges with separate ACLs (default), or give full privileges of corresponding user.

### Read-Only

- `id` (String) Unique token identifier with format `<user_id>!<token_name>`.
- `value` (String, Sensitive) API token value used for authentication. It is populated only when creating a new token, and can't be retrieved at import.

## Import

Import is supported using the following syntax:

```shell
#!/usr/bin/env sh
#Tokens can be imported using they identifiers in format `user_id!token_name` format, e.g.:
terraform import proxmox_virtual_environment_user_token.token1 user@pve!token1
```
`````

## File: docs/resources/virtual_environment_user.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_user
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_user

Manages a user.

## Example Usage

```hcl
resource "proxmox_virtual_environment_user" "operations_automation" {
  acl {
    path      = "/vms/1234"
    propagate = true
    role_id   = proxmox_virtual_environment_role.operations_monitoring.role_id
  }

  comment  = "Managed by Terraform"
  password = "a-strong-password"
  user_id  = "operations-automation@pve"
}

resource "proxmox_virtual_environment_role" "operations_monitoring" {
  role_id = "operations-monitoring"

  privileges = [
    "VM.Monitor",
  ]
}
```

## Argument Reference

- `acl` - (Optional) The access control list (multiple blocks supported).
    - `path` - The path.
    - `propagate` - Whether to propagate to child paths.
    - `role_id` - The role identifier.
- `comment` - (Optional) The user comment.
- `email` - (Optional) The user's email address.
- `enabled` - (Optional) Whether the user account is enabled.
- `expiration_date` - (Optional) The user account's expiration date (RFC 3339).
- `first_name` - (Optional) The user's first name.
- `groups` - (Optional) The user's groups.
- `keys` - (Optional) The user's keys.
- `last_name` - (Optional) The user's last name.
- `password` - (Optional) The user's password. Required for PVE or PAM realms.
- `user_id` - (Required) The user identifier.

## Attribute Reference

There are no additional attributes available for this resource.

## Import

Instances can be imported using the `user_id`, e.g.,

```bash
terraform import proxmox_virtual_environment_user.operations_automation operations-automation@pve
```
`````

## File: docs/resources/virtual_environment_vm.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_vm
parent: Resources
subcategory: Virtual Environment
---

# Resource: proxmox_virtual_environment_vm

Manages a virtual machine.

> This resource uses SSH access to the node. You might need to configure the [`ssh` option in the `provider` section](../index.md#node-ip-address-used-for-ssh-connection).

## Example Usage

```hcl
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name        = "terraform-provider-proxmox-ubuntu-vm"
  description = "Managed by Terraform"
  tags        = ["terraform", "ubuntu"]

  node_name = "first-node"
  vm_id     = 4321

  agent {
    # read 'Qemu guest agent' section, change to true only when ready
    enabled = false
  }
  # if agent is not enabled, the VM may not be able to shutdown properly, and may need to be forced off
  stop_on_destroy = true

  startup {
    order      = "3"
    up_delay   = "60"
    down_delay = "60"
  }

  cpu {
    cores        = 2
    type         = "x86-64-v2-AES"  # recommended for modern CPUs
  }

  memory {
    dedicated = 2048
    floating  = 2048 # set equal to dedicated to enable ballooning
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.latest_ubuntu_22_jammy_qcow2_img.id
    interface    = "scsi0"
  }

  initialization {
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_account {
      keys     = [trimspace(tls_private_key.ubuntu_vm_key.public_key_openssh)]
      password = random_password.ubuntu_vm_password.result
      username = "ubuntu"
    }

    user_data_file_id = proxmox_virtual_environment_file.cloud_config.id
  }

  network_device {
    bridge = "vmbr0"
  }

  operating_system {
    type = "l26"
  }

  tpm_state {
    version = "v2.0"
  }

  serial_device {}

  virtiofs {
    mapping = "data_share"
    cache = "always"
    direct_io = true
  }
}

resource "proxmox_virtual_environment_download_file" "latest_ubuntu_22_jammy_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}

resource "random_password" "ubuntu_vm_password" {
  length           = 16
  override_special = "_%@"
  special          = true
}

resource "tls_private_key" "ubuntu_vm_key" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

output "ubuntu_vm_password" {
  value     = random_password.ubuntu_vm_password.result
  sensitive = true
}

output "ubuntu_vm_private_key" {
  value     = tls_private_key.ubuntu_vm_key.private_key_pem
  sensitive = true
}

output "ubuntu_vm_public_key" {
  value = tls_private_key.ubuntu_vm_key.public_key_openssh
}
```

## Argument Reference

- `acpi` - (Optional) Whether to enable ACPI (defaults to `true`).
- `agent` - (Optional) The QEMU agent configuration.
    - `enabled` - (Optional) Whether to enable the QEMU agent (defaults
        to `false`).
    - `timeout` - (Optional) The maximum amount of time to wait for data from
        the QEMU agent to become available ( defaults to `15m`).
    - `trim` - (Optional) Whether to enable the FSTRIM feature in the QEMU agent
        (defaults to `false`).
    - `type` - (Optional) The QEMU agent interface type (defaults to `virtio`).
        - `isa` - ISA Serial Port.
        - `virtio` - VirtIO (paravirtualized).
- `amd_sev` - (Optional) Secure Encrypted Virtualization (SEV) features by AMD CPUs.
    - `type` - (Optional) Enable standard SEV with `std` or enable experimental SEV-ES with the `es` option or enable experimental SEV-SNP with the `snp` option (defaults to `std`).
    - `allow_smt` - (Optional) Sets policy bit to allow Simultaneous Multi Threading (SMT)
        (Ignored unless for SEV-SNP) (defaults to `true`).
    - `kernel_hashes` - (Optional) Add kernel hashes to guest firmware for measured linux kernel launch (defaults to `false`).
    - `no_debug` - (Optional) Sets policy bit to disallow debugging of guest (defaults
        to `false`).
    - `no_key_sharing` - (Optional) Sets policy bit to disallow key sharing with other guests (Ignored for SEV-SNP) (defaults to `false`).

    The `amd_sev` setting is only allowed for a `root@pam` authenticated user.
- `audio_device` - (Optional) An audio device.
    - `device` - (Optional) The device (defaults to `intel-hda`).
        - `AC97` - Intel 82801AA AC97 Audio.
        - `ich9-intel-hda` - Intel HD Audio Controller (ich9).
        - `intel-hda` - Intel HD Audio.
    - `driver` - (Optional) The driver (defaults to `spice`).
        - `spice` - Spice.
    - `enabled` - (Optional) Whether to enable the audio device (defaults
        to `true`).
- `bios` - (Optional) The BIOS implementation (defaults to `seabios`).
    - `ovmf` - OVMF (UEFI).
    - `seabios` - SeaBIOS.
- `boot_order` - (Optional) Specify a list of devices to boot from in the order
    they appear in the list (defaults to `[]`).
- `cdrom` - (Optional) The CD-ROM configuration.
    - `enabled` - (Optional) Whether to enable the CD-ROM drive (defaults
        to `false`). *Deprecated*. The attribute will be removed in the next version of the provider.
        Set `file_id` to `none` to leave the CD-ROM drive empty.
    - `file_id` - (Optional) A file ID for an ISO file (defaults to `cdrom` as
        in the physical drive). Use `none` to leave the CD-ROM drive empty.
    - `interface` - (Optional) A hardware interface to connect CD-ROM drive to (defaults to `ide3`).
      "Must be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. " +
      "Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
- `clone` - (Optional) The cloning configuration.
    - `datastore_id` - (Optional) The identifier for the target datastore.
    - `node_name` - (Optional) The name of the source node (leave blank, if
        equal to the `node_name` argument).
    - `retries` - (Optional) Number of retries in Proxmox for clone vm.
        Sometimes Proxmox errors with timeout when creating multiple clones at
        once.
    - `vm_id` - (Required) The identifier for the source VM.
    - `full` - (Optional) Full or linked clone (defaults to `true`).
- `cpu` - (Optional) The CPU configuration.
    - `architecture` - (Optional) The CPU architecture (defaults to `x86_64`).
        - `aarch64` - ARM (64 bit).
        - `x86_64` - x86 (64-bit).
    - `cores` - (Optional) The number of CPU cores (defaults to `1`).
    - `flags` - (Optional) The CPU flags.
        - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
        - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
            vulnerable for Spectre on AMD CPUs.
        - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
            AMD CPUs, best used with "virt-ssbd".
        - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
            virtualization (only supported on Intel CPUs).
        - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
            Windows guests (may lead to guest BSOD on old CPUs).
        - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
        - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
            mitigated correctly.
        - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
            Ivy Bridge Intel CPUs.
        - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
            host HW supports it.
        - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
            Intel CPUs.
        - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
            models.
        - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
            protection for AMD models.
    - `hotplugged` - (Optional) The number of hotplugged vCPUs (defaults
        to `0`).
    - `limit` - (Optional) Limit of CPU usage, `0...128`. (defaults to `0` -- no limit).
    - `numa` - (Boolean) Enable/disable NUMA. (default to `false`)
    - `sockets` - (Optional) The number of CPU sockets (defaults to `1`).
    - `type` - (Optional) The emulated CPU type, it's recommended to
        use `x86-64-v2-AES` (defaults to `qemu64`).
        - `486` - Intel 486.
        - `Broadwell`/`Broadwell-IBRS`/`Broadwell-noTSX`/`Broadwell-noTSX-IBRS` - Intel Core Processor (Broadwell, 2014).
        - `Cascadelake-Server`/`Cascadelake-Server-noTSX`/`Cascadelake-Server-v2`/`Cascadelake-Server-v4`/`Cascadelake-Server-v5` - Intel Xeon 32xx/42xx/52xx/62xx/82xx/92xx (2019).
        - `Conroe` - Intel Celeron_4x0 (Conroe/Merom Class Core 2, 2006).
        - `Cooperlake`/`Cooperlake-v2`
        - `EPYC`/`EPYC-IBPB`/`EPYC-Milan`/`EPYC-Rome`/`EPYC-Rome-v2`/`EPYC-v3` / `EPYC-v4` -
            AMD EPYC Processor (2017).
        - `Haswell`/`Haswell-IBRS`/`Haswell-noTSX`/`Haswell-noTSX-IBRS` - Intel
            Core Processor (Haswell, 2013).
        - `Icelake-Client`/`Icelake-Client-noTSX`
        - `Icelake-Server`/`Icelake-Server-noTSX`/`Icelake-Server-v3`/
            `Icelake-Server-v4`/`Icelake-Server-v5`/`Icelake-Server-v6`
        - `IvyBridge`/`IvyBridge-IBRS` - Intel Xeon E3-12xx v2 (Ivy Bridge,
              2012).
        - `KnightsMill` - Intel Xeon Phi 72xx (2017).
        - `Nehalem`/`Nehalem-IBRS` - Intel Core i7 9xx (Nehalem Class Core i7,
            2008).
        - `Opteron_G1` - AMD Opteron 240 (Gen 1 Class Opteron, 2004).
        - `Opteron_G2` - AMD Opteron 22xx (Gen 2 Class Opteron, 2006).
        - `Opteron_G3` - AMD Opteron 23xx (Gen 3 Class Opteron, 2009).
        - `Opteron_G4` - AMD Opteron 62xx class CPU (2011).
        - `Opteron_G5` - AMD Opteron 63xx class CPU (2012).
        - `Penryn` - Intel Core 2 Duo P9xxx (Penryn Class Core 2, 2007).
        - `SandyBridge`/`SandyBridge-IBRS` - Intel Xeon E312xx (Sandy Bridge,
            2011).
        - `SapphireRapids`
        - `Skylake-Client`/`Skylake-Client-IBRS`/`Skylake-Client-noTSX-IBRS`/`Skylake-Client-v4` -
            Intel Core Processor (Skylake, 2015).
        - `Skylake-Server`/`Skylake-Server-IBRS`/`Skylake-Server-noTSX-IBRS`/`Skylake-Server-v4`/`Skylake-Server-v5` -
            Intel Xeon Processor (Skylake, 2016).
        - `Westmere`/`Westmere-IBRS` - Intel Westmere E56xx/L56xx/X56xx (
            Nehalem-C, 2010).
        - `athlon` - AMD Athlon.
        - `core2duo` - Intel Core 2 Duo.
        - `coreduo` - Intel Core Duo.
        - `host` - Host pass-through.
        - `kvm32`/`kvm64` - Common KVM processor (32 & 64 bit variants).
        - `max` - Maximum amount of features from host CPU.
        - `pentium` - Intel Pentium (1993).
        - `pentium2` - Intel Pentium 2 (1997-1999).
        - `pentium3` - Intel Pentium 3 (1999-2001).
        - `phenom` - AMD Phenom (2010).
        - `qemu32`/`qemu64` - QEMU Virtual CPU version 2.5+ (32 & 64 bit
            variants).
        - `x86-64-v2`/`x86-64-v2-AES`/`x86-64-v3`/`x86-64-v4`
            See <https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels>
        - `custom-<model>` - Custom CPU model. All `custom-<model>` values
            should be defined in `/etc/pve/virtual-guest/cpu-models.conf` file.
    - `units` - (Optional) The CPU units (defaults to `1024`).
    - `affinity` - (Optional) The CPU cores that are used to run the VM‚Äôs vCPU. The
        value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.
        For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM‚Äôs vCPUs are run on the first four
        CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
- `description` - (Optional) The description.
- `disk` - (Optional) A disk (multiple blocks supported).
    - `aio` - (Optional) The disk AIO mode (defaults to `io_uring`).
        - `io_uring` - Use io_uring.
        - `native` - Use native AIO. Should be used with to unbuffered, O_DIRECT, raw block storage only,
            with the disk `cache` must be set to `none`. Raw block storage types include iSCSI, CEPH/RBD, and NVMe.
        - `threads` - Use thread-based AIO.
    - `backup` - (Optional) Whether the drive should be included when making backups (defaults to `true`).
    - `cache` - (Optional) The cache type (defaults to `none`).
        - `none` - No cache.
        - `directsync` - Write to the host cache and wait for completion.
        - `writethrough` - Write to the host cache, but write through to
            the guest.
        - `writeback` - Write to the host cache, but write back to the
            guest when possible.
        - `unsafe` - Write directly to the disk bypassing the host cache.
    - `datastore_id` - (Optional) The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
    - `path_in_datastore` - (Optional) The in-datastore path to the disk image.
        ***Experimental.***Use to attach another VM's disks,
        or (as root only) host's filesystem paths (`datastore_id` empty string).
        See "*Example: Attached disks*".
    - `discard` - (Optional) Whether to pass discard/trim requests to the
        underlying storage. Supported values are `on`/`ignore` (defaults
        to `ignore`).
    - `file_format` - (Optional) The file format.
        - `qcow2` - QEMU Disk Image v2.
        - `raw` - Raw Disk Image.
        - `vmdk` - VMware Disk Image.
    - `file_id` - (Optional) The file ID for a disk image when importing a disk into VM. The ID format is
          `<datastore_id>:<content_type>/<file_name>`, for example `local:iso/centos8.img`. Can be also taken from
          `proxmox_virtual_environment_download_file` resource.
    - `interface` - (Required) The disk interface for Proxmox, currently `scsi`,
        `sata` and `virtio` interfaces are supported. Append the disk index at
        the end, for example, `virtio0` for the first virtio disk, `virtio1` for
        the second, etc.
    - `iothread` - (Optional) Whether to use iothreads for this disk (defaults
        to `false`).
    - `replicate` - (Optional) Whether the drive should be considered for replication jobs (defaults to `true`).
    - `serial` - (Optional) The serial number of the disk, up to 20 bytes long.
    - `size` - (Optional) The disk size in gigabytes (defaults to `8`).
    - `speed` - (Optional) The speed limits.
        - `iops_read` - (Optional) The maximum read I/O in operations per second.
        - `iops_read_burstable` - (Optional) The maximum unthrottled read I/O pool in operations per second.
        - `iops_write` - (Optional) The maximum write I/O in operations per second.
        - `iops_write_burstable` - (Optional) The maximum unthrottled write I/O pool in operations per second.
        - `read` - (Optional) The maximum read speed in megabytes per second.
        - `read_burstable` - (Optional) The maximum burstable read speed in
            megabytes per second.
        - `write` - (Optional) The maximum write speed in megabytes per second.
        - `write_burstable` - (Optional) The maximum burstable write speed in
            megabytes per second.
    - `ssd` - (Optional) Whether to use an SSD emulation option for this disk (
        defaults to `false`). Note that SSD emulation is not supported on VirtIO
        Block drives.
- `efi_disk` - (Optional) The efi disk device (required if `bios` is set
    to `ovmf`)
    - `datastore_id` (Optional) The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
    - `file_format` (Optional) The file format (defaults to `raw`).
    - `type` (Optional) Size and type of the OVMF EFI disk. `4m` is newer and
        recommended, and required for Secure Boot. For backwards compatibility
        use `2m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `2m`).
    - `pre_enrolled_keys` (Optional) Use am EFI vars template with
        distribution-specific and Microsoft Standard keys enrolled, if used with
        EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `false`).
- `tpm_state` - (Optional) The TPM state device.
    - `datastore_id` (Optional) The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
    - `version` (Optional) TPM state device version. Can be `v1.2` or `v2.0`.
        (defaults to `v2.0`).
- `hostpci` - (Optional) A host PCI device mapping (multiple blocks supported).
    - `device` - (Required) The PCI device name for Proxmox, in form
        of `hostpciX` where `X` is a sequential number from 0 to 15.
    - `id` - (Optional) The PCI device ID. This parameter is not compatible
        with `api_token` and requires the root `username` and `password`
        configured in the proxmox provider. Use either this or `mapping`.
    - `mapping` - (Optional) The resource mapping name of the device, for
        example gpu. Use either this or `id`.
    - `mdev` - (Optional) The mediated device ID to use.
    - `pcie` - (Optional) Tells Proxmox to use a PCIe or PCI port. Some
        guests/device combination require PCIe rather than PCI. PCIe is only
        available for q35 machine types.
    - `rombar` - (Optional) Makes the firmware ROM visible for the VM (defaults
        to `true`).
    - `rom_file` - (Optional) A path to a ROM file for the device to use. This
        is a relative path under `/usr/share/kvm/`.
    - `xvga` - (Optional) Marks the PCI(e) device as the primary GPU of the VM.
        With this enabled the `vga` configuration argument will be ignored.
- `usb` - (Optional) A host USB device mapping (multiple blocks supported).
    - `host` - (Optional) The Host USB device or port or the value `spice`. Use either this or `mapping`.
    - `mapping` - (Optional) The cluster-wide resource mapping name of the device, for example "usbdevice". Use either this or `host`.
    - `usb3` - (Optional) Makes the USB device a USB3 device for the VM
        (defaults to `false`).
- `initialization` - (Optional) The cloud-init configuration.
    - `datastore_id` - (Optional) The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
    - `interface` - (Optional) The hardware interface to connect the cloud-init
        image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
        detected if the setting is missing but a cloud-init image is present,
        otherwise defaults to `ide2`.
    - `dns` - (Optional) The DNS configuration.
        - `domain` - (Optional) The DNS search domain.
        - `server` - (Optional) The DNS server. The `server` attribute is
            deprecated and will be removed in a future release. Please use the
            `servers` attribute instead.
        - `servers` - (Optional) The list of DNS servers.
    - `ip_config` - (Optional) The IP configuration (one block per network
        device).
        - `ipv4` - (Optional) The IPv4 configuration.
            - `address` - (Optional) The IPv4 address in CIDR notation
                (e.g. 192.168.2.2/24). Alternatively, set this to `dhcp` for
                autodiscovery.
            - `gateway` - (Optional) The IPv4 gateway (must be omitted
                when `dhcp` is used as the address).
        - `ipv6` - (Optional) The IPv6 configuration.
            - `address` - (Optional) The IPv6 address in CIDR notation
                (e.g. fd1c:000:0000::0000:000:7334/64). Alternatively, set this
                to `dhcp` for autodiscovery.
            - `gateway` - (Optional) The IPv6 gateway (must be omitted
                when `dhcp` is used as the address).
    - `user_account` - (Optional) The user account configuration (conflicts
        with `user_data_file_id`).
        - `keys` - (Optional) The SSH keys.
        - `password` - (Optional) The SSH password.
        - `username` - (Optional) The SSH username.
    - `network_data_file_id` - (Optional) The identifier for a file containing
        network configuration data passed to the VM via cloud-init (conflicts
        with `ip_config`).
    - `user_data_file_id` - (Optional) The identifier for a file containing
        custom user data (conflicts with `user_account`).
    - `vendor_data_file_id` - (Optional) The identifier for a file containing
        all vendor data passed to the VM via cloud-init.
    - `meta_data_file_id` - (Optional) The identifier for a file containing
        all meta data passed to the VM via cloud-init.
- `keyboard_layout` - (Optional) The keyboard layout (defaults to `en-us`).
    - `da` - Danish.
    - `de` - German.
    - `de-ch` - Swiss German.
    - `en-gb` - British English.
    - `en-us` - American English.
    - `es` - Spanish.
    - `fi` - Finnish.
    - `fr` - French.
    - `fr-be` - Belgian French.
    - `fr-ca` - French Canadian.
    - `fr-ch` - Swish French.
    - `hu` - Hungarian.
    - `is` - Icelandic.
    - `it` - Italian.
    - `ja` - Japanese.
    - `lt` - Lithuanian.
    - `mk` - Macedonian.
    - `nl` - Dutch.
    - `no` - Norwegian.
    - `pl` - Polish.
    - `pt` - Portuguese.
    - `pt-br` - Brazilian Portuguese.
    - `sl` - Slovenian.
    - `sv` - Swedish.
    - `tr` - Turkish.
- `kvm_arguments` - (Optional) Arbitrary arguments passed to kvm.
- `machine` - (Optional) The VM machine type (defaults to `pc`).
    - `pc` - Standard PC (i440FX + PIIX, 1996).
    - `q35` - Standard PC (Q35 + ICH9, 2009). Optionally, you can enable VIOMMU by adding `viommu=virtio|intel` to the value, for example `q35,viommu=virtio`.
- `memory` - (Optional) The memory configuration.
    - `dedicated` - (Optional) The dedicated memory in megabytes (defaults to `512`).
    - `floating` - (Optional) The floating memory in megabytes. The default is `0`, which disables "ballooning device" for the VM.
        Please note that Proxmox has ballooning enabled by default. To enable it, set `floating` to the same value as `dedicated`.
        See [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_memory) section 10.2.6 for more information.
    - `shared` - (Optional) The shared memory in megabytes (defaults to `0`).
    - `hugepages` - (Optional) Enable/disable hugepages memory (defaults to disable).
        - `2` - 2MB hugepages.
        - `1024` - 1GB hugepages.
        - `any` - Any hugepages.
    - `keep_hugepages` - (Optional) Keep hugepages memory after the VM is stopped (defaults to `false`).

    Settings `hugepages` and `keep_hugepages` are only allowed for `root@pam` authenticated user.
    And required `cpu.numa` to be enabled.
- `numa` - (Optional) The NUMA configuration.
    - `device` - (Required) The NUMA device name for Proxmox, in form
        of `numaX` where `X` is a sequential number from 0 to 7.
    - `cpus` - (Required) The CPU cores to assign to the NUMA node (format is `0-7;16-31`).
    - `memory` - (Required) The memory in megabytes to assign to the NUMA node.
    - `hostnodes` - (Optional) The NUMA host nodes.
    - `policy` - (Optional) The NUMA policy (defaults to `preferred`).
        - `interleave` - Interleave memory across nodes.
        - `preferred` - Prefer the specified node.
        - `bind` - Only use the specified node.

- `migrate` - (Optional) Migrate the VM on node change instead of re-creating
    it (defaults to `false`).
- `name` - (Optional) The virtual machine name.
- `network_device` - (Optional) A network device (multiple blocks supported).
    - `bridge` - (Optional) The name of the network bridge (defaults to `vmbr0`).
    - `disconnected` - (Optional) Whether to disconnect the network device from the network (defaults to `false`).
    - `enabled` - (Optional) Whether to enable the network device (defaults to `true`).
    - `firewall` - (Optional) Whether this interface's firewall rules should be used (defaults to `false`).
    - `mac_address` - (Optional) The MAC address.
    - `model` - (Optional) The network device model (defaults to `virtio`).
        - `e1000` - Intel E1000.
        - `e1000e` - Intel E1000E.
        - `rtl8139` - Realtek RTL8139.
        - `virtio` - VirtIO (paravirtualized).
        - `vmxnet3` - VMware vmxnet3.
    - `mtu` - (Optional) Force MTU, for VirtIO only. Set to 1 to use the bridge MTU. Cannot be larger than the bridge MTU.
    - `queues` - (Optional) The number of queues for VirtIO (1..64).
    - `rate_limit` - (Optional) The rate limit in megabytes per second.
    - `vlan_id` - (Optional) The VLAN identifier.
    - `trunks` - (Optional) String containing a `;` separated list of VLAN trunks
        ("10;20;30"). Note that the VLAN-aware feature need to be enabled on the PVE
        Linux Bridge to use trunks.
- `node_name` - (Required) The name of the node to assign the virtual machine
    to.
- `on_boot` - (Optional) Specifies whether a VM will be started during system
    boot. (defaults to `true`)
- `operating_system` - (Optional) The Operating System configuration.
    - `type` - (Optional) The type (defaults to `other`).
        - `l24` - Linux Kernel 2.4.
        - `l26` - Linux Kernel 2.6 - 5.X.
        - `other` - Unspecified OS.
        - `solaris` - OpenIndiania, OpenSolaris og Solaris Kernel.
        - `w2k` - Windows 2000.
        - `w2k3` - Windows 2003.
        - `w2k8` - Windows 2008.
        - `win7` - Windows 7.
        - `win8` - Windows 8, 2012 or 2012 R2.
        - `win10` - Windows 10 or 2016.
        - `win11` - Windows 11
        - `wvista` - Windows Vista.
        - `wxp` - Windows XP.
- `pool_id` - (Optional) The identifier for a pool to assign the virtual machine to.
- `protection` - (Optional) Sets the protection flag of the VM. This will disable the remove VM and remove disk operations (defaults to `false`).
- `reboot` - (Optional) Reboot the VM after initial creation (defaults to `false`).
- `reboot_after_update` - (Optional) Reboot the VM after update if needed (defaults to `true`).
- `rng` - (Optional) The random number generator configuration. Can only be set by `root@pam.`
    - `source` - The file on the host to gather entropy from. In most cases, `/dev/urandom` should be preferred over `/dev/random` to avoid entropy-starvation issues on the host.
    - `max_bytes` - (Optional) Maximum bytes of entropy allowed to get injected into the guest every `period` milliseconds (defaults to `1024`). Prefer a lower value when using `/dev/random` as source.
    - `period` - (Optional) Every `period` milliseconds the entropy-injection quota is reset, allowing the guest to retrieve another `max_bytes` of entropy (defaults to `1000`).
- `serial_device` - (Optional) A serial device (multiple blocks supported).
    - `device` - (Optional) The device (defaults to `socket`).
        - `/dev/*` - A host serial device.
        - `socket` - A unix socket.
- `scsi_hardware` - (Optional) The SCSI hardware type (defaults to
    `virtio-scsi-pci`).
    - `lsi` - LSI Logic SAS1068E.
    - `lsi53c810` - LSI Logic 53C810.
    - `virtio-scsi-pci` - VirtIO SCSI.
    - `virtio-scsi-single` - VirtIO SCSI (single queue).
    - `megasas` - LSI Logic MegaRAID SAS.
    - `pvscsi` - VMware Paravirtual SCSI.
- `smbios` - (Optional) The SMBIOS (type1) settings for the VM.
    - `family`- (Optional) The family string.
    - `manufacturer` - (Optional) The manufacturer.
    - `product` - (Optional) The product ID.
    - `serial` - (Optional) The serial number.
    - `sku` - (Optional) The SKU number.
    - `uuid` - (Optional) The UUID (defaults to randomly generated UUID).
    - `version` - (Optional) The version.
- `started` - (Optional) Whether to start the virtual machine (defaults
    to `true`).
- `startup` - (Optional) Defines startup and shutdown behavior of the VM.
    - `order` - (Required) A non-negative number defining the general startup
        order.
    - `up_delay` - (Optional) A non-negative number defining the delay in
        seconds before the next VM is started.
    - `down_delay` - (Optional) A non-negative number defining the delay in
        seconds before the next VM is shut down.
- `tablet_device` - (Optional) Whether to enable the USB tablet device (defaults
    to `true`).
- `tags` - (Optional) A list of tags of the VM. This is only meta information (
    defaults to `[]`). Note: Proxmox always sorts the VM tags. If the list in
    template is not sorted, then Proxmox will always report a difference on the
    resource. You may use the `ignore_changes` lifecycle meta-argument to ignore
    changes to this attribute.
- `template` - (Optional) Whether to create a template (defaults to `false`).
- `stop_on_destroy` - (Optional) Whether to stop rather than shutdown on VM destroy (defaults to `false`)
- `timeout_clone` - (Optional) Timeout for cloning a VM in seconds (defaults to
    1800).
- `timeout_create` - (Optional) Timeout for creating a VM in seconds (defaults to
    1800).
- `timeout_migrate` - (Optional) Timeout for migrating the VM (defaults to
    1800).
- `timeout_reboot` - (Optional) Timeout for rebooting a VM in seconds (defaults
    to 1800).
- `timeout_shutdown_vm` - (Optional) Timeout for shutting down a VM in seconds (
    defaults to 1800).
- `timeout_start_vm` - (Optional) Timeout for starting a VM in seconds (defaults
    to 1800).
- `timeout_stop_vm` - (Optional) Timeout for stopping a VM in seconds (defaults
    to 300).
- `vga` - (Optional) The VGA configuration.
    - `memory` - (Optional) The VGA memory in megabytes (defaults to `16`).
    - `type` - (Optional) The VGA type (defaults to `std`).
        - `cirrus` - Cirrus (deprecated since QEMU 2.2).
        - `none` - No VGA device.
        - `qxl` - SPICE.
        - `qxl2` - SPICE Dual Monitor.
        - `qxl3` - SPICE Triple Monitor.
        - `qxl4` - SPICE Quad Monitor.
        - `serial0` - Serial Terminal 0.
        - `serial1` - Serial Terminal 1.
        - `serial2` - Serial Terminal 2.
        - `serial3` - Serial Terminal 3.
        - `std` - Standard VGA.
        - `virtio` - VirtIO-GPU.
        - `virtio-gl` - VirtIO-GPU with 3D acceleration (VirGL). VirGL support needs some extra libraries that aren‚Äôt installed by default. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information.
        - `vmware` - VMware Compatible.
    - `clipboard` - (Optional) Enable VNC clipboard by setting to `vnc`. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information.
- `virtiofs` - (Optional) Virtiofs share
    - `mapping` - Identifier of the directory mapping
    - `cache` - (Optional) The caching mode
        - `auto`
        - `always`
        - `metadata`
        - `never`
    - `direct_io` - (Optional) Whether to allow direct io
    - `expose_acl` - (Optional) Enable POSIX ACLs, implies xattr support
    - `expose_xattr` - (Optional) Enable support for extended attributes
- `vm_id` - (Optional) The VM identifier.
- `hook_script_file_id` - (Optional) The identifier for a file containing a hook script (needs to be executable, e.g. by using the `proxmox_virtual_environment_file.file_mode` attribute).
- `watchdog` - (Optional) The watchdog configuration. Once enabled (by a guest action), the watchdog must be periodically polled by an agent inside the guest or else the watchdog will reset the guest (or execute the respective action specified).
      - `enabled` - (Optional) Whether the watchdog is enabled (defaults to `false`).
    - `model` - (Optional) The watchdog type to emulate (defaults to `i6300esb`).
        - `i6300esb` - Intel 6300ESB.
        - `ib700` - iBase IB700.
    - `action` - (Optional) The action to perform if after activation the guest fails to poll the watchdog in time  (defaults to `none`).
        - `debug`
        - `none`
        - `pause`
        - `poweroff`
        - `reset`
        - `shutdown`

## Attribute Reference

- `ipv4_addresses` - The IPv4 addresses per network interface published by the
    QEMU agent (empty list when `agent.enabled` is `false`)
- `ipv6_addresses` - The IPv6 addresses per network interface published by the
    QEMU agent (empty list when `agent.enabled` is `false`)
- `mac_addresses` - The MAC addresses published by the QEMU agent with fallback
    to the network device configuration, if the agent is disabled
- `network_interface_names` - The network interface names published by the QEMU
    agent (empty list when `agent.enabled` is `false`)

## Qemu guest agent

Qemu-guest-agent is an application which can be installed inside guest VM, see
[Proxmox Wiki](https://pve.proxmox.com/wiki/Qemu-guest-agent) and [Proxmox
Documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_qemu_agent)

For VM with `agent.enabled = false`, Proxmox uses ACPI for `Shutdown` and
`Reboot`, and `qemu-guest-agent` is not needed inside the VM. For some VMs,
the shutdown process may not work, causing the VM to be stuck on destroying.
Add `stop_on_destroy = true` to the VM configuration to stop the VM instead of
shutting it down.

Setting `agent.enabled = true` informs Proxmox that the guest agent is expected
to be *running* inside the VM. Proxmox then uses `qemu-guest-agent` instead of
ACPI to control the VM. If the agent is not running, Proxmox operations
`Shutdown` and `Reboot` time out and fail. The failing operation gets a lock on
the VM, and until the operation times out, other operations like `Stop` and
`Reboot` cannot be used.

Do **not** run VM with `agent.enabled = true`, unless the VM is configured to
automatically **start** `qemu-guest-agent` at some point.

"Monitor" tab in Proxmox GUI can be used to send low-level commands to `qemu`.
See the [documentation](https://www.qemu.org/docs/master/system/monitor.html).
Commands `system_powerdown` and `quit` have proven useful in shutting down VMs
with `agent.enabled = true` and no agent running.

Cloud images usually do not have `qemu-guest-agent` installed. It is possible to
install and *start* it using cloud-init, e.g. using custom `user_data_file_id`
file.

This provider requires `agent.enabled = true` to populate `ipv4_addresses`,
`ipv6_addresses` and `network_interface_names` output attributes.

Setting `agent.enabled = true` without running `qemu-guest-agent` in the VM will
also result in long timeouts when using the provider, both when creating VMs,
and when refreshing resources.  The provider has no way to distinguish between
"qemu-guest-agent not installed" and "very long boot due to a disk check", it
trusts the user to set `agent.enabled` correctly and waits for
`qemu-guest-agent` to start.

## AMD SEV

AMD SEV (-ES, -SNP) are security features for AMD processors. SEV-SNP support
is included in Proxmox version **8.4**, see [Proxmox Wiki](
https://pve.proxmox.com/wiki/Qemu/KVM_Virtual_Machines#qm_virtual_machines_settings)
and [Proxmox Documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_memory_encryption)
for more information.

`amd-sev` requires root and therefore `root@pam` auth.

SEV-SNP requires `bios = OVMF` and a supported AMD CPU (`EPYC-v4` for instance), `machine = q35` is also advised. No EFI disk is required since SEV-SNP uses consolidated read-only firmware. A configured EFI will be ignored.

All changes made to `amd_sev` will trigger reboots. Removing or adding the `amd_sev` block will force a replacement of the resource. Modifying the `amd_sev` block will not trigger replacements.

`allow_smt` is by default set to `true` even if `snp` is not the selected type. Proxmox will ignore this value when `snp` is not in use. Likewise `no_key_sharing` is `false` by default but ignored by Proxmox when `snp` is in use.

## Important Notes

### `local-lvm` Datastore

The `local-lvm` is the **default datastore** for many configuration blocks, including `initialization` and `tpm_state`, which may not seem to be related to "storage".
If you do not have `local-lvm` configured in your environment, you may need to explicitly set the `datastore_id` in such blocks to a different value.

### Cloning

When cloning an existing virtual machine, whether it's a template or not, the
resource will inherit the disks and other configuration from the source VM.

*If* you modify any attributes of an existing disk in the clone, you also need to  
explicitly provide values for any other attributes that differ from the schema defaults  
in the source (e.g., `size`, `discard`, `cache`, `aio`).  
Otherwise, the schema defaults will take effect and override the source values.

Furthermore, when cloning from one node to a different one, the behavior changes
depening on the datastores of the source VM. If at least one non-shared
datastore is used, the VM is first cloned to the source node before being
migrated to the target node. This circumvents a limitation in the Proxmox clone
API.

Because the migration step after the clone tries to preserve the used
datastores by their name, it may fail if a datastore used in the source VM is
not available on the target node (e.g. `local-lvm` is used on the source node in
the VM but no `local-lvm` datastore is available on the target node). In this
case, it is recommended to set the `datastore_id` argument in the `clone` block
to force the migration step to migrate all disks to a specific datastore on the
target node. If you need certain disks to be on specific datastores, set
the `datastore_id` argument of the disks in the `disks` block to move the disks
to the correct datastore after the cloning and migrating succeeded.

## Example: Attached disks

In this example VM `data_vm` holds two data disks, and is not used as an actual VM,
but only as a container for the disks.
It does not have any OS installation, it is never started.

VM `data_user_vm` attaches those disks as `scsi1` and `scsi2`.
**VM `data_user_vm` can be *re-created/replaced* without losing data stored on disks
owned by `data_vm`.**

~> **Experimental** Please test your configuration first in an environment where you can tolerate the potential data loss.

~> Do *not* simultaneously run more than one VM using same disk. For most filesystems,
attaching one disk to multiple VM will cause errors or even data corruption.

~> Do *not* move or resize `data_vm` disks.
(Resource `data_user_vm` should reject attempts to move or resize non-owned disks.)

```hcl
resource "proxmox_virtual_environment_vm" "data_vm" {
  node_name = "first-node"
  started = false
  on_boot = false

  disk {
    datastore_id = "local-zfs"
    interface    = "scsi0"
    size         = 1
  }

  disk {
    datastore_id = "local-zfs"
    interface    = "scsi1"
    size         = 4
  }
}

resource "proxmox_virtual_environment_vm" "data_user_vm" {
  # boot disk
  disk {
    datastore_id = "local-zfs"
    interface    = "scsi0"
    size         = 8
  }

  # attached disks from data_vm
  dynamic "disk" {
    for_each = { for idx, val in proxmox_virtual_environment_vm.data_vm.disk : idx => val }
    iterator = data_disk
    content {
      datastore_id      = data_disk.value["datastore_id"]
      path_in_datastore = data_disk.value["path_in_datastore"]
      file_format       = data_disk.value["file_format"]
      size              = data_disk.value["size"]
      # assign from scsi1 and up
      interface         = "scsi${data_disk.key + 1}"
    }
  }

  # remainder of VM configuration
  ...
}
````

## Example: Disk pass-through

You can attach another physical disk from the PVE host to a VM.
This is done by setting the `path_in_datastore` to the path of the block device on the host.

~> **Experimental** Please test your configuration first in an environment where you can tolerate the potential data loss.

~> Do *not* attach the same disk to more than one VM as it may cause data corruption.

```hcl
resource "proxmox_virtual_environment_vm" "test_vm" {
  ...

  # boot disk
  disk {
    ...
  }
  
  # attached disk
  disk {
    datastore_id = ""
    path_in_datastore  = "/dev/path/to/block/device"
    file_format = "raw"
  }

  ...
}
```

## Import

Instances can be imported using the `node_name` and the `vm_id`, e.g.,

```bash
terraform import proxmox_virtual_environment_vm.ubuntu_vm first-node/4321
```
`````

## File: docs/resources/virtual_environment_vm2.md
`````markdown
---
layout: page
title: proxmox_virtual_environment_vm2
parent: Resources
subcategory: Virtual Environment
description: |-
  This is an experimental implementation of a Proxmox VM resource using Plugin Framework.It is a Proof of Concept, highly experimental and will change in future. It does not support all features of the Proxmox API for VMs and MUST NOT be used in production.
---

# Resource: proxmox_virtual_environment_vm2

!> **DO NOT USE**
This is an experimental implementation of a Proxmox VM resource using Plugin Framework.<br><br>It is a Proof of Concept, highly experimental and **will** change in future. It does not support all features of the Proxmox API for VMs and **MUST NOT** be used in production.

-> Many attributes are marked as **optional** _and_ **computed** in the schema,
hence you may seem added to the plan with "(known after apply)" status, even if they are not set in the configuration.
This is done to support the `clone` operation, when a VM is created from an existing VM or template,
and the source attributes are copied to the clone.<br><br>
Computed attributes allow the provider to set those attributes without user input.
The attributes are also marked as optional to allow the practitioner to set (or overwrite) them if needed.



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `node_name` (String) The name of the node where the VM is provisioned.

### Optional

- `cdrom` (Attributes Map) The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces. (see [below for nested schema](#nestedatt--cdrom))
- `clone` (Attributes) The cloning configuration. (see [below for nested schema](#nestedatt--clone))
- `cpu` (Attributes) The CPU configuration. (see [below for nested schema](#nestedatt--cpu))
- `description` (String) The description of the VM.
- `id` (Number) The unique identifier of the VM in the Proxmox cluster.
- `name` (String) The name of the VM. Doesn't have to be unique.
- `rng` (Attributes) Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.`See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information. (see [below for nested schema](#nestedatt--rng))
- `stop_on_destroy` (Boolean) Set to true to stop (rather than shutdown) the VM on destroy (defaults to `false`).
- `tags` (Set of String) The tags assigned to the VM.
- `template` (Boolean) Set to true to create a VM template.
- `timeouts` (Attributes) (see [below for nested schema](#nestedatt--timeouts))
- `vga` (Attributes) Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters. (see [below for nested schema](#nestedatt--vga))

<a id="nestedatt--cdrom"></a>
### Nested Schema for `cdrom`

Optional:

- `file_id` (String) The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.


<a id="nestedatt--clone"></a>
### Nested Schema for `clone`

Required:

- `id` (Number) The ID of the VM to clone.

Optional:

- `retries` (Number) The number of retries to perform when cloning the VM (default: 3).


<a id="nestedatt--cpu"></a>
### Nested Schema for `cpu`

Optional:

- `affinity` (String) The CPU cores that are used to run the VM‚Äôs vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM‚Äôs vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
- `architecture` (String) The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
- `cores` (Number) The number of CPU cores per socket (defaults to `1`).
- `flags` (Set of String) Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
- `hotplugged` (Number) The number of hotplugged vCPUs (defaults to `0`).
- `limit` (Number) Limit of CPU usage (defaults to `0` which means no limit).
- `numa` (Boolean) Enable NUMA (defaults to `false`).
- `sockets` (Number) The number of CPU sockets (defaults to `1`).
- `type` (String) Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings for more information.
- `units` (Number) CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.


<a id="nestedatt--rng"></a>
### Nested Schema for `rng`

Optional:

- `max_bytes` (Number) Maximum bytes of entropy allowed to get injected into the guest every period. Use 0 to disable limiting (potentially dangerous).
- `period` (Number) Period in milliseconds to limit entropy injection to the guest. Use 0 to disable limiting (potentially dangerous).
- `source` (String) The file on the host to gather entropy from. In most cases, `/dev/urandom` should be preferred over `/dev/random` to avoid entropy-starvation issues on the host.


<a id="nestedatt--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
- `delete` (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
- `read` (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
- `update` (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).


<a id="nestedatt--vga"></a>
### Nested Schema for `vga`

Optional:

- `clipboard` (String) Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
- `memory` (Number) The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
- `type` (String) The VGA type (defaults to `std`).
`````

## File: docs/index.md
`````markdown
---
layout: home
title: "Provider: Proxmox Virtual Environment"
---

# Proxmox Provider

This provider for [Terraform](https://www.terraform.io/) / [OpenTofu](https://opentofu.org/) is used for interacting with resources supported by [Proxmox VE](https://www.proxmox.com/en/products/proxmox-virtual-environment/overview).
The provider needs to be configured with the proper endpoints and credentials before it can be used.

Use the navigation to the left to read about the available resources.

## Table of Contents

- [Environment Variables Summary](#environment-variables-summary)
- [Example Usage](#example-usage)
- [Authentication](#authentication)
    - [Authentication Methods Comparison](#authentication-methods-comparison)
    - [Static Credentials Examples](#static-credentials-examples)
    - [Security Best Practices](#security-best-practices)
    - [Environment variables](#environment-variables)
    - [API Token Authentication](#api-token-authentication)
    - [Pre-Authentication, or Passing an Authentication Ticket into the provider](#pre-authentication-or-passing-an-authentication-ticket-into-the-provider)
- [SSH Connection](#ssh-connection)
    - [SSH Agent](#ssh-agent)
    - [SSH Private Key](#ssh-private-key)
    - [SSH User](#ssh-user)
    - [Node IP address used for SSH connection](#node-ip-address-used-for-ssh-connection)
    - [SSH Connection via SOCKS5 Proxy](#ssh-connection-via-socks5-proxy)
- [VM and Container ID Assignment](#vm-and-container-id-assignment)
- [Temporary Directory](#temporary-directory)
- [Argument Reference](#argument-reference)

## Environment Variables Summary

| Environment Variable | Description | Required |
|---------------------|-------------|-----------|
| `PROXMOX_VE_ENDPOINT` | API endpoint URL | Yes |
| `PROXMOX_VE_USERNAME` | Username with realm | Yes* |
| `PROXMOX_VE_PASSWORD` | User password | Yes* |
| `PROXMOX_VE_API_TOKEN` | API token | Yes* |
| `PROXMOX_VE_AUTH_TICKET` | Auth ticket | Yes* |
| `PROXMOX_VE_CSRF_PREVENTION_TOKEN` | CSRF prevention token | Yes* |
| `PROXMOX_VE_INSECURE` | Skip TLS verification | No |
| `PROXMOX_VE_SSH_USERNAME` | SSH username | No |
| `PROXMOX_VE_SSH_PASSWORD` | SSH password | No |
| `PROXMOX_VE_SSH_PRIVATE_KEY` | SSH private key | No |
| `PROXMOX_VE_TMPDIR` | Custom temporary directory | No |

*One of these authentication methods is required

## Example Usage

```hcl
provider "proxmox" {
  endpoint = "https://10.0.0.2:8006/"

  # TODO: use terraform variable or remove the line, and use PROXMOX_VE_USERNAME environment variable
  username = "root@pam"
  # TODO: use terraform variable or remove the line, and use PROXMOX_VE_PASSWORD environment variable
  password = "the-password-set-during-installation-of-proxmox-ve"

  # because self-signed TLS certificate is in use
  insecure = true
  # uncomment (unless on Windows...)
  # tmp_dir  = "/var/tmp"

  ssh {
    agent = true
    # TODO: uncomment and configure if using api_token instead of password
    # username = "root"
  }
}
```

## Authentication

The Proxmox provider offers a flexible means of providing credentials for authentication.
Static credentials and pre-authenticated session-ticket can be provided to the `proxmox` block through one the choices of arguments below, ordered by precedence:

- `api_token`
- `auth_ticket` and `csrf_prevention_token`
- `username` and `password`

!> Hard-coding credentials into any Terraform configuration is not recommended, and risks secret leakage should this file ever be committed to a public version control system.

### Authentication Methods Comparison

| Method                                                                                   | Use Case             | Pros                                                              | Cons                                                              | Security Level |
|------------------------------------------------------------------------------------------|----------------------|-------------------------------------------------------------------|-------------------------------------------------------------------|----------------|
| [API Token](#api-token-authentication)                                                   | Production, CI/CD    | - No password needed<br>- Fine-grained permissions<br>- Revocable | - Some operations not supported<br>- Requires SSH username config | High           |
| [Auth Ticket](#pre-authentication-or-passing-an-authentication-ticket-into-the-provider) | Automated scripts    | - Short-lived<br>- No password storage<br>- TOTP support          | - More complex setup<br>- Needs periodic renewal                  | High           |
| Username/Password                                                                        | Development, Testing | - Full API support<br>- Simple setup                              | - Password in config/env<br>- Not revocable individually          | Medium         |

### Static Credentials Examples

Credentials can be provided in-line in the Proxmox provider block. Here are examples for each authentication method:

**API Token (Recommended for Production):**

```hcl
provider "proxmox" {
  endpoint  = "https://10.0.0.2:8006/"
  api_token = "terraform@pve!provider=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
}
```

**Username/Password (Development/Testing):**

```hcl
provider "proxmox" {
  endpoint = "https://10.0.0.2:8006/"
  insecure = true
  username = "username@realm"
  password = "a-strong-password"
}
```

**Auth Ticket (Automated Scripts):**

```hcl
provider "proxmox" {
  endpoint              = "https://10.0.0.2:8006/"
  auth_ticket          = "PVE:username@realm:12345678::some_base64_payload=="
  csrf_prevention_token = "12345678:some_blob"
}
```

A better approach is to extract these values into Terraform variables, and reference the variables instead:

```hcl
provider "proxmox" {
  endpoint = var.virtual_environment_endpoint
  
  # Choose one authentication method:
  api_token = var.virtual_environment_api_token
  # OR
  username  = var.virtual_environment_username
  password  = var.virtual_environment_password
  # OR
  auth_ticket           = var.virtual_environment_auth_ticket
  csrf_prevention_token = var.virtual_environment_csrf_prevention_token
}
```

The variable values can be provided via a separate `.tfvars` file that should be gitignored.
See the [Terraform documentation](https://developer.hashicorp.com/terraform/language/values/variables#input-variables) for more information.

### Security Best Practices

1. **API Token Usage:**
   - Use API tokens in production environments
   - Create tokens with minimal required permissions
   - Rotate tokens periodically

2. **Password Authentication:**
   - Limit to development/testing environments
   - Never commit passwords to version control
   - Use strong passwords
   - Change passwords regularly

3. **Auth Ticket:**
   - Implement proper token renewal mechanism
   - Store tickets securely
   - Use TOTP when available

4. **General:**
   - Use HTTPS with valid certificates
   - Only set `insecure = true` in development
   - Use separate credentials for different environments
   - Implement proper secret rotation

### Environment variables

Instead of using static arguments, credentials can be handled through the use of environment variables.
For example:

```hcl
provider "proxmox" {
  endpoint = "https://10.0.0.2:8006/"
}
```

```sh
export PROXMOX_VE_USERNAME="username@realm"
export PROXMOX_VE_PASSWORD='a-strong-password'
terraform plan
```

See the [Argument Reference](#argument-reference) section for the supported variable names and use cases.

### API Token Authentication

API Token authentication can be used to authenticate with the Proxmox API without the need to provide a password.
In combination with the `ssh` block and `ssh-agent` support, this allows for a fully password-less authentication.

You can create an API Token for a user via the Proxmox UI, or via the command line on the Proxmox host or cluster:

- Create a user:

    ```sh
    sudo pveum user add terraform@pve
    ```

- Create a role for the user (you can skip this step if you want to use any of the existing roles):

    ```sh
    sudo pveum role add Terraform -privs "Mapping.Audit Mapping.Modify Mapping.Use Permissions.Modify Pool.Allocate Pool.Audit Realm.AllocateUser Realm.Allocate SDN.Allocate SDN.Audit Sys.Audit Sys.Console Sys.Incoming Sys.Modify Sys.AccessNetwork Sys.PowerMgmt Sys.Syslog User.Modify Group.Allocate SDN.Use VM.Allocate VM.Audit VM.Backup VM.Clone VM.Config.CDROM VM.Config.CPU VM.Config.Cloudinit VM.Config.Disk VM.Config.HWType VM.Config.Memory VM.Config.Network VM.Config.Options VM.Console VM.Migrate VM.Monitor VM.PowerMgmt VM.Snapshot.Rollback VM.Snapshot Datastore.Allocate Datastore.AllocateSpace Datastore.AllocateTemplate Datastore.Audit"
    ```

  ~> The list of privileges above is only an example, please review it and adjust to your needs.
  Refer to the [privileges documentation](https://pve.proxmox.com/pve-docs/pveum.1.html#_privileges) for more details.

- Assign the role to the previously created user:

    ```sh
    sudo pveum aclmod / -user terraform@pve -role Terraform
    ```

- Create an API token for the user:

    ```sh
    sudo pveum user token add terraform@pve provider --privsep=0
    ```

Refer to the upstream docs as needed for additional details concerning [PVE User Management](https://pve.proxmox.com/wiki/User_Management).

Generating the token will output a table containing the token's ID and secret which are meant to be concatenated into a single string for use with either the `api_token` field of the `provider` block (fine for testing but should be avoided) or sourced from the `PROXMOX_VE_API_TOKEN` environment variable.

```hcl
provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = "terraform@pve!provider=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
  insecure  = true
  ssh {
    agent    = true
    username = "terraform"
  }
}
```

-> Not all Proxmox API operations are supported via API Token.
You may see errors like
`error creating container: received an HTTP 403 response - Reason: Permission check failed (changing feature flags for privileged container is only allowed for root@pam)` or
`error creating VM: received an HTTP 500 response - Reason: only root can set 'arch' config` or
`Permission check failed (user != root@pam)` when using API Token authentication, even when `Administrator` role or the `root@pam` user is used with the token.
The workaround is to use password authentication for those operations.

-> You can also configure additional Proxmox users and roles using [`virtual_environment_user`](https://registry.terraform.io/providers/bpg/proxmox/latest/docs/data-sources/virtual_environment_user) and [`virtual_environment_role`](https://registry.terraform.io/providers/bpg/proxmox/latest/docs/data-sources/virtual_environment_role) resources of the provider.

### Pre-Authentication, or Passing an Authentication Ticket into the provider

It is possible to generate a session ticket with the API, and to pass the ticket and csrf_prevention_token into the provider using environment variables `PROXMOX_VE_AUTH_TICKET` and `PROXMOX_VE_CSRF_PREVENTION_TOKEN` (or provider's arguments `auth_ticket` and `csrf_prevention_token`). See more details in the [Proxmox Wiki](https://pve.proxmox.com/wiki/Proxmox_VE_API#Ticket_Cookie).

An example of using `curl` and `jq` to query the Proxmox API to get a Proxmox session ticket; it is also very easy to pass in a TOTP password this way:

```hcl
provider "proxmox" {
  endpoint = "https://10.0.0.2:8006/"
}
```

```bash
#!/usr/bin/bash

## assume vars are set: PROXMOX_VE_ENDPOINT, PROXMOX_VE_USERNAME, PROXMOX_VE_PASSWORD
## end-goal: automatically set PROXMOX_VE_AUTH_TICKET and PROXMOX_VE_CSRF_PREVENTION_TOKEN

_user_totp_password='123456' ## optional TOTP password


proxmox_api_ticket_path='api2/json/access/ticket' ## cannot have double "//" - ensure endpoint ends with a "/" and this string does not begin with a "/", or vice-versa

## call the auth api endpoint
resp=$( curl -q -s -k --data-urlencode "username=${PROXMOX_VE_USERNAME}"  --data-urlencode "password=${PROXMOX_VE_PASSWORD}"  "${PROXMOX_VE_ENDPOINT}${proxmox_api_ticket_path}" )
auth_ticket=$( jq -r '.data.ticket' <<<"${resp}" )
resp_csrf=$( jq -r '.data.CSRFPreventionToken' <<<"${resp}" )

## check if the response payload needs a TFA (totp) passed, call the auth-api endpoint again
if [[ $(jq -r '.data.NeedTFA' <<<"${resp}") == 1 ]]; then
  resp=$( curl -q -s -k  -H "CSRFPreventionToken: ${resp_csrf}" --data-urlencode  "username=${PROXMOX_VE_USERNAME}" --data-urlencode "tfa-challenge=${auth_ticket}" --data-urlencode "password=totp:${_user_totp_password}"  "${PROXMOX_VE_ENDPOINT}${proxmox_api_ticket_path}" )
  auth_ticket=$( jq -r '.data.ticket' <<<"${resp}" )
  resp_csrf=$( jq -r '.data.CSRFPreventionToken' <<<"${resp}" )
fi


export PROXMOX_VE_AUTH_TICKET="${auth_ticket}"
export PROXMOX_VE_CSRF_PREVENTION_TOKEN="${resp_csrf}"

terraform plan
```

## SSH Connection

~> Please read if you are using VMs with custom disk images, or uploading snippets.

The Proxmox provider can connect to a Proxmox node via SSH.
This is used in the `proxmox_virtual_environment_vm` or `proxmox_virtual_environment_file` resource to execute commands on the node to perform actions that are not supported by Proxmox API.
For example, to import VM disks, or to uploading certain type of resources, such as snippets.

The SSH connection configuration is provided via the optional `ssh` block in the `provider` block:

```hcl
provider "proxmox" {
  endpoint = "https://10.0.0.2:8006/"
  username = "username@realm"
  password = "a-strong-password"
  insecure = true

  ssh {
    agent = true
  }
}
```

If no `ssh` block is provided, the provider will attempt to connect to the target node using the credentials provided in the `username` and `password` arguments (or `PROXMOX_VE_USERNAME` and `PROXMOX_VE_PASSWORD` environment variables).
Note that the target node is identified by the `node` argument in the resource, and may be different from the Proxmox API endpoint.
Please refer to the [Argument Reference](#argument-reference) section to view the available arguments of the `ssh` block.

### SSH Agent

The provider does not use OS-specific SSH configuration files, such as `~/.ssh/config`.
Instead, it uses the SSH protocol directly, and supports the `SSH_AUTH_SOCK` environment variable (or `agent_socket` argument) to connect to the `ssh-agent`.
This allows the provider to use the SSH agent configured by the user, and to support multiple SSH agents running on the same machine.
You can find more details on the SSH Agent [here](https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys#adding-your-ssh-keys-to-an-ssh-agent-to-avoid-typing-the-passphrase).
The SSH agent authentication takes precedence over the `private_key` and `password` authentication.

-> By default on Windows, the provider will assume the SSH agent is at `\\.\pipe\openssh-ssh-agent`.

### SSH Private Key

In some cases where SSH agent is not available, for example when using a CI/CD pipeline that does not support SSH agent forwarding,
you can use the `private_key` argument in the `ssh` block (or alternatively `PROXMOX_VE_SSH_PRIVATE_KEY` environment variable) to provide the private key for the SSH connection.

The private key must not be encrypted, and must be in PEM format.

You can provide the private key from a file:

```hcl
provider "proxmox" {
  // ...
  ssh {
    agent       = false
    private_key = file("~/.ssh/id_rsa")
  }
}
```

Alternatively, although not recommended due to the increased risk of exposing an unprotected key, heredoc syntax can be used to supply the private key as a string.
Note that the content of the private key is injected using `<<-` format to ignore indentation:

```hcl
provider "proxmox" {
  // ...

  ssh {
    agent       = false
    private_key = <<-EOF
    -----BEGIN OPENSSH PRIVATE KEY-----
    b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
    <SKIPPED>
    DMUWUEaH7yMCKl7uCZ9xAAAAAAECAwQF
    -----END OPENSSH PRIVATE KEY-----
    EOF
  }
}
```

### SSH User

By default, the provider will use the same username for the SSH connection as the one used for the Proxmox API connection (when using PAM authentication).
This can be overridden by specifying the `username` argument in the `ssh` block (or alternatively a username in the `PROXMOX_VE_SSH_USERNAME` environment variable):

```hcl
provider "proxmox" {
  // ...

  ssh {
    agent    = true
    username = "terraform"
  }
}
```

-> When using API Token or non-PAM authentication for Proxmox API, the `username` field in the `ssh` block (or alternatively a username in `PROXMOX_VE_USERNAME` or `PROXMOX_VE_SSH_USERNAME` environment variable) is **required**.
This is because the provider needs to know which PAM user to use for the SSH connection.

When using a non-root user for the SSH connection, the user **must** have the `sudo` privilege on the target node without requiring a password.

-> If you run clustered Proxmox VE, you will need to configure the `sudo` privilege for the user on all nodes in the cluster.

-> `sudo` may not be installed by default on Proxmox VE nodes. You can install it via the command line on the Proxmox host: `apt install sudo`

~> The `root` user on the Proxmox node must be configured with `bash` as the default shell.

You can configure the `sudo` privilege for the user via the command line on the Proxmox host.
In the example below, we create a user `terraform` and assign the `sudo` privilege to it. Run the following commands on the Proxmox node in the root shell:

- Create a new system user:

    ```sh
    useradd -m terraform
    ```

- Configure the `sudo` privilege for the user, by adding a new sudoers file to the `/etc/sudoers.d` directory:

    ```sh
    visudo -f /etc/sudoers.d/terraform
    ```

  Add the following lines to the file:

    ```text
    terraform ALL=(root) NOPASSWD: /sbin/pvesm
    terraform ALL=(root) NOPASSWD: /sbin/qm
    terraform ALL=(root) NOPASSWD: /usr/bin/tee /var/lib/vz/*
    ```

  If you're using a different datastore for snippets, not the default `local`, you should add the datastore's mount point to the sudoers file as well, for example:
  
    ```text
    terraform ALL=(root) NOPASSWD: /usr/bin/tee /mnt/pve/cephfs/*
    ```

  You can find the mount point of the datastore by running `pvesh get /storage/<name>` on the Proxmox node.

- Copy your SSH public key to the `~/.ssh/authorized_keys` file of the `terraform` user on the target node.

- Test the SSH connection and password-less `sudo`:
  
    ```sh
    ssh terraform@<target-node> sudo pvesm apiinfo 
    ```

  You should be able to connect to the target node and see the output containing `APIVER <number>` on the screen without being prompted for your password.

### Node IP address used for SSH connection

In order to make the SSH connection, the provider needs to be able to resolve the target node name to an IP.
The following methods are used to resolve the node name, in the specified order:

1. Enumerate the node's network interfaces via the Proxmox API, and identify the first interface that:
   1. Has an IPv4 address with IPv4 gateway configured, or
   2. Has an IPv6 address with IPv6 gateway configured, or
   3. Has an IPv4 address
2. Resolve the Proxmox node name (usually a shortname) via DNS using the system DNS resolver of the machine running Terraform.

In some cases this may not be the desired behavior, for example, when the node has multiple network interfaces, and the one that should be used for SSH is not the first one.

To override the node IP address used for SSH connection, you can use the optional `node` blocks in the `ssh` block, and specify the desired IP address (or FQDN) for each node.
For example:

```hcl
provider "proxmox" {
  // ...
  ssh {
    // ...
    node {
      name    = "pve1"
      address = "192.168.10.1"
    }
    node {
      name    = "pve2"
      address = "192.168.10.2"
    }
  }
}
```

### SSH Connection via SOCKS5 Proxy

The provider supports SSH connection to the target node via a SOCKS5 proxy.

To enable the SOCKS5 proxy, you need to configure the `ssh` block in the `provider` block, and specify the `socks5_server` argument:

```hcl
provider "proxmox" {
  // ...
  ssh {
    // ...
    socks5_server     = "ip-or-fqdn-of-socks5-server:port"
    socks5_username   = "username"  # optional  
    socks5_password   = "password"  # optional
  }
}
```

If enabled, this method will be used for all SSH connections to the target nodes in the cluster.

## VM and Container ID Assignment

When creating VMs and Containers, you can specify the optional `vm_id` attribute to set the ID of the VM or Container. However, the ID is a mandatory attribute in the Proxmox API and must be unique within the cluster. If the `vm_id` attribute is not specified, the provider will generate a unique ID and assign it to the resource.

The Proxmox API provides a helper function to retrieve the "next available" unique ID in the cluster, but there is no option to reserve an ID before a resource is created. Instead, the provider uses a file-based locking technique to reserve retrieved sequential IDs and prevent duplicates. However, conflicts cannot be fully avoided, especially when multiple resources are created simultaneously by different provider instances.

To mitigate this issue, you can set the `random_vm_ids` attribute to `true` in the `provider` block. This will generate a random ID for each VM or Container when the `vm_id` attribute is not specified. The generated ID is checked for uniqueness through the Proxmox API before resource creation, significantly reducing the risk of conflicts.

## Temporary Directory

Using `proxmox_virtual_environment_file` with `.iso` files or disk images can require a large amount of space in the temporary directory of the computer running terraform.

Consider pointing `tmp_dir` to a directory with enough space, especially if the default temporary directory is limited by the system memory (e.g. `tmpfs` mounted on `/tmp`).

A better approach is to use `proxmox_virtual_environment_download_file` resource to download the file directly to the target node, without buffering to the local machine.

## Argument Reference

In addition to [generic provider arguments](https://developer.hashicorp.com/terraform/language/providers/configuration#provider-configuration-1) ( e.g. `alias` and `version`), the following arguments are supported in the Proxmox `provider` block:

- `endpoint` - (Required) The endpoint for the Proxmox Virtual Environment API (can also be sourced from `PROXMOX_VE_ENDPOINT`). Usually this is `https://<your-cluster-endpoint>:8006/`. **Do not** include `/api2/json` at the end.
- `insecure` - (Optional) Whether to skip the TLS verification step (can also be sourced from `PROXMOX_VE_INSECURE`). If omitted, defaults to `false`.
- `min_tls` - (Optional) The minimum required TLS version for API calls (can also be sourced from `PROXMOX_VE_MIN_TLS`). Supported values: `1.0|1.1|1.2|1.3`. If omitted, defaults to `1.3`.

- `auth_ticket` - (Optional) The auth ticket from an external auth call (can also be sourced from `PROXMOX_VE_AUTH_TICKET`). To be used in conjunction with `csrf_prevention_token`, takes precedence over `api_token` and `username` with `password`. For example, `PVE:username@realm:12345678::some_base64_payload==`.
- `csrf_prevention_token` - (Optional) The CSRF Prevention Token from an external auth call (can also be sourced from `PROXMOX_VE_CSRF_PREVENTION_TOKEN`). For example, `12345678:some_blob`.

- `api_token` - (Optional) The API Token for the Proxmox Virtual Environment API (can also be sourced from `PROXMOX_VE_API_TOKEN`). Takes precedence over `username` with `password`. For example, `username@realm!for-terraform-provider=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`.

- `otp` - (Optional, Deprecated) The one-time password for the Proxmox Virtual Environment API (can also be sourced from `PROXMOX_VE_OTP`).

- `username` - (Required) The username and realm for the Proxmox Virtual Environment API (can also be sourced from `PROXMOX_VE_USERNAME`). For example, `root@pam`.
- `password` - (Required) The password for the Proxmox Virtual Environment API (can also be sourced from `PROXMOX_VE_PASSWORD`).

- `ssh` - (Optional) The SSH connection configuration to a Proxmox node. This is a block, whose fields are documented below.
    - `username` - (Optional) The username to use for the SSH connection. Defaults to the username used for the Proxmox API connection. Can also be sourced from `PROXMOX_VE_SSH_USERNAME`. Required when using API Token.
    - `password` - (Optional) The password to use for the SSH connection. Defaults to the password used for the Proxmox API connection. Can also be sourced from `PROXMOX_VE_SSH_PASSWORD`.
    - `agent` - (Optional) Whether to use the SSH agent for the SSH authentication. Defaults to `false`. Can also be sourced from `PROXMOX_VE_SSH_AGENT`.
    - `agent_socket` - (Optional) The path to the SSH agent socket. Defaults to the value of the `SSH_AUTH_SOCK` environment variable. Can also be sourced from `PROXMOX_VE_SSH_AUTH_SOCK`.
    - `private_key` - (Optional) The private key to use for the SSH connection. Can also be sourced from `PROXMOX_VE_SSH_PRIVATE_KEY`. The private key must be in PEM format.
    - `socks5_server` - (Optional) The address of the SOCKS5 proxy server to use for the SSH connection. Can also be sourced from `PROXMOX_VE_SSH_SOCKS5_SERVER`.
    - `socks5_username` - (Optional) The username to use for the SOCKS5 proxy server. Can also be sourced from `PROXMOX_VE_SSH_SOCKS5_USERNAME`.
    - `socks5_password` - (Optional) The password to use for the SOCKS5 proxy server. Can also be sourced from `PROXMOX_VE_SSH_SOCKS5_PASSWORD`.
    - `node` - (Optional) The node configuration for the SSH connection. Can be specified multiple times to provide configuration fo multiple nodes.
        - `name` - (Required) The name of the node.
        - `address` - (Required) The FQDN/IP address of the node.
        - `port` - (Optional) SSH port of the node. Defaults to 22.
- `tmp_dir` - (Optional) Use custom temporary directory. (can also be sourced from `PROXMOX_VE_TMPDIR`)
- `random_vm_ids` - (Optional) Use random VM ID for VMs and Containers when `vm_id` attribute is not specified. Defaults to `false`.
- `random_vm_id_start` - (Optional) The start of the range for random VM IDs. Defaults to `10000`.
- `random_vm_id_end` - (Optional) The end of the range for random VM IDs. Defaults to `99999`.
`````

## File: example/test-api-creds-auth/.gitignore
`````
cred-tester.config.sh*
outs_cred-tester__expect_*.log
`````

## File: example/test-api-creds-auth/api-creds-tester.sh
`````bash
#!/usr/bin/env bash
## requires: python, pyotp, gawk, jq, curl, tofu/terraform


##### arg1 (optional) is the TF Binary (tofu, terraform, /path/to/...) 


## TODO:
##   remove PROXMOX_VE_OTP support
##   test credential presidence in 'fake' section
##   remove less-important fake tests
##   handle python requirements.txt (pyotp)


this_shell_config_file="cred-tester.config.sh"
TF_PLAN_EXTRA_ARGS=()


##### create cred-tester config-shell-file if it does not exist

if [[ -e "${this_shell_config_file}" ]]; then
    source "${this_shell_config_file}"
else
    printf '\ncred tester config file does not exist; creating sample file: "%s"\n'  "${this_shell_config_file}"
    cat <<'EOF' > "${this_shell_config_file}"
#/usr/bin/env bash


##### this file is sourced by the cred-tester script


export PROXMOX_VE_ENDPOINT="${PROXMOX_VE_ENDPOINT:-https://127.0.0.1:8006/}"  ## if unset, use localhost


TF_Output_colorized=1 ## 0 disables color, 1 enables


#### real/fake start/end  overrides are inclusive (allows for skipping tests)
###    test-sets begin numbering with '1'
###    skip real/fake by setting the start-override to a large number

# real_start_override=1
# real_end_override=3

# fake_start_override=1
# fake_end_override=10


curl_connect_timeout=5
# debug_print_env_var_values=0  ## 1 enables; any other value disables
# debug_print_arg_var_values=0  ## 1 enables; any other value disables



#### required: admin creds should have power to unlock a users totp
###    topt user(s) will get locked out due to too many failures
admin_un='admin@pam'
admin_pw='secrets'
admin_totp_s=''



#### test cred sets


###  real creds


real_type_1='api_token [pve]'
real_api_token_1='test1@pve!tokenName=hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'


real_type_2='user [pam] + pass'
real_un_2='test2@pam'
real_pw_2='secrets'


real_type_3='user [pve] + pass + otp (aka totpS via totp-secret to otp)'
real_un_3='test3@pve'
real_pw_3='secrets'
real_totp_s_3='HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'


# real_type_4='pre-auth auth-ticket + csrf-token'
# real_auth_ticket_4=''
# real_csrf_token_4=''






fake_totp_s='CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'

fake_csrf='19870727:TmV2ckdvbm5hR2l2VVVwTmV2ckdvbm5hTGV0VURvd24'
fake_ticket='PVE:base64@pve:19870727::UmljayBBc3RsZXk6IEkganVzdCB3YW5uYSB0ZWxsIHlvdSBob3cgSSdtIGZlZWxpbmcuIEdvdHRhIG1ha2UgeW91IHVuZGVyc3RhbmQuIE5ldmVyIGdvbm5hIGdpdmUgeW91IHVwLiBOZXZlciBnb25uYSBsZXQgeW91IGRvd24uIE5ldmVyIGdvbm5hIHJ1biBhcm91bmQgYW5kIGRlc2VydCB5b3UuIE5ldmVyIGdvbm5hIG1ha2UgeW91IGNyeS4gTmV2ZXIgZ29ubmEgc2F5IGdvb2RieWUuIE5ldmVyIGdvbm5hIHRlbGwgYSBsaWUgYW5kIGh1cnQgeW91Lg=='





### fake creds

## TODO
##   filter out less-interesting tests
##   add all cred methods to tests ( user+pass, api-token, auth-ticket+csrf ) with combinations to fail with [to test credential precidence]


fake_type_1='api_token [fake]'
fake_api_token_1='fake@pve!faker=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee'


fake_type_2='un+pw [real] + totpS [real] + csrf [fake]'
fake_un_2=$real_un_3
fake_pw_2=$real_pw_3
fake_totp_s_2=$real_totp_s_3
fake_csrf_2=$fake_csrf


fake_type_3='ticket [fake] + csrf [fake]'
fake_auth_ticket_3=$fake_ticket
fake_csrf_token_3=$fake_csrf


fake_type_4='user [real pam] + pass [fake]'
fake_un_4=$real_un_2
fake_pw_4='this_dont_work'


fake_type_5='user [fake pam] + pass [fake]'
fake_un_5='nope@pam'
fake_pw_5='this_dont_work'


fake_type_6='user [fake pve] + pass [fake]'
fake_un_6='nope@pve'
fake_pw_6='this_dont_work'


## less interesting-ish

fake_type_7='user [pve] + pass + otp [fake] (aka totpS via totp-secret to otp)'
fake_un_7=$real_un_3
fake_pw_7=$real_pw_3
fake_totp_s_7=$fake_totp_s


fake_type_8='user [pve] + pass - otp (aka totpS via totp-secret to otp)'
fake_un_8=$real_un_3
fake_pw_8=$real_pw_3


fake_type_9='user [pve] + pass [fake] + otp [fake] (aka totpS via totp-secret to otp)'
fake_un_9=$real_un_3
fake_pw_9='this_dont_work'
fake_totp_s_9=$fake_totp_s


fake_type_10='user [fake pve] + pass [fake] + otp [fake] (aka totpS via totp-secret to otp)'
fake_un_10='nope@pve'
fake_pw_10='this_dont_work'
fake_totp_s_10=$fake_totp_s

EOF

    
    exit
fi






##### helper funcs



### same logic as makefile to determine tofu or terraform
### then override with arg1 if applicable
if [[  "$(tofu -version 2>/dev/null)" == "" ]]; then
    TF_APP=terraform
else
    TF_APP=tofu
fi
export TF_APP="${1:-"${TF_APP}"}"
## TODO: check app is run-able (-x needs full path)
#if [[ ! -x "${TF_APP}" ]]; then
#    printf 'ERROR: TF App is not executable or does not exit: %s\n'  "${TF_APP}"
#    exit 1
#fi





### function to print TF arg-var names for in-line provider testing
###   optional toggle-var (debug_print_arg_var_values) to print values
print_proxmox_arg_var_names() {
    ## required argvars/list of args sent to TF ( "${@}" )
    printf '    set arg-vars:  '
    if [[ -n "${debug_print_arg_var_values}" && "${debug_print_arg_var_values}" == 1 ]]; then
	## 
        printf '%s  '  $(  for x in "$@"; do if [[ "$x" != "-var" ]]; then echo "${x}"; fi ; done | sort  )
    else
        printf '%s  '  $(  for x in "$@"; do if [[ "$x" != "-var" ]]; then echo "${x%%=*}"; fi ; done | sort  )
    fi
    printf '\n'
    
}





### function to print TF variable names (excluding PROXMOX_VE_ENDPOINT)
###   optional toggle-var (debug_print_env_var_values) to print values
print_proxmox_env_var_names() {
    printf '    set cred-vars:  '
    if [[ -n "${debug_print_env_var_values}" && "${debug_print_env_var_values}" == 1 ]]; then
        printf '%s  '  $(env -0 | sort -z | xargs -0 -n1 | awk -F'=' '/^PROXMOX_/ && !/PROXMOX_VE_ENDPOINT/ && $2 > 0  {print $0}')
    else
        printf '%s  '  $(env -0 | sort -z | xargs -0 -n1 | awk -F'=' '/^PROXMOX_/ && !/PROXMOX_VE_ENDPOINT/ && $2 > 0  {print $1}')
    fi
    printf '\n'
}





### function to send the unlock api call to a particular user
### especially handy when testing a legit user and fake pass (too many failures locks the totp)
curl_api_unlock_user_tfa() {
    ## required argvar: username@realm
    local userid="$1" ## user@realm
    local ticket
    local csrf

    if [[ -z "${userid}" ]]; then return; fi

    ## use read to set variables 'ticket' and 'csrf' from the bash-func api_auth with env-vars set and totpx
    read -d $'\0'  ticket  csrf  <<<"$( PROXMOX_VE_USERNAME=${admin_un} PROXMOX_VE_PASSWORD=${admin_pw} api_auth $( totp_secret_to_otp_func "${admin_totp_s}" ) )"
    curl --connect-timeout ${curl_connect_timeout:-5}  -q -s -k -H "X-API-AUTH-TOKEN: ${ticket}"  -H "X-CSRF-TOKEN: ${csrf}" -X PUT "${PROXMOX_VE_ENDPOINT}api2/json/access/users/${userid}/unlock-tfa"
}





### function calling python to generate a TOTP token from a totp-secret
totp_secret_to_otp_func(){  STR=${1} python -c 'import pyotp; import os; import time;  STR=os.getenv("STR", ""); totp = pyotp.TOTP(STR);  print( totp.now() );'  ;  }





### function to call proxmox-api with a user+pass, and optional totp to get an auth_ticket and csrf_token
### endpoint, username, password are passed in via provider env-vars (PROXMOX_VE_ENDPOINT, PROXMOX_VE_USERNAME, PROXMOX_VE_PASSWORD)
api_auth() {
    ## optional arg1: totp value
    local _user_totp_password=$1
    local proxmox_api_ticket_path='api2/json/access/ticket' ## cannot have double "//" - ensure endpoint ends with a "/" and this string does not begin with a "/", or vice-versa

    local api_resp=$( curl -q -s -k --data-urlencode "username=${PROXMOX_VE_USERNAME}"  --data-urlencode "password=${PROXMOX_VE_PASSWORD}"  "${PROXMOX_VE_ENDPOINT}${proxmox_api_ticket_path}" )
    local auth_ticket=$( jq -r '.data.ticket' <<<"${api_resp}" )
    local auth_csrf=$( jq -r '.data.CSRFPreventionToken' <<<"${api_resp}" )

    if [[ $(jq -r '.data.NeedTFA' <<<"${api_resp}") == 1 ]]; then
        api_resp=$( curl -q -s -k  -H "CSRFPreventionToken: ${auth_csrf}" --data-urlencode  "username=${PROXMOX_VE_USERNAME}" --data-urlencode "tfa-challenge=${auth_ticket}" --data-urlencode "password=totp:${_user_totp_password}"  "${PROXMOX_VE_ENDPOINT}${proxmox_api_ticket_path}" )
        auth_ticket=$( jq -r '.data.ticket' <<<"${api_resp}" )
        auth_csrf=$( jq -r '.data.CSRFPreventionToken' <<<"${api_resp}" )
    fi

    printf '%s\n'  "${auth_ticket}"  "${auth_csrf}"
}





### optional color flag for TF
if [[ -n "${TF_Output_colorized}" && "${TF_Output_colorized}" == 0 ]]; then
    TF_PLAN_EXTRA_ARGS+=('-no-color')
fi




### function which calls TF cmd
### arg-order matters; first 3 args are required test-output; remaining args are passed directly to TF
test_cmd() {
    ## required: pass/fail  itr_num  itr_part_num

    local should_pass_or_fail=${1:pass}
    shift
    local test_iteration=${1:-itr-1}
    shift
    local test_part=${1:-part-1}
    shift
    local ret_expt=0
    local res
    local ret
    local timenow=$(date --iso=s)
    timenow=${timenow//:/_}

    res=$( "${TF_APP}" plan "${TF_PLAN_EXTRA_ARGS[@]}"  "$@" 2>&1 )
    ret=$?

    local msg_pass
    local msg_fail

    #msg_pass="passed ${should_pass_or_fail}-as-expected" # successfully pass-as-expected
    #msg_fail="failed ${should_pass_or_fail}-as-expected" # failed pass-as-expected
    if [[ "${should_pass_or_fail,,}" == "pass" ]]; then ## TODO: word these better
        msg_pass="passed ${should_pass_or_fail}-check (expected pass and passed)" # successfully pass-as-expected
        msg_fail="failed ${should_pass_or_fail}-check (expected pass; got an error) " # failed pass-as-expected
    else
        msg_pass="passed ${should_pass_or_fail}-check (expected error and errored)" # successfully fail-as-expected
        msg_fail="failed ${should_pass_or_fail}-check (expected error; got no-errors)" # failed fail-as-expected
    fi

    local got_pass_or_fail

    
    if [[ "${should_pass_or_fail,,}" == "pass"  &&  "${ret}" == 0 ]]  ||  [[ "${should_pass_or_fail,,}" != "pass"  &&  "${ret}" != 0 ]]; then
        printf '  test %i part %i %s\n' ${test_iteration}  ${test_part}  "${msg_pass}"
	got_pass_or_fail='passed'
    else
        printf '  test %i part %i %s\n' ${test_iteration}  ${test_part}  "${msg_fail}"
	got_pass_or_fail='failed'
    fi

    
    local logfile="outs_cred-tester__expect_${should_pass_or_fail}__${got_pass_or_fail}.${timenow}.log"

    printf '%s\n' "${res}"  > "${logfile}" ## write TF output to logfile
    printf '  see TF-output in file: %s\n'  "${logfile}"

    ## use gawk to capture the Errors and print to screen; colored vs not makes a monster
    if [[ -n "${TF_Output_colorized}" && "${TF_Output_colorized}" == 0 ]]; then
	<<<"${res}"  gawk -v out_spaces="  "   '/^Error:/ { S=1; BLOB=out_spaces $0 ; next }   /^$/ {  if(S==1){ nl++; if(nl>1){S=0;nl=0; print BLOB"\n" }else{ BLOB=BLOB"\n"out_spaces $0} }  }   !/^$/ { if(S==1){  BLOB=BLOB"\n"out_spaces $0} }    END { if(S==1){ print BLOB } } '
    else
        ## ansi-color friendly awk'er for tf-outputs (print Error blocks; can be expanded to include any word (eg Warning); change: "+Error:" to  "+([A-Za-z]+:"  )
        ## print only the errors ( use outs_spaces ) as line prefix (expect to be empty when test-for-failure and plan-passes (eg no tf-files)
        <<<"${res}"  gawk -v outs_spaces="  " -v str_bar=$'\xe2\x94\x82' -v str_bar_end=$'\xe2\x95\xb5' '{  raw=$0;  gsub(/\x1b\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]/,"");  }  {if(S==1 && match($0,str_bar_end)) {S=0; print outs_spaces raw}  } ;  S==1 {print  outs_spaces raw }       { if(match($0, "^"str_bar" +Error:")) { S=1; print outs_spaces raw }    } '
    fi
        

}





printf 'test endpoint: %s\n'  "${PROXMOX_VE_ENDPOINT}"





#### test real+fake   UN + PW



### message formats + hard-code number of check-types per auth-set
_set_parts=4 ## aka number of "checks" per auth-set
real_test_msg_fmt='\npass-test (expect auth-success): set %i/%i %s/'${_set_parts}';  using %s %s:  %s\n'
fake_test_msg_fmt='\nfail-test (expect auth-failure): set %i/%i %s/'${_set_parts}';  using %s %s:  %s\n'
## expect:  set-#   fake/real_end-#    "part 1/2"   "env OR in-line"   "raw-credentials OR auth-ticket"  ${type}
## todo: ensure comment fmt-opts are correct



test_pre_auth_inline_empty_creds=0  ## want to test this once per run (many 'fake' tests cause this to be re-test if not caught)





#### while loop determining real/fake "end" numbers; starting at 1, checks consecutive vars and bails when both are set
real_start=1
real_end=
fake_start=1
fake_end=


_i=1
while :; do ## infinite loop; maybe break after i gets too high?
    _real="real_type_${_i}"
    _fake="fake_type_${_i}"

    ## bash indirect expansion / dynamic variables
    ## check if _real is a variable and that the value real expands to is not an empty value
    ## once i (real_type_2) is out of bounds/does not exist, sets real_too_far
    ## repeat for fake_type
    ## once both real and fake 'too_far' variables are set, break out of loop
    if [[  -v "${_real}" && -n "${!_real}" ]]; then
	real_end=$_i
    else
	real_too_far=$_i
    fi

    if [[ -v "${_fake}" && -n "${!_fake}" ]]; then
	fake_end=$_i
    else
	fake_too_far=$_i
    fi

    if [[ -n "${real_too_far}" && -n "${fake_too_far}" ]]; then
	break
    fi

    ((_i++))
done
unset _i _real _fake real_too_far fake_too_far








#### nested for-loop
## first for-loop over "real" and "fake" as variable name prefixes
##   then loop over each real/fake credential set
## cred tests order:
##   raw-creds via env-vars
##   raw-creds via in-line (using tf provider-block)
##   pre-auth via env-vars
##   pre-auth via in-line (using tf provider-block)


for loop_real_fake in "real" "fake" ; do

    if [[ "${loop_real_fake}" == "real" ]]; then
	loop_rf_pass_fail="pass"
    else
	loop_rf_pass_fail="fail"
    fi


    loop_rf_test_msg_fmt="${loop_real_fake}_test_msg_fmt" ## eg: loop_rf_test_msg_fmt="real_test_msg_fmt" (literal text)
    loop_rf_test_msg_fmt="${!loop_rf_test_msg_fmt}" ## eg: loop_rf_test_msg_fmt= value of real_test_msg_fmt (variable expansion)
    
    loop_rf_start="${loop_real_fake}_start"
    loop_rf_start="${!loop_rf_start}"

    loop_rf_end="${loop_real_fake}_end"
    loop_rf_end="${!loop_rf_end}"

    loop_rf_start_override="${loop_real_fake}_start_override"
    loop_rf_start_override="${!loop_rf_start_override}"

    loop_rf_end_override="${loop_real_fake}_end_override"
    loop_rf_end_override="${!loop_rf_end_override}"
    

    

    
    printf '\nShould %s:\n' "${loop_rf_pass_fail^}"
    for (( i=${loop_rf_start}; i < ((loop_rf_end+1)) ; i++ )); do
	#### if conditions: allow start/end overrides to skip select tests in order
	if [[ -n "${loop_rf_start_override}" &&  "${loop_rf_start_override}" -gt "${i}" ]]; then
            continue
	fi
	if [[ -n "${loop_rf_end_override}" && "${loop_rf_end_override}" -lt "${i}" ]]; then
            printf '\nscript loop complete via real_end_override; range %i to %i inclusive\n'  ${loop_rf_start_override}  ${loop_rf_end_override}
            break
	fi

	## enforce vars are not set
	unset  PROXMOX_VE_USERNAME  PROXMOX_VE_PASSWORD  PROXMOX_VE_OTP  PROXMOX_VE_API_TOKEN  PROXMOX_VE_AUTH_TICKET  PROXMOX_VE_CSRF_PREVENTION_TOKEN  test_cmd_args


	## bash indirect expansions for fake/real values set in config (aka dynamic variables)
	type="${loop_real_fake}_type_${i}" ## type="real_type_1
	type="${!type}" ## indirect expansion, type set to value from real_type_1
	un="${loop_real_fake}_un_${i}"
	un="${!un}"
	pw="${loop_real_fake}_pw_${i}"
	pw="${!pw}"
	totp_s="${loop_real_fake}_totp_s_${i}"
	totp_s=${!totp_s}
	auth_ticket="${loop_real_fake}_auth_ticket_${i}"
	auth_ticket="${!auth_ticket}"
	csrf_token="${loop_real_fake}_csrf_token_${i}"
	csrf_token="${!csrf_token}"
	apitok="${loop_real_fake}_api_token_${i}"
	apitok="${!apitok}"
	



	printf "\n##"


	### raw-creds via env-vars
	printf "${loop_rf_test_msg_fmt}"  $i  ${loop_rf_end}  "part 1"  "env"  "raw-creds"  "${type}"
	curl_api_unlock_user_tfa "${un}"

    
	if [ -n "${totp_s}" ]; then
            export PROXMOX_VE_OTP=$( totp_secret_to_otp_func "${totp_s}" )
	fi

	export PROXMOX_VE_USERNAME=${un}
	export PROXMOX_VE_PASSWORD=${pw}
	if [[ -n "${apitok}" ]]; then
	    export PROXMOX_VE_API_TOKEN="${apitok}"
	fi
	print_proxmox_env_var_names
	print_proxmox_arg_var_names  "${test_cmd_args[@]}"

	test_cmd ${loop_rf_pass_fail} ${i} 1 ## test with args: "real/fake" "itr" and part "1"





	### raw-creds via in-line
	printf "${loop_rf_test_msg_fmt}"  $i  ${loop_rf_end}  "part 2"  "in-line"  "raw-creds"  "${type}"
	curl_api_unlock_user_tfa "${un}"

	###  array of TF cli credential-arguments (to ultimately set provider-config vars:
	## username, password, otp, api_token
	test_cmd_args=(
	    ## ternary-ish; if cred-type var is set, create the TF cli-arg to pass in a variable override
	    ## eg: if this loop's 'un' is set, append to the arg-array:   -var  username="$un"
	    # $( [[ -n "${auth_ticket}" ]] && printf '%s\n'  "-var"  auth_ticket="${auth_ticket}" ) ## consolidate test types would include ticket+csrf here
	    # $( [[ -n "${csrf_token}" ]] && printf '%s\n'  "-var"  csrf_prevention_token="${csrf_prevention_token}" )
	    $( [[ -n "${un}" ]] && printf '%s\n'  "-var"  username="${un}" )
	    $( [[ -n "${pw}" ]] && printf '%s\n'  "-var"  password="${pw}" )
	    $( [[ -n "${totp_s}" ]] && printf '%s\n'  "-var"  otp="$( totp_secret_to_otp_func "${totp_s}" )" )
	    $( [[ -n "${apitok}" ]] && printf '%s\n'  "-var"  api_token="${apitok}" )
	)

	unset  PROXMOX_VE_USERNAME  PROXMOX_VE_PASSWORD  PROXMOX_VE_API_TOKEN  PROXMOX_VE_OTP
	print_proxmox_env_var_names
	print_proxmox_arg_var_names  "${test_cmd_args[@]}"

	test_cmd ${loop_rf_pass_fail} ${i} 2 "${test_cmd_args[@]}"





	### pre-auth via env-vars
	printf "${loop_rf_test_msg_fmt}"  $i  ${loop_rf_end} "part 3"  "env"  "pre-auth"  "${type}"
	if [[ -n "${apitok}" ]] && [[ -z "${un}" && -z "${PROXMOX_VE_AUTH_TICKET}" ]]; then
	    printf '  skip testing api_token with pre-auth ticket+csrf; invalid test (cannot get auth-ticket and csrf with api-token)\n'
	else
	    curl_api_unlock_user_tfa "${un}"


	    ## call the api_auth function with the totp-password generated from the totp-secret
	    read -d $'\0'  pre_auth_ticket  pre_auth_csrf  <<<"$( PROXMOX_VE_USERNAME="${un}"  PROXMOX_VE_PASSWORD="${pw}"  api_auth $( totp_secret_to_otp_func "${totp_s}" ) )"    
	    unset  PROXMOX_VE_AUTH_TICKET  PROXMOX_VE_CSRF_PREVENTION_TOKEN  PROXMOX_VE_USERNAME  PROXMOX_VE_PASSWORD  PROXMOX_VE_API_TOKEN  PROXMOX_VE_OTP  test_cmd_args
	
	    if [[ -n "${pre_auth_ticket}" && "${pre_auth_ticket}" != "null" ]]; then
		export PROXMOX_VE_AUTH_TICKET="${pre_auth_ticket}"
	    fi
	    if [[ -n "${pre_auth_csrf}" && "${pre_auth_csrf}" != "null" ]]; then
		export PROXMOX_VE_CSRF_PREVENTION_TOKEN="${pre_auth_csrf}"
	    fi
	    if [[ -n "${apitok}" ]]; then
		export PROXMOX_VE_API_TOKEN="${apitok}"
	    fi
	    print_proxmox_env_var_names
	    print_proxmox_arg_var_names  "${test_cmd_args[@]}"
	
	    test_cmd ${loop_rf_pass_fail} ${i} 3
	fi




	### pre-auth via in-line
	printf "${loop_rf_test_msg_fmt}"  $i  ${loop_rf_end} "part 4"  "in-line"  "pre-auth"  "${type}"

	## if apitoken is set and username and env-var auth_ticket are unset, skip test
	## else-if skip test if test-scenario has been tested before (case when expect-to-fail and auth_ticket or csrf are empty/unset
	if [[ -n "${apitok}" ]] && [[ -z "${un}" && -z "${PROXMOX_VE_AUTH_TICKET}" ]]; then
	    printf '  skip testing api_token with pre-auth ticket+csrf; invalid test (cannot get auth-ticket and csrf with api-token)\n'
	elif [[ "${test_pre_auth_inline_empty_creds}" != 0 && "${loop_rf_pass_fail}" == "fail" ]] && [[ -z "${PROXMOX_VE_AUTH_TICKET}" || -z "${PROXMOX_VE_CSRF_PREVENTION_TOKEN}" ]]; then
	    printf '  skip testing: fail test has no pre-auth creds and was already tested with no creds; see std-out for: test_pre_auth_inline_empty_creds\n'
	else
	    printf '  Note: setting test_pre_auth_empty_creds as to not re-test empty pre-auth creds with in-line config\n'
	    test_pre_auth_inline_empty_creds=1 ## flag with var to test no more than once this condition (when pre-auth creds are empty/unset with in-line config)
	    curl_api_unlock_user_tfa "${un}"

	    test_cmd_args=(
		## if auth_ticket / csrf is not set, set to values generated in test above
		$( [[ -z "${auth_ticket}" ]] && printf '%s\n'  "-var"  auth_ticket="${PROXMOX_VE_AUTH_TICKET}" ) ## assume auth-ticket above in REAL was generated successfully
		$( [[ -z "${csrf_token}" ]] && printf '%s\n'  "-var"  csrf_prevention_token="${PROXMOX_VE_CSRF_PREVENTION_TOKEN}" )
		## if auth_ticket / csrf is set, use them
		$( [[ -n "${auth_ticket}" ]] && printf '%s\n'  "-var"  auth_ticket="${auth_ticket}" )
		$( [[ -n "${csrf_token}" ]] && printf '%s\n'  "-var"  csrf_prevention_token="${csrf_prevention_token}" )
	    )

	    unset  PROXMOX_VE_AUTH_TICKET  PROXMOX_VE_CSRF_PREVENTION_TOKEN
	    print_proxmox_env_var_names
	    print_proxmox_arg_var_names  "${test_cmd_args[@]}"

	    test_cmd ${loop_rf_pass_fail} ${i} 4 "${test_cmd_args[@]}"
	fi




	printf '\n'



    done ## end real/fake sets


done ## end "real" vs "fake" variable-prefixes
`````

## File: example/test-api-creds-auth/data_object.tf
`````hcl
#### two data objects to help show when an auth-failure will fail immediatly with provider or with each TF-request


data "proxmox_virtual_environment_nodes" "available_nodes_01" {}

data "proxmox_virtual_environment_nodes" "available_nodes_02" {}
`````

## File: example/test-api-creds-auth/example.tfrc
`````
provider_installation {
   dev_overrides {
     "bpg/proxmox" = "../../build"
   }
  direct {}
}
`````

## File: example/test-api-creds-auth/main.tf
`````hcl
provider "proxmox" {
  insecure = true

  auth_ticket           = var.auth_ticket
  csrf_prevention_token = var.csrf_prevention_token

  api_token = var.api_token

  otp = var.otp

  username = var.username
  password = var.password

}
`````

## File: example/test-api-creds-auth/variables.tf
`````hcl
variable "auth_ticket" { default = null }
variable "csrf_prevention_token" { default = null }

variable "api_token" { default = null }

variable "otp" { default = null }

variable "username" { default = null }
variable "password" { default = null }
`````

## File: example/test-api-creds-auth/versions.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source = "bpg/proxmox"
    }
  }
}
`````

## File: example/data_source_virtual_environment_container.tf
`````hcl
data "proxmox_virtual_environment_container" "example" {
  depends_on = [proxmox_virtual_environment_container.example]
  vm_id      = proxmox_virtual_environment_container.example.vm_id
  node_name  = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "proxmox_virtual_environment_container_example" {
  value = data.proxmox_virtual_environment_container.example
}
`````

## File: example/data_source_virtual_environment_datastores.tf
`````hcl
data "proxmox_virtual_environment_datastores" "example" {
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "data_proxmox_virtual_environment_datastores_example" {
  value = data.proxmox_virtual_environment_datastores.example
}
`````

## File: example/data_source_virtual_environment_dns.tf
`````hcl
data "proxmox_virtual_environment_dns" "example" {
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "data_proxmox_virtual_environment_dns_example_domain" {
  value = data.proxmox_virtual_environment_dns.example.domain
}

output "data_proxmox_virtual_environment_dns_example_servers" {
  value = data.proxmox_virtual_environment_dns.example.servers
}
`````

## File: example/data_source_virtual_environment_group.tf
`````hcl
data "proxmox_virtual_environment_group" "example" {
  group_id = proxmox_virtual_environment_group.example.id
}

output "data_proxmox_virtual_environment_group_example_acl" {
  value = data.proxmox_virtual_environment_group.example.acl
}

output "data_proxmox_virtual_environment_group_example_comment" {
  value = data.proxmox_virtual_environment_group.example.comment
}

output "data_proxmox_virtual_environment_group_example_members" {
  value = data.proxmox_virtual_environment_group.example.members
}
`````

## File: example/data_source_virtual_environment_groups.tf
`````hcl
data "proxmox_virtual_environment_groups" "example" {
  depends_on = [proxmox_virtual_environment_group.example]
}

output "data_proxmox_virtual_environment_groups_example" {
  value = tomap({
    "comments"  = data.proxmox_virtual_environment_groups.example.comments
    "group_ids" = data.proxmox_virtual_environment_groups.example.group_ids
  })
}
`````

## File: example/data_source_virtual_environment_hosts.tf
`````hcl
data "proxmox_virtual_environment_hosts" "example" {
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "data_proxmox_virtual_environment_hosts_example_addresses" {
  value = data.proxmox_virtual_environment_hosts.example.addresses
}

output "data_proxmox_virtual_environment_hosts_example_digest" {
  value = data.proxmox_virtual_environment_hosts.example.digest
}

output "data_proxmox_virtual_environment_hosts_example_entries" {
  value = data.proxmox_virtual_environment_hosts.example.entries
}

output "data_proxmox_virtual_environment_hosts_example_hostnames" {
  value = data.proxmox_virtual_environment_hosts.example.hostnames
}
`````

## File: example/data_source_virtual_environment_metrics_server.tf
`````hcl
data "proxmox_virtual_environment_metrics_server" "example" {
  name = proxmox_virtual_environment_metrics_server.influxdb_server.name
}
`````

## File: example/data_source_virtual_environment_node.tf
`````hcl
data "proxmox_virtual_environment_node" "example" {
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "data_proxmox_virtual_environment_node_example_cpu_count" {
  value = data.proxmox_virtual_environment_node.example.cpu_count
}

output "data_proxmox_virtual_environment_node_example_cpu_sockets" {
  value = data.proxmox_virtual_environment_node.example.cpu_sockets
}

output "data_proxmox_virtual_environment_node_example_cpu_model" {
  value = data.proxmox_virtual_environment_node.example.cpu_model
}

output "data_proxmox_virtual_environment_node_example_memory_available" {
  value = data.proxmox_virtual_environment_node.example.memory_available
}

output "data_proxmox_virtual_environment_node_example_memory_used" {
  value = data.proxmox_virtual_environment_node.example.memory_used
}

output "data_proxmox_virtual_environment_node_example_memory_total" {
  value = data.proxmox_virtual_environment_node.example.memory_total
}

output "data_proxmox_virtual_environment_node_example_node_name" {
  value = data.proxmox_virtual_environment_node.example.node_name
}

output "data_proxmox_virtual_environment_node_example_uptime" {
  value = data.proxmox_virtual_environment_node.example.uptime
}
`````

## File: example/data_source_virtual_environment_nodes.tf
`````hcl
data "proxmox_virtual_environment_nodes" "example" {}

output "data_proxmox_virtual_environment_nodes_example_cpu_count" {
  value = data.proxmox_virtual_environment_nodes.example.cpu_count
}

output "data_proxmox_virtual_environment_nodes_example_cpu_utilization" {
  value = data.proxmox_virtual_environment_nodes.example.cpu_utilization
}

output "data_proxmox_virtual_environment_nodes_example_memory_available" {
  value = data.proxmox_virtual_environment_nodes.example.memory_available
}

output "data_proxmox_virtual_environment_nodes_example_memory_used" {
  value = data.proxmox_virtual_environment_nodes.example.memory_used
}

output "data_proxmox_virtual_environment_nodes_example_names" {
  value = data.proxmox_virtual_environment_nodes.example.names
}

output "data_proxmox_virtual_environment_nodes_example_online" {
  value = data.proxmox_virtual_environment_nodes.example.online
}

output "data_proxmox_virtual_environment_nodes_example_ssl_fingerprints" {
  value = data.proxmox_virtual_environment_nodes.example.ssl_fingerprints
}

output "data_proxmox_virtual_environment_nodes_example_support_levels" {
  value = data.proxmox_virtual_environment_nodes.example.support_levels
}

output "data_proxmox_virtual_environment_nodes_example_uptime" {
  value = data.proxmox_virtual_environment_nodes.example.uptime
}
`````

## File: example/data_source_virtual_environment_pool.tf
`````hcl
data "proxmox_virtual_environment_pool" "example" {
  pool_id = proxmox_virtual_environment_pool.example.id
}

output "data_proxmox_virtual_environment_pool_example_comment" {
  value = data.proxmox_virtual_environment_pool.example.comment
}

output "data_proxmox_virtual_environment_pool_example_members" {
  value = data.proxmox_virtual_environment_pool.example.members
}

output "data_proxmox_virtual_environment_pool_example_pool_id" {
  value = data.proxmox_virtual_environment_pool.example.id
}
`````

## File: example/data_source_virtual_environment_pools.tf
`````hcl
data "proxmox_virtual_environment_pools" "example" {
  depends_on = [proxmox_virtual_environment_pool.example]
}

output "data_proxmox_virtual_environment_pools_example" {
  value = {
    pool_ids = data.proxmox_virtual_environment_pools.example.pool_ids
  }
}
`````

## File: example/data_source_virtual_environment_role.tf
`````hcl
data "proxmox_virtual_environment_role" "example" {
  role_id = proxmox_virtual_environment_role.example.id
}

output "data_proxmox_virtual_environment_role_example_privileges" {
  value = data.proxmox_virtual_environment_role.example.privileges
}

output "data_proxmox_virtual_environment_role_example_role_id" {
  value = data.proxmox_virtual_environment_role.example.id
}
`````

## File: example/data_source_virtual_environment_roles.tf
`````hcl
data "proxmox_virtual_environment_roles" "example" {
  depends_on = [proxmox_virtual_environment_role.example]
}

output "data_proxmox_virtual_environment_roles_example_privileges" {
  value = data.proxmox_virtual_environment_roles.example.privileges
}

output "data_proxmox_virtual_environment_roles_example_role_ids" {
  value = data.proxmox_virtual_environment_roles.example.role_ids
}

output "data_proxmox_virtual_environment_roles_example_special" {
  value = data.proxmox_virtual_environment_roles.example.special
}
`````

## File: example/data_source_virtual_environment_time.tf
`````hcl
data "proxmox_virtual_environment_time" "example" {
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "data_proxmox_virtual_environment_time" {
  value = {
    local_time = data.proxmox_virtual_environment_time.example.local_time
    time_zone  = data.proxmox_virtual_environment_time.example.time_zone
    utc_time   = data.proxmox_virtual_environment_time.example.utc_time
  }
}
`````

## File: example/data_source_virtual_environment_user.tf
`````hcl
data "proxmox_virtual_environment_user" "example" {
  user_id = proxmox_virtual_environment_user.example.id
}

output "data_proxmox_virtual_environment_user_example_acl" {
  value = data.proxmox_virtual_environment_user.example.acl
}

output "data_proxmox_virtual_environment_user_example_comment" {
  value = data.proxmox_virtual_environment_user.example.comment
}

output "data_proxmox_virtual_environment_user_example_email" {
  value = data.proxmox_virtual_environment_user.example.email
}

output "data_proxmox_virtual_environment_user_example_enabled" {
  value = data.proxmox_virtual_environment_user.example.enabled
}

output "data_proxmox_virtual_environment_user_example_expiration_date" {
  value = data.proxmox_virtual_environment_user.example.expiration_date
}

output "data_proxmox_virtual_environment_user_example_first_name" {
  value = data.proxmox_virtual_environment_user.example.first_name
}

output "data_proxmox_virtual_environment_user_example_groups" {
  value = data.proxmox_virtual_environment_user.example.groups
}

output "data_proxmox_virtual_environment_user_example_keys" {
  value = data.proxmox_virtual_environment_user.example.keys
}

output "data_proxmox_virtual_environment_user_example_last_name" {
  value = data.proxmox_virtual_environment_user.example.last_name
}

output "data_proxmox_virtual_environment_user_example_user_id" {
  value = data.proxmox_virtual_environment_user.example.id
}
`````

## File: example/data_source_virtual_environment_users.tf
`````hcl
data "proxmox_virtual_environment_users" "example" {
  depends_on = [proxmox_virtual_environment_user.example]
}

output "data_proxmox_virtual_environment_users_example_comments" {
  value = data.proxmox_virtual_environment_users.example.comments
}

output "data_proxmox_virtual_environment_users_example_emails" {
  value = data.proxmox_virtual_environment_users.example.emails
}

output "data_proxmox_virtual_environment_users_example_enabled" {
  value = data.proxmox_virtual_environment_users.example.enabled
}

output "data_proxmox_virtual_environment_users_example_expiration_dates" {
  value = data.proxmox_virtual_environment_users.example.expiration_dates
}

output "data_proxmox_virtual_environment_users_example_first_names" {
  value = data.proxmox_virtual_environment_users.example.first_names
}

output "data_proxmox_virtual_environment_users_example_groups" {
  value = data.proxmox_virtual_environment_users.example.groups
}

output "data_proxmox_virtual_environment_users_example_keys" {
  value = data.proxmox_virtual_environment_users.example.keys
}

output "data_proxmox_virtual_environment_users_example_last_names" {
  value = data.proxmox_virtual_environment_users.example.last_names
}

output "data_proxmox_virtual_environment_users_example_user_ids" {
  value = data.proxmox_virtual_environment_users.example.user_ids
}
`````

## File: example/data_source_virtual_environment_vm.tf
`````hcl
data "proxmox_virtual_environment_vm" "example" {
  depends_on = [proxmox_virtual_environment_vm.example]
  vm_id      = proxmox_virtual_environment_vm.example.vm_id
  node_name  = data.proxmox_virtual_environment_nodes.example.names[0]
}

output "proxmox_virtual_environment_vm_example" {
  value = data.proxmox_virtual_environment_vm.example
}
`````

## File: example/data_source_virtual_environment_vms.tf
`````hcl
data "proxmox_virtual_environment_vms" "example" {
  depends_on = [proxmox_virtual_environment_vm.example]
  tags       = ["ubuntu"]

  lifecycle {
    postcondition {
      condition     = length(self.vms) == 1
      error_message = "Only 1 vm should have this tag"
    }
  }
}

data "proxmox_virtual_environment_vms" "template_example" {
  depends_on = [proxmox_virtual_environment_vm.example]
  tags       = ["ubuntu"]

  filter {
    name   = "template"
    values = [false]
  }

  filter {
    name   = "status"
    values = ["running"]
  }

  filter {
    name   = "name"
    regex  = true
    values = [".*ubuntu.*"]
  }
}

output "proxmox_virtual_environment_vms_example" {
  value = data.proxmox_virtual_environment_vms.example.vms
}

output "proxmox_virtual_environment_template_vms_example" {
  value = data.proxmox_virtual_environment_vms.template_example.vms
}
`````

## File: example/main.tf
`````hcl
provider "proxmox" {
  endpoint = var.virtual_environment_endpoint
  api_token = var.virtual_environment_api_token
  insecure = true
  ssh {
    agent = true
    username = var.virtual_environment_ssh_username
  }
}
`````

## File: example/resource_virtual_environment_cluster_firewall_security_group.tf
`````hcl
resource "proxmox_virtual_environment_cluster_firewall_security_group" "example" {
  name    = "example-sg"
  comment = "Managed by Terraform"

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow FTP"
    dest    = "192.168.1.5"
    dport   = "21"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    type    = "in"
    action  = "DROP"
    comment = "Drop SSH"
    dest    = "192.168.1.5"
    dport   = "22"
    proto   = "udp"
    log     = "info"
  }
}

output "resource_proxmox_virtual_environment_cluster_firewall_security_group_example" {
  value = proxmox_virtual_environment_cluster_firewall_security_group.example
}
`````

## File: example/resource_virtual_environment_cluster_options.tf
`````hcl
resource "proxmox_virtual_environment_cluster_options" "options" {
  language                  = "en"
  keyboard                  = "pl"
  email_from                = "ged@gont.earthsea"
  bandwidth_limit_migration = 555555
  bandwidth_limit_default   = 666666
  max_workers               = 5
  migration_cidr            = "10.0.0.0/8"
  migration_type            = "secure"
}
`````

## File: example/resource_virtual_environment_container.tf
`````hcl
resource "proxmox_virtual_environment_container" "example_template" {
  description = "Managed by Terraform"

  start_on_boot = "true"

  disk {
    datastore_id = "local-lvm"
    size         = 4
  }

  mount_point {
    // volume mount
    volume = "local-lvm"
    size   = "4G"
    path   = "mnt/local"
  }

  initialization {
    dns {
      servers = ["1.1.1.1", "8.8.8.8"]
    }

    hostname = "terraform-provider-proxmox-example-lxc-template"

    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_account {
      keys     = [trimspace(tls_private_key.example.public_key_openssh)]
      password = "example"
    }
  }

  network_interface {
    name = "veth0"
    mtu  = 1450
  }

  node_name = data.proxmox_virtual_environment_nodes.example.names[0]

  operating_system {
    template_file_id = proxmox_virtual_environment_download_file.release_20240725_ubuntu_24_noble_lxc_img.id
    type             = "ubuntu"
  }

  pool_id  = proxmox_virtual_environment_pool.example.id
  template = true

  // use auto-generated vm_id

  tags = [
    "container",
    "example",
    "terraform",
  ]

  startup {
    order      = "3"
    up_delay   = "60"
    down_delay = "60"
  }
}

resource "proxmox_virtual_environment_container" "example" {
  disk {
    datastore_id = "local-lvm"
  }

  clone {
    vm_id = proxmox_virtual_environment_container.example_template.id
  }

  initialization {
    hostname = "terraform-provider-proxmox-example-lxc"
  }

  mount_point {
    // bind mount, requires root@pam
    volume = "/mnt/bindmounts/shared"
    path   = "/shared"
  }

  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
  pool_id   = proxmox_virtual_environment_pool.example.id
  # Set the protection flag to prevent the deletion/update operations for the container and its disks.
  # protection = true
  vm_id      = 2043
}

output "resource_proxmox_virtual_environment_container_example_id" {
  value = proxmox_virtual_environment_container.example.id
}
`````

## File: example/resource_virtual_environment_dns.tf
`````hcl
resource "proxmox_virtual_environment_dns" "example" {
  domain    = data.proxmox_virtual_environment_dns.example.domain
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
  servers   = data.proxmox_virtual_environment_dns.example.servers
}
`````

## File: example/resource_virtual_environment_download_file.tf
`````hcl
## Debian and ubuntu image download

resource "proxmox_virtual_environment_download_file" "release_20240725_ubuntu_24_noble_lxc_img" {
  content_type        = "vztmpl"
  datastore_id        = "local"
  node_name           = "pve"
  url                 = var.release_20240725_ubuntu_24_noble_lxc_img_url
  checksum            = var.release_20240725_ubuntu_24_noble_lxc_img_checksum
  checksum_algorithm  = "sha256"
  upload_timeout      = 4444
  overwrite_unmanaged = true
}

resource "proxmox_virtual_environment_download_file" "latest_debian_12_bookworm_qcow2_img" {
  content_type        = "iso"
  datastore_id        = "local"
  file_name           = "debian-12-generic-amd64.img"
  node_name           = "pve"
  url                 = var.latest_debian_12_bookworm_qcow2_img_url
  overwrite           = true
  overwrite_unmanaged = true
}
`````

## File: example/resource_virtual_environment_file.tf
`````hcl
#===============================================================================
# Cloud Config (cloud-init)
#===============================================================================

resource "proxmox_virtual_environment_file" "user_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = data.proxmox_virtual_environment_nodes.example.names[0]

  source_raw {
    data = <<-EOF
    #cloud-config
    chpasswd:
      list: |
        ubuntu:example
      expire: false
    hostname: terraform-provider-proxmox-example
    users:
      - default
      - name: ubuntu
        groups: sudo
        shell: /bin/bash
        ssh-authorized-keys:
          - ${trimspace(tls_private_key.example.public_key_openssh)}
        sudo: ALL=(ALL) NOPASSWD:ALL
    EOF

    file_name = "terraform-provider-proxmox-example-user-config.yaml"
  }
}

resource "proxmox_virtual_environment_file" "vendor_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = data.proxmox_virtual_environment_nodes.example.names[0]

  source_raw {
    data = <<-EOF
    #cloud-config
    runcmd:
      - apt update
      - apt install -y qemu-guest-agent
      - systemctl enable qemu-guest-agent
      - systemctl start qemu-guest-agent
      - echo "done" > /tmp/vendor-cloud-init-done
    EOF

    file_name = "terraform-provider-proxmox-example-vendor-config.yaml"
  }
}


resource "proxmox_virtual_environment_file" "meta_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = data.proxmox_virtual_environment_nodes.example.names[0]

  source_raw {
    data = <<-EOF
    local-hostname: myhost.internal
    EOF

    file_name = "meta-config.yaml"
  }
}
`````

## File: example/resource_virtual_environment_firewall_alias.tf
`````hcl
resource "proxmox_virtual_environment_firewall_alias" "cluster_alias" {
  name    = "cluster-alias"
  cidr    = "192.168.0.0/23"
  comment = "Managed by Terraform"
}

resource "proxmox_virtual_environment_firewall_alias" "vm_alias" {
  depends_on = [proxmox_virtual_environment_vm.example]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  name    = "vm-alias"
  cidr    = "192.168.1.0/23"
  comment = "Managed by Terraform"
}

resource "proxmox_virtual_environment_firewall_alias" "container_alias" {
  depends_on = [proxmox_virtual_environment_container.example]

  node_name    = proxmox_virtual_environment_container.example.node_name
  container_id = proxmox_virtual_environment_container.example.vm_id

  name    = "container-alias"
  cidr    = "192.168.2.0/23"
  comment = "Managed by Terraform"
}

output "resource_proxmox_virtual_environment_firewall_alias_cluster" {
  value = proxmox_virtual_environment_firewall_alias.cluster_alias
}

output "resource_proxmox_virtual_environment_firewall_alias_vm" {
  value = proxmox_virtual_environment_firewall_alias.vm_alias
}

output "resource_proxmox_virtual_environment_firewall_alias_container" {
  value = proxmox_virtual_environment_firewall_alias.container_alias
}
`````

## File: example/resource_virtual_environment_firewall_ipset.tf
`````hcl
resource "proxmox_virtual_environment_firewall_ipset" "cluster_ipset" {
  name    = "cluster-ipset"
  comment = "Managed by Terraform"

  cidr {
    name    = "192.168.0.1"
    comment = "Server 1"
    nomatch = true
  }

  cidr {
    name    = "192.168.0.2"
    comment = "Server 2"
  }
}

resource "proxmox_virtual_environment_firewall_ipset" "vm_ipset" {
  depends_on = [proxmox_virtual_environment_vm.example]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  name    = "vm-ipset"
  comment = "Managed by Terraform"

  cidr {
    name    = "192.168.1.1"
    comment = "Server 1"
    nomatch = true
  }

  cidr {
    name    = "192.168.1.2"
    comment = "Server 2"
  }
}

resource "proxmox_virtual_environment_firewall_ipset" "container_ipset" {
  depends_on = [proxmox_virtual_environment_container.example]

  node_name    = proxmox_virtual_environment_container.example.node_name
  container_id = proxmox_virtual_environment_container.example.vm_id

  name    = "container-ipset"
  comment = "Managed by Terraform"

  cidr {
    name    = "192.168.2.1"
    comment = "Server 1"
    nomatch = true
  }

  cidr {
    name    = "192.168.2.2"
    comment = "Server 2"
  }
}


output "resource_proxmox_virtual_environment_firewall_ipset_cluster" {
  value = proxmox_virtual_environment_firewall_ipset.cluster_ipset
}

output "resource_proxmox_virtual_environment_firewall_ipset_vm" {
  value = proxmox_virtual_environment_firewall_ipset.vm_ipset
}

output "resource_proxmox_virtual_environment_firewall_ipset_container" {
  value = proxmox_virtual_environment_firewall_ipset.container_ipset
}
`````

## File: example/resource_virtual_environment_firewall_options.tf
`````hcl
resource "proxmox_virtual_environment_cluster_firewall" "cluster_options" {
  enabled = false

  ebtables      = false
  input_policy  = "ACCEPT"
  output_policy = "REJECT"
  log_ratelimit {
    enabled = false
    burst   = 20
    rate    = "5/second"
  }
}


resource "proxmox_virtual_environment_firewall_options" "vm_options" {
  depends_on = [proxmox_virtual_environment_vm.example]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  dhcp          = true
  enabled       = false
  ipfilter      = true
  log_level_in  = "info"
  log_level_out = "info"
  macfilter     = false
  ndp           = true
  input_policy  = "REJECT"
  output_policy = "REJECT"
  radv          = true
}


resource "proxmox_virtual_environment_firewall_options" "container_options" {
  depends_on = [proxmox_virtual_environment_container.example]

  node_name    = proxmox_virtual_environment_container.example.node_name
  container_id = proxmox_virtual_environment_container.example.vm_id

  dhcp          = false
  enabled       = false
  ipfilter      = false
  log_level_in  = "alert"
  log_level_out = "alert"
  macfilter     = true
  ndp           = false
  input_policy  = "ACCEPT"
  output_policy = "DROP"
  radv          = false
}

output "resource_proxmox_virtual_environment_firewall_options_cluster" {
  value = proxmox_virtual_environment_cluster_firewall.cluster_options
}

output "resource_proxmox_virtual_environment_firewall_options_vm" {
  value = proxmox_virtual_environment_firewall_options.vm_options
}

output "resource_proxmox_virtual_environment_firewall_options_container" {
  value = proxmox_virtual_environment_firewall_options.container_options
}
`````

## File: example/resource_virtual_environment_firewall_rules.tf
`````hcl
resource "proxmox_virtual_environment_firewall_rules" "cluster_rules" {
  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow FTP"
    dest    = "192.168.0.5"
    dport   = "21"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    type    = "out"
    action  = "DROP"
    comment = "Drop SSH"
    dest    = "192.168.0.5"
    dport   = "22"
    proto   = "tcp"
  }
}

resource "proxmox_virtual_environment_firewall_rules" "vm_rules" {
  depends_on = [
    proxmox_virtual_environment_vm.example,
    proxmox_virtual_environment_cluster_firewall_security_group.example,
  ]

  node_name = proxmox_virtual_environment_vm.example.node_name
  vm_id     = proxmox_virtual_environment_vm.example.vm_id

  rule {
    security_group = proxmox_virtual_environment_cluster_firewall_security_group.example.name
    enabled        = true
    comment        = "From XXX"
    iface          = "net0"
  }

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow FTP"
    dest    = "192.168.1.15"
    dport   = "21"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    type    = "out"
    action  = "DROP"
    comment = "Drop SSH"
    dest    = "192.168.1.15"
    dport   = "22"
    proto   = "tcp"
  }
}

resource "proxmox_virtual_environment_firewall_rules" "container_rules" {
  depends_on = [proxmox_virtual_environment_container.example]

  node_name    = proxmox_virtual_environment_container.example.node_name
  container_id = proxmox_virtual_environment_container.example.vm_id

  rule {
    type    = "in"
    action  = "ACCEPT"
    comment = "Allow FTP"
    dest    = "192.168.2.5"
    dport   = "21"
    proto   = "tcp"
    log     = "info"
  }

  rule {
    type    = "out"
    action  = "DROP"
    comment = "Drop SSH"
    dest    = "192.168.2.5"
    dport   = "22"
    proto   = "tcp"
  }
}

output "resource_proxmox_virtual_environment_firewall_rules_cluster" {
  value = proxmox_virtual_environment_firewall_rules.cluster_rules
}

output "resource_proxmox_virtual_environment_firewall_rules_vm" {
  value = proxmox_virtual_environment_firewall_rules.vm_rules
}

output "resource_proxmox_virtual_environment_firewall_rules_container" {
  value = proxmox_virtual_environment_firewall_rules.container_rules
}
`````

## File: example/resource_virtual_environment_group.tf
`````hcl
resource "proxmox_virtual_environment_group" "example" {
  acl {
    path    = "/vms/${proxmox_virtual_environment_vm.example.id}"
    role_id = proxmox_virtual_environment_role.example.id
  }

  comment  = "Managed by Terraform"
  group_id = "terraform-provider-proxmox-example"
}

output "resource_proxmox_virtual_environment_group_example_acl" {
  value = proxmox_virtual_environment_group.example.acl
}

output "resource_proxmox_virtual_environment_group_example_comment" {
  value = proxmox_virtual_environment_group.example.comment
}

output "resource_proxmox_virtual_environment_group_example_id" {
  value = proxmox_virtual_environment_group.example.id
}

output "resource_proxmox_virtual_environment_group_example_members" {
  value = proxmox_virtual_environment_group.example.members
}
`````

## File: example/resource_virtual_environment_hosts.tf
`````hcl
resource "proxmox_virtual_environment_hosts" "example" {
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]

  dynamic "entry" {
    for_each = data.proxmox_virtual_environment_hosts.example.entries

    content {
      address   = entry.value.address
      hostnames = entry.value.hostnames
    }
  }
}

output "resource_proxmox_virtual_environment_hosts_example_addresses" {
  value = proxmox_virtual_environment_hosts.example.addresses
}

output "resource_proxmox_virtual_environment_hosts_example_digest" {
  value = proxmox_virtual_environment_hosts.example.digest
}

output "resource_proxmox_virtual_environment_hosts_example_entries" {
  value = proxmox_virtual_environment_hosts.example.entries
}

output "resource_proxmox_virtual_environment_hosts_example_hostnames" {
  value = proxmox_virtual_environment_hosts.example.hostnames
}
`````

## File: example/resource_virtual_environment_metrics_server.tf
`````hcl
resource "proxmox_virtual_environment_metrics_server" "influxdb_server" {
  name   = "example_influxdb_server"
  server = "192.168.3.2"
  port   = 18089
  type   = "influxdb"

}

resource "proxmox_virtual_environment_metrics_server" "graphite_server" {
  name   = "example_graphite_server"
  server = "192.168.4.2"
  port   = 20033
  type   = "graphite"
}

resource "proxmox_virtual_environment_metrics_server" "graphite_server2" {
  name           = "example_graphite_server2"
  server         = "192.168.4.3"
  port           = 20033
  type           = "graphite"
  mtu            = 60000
  timeout        = 5
  graphite_proto = "udp"
}
`````

## File: example/resource_virtual_environment_pool.tf
`````hcl
resource "proxmox_virtual_environment_pool" "example" {
  comment = "Managed by Terraform"
  pool_id = "terraform-provider-proxmox-example"
}

output "resource_proxmox_virtual_environment_pool_example_comment" {
  value = proxmox_virtual_environment_pool.example.comment
}

output "resource_proxmox_virtual_environment_pool_example_members" {
  value = proxmox_virtual_environment_pool.example.members
}

output "resource_proxmox_virtual_environment_pool_example_pool_id" {
  value = proxmox_virtual_environment_pool.example.id
}
`````

## File: example/resource_virtual_environment_role.tf
`````hcl
resource "proxmox_virtual_environment_role" "example" {
  privileges = [
    "VM.Monitor",
  ]
  role_id = "terraform-provider-proxmox-example"
}

output "resource_proxmox_virtual_environment_role_example_privileges" {
  value = proxmox_virtual_environment_role.example.privileges
}

output "resource_proxmox_virtual_environment_role_example_role_id" {
  value = proxmox_virtual_environment_role.example.role_id
}
`````

## File: example/resource_virtual_environment_time.tf
`````hcl
resource "proxmox_virtual_environment_time" "example" {
  node_name = data.proxmox_virtual_environment_time.example.node_name
  time_zone = data.proxmox_virtual_environment_time.example.time_zone
}

output "resource_proxmox_virtual_environment_time" {
  value = {
    local_time = proxmox_virtual_environment_time.example.local_time
    time_zone  = proxmox_virtual_environment_time.example.time_zone
    utc_time   = proxmox_virtual_environment_time.example.utc_time
  }
}
`````

## File: example/resource_virtual_environment_trunks.tf
`````hcl
resource "proxmox_virtual_environment_vm" "trunks-example" {
  name        = "trunks-example"
  node_name   = data.proxmox_virtual_environment_nodes.example.names[0]
  description = "Example of a VM using trunks to pass multiple VLANs on a single network interface."

  disk {
    datastore_id = local.datastore_id
    file_id      = proxmox_virtual_environment_download_file.latest_debian_12_bookworm_qcow2_img.id
    interface    = "scsi0"
    discard      = "on"
    cache        = "writeback"
    ssd          = true
  }

  initialization {
    datastore_id = local.datastore_id
    interface    = "scsi4"

    dns {
      servers = ["1.1.1.1", "8.8.8.8"]
    }

    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }
    user_data_file_id   = proxmox_virtual_environment_file.user_config.id
    vendor_data_file_id = proxmox_virtual_environment_file.vendor_config.id
    meta_data_file_id   = proxmox_virtual_environment_file.meta_config.id
  }

  memory {
    dedicated = 1024
  }

  cpu {
    cores = 2
  }

  agent {
    enabled = true
  }

  boot_order    = ["scsi0"]
  scsi_hardware = "virtio-scsi-pci"

  network_device {
    model  = "virtio"
    bridge = "vmbr0"
    trunks = "10;20;30"
  }
}
`````

## File: example/resource_virtual_environment_user.tf
`````hcl
resource "proxmox_virtual_environment_user" "example" {
  acl {
    path      = "/vms/${proxmox_virtual_environment_vm.example.id}"
    propagate = true
    role_id   = "PVEVMAdmin"
  }

  comment         = "Managed by Terraform"
  password        = "Test1234!"
  user_id         = "terraform-provider-proxmox-example@pve"
  expiration_date = "2035-12-31T23:59:59Z"
}

resource "proxmox_virtual_environment_user" "example2" {
  comment = "Managed by Terraform"
  user_id = "terraform-provider-proxmox-example2@pve"
}

output "resource_proxmox_virtual_environment_user_example_acl" {
  value = proxmox_virtual_environment_user.example.acl
}

output "resource_proxmox_virtual_environment_user_example_comment" {
  value = proxmox_virtual_environment_user.example.comment
}

output "resource_proxmox_virtual_environment_user_example_email" {
  value = proxmox_virtual_environment_user.example.email
}

output "resource_proxmox_virtual_environment_user_example_enabled" {
  value = proxmox_virtual_environment_user.example.enabled
}

output "resource_proxmox_virtual_environment_user_example_expiration_date" {
  value = proxmox_virtual_environment_user.example.expiration_date
}

output "resource_proxmox_virtual_environment_user_example_first_name" {
  value = proxmox_virtual_environment_user.example.first_name
}

output "resource_proxmox_virtual_environment_user_example_groups" {
  value = proxmox_virtual_environment_user.example.groups
}

output "resource_proxmox_virtual_environment_user_example_keys" {
  value = proxmox_virtual_environment_user.example.keys
}

output "resource_proxmox_virtual_environment_user_example_last_name" {
  value = proxmox_virtual_environment_user.example.last_name
}

output "resource_proxmox_virtual_environment_user_example_password" {
  value     = proxmox_virtual_environment_user.example.password
  sensitive = true
}

output "resource_proxmox_virtual_environment_user_example_user_id" {
  value = proxmox_virtual_environment_user.example.id
}
`````

## File: example/resource_virtual_environment_vm.tf
`````hcl
locals {
  datastore_id = "local-lvm"
}

resource "proxmox_virtual_environment_vm" "example_template" {
  agent {
    enabled = true
  }

  bios        = "ovmf"
  description = "Managed by Terraform"

  cpu {
    cores = 2
    numa  = true
    limit = 64
    # affinity = "0-1"
  }

  smbios {
    manufacturer = "Terraform"
    product      = "Terraform Provider Proxmox"
    version      = "0.0.1"
  }

  startup {
    order      = "3"
    up_delay   = "60"
    down_delay = "60"
  }

  efi_disk {
    datastore_id = local.datastore_id
    type         = "4m"
  }

  tpm_state {
    datastore_id = local.datastore_id
    version      = "v2.0"
  }

  disk {
    datastore_id = local.datastore_id
    interface    = "ide0"
    size         = 8
  }

  disk {
    datastore_id = local.datastore_id
    file_id      = proxmox_virtual_environment_download_file.latest_debian_12_bookworm_qcow2_img.id
    interface    = "scsi0"
    discard      = "on"
    cache        = "writeback"
    serial       = "dead_beef"
    ssd          = true
  }

  #  disk {
  #    datastore_id = "nfs"
  #    interface    = "scsi1"
  #    discard      = "ignore"
  #  }

  initialization {
    datastore_id = local.datastore_id
    interface    = "scsi4"

    dns {
      servers = ["1.1.1.1", "8.8.8.8"]
    }

    ip_config {
      ipv4 {
        address = "dhcp"
      }
      # ipv6 {
      #    address = "dhcp"
      #}
    }

    user_data_file_id   = proxmox_virtual_environment_file.user_config.id
    vendor_data_file_id = proxmox_virtual_environment_file.vendor_config.id
    meta_data_file_id   = proxmox_virtual_environment_file.meta_config.id
  }

  machine = "q35"
  name    = "terraform-provider-proxmox-example-template"

  cdrom {
    file_id = "none"
  }

  network_device {
    mtu    = 1450
    queues = 2
  }

  network_device {
    vlan_id = 1024
  }

  node_name = data.proxmox_virtual_environment_nodes.example.names[0]

  operating_system {
    type = "l26"
  }

  pool_id = proxmox_virtual_environment_pool.example.id

  serial_device {}

  vga {
    type = "qxl"
  }

  template = true

  // use auto-generated vm_id
}

resource "proxmox_virtual_environment_vm" "example" {
  name      = "terraform-provider-proxmox-example"
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
  migrate   = true // migrate the VM on node change
  pool_id   = proxmox_virtual_environment_pool.example.id
  vm_id     = 2041
  tags      = ["terraform", "ubuntu"]

  clone {
    vm_id = proxmox_virtual_environment_vm.example_template.id
  }

  machine = "q35"

  memory {
    dedicated = 768
    # hugepages = "2"
  }

  # numa {
  #   device = "numa0"
  #   cpus   = "0-1"
  #   memory = 768
  # }

  connection {
    type        = "ssh"
    agent       = false
    host        = element(element(self.ipv4_addresses, index(self.network_interface_names, "eth0")), 0)
    private_key = tls_private_key.example.private_key_pem
    user        = "ubuntu"
  }

  provisioner "remote-exec" {
    inline = [
      "echo Welcome to $(hostname)!",
    ]
  }

  smbios {
    serial = "my-custom-serial"
  }

  efi_disk {
    datastore_id = local.datastore_id
    type         = "4m"
  }

  initialization {
    datastore_id = local.datastore_id
    // if unspecified:
    //   - autodetected if there is a cloud-init device on the template
    //   - otherwise defaults to ide2
    interface = "scsi4"

    dns {
      servers = ["1.1.1.1"]
    }
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }
  }

  #hostpci {
  #  device = "hostpci0"
  #  id = "0000:00:1f.0"
  #  pcie = true
  #}

  #hostpci {
  #  device = "hostpci1"
  #  mapping = "gpu"
  #  pcie = true
  #}

  #usb {
  #  host = "0000:1234"
  #  mapping = "usbdevice1"
  #  usb3 = false
  #}

  #usb {
  #  host = "0000:5678"
  #  mapping = "usbdevice2"
  #  usb3 = false
  #}

  # attached disks from data_vm
  dynamic "disk" {
    for_each = { for idx, val in proxmox_virtual_environment_vm.data_vm.disk : idx => val }
    iterator = data_disk
    content {
      datastore_id      = data_disk.value["datastore_id"]
      path_in_datastore = data_disk.value["path_in_datastore"]
      file_format       = data_disk.value["file_format"]
      size              = data_disk.value["size"]
      # assign from scsi1 and up
      interface = "scsi${data_disk.key + 1}"
    }
  }
}

resource "proxmox_virtual_environment_vm" "data_vm" {
  name      = "terraform-provider-proxmox-data-vm"
  node_name = data.proxmox_virtual_environment_nodes.example.names[0]
  started   = false
  on_boot   = false

  disk {
    datastore_id = local.datastore_id
    interface    = "scsi0"
    size         = 1
  }
  disk {
    datastore_id = local.datastore_id
    interface    = "scsi1"
    size         = 4
  }
}

resource "proxmox_virtual_environment_hardware_mapping_dir" "dir_mapping" {
  name = "terraform-provider-proxmox-dir-mapping"

  map = [{
    node = data.proxmox_virtual_environment_nodes.example.names[0]
    path = "/mnt"
  }]
}

output "resource_proxmox_virtual_environment_vm_example_id" {
  value = proxmox_virtual_environment_vm.example.id
}

output "resource_proxmox_virtual_environment_vm_example_ipv4_addresses" {
  value = proxmox_virtual_environment_vm.example.ipv4_addresses
}

output "resource_proxmox_virtual_environment_vm_example_ipv6_addresses" {
  value = proxmox_virtual_environment_vm.example.ipv6_addresses
}

output "resource_proxmox_virtual_environment_vm_example_mac_addresses" {
  value = proxmox_virtual_environment_vm.example.mac_addresses
}

output "resource_proxmox_virtual_environment_vm_example_network_interface_names" {
  value = proxmox_virtual_environment_vm.example.network_interface_names
}
`````

## File: example/ssh.tf
`````hcl
resource "local_sensitive_file" "example_ssh_private_key" {
  filename = "${path.module}/autogenerated/id_rsa"
  content  = tls_private_key.example.private_key_pem
}

resource "local_sensitive_file" "example_ssh_public_key" {
  filename = "${path.module}/autogenerated/id_rsa.pub"
  content  = tls_private_key.example.public_key_openssh
}

resource "tls_private_key" "example" {
  algorithm = "RSA"
  rsa_bits  = 2048
}
`````

## File: example/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_api_token" {
  type        = string
  description = "The API token for the Proxmox Virtual Environment API"
}

variable "virtual_environment_ssh_username" {
  type        = string
  description = "The username for the Proxmox Virtual Environment API"
}

variable "latest_debian_12_bookworm_qcow2_img_url" {
  type        = string
  description = "The URL for the latest Debian 12 Bookworm qcow2 image"
  default     = "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
}

variable "release_20240725_ubuntu_24_noble_lxc_img_url" {
  type        = string
  description = "The URL for the Ubuntu 24.04 LXC image"
  default     = "https://mirrors.servercentral.com/ubuntu-cloud-images/releases/24.04/release-20240725/ubuntu-24.04-server-cloudimg-amd64-root.tar.xz"
}

variable "release_20240725_ubuntu_24_noble_lxc_img_checksum" {
  type        = string
  description = "The checksum for the Ubuntu 24.04 LXC image"
  default     = "d767d38cb25b2c25d84edc31a80dd1c29a8c922b74188b0e14768b2b2fb6df8e"
}
`````

## File: example/versions.tf
`````hcl
terraform {
  required_providers {
    local = {
      source  = "hashicorp/local"
      version = "2.5.3"
    }
    tls = {
      source  = "hashicorp/tls"
      version = "4.1.0"
    }
    proxmox = {
      source = "bpg/proxmox"
    }
  }
}
`````

## File: examples/data-sources/proxmox_virtual_environment_acme_account/data-source.tf
`````hcl
// This will fetch all ACME accounts...
data "proxmox_virtual_environment_acme_accounts" "all" {}

// ...which we will go through in order to fetch the whole data on each account.
data "proxmox_virtual_environment_acme_account" "example" {
  for_each = data.proxmox_virtual_environment_acme_accounts.all.accounts
  name     = each.value
}

output "data_proxmox_virtual_environment_acme_account" {
  value = data.proxmox_virtual_environment_acme_account.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_acme_accounts/data-source.tf
`````hcl
data "proxmox_virtual_environment_acme_accounts" "example" {}

output "data_proxmox_virtual_environment_acme_accounts" {
  value = data.proxmox_virtual_environment_acme_accounts.example.accounts
}
`````

## File: examples/data-sources/proxmox_virtual_environment_acme_plugin/data-source.tf
`````hcl
data "proxmox_virtual_environment_acme_plugin" "example" {
  plugin = "standalone"
}

output "data_proxmox_virtual_environment_acme_plugin" {
  value = data.proxmox_virtual_environment_acme_plugin.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_acme_plugins/data-source.tf
`````hcl
data "proxmox_virtual_environment_acme_plugins" "example" {}

output "data_proxmox_virtual_environment_acme_plugins" {
  value = data.proxmox_virtual_environment_acme_plugins.example.plugins
}
`````

## File: examples/data-sources/proxmox_virtual_environment_apt_repository/data-source.tf
`````hcl
data "proxmox_virtual_environment_apt_repository" "example" {
  file_path = "/etc/apt/sources.list"
  index     = 0
  node      = "pve"
}

output "proxmox_virtual_environment_apt_repository" {
  value = data.proxmox_virtual_environment_apt_repository.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_apt_standard_repository/data-source.tf
`````hcl
data "proxmox_virtual_environment_apt_standard_repository" "example" {
  handle = "no-subscription"
  node   = "pve"
}

output "proxmox_virtual_environment_apt_standard_repository" {
  value = data.proxmox_virtual_environment_apt_standard_repository.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_hagroup/data-source.tf
`````hcl
// This will fetch the set of HA group identifiers...
data "proxmox_virtual_environment_hagroups" "all" {}

// ...which we will go through in order to fetch the whole data on each group.
data "proxmox_virtual_environment_hagroup" "example" {
  for_each = data.proxmox_virtual_environment_hagroups.all.group_ids
  group    = each.value
}

output "proxmox_virtual_environment_hagroups_full" {
  value = data.proxmox_virtual_environment_hagroup.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_hagroups/data-source.tf
`````hcl
data "proxmox_virtual_environment_hagroups" "example" {}

output "data_proxmox_virtual_environment_hagroups" {
  value = data.proxmox_virtual_environment_hagroups.example.group_ids
}
`````

## File: examples/data-sources/proxmox_virtual_environment_hardware_mapping_dir/data-source.tf
`````hcl
data "proxmox_virtual_environment_hardware_mapping_dir" "example" {
  name = "example"
}

output "data_proxmox_virtual_environment_hardware_mapping_dir" {
  value = data.proxmox_virtual_environment_hardware_mapping_dir.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_hardware_mapping_pci/data-source.tf
`````hcl
data "proxmox_virtual_environment_hardware_mapping_pci" "example" {
  name = "example"
}

output "data_proxmox_virtual_environment_hardware_mapping_pci" {
  value = data.proxmox_virtual_environment_hardware_mapping_pci.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_hardware_mapping_usb/data-source.tf
`````hcl
data "proxmox_virtual_environment_hardware_mapping_usb" "example" {
  name = "example"
}

output "data_proxmox_virtual_environment_hardware_mapping_usb" {
  value = data.proxmox_virtual_environment_hardware_mapping_usb.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_hardware_mappings/data-source.tf
`````hcl
data "proxmox_virtual_environment_hardware_mappings" "example-dir" {
  check_node = "pve"
  type       = "dir"
}

data "proxmox_virtual_environment_hardware_mappings" "example-pci" {
  check_node = "pve"
  type       = "pci"
}

data "proxmox_virtual_environment_hardware_mappings" "example-usb" {
  check_node = "pve"
  type       = "usb"
}

output "data_proxmox_virtual_environment_hardware_mappings_pci" {
  value = data.proxmox_virtual_environment_hardware_mappings.example-pci
}

output "data_proxmox_virtual_environment_hardware_mappings_usb" {
  value = data.proxmox_virtual_environment_hardware_mappings.example-usb
}
`````

## File: examples/data-sources/proxmox_virtual_environment_haresource/data-source.tf
`````hcl
// This will fetch the set of all HA resource identifiers...
data "proxmox_virtual_environment_haresources" "all" {}

// ...which we will go through in order to fetch the whole record for each resource.
data "proxmox_virtual_environment_haresource" "example" {
  for_each    = data.proxmox_virtual_environment_haresources.all.resource_ids
  resource_id = each.value
}

output "proxmox_virtual_environment_haresources_full" {
  value = data.proxmox_virtual_environment_haresource.example
}
`````

## File: examples/data-sources/proxmox_virtual_environment_haresources/data-source.tf
`````hcl
// This will fetch the set of all HA resource identifiers.
data "proxmox_virtual_environment_haresources" "example_all" {}

// This will fetch the set of HA resource identifiers that correspond to virtual machines.
data "proxmox_virtual_environment_haresources" "example_vm" {
  type = "vm"
}

output "data_proxmox_virtual_environment_haresources" {
  value = {
    all = data.proxmox_virtual_environment_haresources.example_all.resource_ids
    vms = data.proxmox_virtual_environment_haresources.example_vm.resource_ids
  }
}
`````

## File: examples/data-sources/proxmox_virtual_environment_metrics_server/data-source.tf
`````hcl
data "proxmox_virtual_environment_metrics_server" "example" {
  name = "example_influxdb"
}

output "data_proxmox_virtual_environment_metrics_server" {
  value = {
    server = data.proxmox_virtual_environment_metrics_server.example.server
    port   = data.proxmox_virtual_environment_metrics_server.example.port
  }
}
`````

## File: examples/data-sources/proxmox_virtual_environment_version/data-source.tf
`````hcl
data "proxmox_virtual_environment_version" "example" {}

output "data_proxmox_virtual_environment_version" {
  value = {
    release       = data.proxmox_virtual_environment_version.example.release
    repository_id = data.proxmox_virtual_environment_version.example.repository_id
    version       = data.proxmox_virtual_environment_version.example.version
  }
}
`````

## File: examples/guides/clone-vm/clone.tf
`````hcl
resource "proxmox_virtual_environment_vm" "ubuntu_clone" {
  name      = "ubuntu-clone"
  node_name = "pve"

  clone {
    vm_id = proxmox_virtual_environment_vm.ubuntu_template.id
  }

  agent {
    # NOTE: The agent is installed and enabled as part of the cloud-init configuration in the template VM, see cloud-config.tf
    # The working agent is *required* to retrieve the VM IP addresses.
    # If you are using a different cloud-init configuration, or a different clone source
    # that does not have the qemu-guest-agent installed, you may need to disable the `agent` below and remove the `vm_ipv4_address` output.
    # See https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_vm#qemu-guest-agent for more details.
    enabled = true
  }

  memory {
    dedicated = 768
  }

  initialization {
    dns {
      servers = ["1.1.1.1"]
    }
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }
  }
}

output "vm_ipv4_address" {
  value = proxmox_virtual_environment_vm.ubuntu_clone.ipv4_addresses[1][0]
}
`````

## File: examples/guides/clone-vm/cloud-config.tf
`````hcl
data "local_file" "ssh_public_key" {
  filename = "./id_rsa.pub"
}

resource "proxmox_virtual_environment_file" "user_data_cloud_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"

  source_raw {
    data = <<-EOF
    #cloud-config
    hostname: test-ubuntu
    timezone: America/Toronto
    users:
      - default
      - name: ubuntu
        groups:
          - sudo
        shell: /bin/bash
        ssh_authorized_keys:
          - ${trimspace(data.local_file.ssh_public_key.content)}
        sudo: ALL=(ALL) NOPASSWD:ALL
    package_update: true
    packages:
      - qemu-guest-agent
      - net-tools
      - curl
    runcmd:
      - systemctl enable qemu-guest-agent
      - systemctl start qemu-guest-agent
      - echo "done" > /tmp/cloud-config.done
    EOF

    file_name = "user-data-cloud-config.yaml"
  }
}
`````

## File: examples/guides/clone-vm/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source  = "bpg/proxmox"
      version = "0.78.1" # x-release-please-version
    }
  }
}

provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = var.virtual_environment_token
  ssh {
    agent    = true
    username = "terraform"
  }
}
`````

## File: examples/guides/clone-vm/template.tf
`````hcl
resource "proxmox_virtual_environment_vm" "ubuntu_template" {
  name      = "ubuntu-template"
  node_name = "pve"

  template = true
  started  = false

  machine     = "q35"
  bios        = "ovmf"
  description = "Managed by Terraform"

  cpu {
    cores = 2
  }

  memory {
    dedicated = 2048
  }

  efi_disk {
    datastore_id = "local"
    type         = "4m"
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }

  initialization {
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_data_file_id = proxmox_virtual_environment_file.user_data_cloud_config.id
  }

  network_device {
    bridge = "vmbr0"
  }

}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}
`````

## File: examples/guides/clone-vm/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_token" {
  type        = string
  description = "The token for the Proxmox Virtual Environment API"
  sensitive   = true
}
`````

## File: examples/guides/cloud-image/centos-qcow2/main.tf
`````hcl
resource "proxmox_virtual_environment_vm" "centos_vm" {
  name      = "test-centos"
  node_name = "pve"

  # should be true if qemu agent is not installed / enabled on the VM
  stop_on_destroy = true

  initialization {
    user_account {
      # do not use this in production, configure your own ssh key instead!
      username = "user"
      password = "password"
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.centos_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }
}

resource "proxmox_virtual_environment_download_file" "centos_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud.centos.org/centos/8-stream/x86_64/images/CentOS-Stream-GenericCloud-8-latest.x86_64.qcow2"
  file_name    = "centos8.img"
}
`````

## File: examples/guides/cloud-image/centos-qcow2/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source  = "bpg/proxmox"
      version = "0.78.1" # x-release-please-version
    }
  }
}

provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = var.virtual_environment_token
  ssh {
    agent    = true
    username = "terraform"
  }
}
`````

## File: examples/guides/cloud-image/centos-qcow2/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_token" {
  type        = string
  description = "The token for the Proxmox Virtual Environment API"
  sensitive   = true
}
`````

## File: examples/guides/cloud-image/debian-from-storage/main.tf
`````hcl
resource "proxmox_virtual_environment_vm" "debian_vm" {
  name      = "test-debian"
  node_name = "pve"

  # should be true if qemu agent is not installed / enabled on the VM
  stop_on_destroy = true

  initialization {
    user_account {
      # do not use this in production, configure your own ssh key instead!
      username = "user"
      password = "password"
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = "local:iso/debian-12-genericcloud-amd64.img"
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }
}
`````

## File: examples/guides/cloud-image/debian-from-storage/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source  = "bpg/proxmox"
      version = "0.78.1" # x-release-please-version
    }
  }
}

provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = var.virtual_environment_token
  ssh {
    agent    = true
    username = "terraform"
  }
}
`````

## File: examples/guides/cloud-image/debian-from-storage/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_token" {
  type        = string
  description = "The token for the Proxmox Virtual Environment API"
  sensitive   = true
}
`````

## File: examples/guides/cloud-image/ubuntu-img/main.tf
`````hcl
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name      = "test-ubuntu"
  node_name = "pve"

  # should be true if qemu agent is not installed / enabled on the VM
  stop_on_destroy = true

  initialization {
    user_account {
      # do not use this in production, configure your own ssh key instead!
      username = "user"
      password = "password"
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }
}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}
`````

## File: examples/guides/cloud-image/ubuntu-img/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source  = "bpg/proxmox"
      version = "0.78.1" # x-release-please-version
    }
  }
}

provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = var.virtual_environment_token
  ssh {
    agent    = true
    username = "terraform"
  }
}
`````

## File: examples/guides/cloud-image/ubuntu-img/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_token" {
  type        = string
  description = "The token for the Proxmox Virtual Environment API"
}
`````

## File: examples/guides/cloud-init/custom/cloud-config.tf
`````hcl
data "local_file" "ssh_public_key" {
  filename = "./id_rsa.pub"
}

resource "proxmox_virtual_environment_file" "user_data_cloud_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"

  source_raw {
    data = <<-EOF
    #cloud-config
    hostname: test-ubuntu
    timezone: America/Toronto
    users:
      - default
      - name: ubuntu
        groups:
          - sudo
        shell: /bin/bash
        ssh_authorized_keys:
          - ${trimspace(data.local_file.ssh_public_key.content)}
        sudo: ALL=(ALL) NOPASSWD:ALL
    package_update: true
    packages:
      - qemu-guest-agent
      - net-tools
      - curl
    runcmd:
      - systemctl enable qemu-guest-agent
      - systemctl start qemu-guest-agent
      - echo "done" > /tmp/cloud-config.done
    EOF

    file_name = "user-data-cloud-config.yaml"
  }
}
`````

## File: examples/guides/cloud-init/custom/main.tf
`````hcl
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name      = "test-ubuntu"
  node_name = "pve"

  agent {
    enabled = true
  }

  cpu {
    cores = 2
  }

  memory {
    dedicated = 2048
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }

  initialization {
    ip_config {
      ipv4 {
        address = "dhcp"
      }
    }

    user_data_file_id = proxmox_virtual_environment_file.user_data_cloud_config.id
  }

  network_device {
    bridge = "vmbr0"
  }

}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}

output "vm_ipv4_address" {
  value = proxmox_virtual_environment_vm.ubuntu_vm.ipv4_addresses[1][0]
}
`````

## File: examples/guides/cloud-init/custom/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source  = "bpg/proxmox"
      version = "0.78.1" # x-release-please-version
    }
  }
}

provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = var.virtual_environment_token
  ssh {
    agent    = true
    username = "terraform"
  }
}
`````

## File: examples/guides/cloud-init/custom/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_token" {
  type        = string
  description = "The token for the Proxmox Virtual Environment API"
}
`````

## File: examples/guides/cloud-init/native/main.tf
`````hcl
data "local_file" "ssh_public_key" {
  filename = "./id_rsa.pub"
}

resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  name      = "test-ubuntu"
  node_name = "pve"

  initialization {
    ip_config {
      ipv4 {
        address = "192.168.3.233/24"
        gateway = "192.168.3.1"
      }
    }

    user_account {
      username = "ubuntu"
      keys     = [trimspace(data.local_file.ssh_public_key.content)]
    }
  }

  disk {
    datastore_id = "local-lvm"
    file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
    interface    = "virtio0"
    iothread     = true
    discard      = "on"
    size         = 20
  }

  network_device {
    bridge = "vmbr0"
  }
}

resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"

  url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}
`````

## File: examples/guides/cloud-init/native/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source  = "bpg/proxmox"
      version = "0.78.1" # x-release-please-version
    }
  }
}

provider "proxmox" {
  endpoint  = var.virtual_environment_endpoint
  api_token = var.virtual_environment_token
  ssh {
    agent    = true
    username = "terraform"
  }
}
`````

## File: examples/guides/cloud-init/native/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_token" {
  type        = string
  description = "The token for the Proxmox Virtual Environment API"
}
`````

## File: examples/provider/provider.tf
`````hcl
terraform {
  required_providers {
    proxmox = {
      source = "bpg/proxmox"
    }
  }
}

provider "proxmox" {
  endpoint = var.virtual_environment_endpoint
  username = var.virtual_environment_username
  password = var.virtual_environment_password
  insecure = true
  ssh {
    agent = true
  }
}
`````

## File: examples/provider/variables.tf
`````hcl
variable "virtual_environment_endpoint" {
  type        = string
  description = "The endpoint for the Proxmox Virtual Environment API (example: https://host:port)"
}

variable "virtual_environment_password" {
  type        = string
  description = "The password for the Proxmox Virtual Environment API"
}

variable "virtual_environment_username" {
  type        = string
  description = "The username and realm for the Proxmox Virtual Environment API (example: root@pam)"
}
`````

## File: examples/resources/proxmox_virtual_environment_acl/import.sh
`````bash
#!/usr/bin/env sh
# ACL can be imported using its unique identifier, e.g.: {path}?{group|user@realm|user@realm!token}?{role}
terraform import proxmox_virtual_environment_acl.operations_automation_monitoring /?monitor@pve?operations-monitoring
`````

## File: examples/resources/proxmox_virtual_environment_acl/resource.tf
`````hcl
resource "proxmox_virtual_environment_user" "operations_automation" {
  comment  = "Managed by Terraform"
  password = "a-strong-password"
  user_id  = "operations-automation@pve"
}

resource "proxmox_virtual_environment_role" "operations_monitoring" {
  role_id = "operations-monitoring"

  privileges = [
    "VM.Monitor",
  ]
}

resource "proxmox_virtual_environment_acl" "operations_automation_monitoring" {
  user_id = proxmox_virtual_environment_user.operations_automation.user_id
  role_id = proxmox_virtual_environment_role.operations_monitoring.role_id

  path      = "/vms/1234"
  propagate = true
}
`````

## File: examples/resources/proxmox_virtual_environment_acme_account/import.sh
`````bash
#!/usr/bin/env sh
# ACME accounts can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_acme_account.example example
`````

## File: examples/resources/proxmox_virtual_environment_acme_account/resource.tf
`````hcl
resource "proxmox_virtual_environment_acme_account" "example" {
  name      = "example"
  contact   = "example@email.com"
  directory = "https://acme-staging-v02.api.letsencrypt.org/directory"
  tos       = "https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf"
}
`````

## File: examples/resources/proxmox_virtual_environment_acme_dns_plugin/import.sh
`````bash
#!/usr/bin/env sh
# ACME accounts can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_acme_dns_plugin.example test
`````

## File: examples/resources/proxmox_virtual_environment_acme_dns_plugin/resource.tf
`````hcl
resource "proxmox_virtual_environment_acme_dns_plugin" "example" {
  plugin = "test"
  api    = "aws"
  data = {
    AWS_ACCESS_KEY_ID     = "EXAMPLE"
    AWS_SECRET_ACCESS_KEY = "EXAMPLE"
  }
}
`````

## File: examples/resources/proxmox_virtual_environment_apt_repository/import.sh
`````bash
#!/usr/bin/env sh
# An APT repository can be imported using a comma-separated list consisting of the name of the Proxmox VE node,
# the absolute source list file path, and the index in the exact same order, e.g.:
terraform import proxmox_virtual_environment_apt_repository.example pve,/etc/apt/sources.list,0
`````

## File: examples/resources/proxmox_virtual_environment_apt_repository/resource.tf
`````hcl
resource "proxmox_virtual_environment_apt_repository" "example" {
  enabled   = true
  file_path = "/etc/apt/sources.list"
  index     = 0
  node      = "pve"
}
`````

## File: examples/resources/proxmox_virtual_environment_apt_standard_repository/import.sh
`````bash
#!/usr/bin/env sh
# An APT standard repository can be imported using a comma-separated list consisting of the name of the Proxmox VE node,
# and the standard repository handle in the exact same order, e.g.:
terraform import proxmox_virtual_environment_apt_standard_repository.example pve,no-subscription
`````

## File: examples/resources/proxmox_virtual_environment_apt_standard_repository/resource.tf
`````hcl
resource "proxmox_virtual_environment_apt_standard_repository" "example" {
  handle = "no-subscription"
  node   = "pve"
}

resource "proxmox_virtual_environment_apt_repository" "example" {
  enabled   = true
  file_path = proxmox_virtual_environment_apt_standard_repository.example.file_path
  index     = proxmox_virtual_environment_apt_standard_repository.example.index
  node      = proxmox_virtual_environment_apt_standard_repository.example.node
}
`````

## File: examples/resources/proxmox_virtual_environment_cluster_options/import.sh
`````bash
#!/usr/bin/env sh
# Cluster options are global and can be imported using e.g.:
terraform import proxmox_virtual_environment_cluster_options.options cluster
`````

## File: examples/resources/proxmox_virtual_environment_cluster_options/resource.tf
`````hcl
resource "proxmox_virtual_environment_cluster_options" "options" {
  language                  = "en"
  keyboard                  = "pl"
  email_from                = "ged@gont.earthsea"
  bandwidth_limit_migration = 555555
  bandwidth_limit_default   = 666666
  max_workers               = 5
  migration_cidr            = "10.0.0.0/8"
  migration_type            = "secure"
  next_id = {
    lower = 100
    upper = 999999999
  }
  notify = {
    ha_fencing_mode            = "never"
    ha_fencing_target          = "default-matcher"
    package_updates            = "always"
    package_updates_target     = "default-matcher"
    package_replication        = "always"
    package_replication_target = "default-matcher"
  }
}
`````

## File: examples/resources/proxmox_virtual_environment_download_file/resource.tf
`````hcl
resource "proxmox_virtual_environment_download_file" "release_20231228_debian_12_bookworm_qcow2_img" {
  content_type       = "iso"
  datastore_id       = "local"
  file_name          = "debian-12-generic-amd64-20231228-1609.img"
  node_name          = "pve"
  url                = "https://cloud.debian.org/images/cloud/bookworm/20231228-1609/debian-12-generic-amd64-20231228-1609.qcow2"
  checksum           = "d2fbcf11fb28795842e91364d8c7b69f1870db09ff299eb94e4fbbfa510eb78d141e74c1f4bf6dfa0b7e33d0c3b66e6751886feadb4e9916f778bab1776bdf1b"
  checksum_algorithm = "sha512"
}

resource "proxmox_virtual_environment_download_file" "latest_debian_12_bookworm_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  file_name    = "debian-12-generic-amd64.qcow2.img"
  node_name    = "pve"
  url          = "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2"
}

resource "proxmox_virtual_environment_download_file" "latest_ubuntu_22_jammy_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
}

resource "proxmox_virtual_environment_download_file" "latest_static_ubuntu_24_noble_qcow2_img" {
  content_type = "iso"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"
  overwrite    = false
}

resource "proxmox_virtual_environment_download_file" "release_20231211_ubuntu_22_jammy_lxc_img" {
  content_type       = "vztmpl"
  datastore_id       = "local"
  node_name          = "pve"
  url                = "https://cloud-images.ubuntu.com/releases/22.04/release-20231211/ubuntu-22.04-server-cloudimg-amd64-root.tar.xz"
  checksum           = "c9997dcfea5d826fd04871f960c513665f2e87dd7450bba99f68a97e60e4586e"
  checksum_algorithm = "sha256"
  upload_timeout     = 4444
}

resource "proxmox_virtual_environment_download_file" "latest_ubuntu_22_jammy_lxc_img" {
  content_type = "vztmpl"
  datastore_id = "local"
  node_name    = "pve"
  url          = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.tar.gz"
}
`````

## File: examples/resources/proxmox_virtual_environment_hagroup/import.sh
`````bash
#!/usr/bin/env sh
# HA groups can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hagroup.example example
`````

## File: examples/resources/proxmox_virtual_environment_hagroup/resource.tf
`````hcl
resource "proxmox_virtual_environment_hagroup" "example" {
  group   = "example"
  comment = "This is a comment."

  # Member nodes, with or without priority.
  nodes = {
    node1 = null
    node2 = 2
    node3 = 1
  }

  restricted  = true
  no_failback = false
}
`````

## File: examples/resources/proxmox_virtual_environment_hardware_mapping_dir/import.sh
`````bash
#!/usr/bin/env sh
# A directory mapping can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hardware_mapping_dir.example example
`````

## File: examples/resources/proxmox_virtual_environment_hardware_mapping_dir/resource.tf
`````hcl
resource "proxmox_virtual_environment_hardware_mapping_dir" "example" {
  comment = "This is a comment"
  name    = "example"
  # The actual map of devices.
  map = [
    {
      node = "pve"
      path = "/mnt/data"
    },
  ]
}
`````

## File: examples/resources/proxmox_virtual_environment_hardware_mapping_pci/import.sh
`````bash
#!/usr/bin/env sh
# A PCI hardware mapping can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hardware_mapping_pci.example example
`````

## File: examples/resources/proxmox_virtual_environment_hardware_mapping_pci/resource.tf
`````hcl
resource "proxmox_virtual_environment_hardware_mapping_pci" "example" {
  comment = "This is a comment"
  name    = "example"
  # The actual map of devices.
  map = [
    {
      comment = "This is a device specific comment"
      id      = "8086:5916"
      # This is an optional attribute, but causes a mapping to be incomplete when not defined.
      iommu_group = 0
      node        = "pve"
      path        = "0000:00:02.0"
      # This is an optional attribute, but causes a mapping to be incomplete when not defined.
      subsystem_id = "8086:2068"
    },
  ]
  mediated_devices = true
}
`````

## File: examples/resources/proxmox_virtual_environment_hardware_mapping_usb/import.sh
`````bash
#!/usr/bin/env sh
# A USB hardware mapping can be imported using their name, e.g.:
terraform import proxmox_virtual_environment_hardware_mapping_usb.example example
`````

## File: examples/resources/proxmox_virtual_environment_hardware_mapping_usb/resource.tf
`````hcl
resource "proxmox_virtual_environment_hardware_mapping_usb" "example" {
  comment = "This is a comment"
  name    = "example"
  # The actual map of devices.
  map = [
    {
      comment = "This is a device specific comment"
      id      = "8087:0a2b"
      node    = "pve"
      # This attribute is optional, but can be used to map the device based on its port instead of only the device ID.
      path = "1-8.2"
    },
  ]
}
`````

## File: examples/resources/proxmox_virtual_environment_haresource/import.sh
`````bash
#!/usr/bin/env sh
# HA resources can be imported using their identifiers, e.g.:
terraform import proxmox_virtual_environment_haresource.example vm:123
`````

## File: examples/resources/proxmox_virtual_environment_haresource/resource.tf
`````hcl
resource "proxmox_virtual_environment_haresource" "example" {
  depends_on = [
    proxmox_virtual_environment_hagroup.example
  ]
  resource_id = "vm:123"
  state       = "started"
  group       = "example"
  comment     = "Managed by Terraform"
}
`````

## File: examples/resources/proxmox_virtual_environment_metrics_server/import.sh
`````bash
#!/usr/bin/env sh
terraform import proxmox_virtual_environment_metrics_server.example example
`````

## File: examples/resources/proxmox_virtual_environment_metrics_server/resource.tf
`````hcl
resource "proxmox_virtual_environment_metrics_server" "influxdb_server" {
  name   = "example_influxdb_server"
  server = "192.168.3.2"
  port   = 8089
  type   = "influxdb"
}

resource "proxmox_virtual_environment_metrics_server" "graphite_server" {
  name   = "example_graphite_server"
  server = "192.168.4.2"
  port   = 2003
  type   = "graphite"
}
`````

## File: examples/resources/proxmox_virtual_environment_network_linux_bridge/import.sh
`````bash
#!/usr/bin/env sh
#Interfaces can be imported using the `node_name:iface` format, e.g.
terraform import proxmox_virtual_environment_network_linux_bridge.vmbr99 pve:vmbr99
`````

## File: examples/resources/proxmox_virtual_environment_network_linux_bridge/resource.tf
`````hcl
resource "proxmox_virtual_environment_network_linux_bridge" "vmbr99" {
  depends_on = [
    proxmox_virtual_environment_network_linux_vlan.vlan99
  ]

  node_name = "pve"
  name      = "vmbr99"

  address = "99.99.99.99/16"

  comment = "vmbr99 comment"

  ports = [
    # Network (or VLAN) interfaces to attach to the bridge, specified by their interface name
    # (e.g. "ens18.99" for VLAN 99 on interface ens18).
    # For VLAN interfaces with custom names, use the interface name without the VLAN tag, e.g. "vlan_lab"
    "ens18.99"
  ]
}

resource "proxmox_virtual_environment_network_linux_vlan" "vlan99" {
  node_name = "pve"
  name      = "ens18.99"

  ## or alternatively, use custom name:
  # name      = "vlan_lab"
  # interface = "eno0"
  # vlan      = 98
}
`````

## File: examples/resources/proxmox_virtual_environment_network_linux_vlan/import.sh
`````bash
#!/usr/bin/env sh
#Interfaces can be imported using the `node_name:iface` format, e.g.
terraform import proxmox_virtual_environment_network_linux_vlan.vlan99 pve:vlan99
`````

## File: examples/resources/proxmox_virtual_environment_network_linux_vlan/resource.tf
`````hcl
# using VLAN tag
resource "proxmox_virtual_environment_network_linux_vlan" "vlan99" {
  node_name = "pve"
  name      = "eno0.99"

  comment = "VLAN 99"
}

# using custom network interface name
resource "proxmox_virtual_environment_network_linux_vlan" "vlan98" {
  node_name = "pve"
  name      = "vlan_lab"

  interface = "eno0"
  vlan      = 98
  comment   = "VLAN 98"
}
`````

## File: examples/resources/proxmox_virtual_environment_user_token/import.sh
`````bash
#!/usr/bin/env sh
#Tokens can be imported using they identifiers in format `user_id!token_name` format, e.g.:
terraform import proxmox_virtual_environment_user_token.token1 user@pve!token1
`````

## File: examples/resources/proxmox_virtual_environment_user_token/resource.tf
`````hcl
# if creating a user token, the user must be created first
resource "proxmox_virtual_environment_user" "user" {
  comment         = "Managed by Terraform"
  email           = "user@pve"
  enabled         = true
  expiration_date = "2034-01-01T22:00:00Z"
  user_id         = "user@pve"
}

resource "proxmox_virtual_environment_user_token" "user_token" {
  comment         = "Managed by Terraform"
  expiration_date = "2033-01-01T22:00:00Z"
  token_name      = "tk1"
  user_id         = proxmox_virtual_environment_user.user.user_id
}
`````

## File: examples/README.md
`````markdown
`/examples` contain a set of examples that can be used to test the provider as
well as documentation examples. The examples are not meant to be used in
production.

NOTE: during migration to the TF plugin framework, examples of migrated resources /
data sources will be moving from `/example` to `/examples` folder
`````

## File: fwprovider/access/resource_acl_model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/types"

	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
)

type aclResourceModel struct {
	ID types.String `tfsdk:"id"`

	GroupID   types.String `tfsdk:"group_id"`
	Path      string       `tfsdk:"path"`
	Propagate bool         `tfsdk:"propagate"`
	RoleID    string       `tfsdk:"role_id"`
	TokenID   types.String `tfsdk:"token_id"`
	UserID    types.String `tfsdk:"user_id"`
}

const aclIDFormat = "{path}?{group|user@realm|user@realm!token}?{role}"

func (r *aclResourceModel) generateID() types.String {
	entityID := r.GroupID.ValueString() + r.TokenID.ValueString() + r.UserID.ValueString()

	return types.StringValue(r.Path + "?" + entityID + "?" + r.RoleID)
}

func parseACLResourceModelFromID(id string) (*aclResourceModel, error) {
	parts := strings.Split(id, "?")
	if len(parts) != 3 {
		return nil, fmt.Errorf("invalid ACL resource ID format %#v, expected %v", id, aclIDFormat)
	}

	path := parts[0]
	entityID := parts[1]
	roleID := parts[2]

	model := &aclResourceModel{
		ID:        types.StringValue(id),
		GroupID:   types.StringNull(),
		Path:      path,
		Propagate: false,
		RoleID:    roleID,
		TokenID:   types.StringNull(),
		UserID:    types.StringNull(),
	}

	switch {
	case strings.Contains(entityID, "!"):
		model.TokenID = types.StringValue(entityID)
	case strings.Contains(entityID, "@"):
		model.UserID = types.StringValue(entityID)
	default:
		model.GroupID = types.StringValue(entityID)
	}

	return model, nil
}

func (r *aclResourceModel) intoUpdateBody() *access.ACLUpdateRequestBody {
	body := &access.ACLUpdateRequestBody{
		Groups:    nil,
		Path:      r.Path,
		Propagate: proxmoxtypes.CustomBool(r.Propagate).Pointer(),
		Roles:     []string{r.RoleID},
		Tokens:    nil,
		Users:     nil,
	}

	if !r.GroupID.IsNull() {
		body.Groups = []string{r.GroupID.ValueString()}
	}

	if !r.TokenID.IsNull() {
		body.Tokens = []string{r.TokenID.ValueString()}
	}

	if !r.UserID.IsNull() {
		body.Users = []string{r.UserID.ValueString()}
	}

	return body
}
`````

## File: fwprovider/access/resource_acl_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access_test

import (
	"context"
	"fmt"
	"regexp"
	"testing"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
)

func TestAccAcl_User(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	userID := fmt.Sprintf("%s@pve", gofakeit.Username())
	te.AddTemplateVars(map[string]any{
		"UserID": userID,
	})

	resource.Test(t, resource.TestCase{
		ProtoV6ProviderFactories: te.AccProviders,
		CheckDestroy:             nil,
		PreCheck: func() {
			err := te.AccessClient().CreateUser(context.Background(), &access.UserCreateRequestBody{
				ID:       userID,
				Password: gofakeit.Password(true, true, true, true, false, 8),
			})
			require.NoError(t, err)

			t.Cleanup(func() {
				err := te.AccessClient().DeleteUser(context.Background(), userID)
				require.NoError(t, err)
			})
		},
		Steps: []resource.TestStep{
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_acl" "test" {
					user_id = "{{.UserID}}"
					path = "/"
					role_id = "NoAccess"
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_acl.test", map[string]string{
						"path":      "/",
						"role_id":   "NoAccess",
						"user_id":   userID,
						"propagate": "true",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_acl.test", []string{
						"group_id",
						"token_id",
					}),
				),
			},
			{
				ResourceName:      "proxmox_virtual_environment_acl.test",
				ImportState:       true,
				ImportStateIdFunc: testAccACLImportStateIDFunc(),
				ImportStateVerify: true,
			},
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_acl" "test" {
					user_id = "{{.UserID}}"
					path = "/"
					role_id = "PVEPoolUser"
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_acl.test", map[string]string{
						"path":      "/",
						"role_id":   "PVEPoolUser",
						"user_id":   userID,
						"propagate": "true",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_acl.test", []string{
						"group_id",
						"token_id",
					}),
				),
			},
		},
	})
}

func TestAccAcl_Validators(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	resource.UnitTest(t, resource.TestCase{
		ProtoV6ProviderFactories: te.AccProviders,
		CheckDestroy:             nil,
		Steps: []resource.TestStep{
			{
				PlanOnly: true,
				Config: `resource "proxmox_virtual_environment_acl" "test" {
					group_id = "test"
					path = "/"
					role_id = "test"
					token_id = "test"
				}`,
				ExpectError: regexp.MustCompile(`.*Error: Invalid Attribute Combination`),
			},
			{
				PlanOnly: true,
				Config: `resource "proxmox_virtual_environment_acl" "test" {
					path = "/"
					role_id = "test"
					token_id = "test"
					user_id = "test"
				}`,
				ExpectError: regexp.MustCompile(`.*Error: Invalid Attribute Combination`),
			},
			{
				PlanOnly: true,
				Config: `resource "proxmox_virtual_environment_acl" "test" {
					group_id = "test"
					path = "/"
					role_id = "test"
					user_id = "test"
				}`,
				ExpectError: regexp.MustCompile(`.*Error: Invalid Attribute Combination`),
			},
			{
				PlanOnly: true,
				Config: `resource "proxmox_virtual_environment_acl" "test" {
					group_id = "test"
					path = "/"
					role_id = "test"
					token_id = "test"
					user_id = "test"
				}`,
				ExpectError: regexp.MustCompile(`.*Error: Invalid Attribute Combination`),
			},
		},
	})
}

func testAccACLImportStateIDFunc() resource.ImportStateIdFunc {
	return func(s *terraform.State) (string, error) {
		resourceName := "proxmox_virtual_environment_acl.test"

		rs, ok := s.RootModule().Resources[resourceName]
		if !ok {
			return "", fmt.Errorf("not found: %s", resourceName)
		}

		path := rs.Primary.Attributes["path"]

		groupID := rs.Primary.Attributes["group_id"]
		tokenID := rs.Primary.Attributes["token_id"]
		userID := rs.Primary.Attributes["user_id"]
		entityID := groupID + tokenID + userID

		roleID := rs.Primary.Attributes["role_id"]

		return path + "?" + entityID + "?" + roleID, nil
	}
}
`````

## File: fwprovider/access/resource_acl.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/resourcevalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	_ resource.Resource                     = (*aclResource)(nil)
	_ resource.ResourceWithConfigure        = (*aclResource)(nil)
	_ resource.ResourceWithImportState      = (*aclResource)(nil)
	_ resource.ResourceWithConfigValidators = (*aclResource)(nil)
)

type aclResource struct {
	client proxmox.Client
}

// NewACLResource creates a new ACL resource.
func NewACLResource() resource.Resource {
	return &aclResource{}
}

func (r *aclResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages ACLs on the Proxmox cluster",
		MarkdownDescription: "Manages ACLs on the Proxmox cluster.\n\n" +
			"ACLs are used to control access to resources in the Proxmox cluster.\n" +
			"Each ACL consists of a path, a user, group or token, a role, and a flag to allow propagation of permissions.",
		Attributes: map[string]schema.Attribute{
			"group_id": schema.StringAttribute{
				Description: "The group the ACL should apply to (mutually exclusive with `token_id` and `user_id`)",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": attribute.ResourceID(),
			"path": schema.StringAttribute{
				Description: "Access control path",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"propagate": schema.BoolAttribute{
				Description: "Allow to propagate (inherit) permissions.",
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(true),
			},
			"role_id": schema.StringAttribute{
				Description: "The role to apply",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"token_id": schema.StringAttribute{
				Description: "The token the ACL should apply to (mutually exclusive with `group_id` and `user_id`)",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"user_id": schema.StringAttribute{
				Description: "The user the ACL should apply to (mutually exclusive with `group_id` and `token_id`)",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (r *aclResource) ConfigValidators(_ context.Context) []resource.ConfigValidator {
	return []resource.ConfigValidator{
		resourcevalidator.Conflicting(
			path.MatchRoot("group_id"),
			path.MatchRoot("token_id"),
			path.MatchRoot("user_id"),
		),
	}
}

func (r *aclResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

func (r *aclResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_acl"
}

func (r *aclResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan aclResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.intoUpdateBody()

	err := r.client.Access().UpdateACL(ctx, body)
	if err != nil {
		resp.Diagnostics.AddError("Unable to create ACL", apiCallFailed+err.Error())
		return
	}

	plan.ID = plan.generateID()

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

func (r *aclResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state aclResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	acls, err := r.client.Access().GetACL(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Unable read ACL", apiCallFailed+err.Error())
		return
	}

	for _, acl := range acls {
		switch acl.Type {
		case "group":
			if acl.UserOrGroupID != state.GroupID.ValueString() {
				continue
			}
		case "token":
			if acl.UserOrGroupID != state.TokenID.ValueString() {
				continue
			}
		case "user":
			if acl.UserOrGroupID != state.UserID.ValueString() {
				continue
			}
		default:
			// ignore unknown values
			continue
		}

		if acl.Path != state.Path {
			continue
		}

		if acl.RoleID != state.RoleID {
			continue
		}

		state.Propagate = ptr.Or(acl.Propagate.PointerBool(), true)

		resp.Diagnostics.Append(resp.State.Set(ctx, state)...)

		return
	}

	resp.State.RemoveResource(ctx)
}

func (r *aclResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var (
		state aclResourceModel
		plan  aclResourceModel
	)

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	stateBody := state.intoUpdateBody()
	stateBody.Delete = proxmoxtypes.CustomBool(true).Pointer()

	err := r.client.Access().UpdateACL(ctx, stateBody)
	if err != nil {
		resp.Diagnostics.AddError("Unable to delete old ACL", apiCallFailed+err.Error())
		return
	}

	planBody := plan.intoUpdateBody()

	err = r.client.Access().UpdateACL(ctx, planBody)
	if err != nil {
		resp.Diagnostics.AddError("Unable to create ACL", apiCallFailed+err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

func (r *aclResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state aclResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	stateBody := state.intoUpdateBody()
	stateBody.Delete = proxmoxtypes.CustomBool(true).Pointer()

	err := r.client.Access().UpdateACL(ctx, stateBody)
	if err != nil {
		resp.Diagnostics.AddError("Unable to delete old ACL", apiCallFailed+err.Error())
		return
	}
}

func (r *aclResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	model, err := parseACLResourceModelFromID(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Unable to import ACL", "failed to parse ID: "+err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, model)...)
}

const apiCallFailed = "API call failed: "
`````

## File: fwprovider/access/resource_user_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access_test

import (
	"context"
	"fmt"
	"testing"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
)

func TestAccResourceUser(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	userID := fmt.Sprintf("%s@pve", gofakeit.Username())
	te.AddTemplateVars(map[string]any{
		"UserID": userID,
	})

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create and update user", []resource.TestStep{
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_user" "user" {
					  comment  			= "Managed by Terraform"
					  email 			= "{{.UserID}}"
					  enabled 			= true
					  expiration_date 	= "2034-01-01T22:00:00Z"
					  first_name 		= "First"
					  last_name 		= "Last"
					  user_id  			= "{{.UserID}}"
				}`),
				Check: test.ResourceAttributes("proxmox_virtual_environment_user.user", map[string]string{
					"comment":         "Managed by Terraform",
					"email":           userID,
					"enabled":         "true",
					"expiration_date": "2034-01-01T22:00:00Z",
					"first_name":      "First",
					"last_name":       "Last",
					"user_id":         userID,
				}),
			},
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_user" "user" {
					  enabled 			= false
					  expiration_date 	= "2035-01-01T22:00:00Z"
					  user_id  			= "{{.UserID}}"
					  first_name 		= "First One"
				}`),
				Check: test.ResourceAttributes("proxmox_virtual_environment_user.user", map[string]string{
					"enabled":         "false",
					"expiration_date": "2035-01-01T22:00:00Z",
					"first_name":      "First One",
					"user_id":         userID,
				}),
			},
			{
				ResourceName:      "proxmox_virtual_environment_user.user",
				ImportState:       true,
				ImportStateVerify: true,
			},
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}

func TestAccResourceUserToken(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)
	userID := fmt.Sprintf("%s@pve", gofakeit.Username())
	tokenName := gofakeit.Word()

	te.AddTemplateVars(map[string]any{
		"UserID":    userID,
		"TokenName": tokenName,
	})

	tests := []struct {
		name     string
		preCheck func()
		steps    []resource.TestStep
	}{
		{
			"create and update user token",
			func() {
				err := te.AccessClient().CreateUser(context.Background(), &access.UserCreateRequestBody{
					ID:       userID,
					Password: gofakeit.Password(true, true, true, true, false, 8),
				})
				require.NoError(t, err)

				t.Cleanup(func() {
					err = te.AccessClient().DeleteUser(context.Background(), userID)
					require.NoError(t, err)
				})
			},
			[]resource.TestStep{
				{
					Config: te.RenderConfig(`resource "proxmox_virtual_environment_user_token" "user_token" {
						comment  			= "Managed by Terraform"
						token_name 			= "{{.TokenName}}"
						user_id  			= "{{.UserID}}"
					}`),
					Check: test.ResourceAttributes("proxmox_virtual_environment_user_token.user_token", map[string]string{
						"comment": "Managed by Terraform",
						"id":      fmt.Sprintf("%s!%s", userID, tokenName),
						"user_id": userID,
						"value":   fmt.Sprintf("%s!%s=.*", userID, tokenName),
					}),
				},
				{
					Config: te.RenderConfig(`resource "proxmox_virtual_environment_user_token" "user_token" {
						comment  			  = "Managed by Terraform 2"
						expiration_date 	  = "2033-01-01T01:01:01Z"
						privileges_separation = false
						token_name 			  = "{{.TokenName}}"
						user_id  			  = "{{.UserID}}"
					}`),
					Check: resource.ComposeTestCheckFunc(
						test.ResourceAttributes("proxmox_virtual_environment_user_token.user_token", map[string]string{
							"comment":               "Managed by Terraform 2",
							"expiration_date":       "2033-01-01T01:01:01Z",
							"privileges_separation": "false",
							"token_name":            tokenName,
							"user_id":               userID,
							"value":                 fmt.Sprintf("%s!%s=.*", userID, tokenName),
						}),
					),
				},
				{
					Config: te.RenderConfig(`resource "proxmox_virtual_environment_user_token" "user_token" {
						comment  			  = "Managed by Terraform 2"
						privileges_separation = false
						token_name 			  = "{{.TokenName}}"
						user_id  			  = "{{.UserID}}"
					}`),
					Check: resource.ComposeTestCheckFunc(
						test.ResourceAttributes("proxmox_virtual_environment_user_token.user_token", map[string]string{
							"comment":               "Managed by Terraform 2",
							"privileges_separation": "false",
							"token_name":            tokenName,
							"user_id":               userID,
							"value":                 fmt.Sprintf("%s!%s=.*", userID, tokenName),
						}),
						test.NoResourceAttributesSet("proxmox_virtual_environment_user_token.user_token", []string{
							"expiration_date",
						}),
					),
				},
				{
					ResourceName:      "proxmox_virtual_environment_user_token.user_token",
					ImportState:       true,
					ImportStateVerify: true,
					ImportStateVerifyIgnore: []string{
						"value",
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				PreCheck:                 tt.preCheck,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/access/resource_user_token.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	_ resource.Resource                = &userTokenResource{}
	_ resource.ResourceWithConfigure   = &userTokenResource{}
	_ resource.ResourceWithImportState = &userTokenResource{}
)

type userTokenResource struct {
	client proxmox.Client
}

type userTokenModel struct {
	Comment        types.String `tfsdk:"comment"`
	ExpirationDate types.String `tfsdk:"expiration_date"`
	ID             types.String `tfsdk:"id"`
	PrivSeparation types.Bool   `tfsdk:"privileges_separation"`
	UserID         types.String `tfsdk:"user_id"`
	TokenName      types.String `tfsdk:"token_name"`
	Value          types.String `tfsdk:"value"`
}

// NewUserTokenResource creates a new user token resource.
func NewUserTokenResource() resource.Resource {
	return &userTokenResource{}
}

func (r *userTokenResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "User API tokens.",
		Attributes: map[string]schema.Attribute{
			"comment": schema.StringAttribute{
				Description: "Comment for the token.",
				Optional:    true,
			},
			"expiration_date": schema.StringAttribute{
				Description: "Expiration date for the token.",
				Optional:    true,
				Validators: []validator.String{
					validators.NewParseValidator(func(s string) (time.Time, error) {
						return time.Parse(time.RFC3339, s)
					}, "must be a valid RFC3339 date"),
				},
			},
			"id": attribute.ResourceID("Unique token identifier with format `<user_id>!<token_name>`."),
			"privileges_separation": schema.BoolAttribute{
				Description: "Restrict API token privileges with separate ACLs (default)",
				MarkdownDescription: "Restrict API token privileges with separate ACLs (default), " +
					"or give full privileges of corresponding user.",
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(true),
			},
			"token_name": schema.StringAttribute{
				Description: "User-specific token identifier.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile(`[A-Za-z][A-Za-z0-9.\-_]+`), "must be a valid token identifier"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"user_id": schema.StringAttribute{
				Description: "User identifier.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"value": schema.StringAttribute{
				Description: "API token value used for authentication.",
				MarkdownDescription: "API token value used for authentication. It is populated only when creating a new token, " +
					"and can't be retrieved at import.",
				Computed:  true,
				Sensitive: true,
				PlanModifiers: []planmodifier.String{
					// the attribute can't be retrieved after token creation, so during update we have to use value
					// from state (i.e. populated at create) if available.
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (r *userTokenResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client

	r.client = cfg.Client
}

func (r *userTokenResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_user_token"
}

func (r *userTokenResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan userTokenModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	body := access.UserTokenCreateRequestBody{
		Comment:      plan.Comment.ValueStringPointer(),
		PrivSeparate: proxmoxtypes.CustomBoolPtr(plan.PrivSeparation.ValueBoolPointer()),
	}

	if !plan.ExpirationDate.IsNull() && plan.ExpirationDate.ValueString() != "" {
		expirationDate, err := time.Parse(
			time.RFC3339,
			plan.ExpirationDate.ValueString(),
		)
		if err != nil {
			resp.Diagnostics.AddError("Error parsing expiration date", err.Error())
			return
		}

		v := expirationDate.Unix()
		body.ExpirationDate = &v
	}

	value, err := r.client.Access().CreateUserToken(ctx, plan.UserID.ValueString(), plan.TokenName.ValueString(), &body)
	if err != nil {
		resp.Diagnostics.AddError("Error creating user token", err.Error())
	}

	if resp.Diagnostics.HasError() {
		return
	}

	plan.ID = types.StringValue(plan.UserID.ValueString() + "!" + plan.TokenName.ValueString())
	plan.Value = types.StringValue(value)
	resp.State.Set(ctx, plan)
}

func (r *userTokenResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state userTokenModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	data, err := r.client.Access().GetUserToken(ctx, state.UserID.ValueString(), state.TokenName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error reading user token", err.Error())
		return
	}

	state.Comment = types.StringPointerValue(data.Comment)

	if data.ExpirationDate != nil && *data.ExpirationDate > 0 {
		dt := time.Unix(int64(*data.ExpirationDate), 0).UTC().Format(time.RFC3339)
		state.ExpirationDate = types.StringValue(dt)
	}

	state.PrivSeparation = types.BoolPointerValue(data.PrivSeparate.PointerBool())

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

func (r *userTokenResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state userTokenModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := access.UserTokenUpdateRequestBody{
		// note: PVE API does not support resetting comment to empty string
		Comment:      plan.Comment.ValueStringPointer(),
		PrivSeparate: proxmoxtypes.CustomBoolPtr(plan.PrivSeparation.ValueBoolPointer()),
	}

	if !plan.ExpirationDate.IsNull() && plan.ExpirationDate.ValueString() != "" {
		// if planned value is not empty then set it
		expirationDate, err := time.Parse(
			time.RFC3339,
			plan.ExpirationDate.ValueString(),
		)
		if err != nil {
			resp.Diagnostics.AddError("Error parsing expiration date", err.Error())
			return
		}

		v := expirationDate.Unix()
		body.ExpirationDate = &v
	} else if !state.ExpirationDate.IsNull() {
		// if planned value is empty, but the current value is not then reset it
		body.ExpirationDate = new(int64)
	}

	err := r.client.Access().UpdateUserToken(ctx, plan.UserID.ValueString(), plan.TokenName.ValueString(), &body)
	if err != nil {
		resp.Diagnostics.AddError("Error creating user token", err.Error())
	}

	if resp.Diagnostics.HasError() {
		return
	}

	resp.State.Set(ctx, plan)
}

func (r *userTokenResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state userTokenModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.Access().DeleteUserToken(ctx, state.UserID.ValueString(), state.TokenName.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error deleting user token", err.Error())
		return
	}

	resp.State.RemoveResource(ctx)
}

func (r *userTokenResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	idParts := strings.Split(req.ID, "!")
	if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: 'user_id!token_name'. Got: %q", req.ID),
		)

		return
	}

	userID := idParts[0]
	tokenName := idParts[1]

	data, err := r.client.Access().GetUserToken(ctx, userID, tokenName)
	if err != nil {
		resp.Diagnostics.AddError("Error reading user token", err.Error())
		return
	}

	state := userTokenModel{
		Comment:        types.StringPointerValue(data.Comment),
		ID:             types.StringValue(req.ID),
		PrivSeparation: types.BoolPointerValue(data.PrivSeparate.PointerBool()),
		UserID:         types.StringValue(userID),
		TokenName:      types.StringValue(tokenName),
		Value:          types.StringNull(),
	}

	if data.ExpirationDate != nil && *data.ExpirationDate > 0 {
		state.ExpirationDate = types.StringValue(time.Unix(int64(*data.ExpirationDate), 0).UTC().Format(time.RFC3339))
	}

	diags := resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}
`````

## File: fwprovider/attribute/attribute.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package attribute

import (
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
)

// ResourceID generates an attribute definition suitable for the always-present resource `id` attribute.
func ResourceID(desc ...string) schema.StringAttribute {
	a := schema.StringAttribute{
		Computed:    true,
		Description: "The unique identifier of this resource.",
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	if len(desc) > 0 {
		a.Description = desc[0]
	}

	return a
}

// ShouldBeRemoved evaluates if an attribute should be removed from the plan during update.
func ShouldBeRemoved(plan attr.Value, state attr.Value, isClone bool) bool {
	return !IsDefined(plan) && IsDefined(state) && !isClone
}

// IsDefined returns true if attribute is known and not null.
func IsDefined(v attr.Value) bool {
	return !v.IsNull() && !v.IsUnknown()
}
`````

## File: fwprovider/cluster/acme/datasource_acme_account.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/account"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &acmeAccountDatasource{}
	_ datasource.DataSourceWithConfigure = &acmeAccountDatasource{}
)

// NewACMEAccountDataSource is a helper function to simplify the provider implementation.
func NewACMEAccountDataSource() datasource.DataSource {
	return &acmeAccountDatasource{}
}

// acmeAccountDatasource is the data source implementation for ACME accounts.
type acmeAccountDatasource struct {
	client *account.Client
}

type accountDataModel struct {
	Contact   []types.String `tfsdk:"contact"`
	CreatedAt types.String   `tfsdk:"created_at"`
	Status    types.String   `tfsdk:"status"`
}

func (m *accountDataModel) attrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"contact":    types.ListType{ElemType: types.StringType},
		"created_at": types.StringType,
		"status":     types.StringType,
	}
}

// accountModel is the model used to represent an ACME account.
type accountModel struct {
	// Name is the ACME account config file name.
	Name types.String `tfsdk:"name"`
	// Account is the ACME account information.
	Account types.Object `tfsdk:"account"`
	// Directory is the URL of the ACME CA directory endpoint.
	Directory types.String `tfsdk:"directory"`
	// Location is the location of the ACME account.
	Location types.String `tfsdk:"location"`
	// URL of CA TermsOfService - setting this indicates agreement.
	TOS types.String `tfsdk:"tos"`
}

// Metadata returns the data source type name.
func (d *acmeAccountDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_acme_account"
}

// Schema returns the schema for the data source.
func (d *acmeAccountDatasource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves information about a specific ACME account.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Description: "The identifier of the ACME account to read.",
				Optional:    true,
			},
			"account": schema.SingleNestedAttribute{
				Description: "The ACME account information.",
				Computed:    true,
				Attributes: map[string]schema.Attribute{
					"contact": schema.ListAttribute{
						Description: "An array of contact email addresses.",
						ElementType: types.StringType,
						Computed:    true,
					},
					"created_at": schema.StringAttribute{
						Description: "The timestamp of the account creation.",
						Computed:    true,
					},
					"status": schema.StringAttribute{
						Description:         "The status of the account.",
						MarkdownDescription: "The status of the account. Can be one of `valid`, `deactivated` or `revoked`.",
						Computed:            true,
					},
				},
			},
			"directory": schema.StringAttribute{
				Description: "The directory URL of the ACME account.",
				Computed:    true,
			},
			"location": schema.StringAttribute{
				Description: "The location URL of the ACME account.",
				Computed:    true,
			},
			"tos": schema.StringAttribute{
				Description: "The URL of the terms of service of the ACME account.",
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *acmeAccountDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().ACME().Account()
}

// Read retrieves the ACME account information.
func (d *acmeAccountDatasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state accountModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	name := state.Name.ValueString()

	accountData, err := d.client.Get(ctx, name)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to read ACME account '%s'", name),
			err.Error(),
		)

		return
	}

	contactList := make([]types.String, len(accountData.Account.Contact))
	for i, contact := range accountData.Account.Contact {
		contactList[i] = types.StringValue(contact)
	}

	data := &accountDataModel{
		Contact:   contactList,
		CreatedAt: types.StringValue(accountData.Account.CreatedAt),
		Status:    types.StringValue(accountData.Account.Status),
	}

	accountObject, diags := types.ObjectValueFrom(ctx, data.attrTypes(), data)
	resp.Diagnostics.Append(diags...)

	state.Account = accountObject

	state.Directory = types.StringValue(accountData.Directory)
	state.Location = types.StringValue(accountData.Location)
	state.TOS = types.StringValue(accountData.TOS)

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
`````

## File: fwprovider/cluster/acme/datasource_acme_accounts.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/account"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &acmeAccountsDatasource{}
	_ datasource.DataSourceWithConfigure = &acmeAccountsDatasource{}
)

// NewACMEAccountsDataSource is a helper function to simplify the provider implementation.
func NewACMEAccountsDataSource() datasource.DataSource {
	return &acmeAccountsDatasource{}
}

// acmeAccountsDatasource is the data source implementation for ACME accounts.
type acmeAccountsDatasource struct {
	client *account.Client
}

// acmeAccountsModel maps the schema data for the ACME accounts data source.
type acmeAccountsModel struct {
	Accounts types.Set `tfsdk:"accounts"`
}

// Metadata returns the data source type name.
func (d *acmeAccountsDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_acme_accounts"
}

// Schema returns the schema for the data source.
func (d *acmeAccountsDatasource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves the list of ACME accounts.",
		Attributes: map[string]schema.Attribute{
			"accounts": schema.SetAttribute{
				Description: "The identifiers of the ACME accounts.",
				ElementType: types.StringType,
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *acmeAccountsDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().ACME().Account()
}

// Read fetches the list of ACME Accounts from the Proxmox cluster then converts it to a list of strings.
func (d *acmeAccountsDatasource) Read(ctx context.Context, _ datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state acmeAccountsModel

	list, err := d.client.List(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read ACME accounts",
			err.Error(),
		)

		return
	}

	accounts := make([]attr.Value, len(list))
	for i, v := range list {
		accounts[i] = types.StringValue(v.Name)
	}

	accountsValue, diags := types.SetValue(types.StringType, accounts)
	resp.Diagnostics.Append(diags...)

	state.Accounts = accountsValue

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
`````

## File: fwprovider/cluster/acme/datasource_acme_plugin.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/plugins"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &acmePluginDatasource{}
	_ datasource.DataSourceWithConfigure = &acmePluginDatasource{}
)

// NewACMEPluginDataSource is a helper function to simplify the provider implementation.
func NewACMEPluginDataSource() datasource.DataSource {
	return &acmePluginDatasource{}
}

// acmePluginDatasource is the data source implementation for ACME plugin.
type acmePluginDatasource struct {
	client *plugins.Client
}

// Metadata returns the data source type name.
func (d *acmePluginDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_acme_plugin"
}

// Schema returns the schema for the data source.
func (d *acmePluginDatasource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves a single ACME plugin by plugin ID name.",
		Attributes: map[string]schema.Attribute{
			"api": schema.StringAttribute{
				Description: "API plugin name.",
				Computed:    true,
			},
			"data": schema.MapAttribute{
				Description: "DNS plugin data.",
				Computed:    true,
				ElementType: types.StringType,
			},
			"digest": schema.StringAttribute{
				Description: "Prevent changes if current configuration file has a different digest. " +
					"This can be used to prevent concurrent modifications.",
				Computed: true,
			},
			"plugin": schema.StringAttribute{
				Description: "ACME Plugin ID name.",
				Required:    true,
			},
			"type": schema.StringAttribute{
				Description: "ACME challenge type (dns, standalone).",
				Computed:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("dns", "standalone"),
				},
			},
			"validation_delay": schema.Int64Attribute{
				Description: "Extra delay in seconds to wait before requesting validation. " +
					"Allows to cope with a long TTL of DNS records (0 - 172800).",
				Computed: true,
				Validators: []validator.Int64{
					int64validator.Between(0, 172800),
				},
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *acmePluginDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().ACME().Plugins()
}

// Read fetches the ACME plugin from the Proxmox cluster.
func (d *acmePluginDatasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state acmePluginModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := state.Plugin.ValueString()

	plugin, err := d.client.Get(ctx, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read ACME plugin",
			err.Error(),
		)

		return
	}

	state.API = types.StringValue(plugin.API)

	mapValue, diags := types.MapValueFrom(ctx, types.StringType, plugin.Data)
	resp.Diagnostics.Append(diags...)

	state.Data = mapValue
	state.Digest = types.StringValue(plugin.Digest)
	state.Plugin = types.StringValue(plugin.Plugin)
	state.Type = types.StringValue(plugin.Type)
	state.ValidationDelay = types.Int64Value(plugin.ValidationDelay)

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
`````

## File: fwprovider/cluster/acme/datasource_acme_plugins.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/plugins"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &acmePluginsDatasource{}
	_ datasource.DataSourceWithConfigure = &acmePluginsDatasource{}
)

// NewACMEPluginsDataSource is a helper function to simplify the provider implementation.
func NewACMEPluginsDataSource() datasource.DataSource {
	return &acmePluginsDatasource{}
}

// acmePluginsDatasource is the data source implementation for ACME plugins.
type acmePluginsDatasource struct {
	client *plugins.Client
}

// Metadata returns the data source type name.
func (d *acmePluginsDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_acme_plugins"
}

// Schema returns the schema for the data source.
func (d *acmePluginsDatasource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves the list of ACME plugins.",
		Attributes: map[string]schema.Attribute{
			"plugins": schema.ListNestedAttribute{
				Description: "List of ACME plugins",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api": schema.StringAttribute{
							Description: "API plugin name.",
							Computed:    true,
						},
						"data": schema.MapAttribute{
							Description: "DNS plugin data.",
							Computed:    true,
							ElementType: types.StringType,
						},
						"digest": schema.StringAttribute{
							Description: "Prevent changes if current configuration file has a different digest. " +
								"This can be used to prevent concurrent modifications.",
							Computed: true,
						},
						"plugin": schema.StringAttribute{
							Description: "ACME Plugin ID name.",
							Computed:    true,
						},
						"type": schema.StringAttribute{
							Description: "ACME challenge type (dns, standalone).",
							Computed:    true,
							Validators: []validator.String{
								stringvalidator.OneOf("dns", "standalone"),
							},
						},
						"validation_delay": schema.Int64Attribute{
							Description: "Extra delay in seconds to wait before requesting validation. " +
								"Allows to cope with a long TTL of DNS records (0 - 172800).",
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 172800),
							},
						},
					},
				},
				Computed: true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *acmePluginsDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().ACME().Plugins()
}

// Read fetches the list of ACME plugins from the Proxmox cluster.
func (d *acmePluginsDatasource) Read(ctx context.Context, _ datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state acmePluginsModel

	list, err := d.client.List(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read ACME plugins",
			err.Error(),
		)

		return
	}

	for _, plugin := range list {
		mapValue, diags := types.MapValueFrom(ctx, types.StringType, plugin.Data)
		resp.Diagnostics.Append(diags...)

		state.Plugins = append(state.Plugins, acmePluginModel{
			baseACMEPluginModel: baseACMEPluginModel{
				API:             types.StringValue(plugin.API),
				Data:            mapValue,
				Digest:          types.StringValue(plugin.Digest),
				Plugin:          types.StringValue(plugin.Plugin),
				ValidationDelay: types.Int64Value(plugin.ValidationDelay),
			},
			Type: types.StringValue(plugin.Type),
		})
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
`````

## File: fwprovider/cluster/acme/plugin_model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// acmePluginsModel maps the schema data for the ACME plugins data source.
type acmePluginsModel struct {
	Plugins []acmePluginModel `tfsdk:"plugins"`
}

type baseACMEPluginModel struct {
	// API plugin name
	API types.String `tfsdk:"api"`
	// DNS plugin data
	Data types.Map `tfsdk:"data"`
	// Prevent changes if current configuration file has a different digest.
	// This can be used to prevent concurrent modifications.
	Digest types.String `tfsdk:"digest"`
	// Plugin ID name
	Plugin types.String `tfsdk:"plugin"`
	// Extra delay in seconds to wait before requesting validation (0 - 172800)
	ValidationDelay types.Int64 `tfsdk:"validation_delay"`
}

// acmePluginModel maps the schema data for an ACME plugin.
type acmePluginModel struct {
	baseACMEPluginModel
	Type types.String `tfsdk:"type"`
}

// acmePluginCreateModel maps the schema data for an ACME plugin.
type acmePluginCreateModel struct {
	baseACMEPluginModel
	// Flag to disable the config
	Disable types.Bool `tfsdk:"disable"`
}
`````

## File: fwprovider/cluster/acme/resource_acme_account.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/account"
)

var (
	_ resource.Resource                = &acmeAccountResource{}
	_ resource.ResourceWithConfigure   = &acmeAccountResource{}
	_ resource.ResourceWithImportState = &acmeAccountResource{}
)

// NewACMEAccountResource creates a new resource for managing ACME accounts.
func NewACMEAccountResource() resource.Resource {
	return &acmeAccountResource{}
}

// acmeAccountResource contains the resource's internal data.
type acmeAccountResource struct {
	// The ACME account API client
	client *account.Client
}

// acmeAccountModel maps the schema data for the ACME account resource.
type acmeAccountModel struct {
	// Contact email addresses.
	Contact types.String `tfsdk:"contact"`
	// CreatedAt timestamp of the account creation.
	CreatedAt types.String `tfsdk:"created_at"`
	// URL of ACME CA directory endpoint.
	Directory types.String `tfsdk:"directory"`
	// HMAC key for External Account Binding.
	EABHMACKey types.String `tfsdk:"eab_hmac_key"`
	// Key Identifier for External Account Binding.
	EABKID types.String `tfsdk:"eab_kid"`
	// Location of the ACME account.
	Location types.String `tfsdk:"location"`
	// ACME account config file name.
	Name types.String `tfsdk:"name"`
	// URL of CA TermsOfService - setting this indicates agreement.
	TOS types.String `tfsdk:"tos"`
}

// Metadata defines the name of the resource.
func (r *acmeAccountResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_acme_account"
}

// Schema defines the schema for the resource.
func (r *acmeAccountResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages an ACME account in a Proxmox VE cluster.",
		MarkdownDescription: "Manages an ACME account in a Proxmox VE cluster.\n\n" +
			"~> This resource requires `root@pam` authentication.",
		Attributes: map[string]schema.Attribute{
			"contact": schema.StringAttribute{
				Description: "The contact email addresses.",
				Required:    true,
			},
			"created_at": schema.StringAttribute{
				Description: "The timestamp of the ACME account creation.",
				Computed:    true,
			},
			"directory": schema.StringAttribute{
				Description: "The URL of the ACME CA directory endpoint.",
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^https?://.*$`),
						"must be a valid URL",
					),
				},
				Optional: true,
			},
			"eab_hmac_key": schema.StringAttribute{
				Description: "The HMAC key for External Account Binding.",
				Optional:    true,
			},
			"eab_kid": schema.StringAttribute{
				Description: "The Key Identifier for External Account Binding.",
				Optional:    true,
			},
			"location": schema.StringAttribute{
				Description: "The location of the ACME account.",
				Computed:    true,
			},
			"name": schema.StringAttribute{
				Description: "The ACME account config file name.",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("default"),
			},
			"tos": schema.StringAttribute{
				Description: "The URL of CA TermsOfService - setting this indicates agreement.",
				Optional:    true,
			},
		},
	}
}

// Configure accesses the provider-configured Proxmox API client on behalf of the resource.
func (r *acmeAccountResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().ACME().Account()
}

// Create creates a new ACME account on the Proxmox cluster.
func (r *acmeAccountResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan acmeAccountModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	createRequest := &account.ACMEAccountCreateRequestBody{}
	createRequest.Contact = plan.Contact.ValueString()
	createRequest.Directory = plan.Directory.ValueString()
	createRequest.EABHMACKey = plan.EABHMACKey.ValueString()
	createRequest.EABKID = plan.EABKID.ValueString()
	createRequest.Name = plan.Name.ValueString()
	createRequest.TOS = plan.TOS.ValueString()

	err := r.client.Create(ctx, createRequest)
	if err != nil {
		if !strings.Contains(err.Error(), "already exists") {
			resp.Diagnostics.AddError(
				fmt.Sprintf("Unable to create ACME account '%s'", plan.Name),
				err.Error(),
			)

			return
		}

		resp.Diagnostics.AddError(
			fmt.Sprintf("ACME account '%s' already exists", plan.Name),
			err.Error(),
		)
	}

	r.readBack(ctx, &plan, &resp.Diagnostics, &resp.State)
}

// Read retrieves the current state of the ACME account from the Proxmox cluster.
func (r *acmeAccountResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state acmeAccountModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, state)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Update modifies an existing ACME account on the Proxmox cluster.
func (r *acmeAccountResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan acmeAccountModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	updateRequest := &account.ACMEAccountUpdateRequestBody{}
	updateRequest.Contact = plan.Contact.ValueString()

	err := r.client.Update(ctx, plan.Name.ValueString(), updateRequest)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to update ACME account '%s'", plan.Name),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &plan, &resp.Diagnostics, &resp.State)
}

// Delete removes an existing ACME account from the Proxmox cluster.
func (r *acmeAccountResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state acmeAccountModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.Delete(ctx, state.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to delete ACME account '%s'", state.Name),
			err.Error(),
		)

		return
	}
}

// ImportState retrieves the current state of an existing ACME account from the Proxmox cluster.
func (r *acmeAccountResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	resource.ImportStatePassthroughID(ctx, path.Root("name"), req, resp)
}

func (r *acmeAccountResource) readBack(
	ctx context.Context,
	data *acmeAccountModel,
	respDiags *diag.Diagnostics,
	respState *tfsdk.State,
) {
	found, diags := r.read(ctx, data)

	respDiags.Append(diags...)

	if !found {
		respDiags.AddError(
			fmt.Sprintf("ACME account '%s' not found after update", data.Name),
			"Failed to find ACME account when trying to read back the updated ACME account's data.",
		)
	}

	if !respDiags.HasError() {
		respDiags.Append(respState.Set(ctx, data)...)
	}
}

func (r *acmeAccountResource) read(ctx context.Context, data *acmeAccountModel) (bool, diag.Diagnostics) {
	name := data.Name.ValueString()

	acc, err := r.client.Get(ctx, name)
	if err != nil {
		diags := diag.Diagnostics{}

		if !strings.Contains(err.Error(), "does not exist") {
			diags.AddError(
				fmt.Sprintf("Unable to read ACME account '%s'", name),
				err.Error(),
			)
		}

		return false, diags
	}

	var contact string
	if len(acc.Account.Contact) > 0 {
		contact = strings.Replace(acc.Account.Contact[0], "mailto:", "", 1)
	}

	data.Directory = types.StringValue(acc.Directory)
	data.TOS = types.StringValue(acc.TOS)
	data.Location = types.StringValue(acc.Location)
	data.Contact = types.StringValue(contact)
	data.CreatedAt = types.StringValue(acc.Account.CreatedAt)

	return true, nil
}
`````

## File: fwprovider/cluster/acme/resource_acme_dns_plugin.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/plugins"
)

var (
	_ resource.Resource                = &acmePluginResource{}
	_ resource.ResourceWithConfigure   = &acmePluginResource{}
	_ resource.ResourceWithImportState = &acmePluginResource{}
)

// NewACMEPluginResource creates a new resource for managing ACME plugins.
func NewACMEPluginResource() resource.Resource {
	return &acmePluginResource{}
}

// acmePluginResource contains the resource's internal data.
type acmePluginResource struct {
	// The ACME plugin API client
	client *plugins.Client
}

// Metadata defines the name of the resource.
func (r *acmePluginResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_acme_dns_plugin"
}

// Schema defines the schema for the resource.
func (r *acmePluginResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages an ACME plugin in a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			"api": schema.StringAttribute{
				Description: "API plugin name.",
				Required:    true,
			},
			"data": schema.MapAttribute{
				Description: "DNS plugin data.",
				Optional:    true,
				ElementType: types.StringType,
			},
			"digest": schema.StringAttribute{
				Description: "SHA1 digest of the current configuration.",
				MarkdownDescription: "SHA1 digest of the current configuration. " +
					"Prevent changes if current configuration file has a different digest. " +
					"This can be used to prevent concurrent modifications.",
				Optional: true,
				Computed: true,
			},
			"disable": schema.BoolAttribute{
				Description: "Flag to disable the config.",
				Optional:    true,
			},
			"plugin": schema.StringAttribute{
				Description: "ACME Plugin ID name.",
				Required:    true,
			},
			"validation_delay": schema.Int64Attribute{
				Description: "Extra delay in seconds to wait before requesting validation.",
				MarkdownDescription: "Extra delay in seconds to wait before requesting validation. " +
					"Allows to cope with a long TTL of DNS records (0 - 172800).",
				Optional: true,
				Computed: true,
				Default:  int64default.StaticInt64(30),
				Validators: []validator.Int64{
					int64validator.Between(0, 172800),
				},
			},
		},
	}
}

// Configure accesses the provider-configured Proxmox API client on behalf of the resource.
func (r *acmePluginResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().ACME().Plugins()
}

// Create creates a new ACME plugin on the Proxmox cluster.
func (r *acmePluginResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan acmePluginCreateModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	createRequest := &plugins.ACMEPluginsCreateRequestBody{}
	createRequest.Plugin = plan.Plugin.ValueString()
	createRequest.Type = "dns"
	createRequest.API = plan.API.ValueString()
	data := make(plugins.DNSPluginData)

	plan.Data.ElementsAs(ctx, &data, false)

	createRequest.Data = &data
	createRequest.Disable = plan.Disable.ValueBool()
	createRequest.ValidationDelay = plan.ValidationDelay.ValueInt64()

	err := r.client.Create(ctx, createRequest)
	if err != nil {
		if !strings.Contains(err.Error(), "already exists") {
			resp.Diagnostics.AddError(
				fmt.Sprintf("Unable to create ACME plugin '%s'", createRequest.Plugin),
				err.Error(),
			)

			return
		}

		resp.Diagnostics.AddError(
			fmt.Sprintf("ACME plugin '%s' already exists", createRequest.Plugin),
			err.Error(),
		)
	}

	plugin, err := r.client.Get(ctx, plan.Plugin.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read ACME plugin",
			err.Error(),
		)

		return
	}

	plan.Digest = types.StringValue(plugin.Digest)

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Read retrieves the current state of the ACME plugin from the Proxmox cluster.
func (r *acmePluginResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state acmePluginCreateModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := state.Plugin.ValueString()

	plugin, err := r.client.Get(ctx, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read ACME plugin",
			err.Error(),
		)

		return
	}

	state.API = types.StringValue(plugin.API)
	state.Digest = types.StringValue(plugin.Digest)
	state.ValidationDelay = types.Int64Value(plugin.ValidationDelay)

	mapValue, diags := types.MapValueFrom(ctx, types.StringType, plugin.Data)
	resp.Diagnostics.Append(diags...)

	state.Data = mapValue

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update modifies an existing ACME plugin on the Proxmox cluster.
func (r *acmePluginResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state acmePluginCreateModel

	toDelete := make([]string, 0)

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	updateRequest := &plugins.ACMEPluginsUpdateRequestBody{}
	updateRequest.API = plan.API.ValueString()

	data := make(plugins.DNSPluginData)

	plan.Data.ElementsAs(ctx, &data, false)

	if plan.Data.IsNull() && !state.Data.IsNull() {
		toDelete = append(toDelete, "data")
	} else {
		updateRequest.Data = &data
	}

	updateRequest.Digest = plan.Digest.ValueString()

	if plan.Disable.IsNull() && !state.Disable.IsNull() || !plan.Disable.ValueBool() {
		toDelete = append(toDelete, "disable")
	} else {
		updateRequest.Disable = plan.Disable.ValueBool()
	}

	if plan.ValidationDelay.IsNull() && !state.ValidationDelay.IsNull() {
		toDelete = append(toDelete, "validation_delay")
	} else {
		updateRequest.ValidationDelay = plan.ValidationDelay.ValueInt64()
	}

	if len(toDelete) > 0 {
		updateRequest.Delete = strings.Join(toDelete, ",")
	}

	err := r.client.Update(ctx, plan.Plugin.ValueString(), updateRequest)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to update ACME account '%s'", plan.Plugin.ValueString()),
			err.Error(),
		)

		return
	}

	plugin, err := r.client.Get(ctx, plan.Plugin.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read ACME plugin",
			err.Error(),
		)

		return
	}

	plan.Digest = types.StringValue(plugin.Digest)

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Delete removes an existing ACME plugin from the Proxmox cluster.
func (r *acmePluginResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state acmePluginCreateModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.Delete(ctx, state.Plugin.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to delete ACME plugin '%s'", state.Plugin.ValueString()),
			err.Error(),
		)
	}
}

// ImportState retrieves the current state of an existing ACME plugin from the Proxmox cluster.
func (r *acmePluginResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	resource.ImportStatePassthroughID(ctx, path.Root("plugin"), req, resp)
}
`````

## File: fwprovider/cluster/ha/datasource_hagroup.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"

	hagroups "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/groups"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &haGroupDatasource{}
	_ datasource.DataSourceWithConfigure = &haGroupDatasource{}
)

// NewHAGroupDataSource is a helper function to simplify the provider implementation.
func NewHAGroupDataSource() datasource.DataSource {
	return &haGroupDatasource{}
}

// haGroupDatasource is the data source implementation for full information about
// specific High Availability groups.
type haGroupDatasource struct {
	client *hagroups.Client
}

// Metadata returns the data source type name.
func (d *haGroupDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_hagroup"
}

// Schema returns the schema for the data source.
func (d *haGroupDatasource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Retrieves information about a specific High Availability group.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"group": schema.StringAttribute{
				Description: "The identifier of the High Availability group to read.",
				Required:    true,
			},
			"comment": schema.StringAttribute{
				Description: "The comment associated with this group",
				Computed:    true,
			},
			"nodes": schema.MapAttribute{
				Description: "The member nodes for this group. They are provided as a map, where the keys are the node " +
					"names and the values represent their priority: integers for known priorities or `null` for unset " +
					"priorities.",
				Computed:    true,
				ElementType: types.Int64Type,
			},
			"no_failback": schema.BoolAttribute{
				Description: "A flag that indicates that failing back to a higher priority node is disabled for this HA group.",
				Computed:    true,
			},
			"restricted": schema.BoolAttribute{
				Description: "A flag that indicates that other nodes may not be used to run resources associated to this HA group.",
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *haGroupDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HA().Groups()
}

// Read fetches the list of HA groups from the Proxmox cluster then converts it to a list of strings.
func (d *haGroupDatasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state GroupModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	groupID := state.Group.ValueString()

	group, err := d.client.Get(ctx, groupID)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to read High Availability group '%s'", groupID),
			err.Error(),
		)

		return
	}

	state.ID = types.StringValue(groupID)

	resp.Diagnostics.Append(state.ImportFromAPI(*group)...)
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
`````

## File: fwprovider/cluster/ha/datasource_hagroups.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"

	hagroups "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/groups"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &haGroupsDatasource{}
	_ datasource.DataSourceWithConfigure = &haGroupsDatasource{}
)

// NewHAGroupsDataSource is a helper function to simplify the provider implementation.
func NewHAGroupsDataSource() datasource.DataSource {
	return &haGroupsDatasource{}
}

// haGroupsDatasource is the data source implementation for High Availability groups.
type haGroupsDatasource struct {
	client *hagroups.Client
}

// haGroupsModel maps the schema data for the High Availability groups data source.
type haGroupsModel struct {
	Groups types.Set    `tfsdk:"group_ids"`
	ID     types.String `tfsdk:"id"`
}

// Metadata returns the data source type name.
func (d *haGroupsDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_hagroups"
}

// Schema returns the schema for the data source.
func (d *haGroupsDatasource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Retrieves the list of High Availability groups.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"group_ids": schema.SetAttribute{
				Description: "The identifiers of the High Availability groups.",
				ElementType: types.StringType,
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *haGroupsDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HA().Groups()
}

// Read fetches the list of HA groups from the Proxmox cluster then converts it to a list of strings.
func (d *haGroupsDatasource) Read(ctx context.Context, _ datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state haGroupsModel

	list, err := d.client.List(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read High Availability groups",
			err.Error(),
		)

		return
	}

	groups := make([]attr.Value, len(list))
	for i, v := range list {
		groups[i] = types.StringValue(v.ID)
	}

	groupsValue, diags := types.SetValue(types.StringType, groups)
	resp.Diagnostics.Append(diags...)

	state.ID = types.StringValue("hagroups")
	state.Groups = groupsValue

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
`````

## File: fwprovider/cluster/ha/datasource_haresource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	haresources "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/resources"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &haResourceDatasource{}
	_ datasource.DataSourceWithConfigure = &haResourceDatasource{}
)

// NewHAResourceDataSource is a helper function to simplify the provider implementation.
func NewHAResourceDataSource() datasource.DataSource {
	return &haResourceDatasource{}
}

// haResourceDatasource is the data source implementation for High Availability resources.
type haResourceDatasource struct {
	client *haresources.Client
}

// Metadata returns the data source type name.
func (d *haResourceDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_haresource"
}

// Schema returns the schema for the data source.
func (d *haResourceDatasource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Retrieves the list of High Availability resources.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"resource_id": schema.StringAttribute{
				Description: "The identifier of the Proxmox HA resource to read.",
				Required:    true,
				Validators: []validator.String{
					resourceIDValidator(),
				},
			},
			"type": schema.StringAttribute{
				Description: "The type of High Availability resource (`vm` or `ct`).",
				Computed:    true,
			},
			"comment": schema.StringAttribute{
				Description: "The comment associated with this resource.",
				Computed:    true,
			},
			"group": schema.StringAttribute{
				Description: "The identifier of the High Availability group this resource is a member of.",
				Computed:    true,
			},
			"max_relocate": schema.Int64Attribute{
				Description: "The maximal number of relocation attempts.",
				Computed:    true,
			},
			"max_restart": schema.Int64Attribute{
				Description: "The maximal number of restart attempts.",
				Computed:    true,
			},
			"state": schema.StringAttribute{
				Description: "The desired state of the resource.",
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *haResourceDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HA().Resources()
}

// Read fetches the specified HA resource.
func (d *haResourceDatasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data ResourceModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resID, err := proxmoxtypes.ParseHAResourceID(data.ResourceID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected error parsing Proxmox HA resource identifier",
			fmt.Sprintf("Couldn't parse configuration into a valid HA resource identifier: %ss", err.Error()),
		)

		return
	}

	resource, err := d.client.Get(ctx, resID)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to read High Availability resource %v", resID),
			err.Error(),
		)

		return
	}

	data.ImportFromAPI(resource)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
`````

## File: fwprovider/cluster/ha/datasource_haresources.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"

	haresources "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/resources"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &haResourcesDatasource{}
	_ datasource.DataSourceWithConfigure = &haResourcesDatasource{}
)

// NewHAResourcesDataSource is a helper function to simplify the provider implementation.
func NewHAResourcesDataSource() datasource.DataSource {
	return &haResourcesDatasource{}
}

// haResourcesDatasource is the data source implementation for High Availability resources.
type haResourcesDatasource struct {
	client *haresources.Client
}

// haResourcesModel maps the schema data for the High Availability resources data source.
type haResourcesModel struct {
	// The Terraform resource identifier
	ID types.String `tfsdk:"id"`
	// The type of HA resources to fetch. If unset, all resources will be fetched.
	Type types.String `tfsdk:"type"`
	// The set of HA resource identifiers
	Resources types.Set `tfsdk:"resource_ids"`
}

// Metadata returns the data source type name.
func (d *haResourcesDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_haresources"
}

// Schema returns the schema for the data source.
func (d *haResourcesDatasource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Retrieves the list of High Availability resources.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"type": schema.StringAttribute{
				Description: "The type of High Availability resources to fetch (`vm` or `ct`). All resources " +
					"will be fetched if this option is unset.",
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf("ct", "vm"),
				},
			},
			"resource_ids": schema.SetAttribute{
				Description: "The identifiers of the High Availability resources.",
				ElementType: types.StringType,
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider-configured client to the data source.
func (d *haResourcesDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HA().Resources()
}

// Read fetches the list of HA resources from the Proxmox cluster then converts it to a list of strings.
func (d *haResourcesDatasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var (
		data      haResourcesModel
		fetchType *proxmoxtypes.HAResourceType
	)

	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if data.Type.IsNull() {
		data.ID = types.StringValue("haresources")
	} else {
		confType, err := proxmoxtypes.ParseHAResourceType(data.Type.ValueString())
		if err != nil {
			resp.Diagnostics.AddError(
				"Unexpected HA resource type",
				fmt.Sprintf(
					"Couldn't parse configuration into a valid HA resource type: %s. Please report this issue to the "+
						"provider developers.", err.Error(),
				),
			)

			return
		}

		fetchType = &confType
		data.ID = types.StringValue(fmt.Sprintf("haresources:%v", confType))
	}

	list, err := d.client.List(ctx, fetchType)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read High Availability resources",
			err.Error(),
		)

		return
	}

	resources := make([]attr.Value, len(list))
	for i, v := range list {
		resources[i] = types.StringValue(v.ID.String())
	}

	resourcesValue, diags := types.SetValue(types.StringType, resources)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	data.Resources = resourcesValue
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
`````

## File: fwprovider/cluster/ha/hagroup_model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"

	hagroups "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/groups"
)

// GroupModel is the model used to represent a High Availability group.
type GroupModel struct {
	ID         types.String `tfsdk:"id"`          // Identifier used by Terraform
	Group      types.String `tfsdk:"group"`       // HA group name
	Comment    types.String `tfsdk:"comment"`     // Comment, if present
	Nodes      types.Map    `tfsdk:"nodes"`       // Map of member nodes associated with their priorities
	NoFailback types.Bool   `tfsdk:"no_failback"` // Flag that disables failback
	Restricted types.Bool   `tfsdk:"restricted"`  // Flag that prevents execution on other member nodes
}

// ImportFromAPI imports the contents of a HA group model from the API's response data.
func (m *GroupModel) ImportFromAPI(group hagroups.HAGroupGetResponseData) diag.Diagnostics {
	m.Comment = types.StringPointerValue(group.Comment)
	m.NoFailback = group.NoFailback.ToValue()
	m.Restricted = group.Restricted.ToValue()

	return m.parseHAGroupNodes(group.Nodes)
}

// Parse the list of member nodes. The list is received from the Proxmox API as a string. It must
// be converted into a map value. Errors will be returned as Terraform diagnostics.
func (m *GroupModel) parseHAGroupNodes(nodes string) diag.Diagnostics {
	diags := diag.Diagnostics{}

	nodesIn := strings.Split(nodes, ",")
	nodesOut := make(map[string]attr.Value)

	for _, nodeDescStr := range nodesIn {
		nodeDesc := strings.Split(nodeDescStr, ":")
		if len(nodeDesc) > 2 {
			diags.AddWarning(
				"Could not parse HA group node",
				fmt.Sprintf("Received group node '%s' for HA group '%s'",
					nodeDescStr, m.Group.ValueString()),
			)

			continue
		}

		priority := types.Int64Null()

		if len(nodeDesc) == 2 {
			prio, err := strconv.Atoi(nodeDesc[1])
			if err == nil {
				priority = types.Int64Value(int64(prio))
			} else {
				diags.AddWarning(
					"Could not parse HA group node priority",
					fmt.Sprintf("Node priority string '%s' for node %s of HA group '%s'",
						nodeDesc[1], nodeDesc[0], m.Group.ValueString()),
				)
			}
		}

		nodesOut[nodeDesc[0]] = priority
	}

	value, mbDiags := types.MapValue(types.Int64Type, nodesOut)
	diags.Append(mbDiags...)

	m.Nodes = value

	return diags
}
`````

## File: fwprovider/cluster/ha/haresource_model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"fmt"

	haresources "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/resources"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"

	"github.com/hashicorp/terraform-plugin-framework/types"
)

// ResourceModel maps the schema data for the High Availability resource data source.
type ResourceModel struct {
	// The Terraform resource identifier
	ID types.String `tfsdk:"id"`
	// The Proxmox HA resource identifier
	ResourceID types.String `tfsdk:"resource_id"`
	// The type of HA resources to fetch. If unset, all resources will be fetched.
	Type types.String `tfsdk:"type"`
	// The desired state of the resource.
	State types.String `tfsdk:"state"`
	// The comment associated with this resource.
	Comment types.String `tfsdk:"comment"`
	// The identifier of the High Availability group this resource is a member of.
	Group types.String `tfsdk:"group"`
	// The maximal number of relocation attempts.
	MaxRelocate types.Int64 `tfsdk:"max_relocate"`
	// The maximal number of restart attempts.
	MaxRestart types.Int64 `tfsdk:"max_restart"`
}

// ImportFromAPI imports the contents of a HA resource model from the API's response data.
func (d *ResourceModel) ImportFromAPI(data *haresources.HAResourceGetResponseData) {
	d.ID = data.ID.ToValue()
	d.ResourceID = data.ID.ToValue()
	d.Type = data.Type.ToValue()
	d.State = data.State.ToValue()
	d.Comment = types.StringPointerValue(data.Comment)
	d.Group = types.StringPointerValue(data.Group)
	d.MaxRelocate = types.Int64PointerValue(data.MaxRelocate)
	d.MaxRestart = types.Int64PointerValue(data.MaxRestart)
}

// toRequestBase builds the common request data structure for HA resource creation or update API calls.
func (d *ResourceModel) toRequestBase() haresources.HAResourceDataBase {
	var state proxmoxtypes.HAResourceState

	if d.State.IsNull() {
		state = proxmoxtypes.HAResourceStateStarted
	} else {
		var err error

		state, err = proxmoxtypes.ParseHAResourceState(d.State.ValueString())
		if err != nil {
			panic(fmt.Errorf(
				"state string '%s' wrongly assumed to be valid; error: %w",
				d.State.ValueString(), err,
			))
		}
	}

	return haresources.HAResourceDataBase{
		State:       state,
		Comment:     d.Comment.ValueStringPointer(),
		Group:       d.Group.ValueStringPointer(),
		MaxRelocate: d.MaxRelocate.ValueInt64Pointer(),
		MaxRestart:  d.MaxRestart.ValueInt64Pointer(),
	}
}

// ToCreateRequest builds the request data structure for creating a new HA resource.
func (d *ResourceModel) ToCreateRequest(resID proxmoxtypes.HAResourceID) *haresources.HAResourceCreateRequestBody {
	return &haresources.HAResourceCreateRequestBody{
		ID:                 resID,
		Type:               &resID.Type,
		HAResourceDataBase: d.toRequestBase(),
	}
}

// ToUpdateRequest builds the request data structure for updating an existing HA resource.
func (d *ResourceModel) ToUpdateRequest(state *ResourceModel) *haresources.HAResourceUpdateRequestBody {
	var del []string

	if d.Comment.IsNull() && !state.Comment.IsNull() {
		del = append(del, "comment")
	}

	if d.Group.IsNull() && !state.Group.IsNull() {
		del = append(del, "group")
	}

	if d.MaxRelocate.IsNull() && !state.MaxRelocate.IsNull() {
		del = append(del, "max_relocate")
	}

	if d.MaxRestart.IsNull() && !state.MaxRestart.IsNull() {
		del = append(del, "max_restart")
	}

	return &haresources.HAResourceUpdateRequestBody{
		HAResourceDataBase: d.toRequestBase(),
		Delete:             del,
	}
}
`````

## File: fwprovider/cluster/ha/resource_hagroup.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"

	hagroups "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/groups"
)

var (
	_ resource.Resource                = &hagroupResource{}
	_ resource.ResourceWithConfigure   = &hagroupResource{}
	_ resource.ResourceWithImportState = &hagroupResource{}
)

// NewHAGroupResource creates a new resource for managing Linux Bridge network interfaces.
func NewHAGroupResource() resource.Resource {
	return &hagroupResource{}
}

// hagroupResource contains the resource's internal data.
type hagroupResource struct {
	// The HA groups API client
	client *hagroups.Client
}

// Metadata defines the name of the resource.
func (r *hagroupResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_hagroup"
}

// Schema defines the schema for the resource.
func (r *hagroupResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages a High Availability group in a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"group": schema.StringAttribute{
				Description: "The identifier of the High Availability group to manage.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9\-_.]*[a-zA-Z0-9]$`),
						"must start with a letter, end with a letter or number, be composed of "+
							"letters, numbers, '-', '_' and '.', and must be at least 2 characters long",
					),
				},
			},
			"comment": schema.StringAttribute{
				Description: "The comment associated with this group",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtLeast(1),
					stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
					stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
				},
			},
			"nodes": schema.MapAttribute{
				Description: "The member nodes for this group. They are provided as a map, where the keys are the node " +
					"names and the values represent their priority: integers for known priorities or `null` for unset " +
					"priorities.",
				Required:    true,
				ElementType: types.Int64Type,
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
					mapvalidator.KeysAre(
						stringvalidator.RegexMatches(
							regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?$`),
							"must be a valid Proxmox node name",
						),
					),
					mapvalidator.ValueInt64sAre(int64validator.Between(0, 1000)),
				},
			},
			"no_failback": schema.BoolAttribute{
				Description: "A flag that indicates that failing back to a higher priority node is disabled for this HA " +
					"group. Defaults to `false`.",
				Computed: true,
				Optional: true,
				Default:  booldefault.StaticBool(false),
			},
			"restricted": schema.BoolAttribute{
				Description: "A flag that indicates that other nodes may not be used to run resources associated to this HA " +
					"group. Defaults to `false`.",
				Computed: true,
				Optional: true,
				Default:  booldefault.StaticBool(false),
			},
		},
	}
}

// Configure accesses the provider-configured Proxmox API client on behalf of the resource.
func (r *hagroupResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().HA().Groups()
}

// Create creates a new HA group on the Proxmox cluster.
func (r *hagroupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data GroupModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	groupID := data.Group.ValueString()
	createRequest := &hagroups.HAGroupCreateRequestBody{}
	createRequest.ID = groupID
	createRequest.Comment = data.Comment.ValueStringPointer()
	createRequest.Nodes = r.groupNodesToString(data.Nodes)
	createRequest.NoFailback.FromValue(data.NoFailback)
	createRequest.Restricted.FromValue(data.Restricted)
	createRequest.Type = "group"

	err := r.client.Create(ctx, createRequest)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not create HA group '%s'.", groupID),
			err.Error(),
		)

		return
	}

	data.ID = types.StringValue(groupID)

	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// Read reads a HA group definition from the Proxmox cluster.
func (r *hagroupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data GroupModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Update updates a HA group definition on the Proxmox cluster.
func (r *hagroupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data, state GroupModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	updateRequest := &hagroups.HAGroupUpdateRequestBody{}
	updateRequest.Comment = data.Comment.ValueStringPointer()
	updateRequest.Nodes = r.groupNodesToString(data.Nodes)
	updateRequest.NoFailback.FromValue(data.NoFailback)
	updateRequest.Restricted.FromValue(data.Restricted)

	if updateRequest.Comment == nil && !state.Comment.IsNull() {
		updateRequest.Delete = "comment"
	}

	err := r.client.Update(ctx, state.Group.ValueString(), updateRequest)
	if err == nil {
		r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
	} else {
		resp.Diagnostics.AddError(
			"Error updating HA group",
			fmt.Sprintf("Could not update HA group '%s', unexpected error: %s",
				state.Group.ValueString(), err.Error()),
		)
	}
}

// Delete deletes a HA group definition.
func (r *hagroupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data GroupModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	groupID := data.Group.ValueString()

	err := r.client.Delete(ctx, groupID)
	if err != nil {
		if strings.Contains(err.Error(), "no such ha group") {
			resp.Diagnostics.AddWarning(
				"HA group does not exist",
				fmt.Sprintf(
					"Could not delete HA group '%s', it does not exist or has been deleted outside of Terraform.",
					groupID,
				),
			)
		} else {
			resp.Diagnostics.AddError(
				"Error deleting HA group",
				fmt.Sprintf("Could not delete HA group '%s', unexpected error: %s",
					groupID, err.Error()),
			)
		}
	}
}

// ImportState imports a HA group from the Proxmox cluster.
func (r *hagroupResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	reqID := req.ID
	data := GroupModel{
		ID:    types.StringValue(reqID),
		Group: types.StringValue(reqID),
	}
	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// readBack reads information about a created or modified HA group from the cluster then updates the response
// state accordingly. It is assumed that the `state`'s identifier is set.
func (r *hagroupResource) readBack(
	ctx context.Context,
	data *GroupModel,
	respDiags *diag.Diagnostics,
	respState *tfsdk.State,
) {
	found, diags := r.read(ctx, data)

	respDiags.Append(diags...)

	if !found {
		respDiags.AddError(
			"HA group not found after update",
			"Failed to find the group when trying to read back the updated HA group's data.",
		)
	}

	if !respDiags.HasError() {
		respDiags.Append(respState.Set(ctx, *data)...)
	}
}

// read reads information about a HA group from the cluster. The group identifier must have been set in the
// `data`.
func (r *hagroupResource) read(ctx context.Context, data *GroupModel) (bool, diag.Diagnostics) {
	name := data.Group.ValueString()

	group, err := r.client.Get(ctx, name)
	if err != nil {
		diags := diag.Diagnostics{}

		if !strings.Contains(err.Error(), "no such ha group") {
			diags.AddError("Could not read HA group", err.Error())
		}

		return false, diags
	}

	return true, data.ImportFromAPI(*group)
}

// groupNodesToString converts the map of group member nodes into a string.
func (r *hagroupResource) groupNodesToString(nodes types.Map) string {
	mbElements := nodes.Elements()
	mbNodes := make([]string, len(mbElements))
	i := 0

	for name, value := range mbElements {
		if value.IsNull() {
			mbNodes[i] = name
		} else {
			mbNodes[i] = fmt.Sprintf("%s:%d", name, value.(types.Int64).ValueInt64())
		}

		i++
	}

	return strings.Join(mbNodes, ",")
}
`````

## File: fwprovider/cluster/ha/resource_haresource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	haresources "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/resources"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// haResourceResource contains the resource's internal data.
// NOTE: the naming is horrible, but this is the convention used by the framework.
// and the entity name in the API is "ha resource", so...
type haResourceResource struct {
	// The HA resources API client
	client *haresources.Client
}

// Ensure the resource implements the expected interfaces.
var (
	_ resource.Resource                = &haResourceResource{}
	_ resource.ResourceWithConfigure   = &haResourceResource{}
	_ resource.ResourceWithImportState = &haResourceResource{}
)

// NewHAResourceResource returns a new resource for managing High Availability resources.
func NewHAResourceResource() resource.Resource {
	return &haResourceResource{}
}

// Metadata defines the name of the resource.
func (r *haResourceResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_haresource"
}

// Schema defines the schema for the resource.
func (r *haResourceResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages Proxmox HA resources.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"resource_id": schema.StringAttribute{
				Description: "The Proxmox HA resource identifier",
				Required:    true,
				Validators: []validator.String{
					resourceIDValidator(),
				},
			},
			"state": schema.StringAttribute{
				Description: "The desired state of the resource.",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("started"),
				Validators: []validator.String{
					resourceStateValidator(),
				},
			},
			"type": schema.StringAttribute{
				MarkdownDescription: "The type of HA resources to create. If unset, it will be deduced from the `resource_id`.",
				Computed:            true,
				Optional:            true,
				Validators: []validator.String{
					resourceTypeValidator(),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"comment": schema.StringAttribute{
				Description: "The comment associated with this resource.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.UTF8LengthAtLeast(1),
					stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
					stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
				},
			},
			"group": schema.StringAttribute{
				Description: "The identifier of the High Availability group this resource is a member of.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9\-_.]*[a-zA-Z0-9]$`),
						"must start with a letter, end with a letter or number, be composed of "+
							"letters, numbers, '-', '_' and '.', and must be at least 2 characters long",
					),
				},
			},
			"max_relocate": schema.Int64Attribute{
				Description: "The maximal number of relocation attempts.",
				Optional:    true,
				Validators: []validator.Int64{
					int64validator.Between(0, 10),
				},
			},
			"max_restart": schema.Int64Attribute{
				Description: "The maximal number of restart attempts.",
				Optional:    true,
				Validators: []validator.Int64{
					int64validator.Between(0, 10),
				},
			},
		},
	}
}

// Configure adds the provider-configured client to the resource.
func (r *haResourceResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().HA().Resources()
}

// Create creates a new HA resource.
func (r *haResourceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data ResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resID, err := proxmoxtypes.ParseHAResourceID(data.ResourceID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected error parsing Proxmox HA resource identifier",
			fmt.Sprintf("Couldn't parse the Terraform resource ID into a valid HA resource identifier: %s", err),
		)

		return
	}

	createRequest := data.ToCreateRequest(resID)

	err = r.client.Create(ctx, createRequest)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not create HA resource '%v'.", resID),
			err.Error(),
		)

		return
	}

	data.ID = types.StringValue(resID.String())

	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// Update updates an existing HA resource.
func (r *haResourceResource) Update(
	ctx context.Context,
	req resource.UpdateRequest,
	resp *resource.UpdateResponse,
) {
	var data, state ResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resID, err := proxmoxtypes.ParseHAResourceID(state.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected error parsing Proxmox HA resource identifier",
			fmt.Sprintf("Couldn't parse the Terraform resource ID into a valid HA resource identifier: %s", err),
		)

		return
	}

	updateRequest := data.ToUpdateRequest(&state)

	err = r.client.Update(ctx, resID, updateRequest)
	if err == nil {
		r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
	} else {
		resp.Diagnostics.AddError(
			"Error updating HA resource",
			fmt.Sprintf("Could not update HA resource '%s', unexpected error: %s",
				state.Group.ValueString(), err.Error()),
		)
	}
}

// Delete deletes an existing HA resource.
func (r *haResourceResource) Delete(
	ctx context.Context,
	req resource.DeleteRequest,
	resp *resource.DeleteResponse,
) {
	var data ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resID, err := proxmoxtypes.ParseHAResourceID(data.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected error parsing Proxmox HA resource identifier",
			fmt.Sprintf("Couldn't parse the Terraform resource ID into a valid HA resource identifier: %s", err),
		)

		return
	}

	err = r.client.Delete(ctx, resID)
	if err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			resp.Diagnostics.AddWarning(
				"HA resource does not exist",
				fmt.Sprintf(
					"Could not delete HA resource '%v', it does not exist or has been deleted outside of Terraform.",
					resID,
				),
			)
		} else {
			resp.Diagnostics.AddError(
				"Error deleting HA resource",
				fmt.Sprintf("Could not delete HA resource '%v', unexpected error: %s",
					resID, err.Error()),
			)
		}
	}
}

// Read reads the HA resource.
func (r *haResourceResource) Read(
	ctx context.Context,
	req resource.ReadRequest,
	resp *resource.ReadResponse,
) {
	var data ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// ImportState imports a HA resource from the Proxmox cluster.
func (r *haResourceResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	reqID := req.ID
	data := ResourceModel{
		ID:         types.StringValue(reqID),
		ResourceID: types.StringValue(reqID),
	}
	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// read reads information about a HA resource from the cluster. The Terraform resource identifier must have been set
// in the model before this function is called.
func (r *haResourceResource) read(ctx context.Context, data *ResourceModel) (bool, diag.Diagnostics) {
	diags := diag.Diagnostics{}

	resID, err := proxmoxtypes.ParseHAResourceID(data.ID.ValueString())
	if err != nil {
		diags.AddError(
			"Unexpected error parsing Proxmox HA resource identifier",
			fmt.Sprintf("Couldn't parse the Terraform resource ID into a valid HA resource identifier: %s", err),
		)

		return false, diags
	}

	res, err := r.client.Get(ctx, resID)
	if err != nil {
		if !strings.Contains(err.Error(), "no such resource") {
			diags.AddError("Could not read HA resource", err.Error())
		}

		return false, diags
	}

	data.ImportFromAPI(res)

	return true, nil
}

// readBack reads information about a created or modified HA resource from the cluster then updates the response
// state accordingly. It is assumed that the `state`'s identifier is set.
func (r *haResourceResource) readBack(
	ctx context.Context,
	data *ResourceModel,
	respDiags *diag.Diagnostics,
	respState *tfsdk.State,
) {
	found, diags := r.read(ctx, data)

	respDiags.Append(diags...)

	if !found {
		respDiags.AddError(
			"HA resource not found after update",
			"Failed to find the resource when trying to read back the updated HA resource's data.",
		)
	}

	if !respDiags.HasError() {
		respDiags.Append(respState.Set(ctx, *data)...)
	}
}
`````

## File: fwprovider/cluster/ha/validators.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// resourceIDValidator returns a new HA resource identifier validator.
func resourceIDValidator() validator.String {
	return validators.NewParseValidator(types.ParseHAResourceID, "value must be a valid HA resource identifier")
}

// resourceStateValidator returns a new HA resource state validator.
func resourceStateValidator() validator.String {
	return validators.NewParseValidator(types.ParseHAResourceState, "value must be a valid HA resource state")
}

// resourceTypeValidator returns a new HA resource type validator.
func resourceTypeValidator() validator.String {
	return validators.NewParseValidator(types.ParseHAResourceType, "value must be a valid HA resource type")
}
`````

## File: fwprovider/cluster/hardwaremapping/datasource_dir.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	mappings "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the implementation satisfies the required interfaces.
var (
	_ datasource.DataSource              = &dirDataSource{}
	_ datasource.DataSourceWithConfigure = &dirDataSource{}
)

// dirDataSource is the data source implementation for a directory mapping.
type dirDataSource struct {
	client *mappings.Client
}

// Configure adds the provider-configured client to the data source.
func (d *dirDataSource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HardwareMapping()
}

// Metadata returns the data source type name.
func (d *dirDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mapping_dir"
}

// Read fetches the specified directory mapping from the Proxmox VE API.
func (d *dirDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var hm modelDir

	resp.Diagnostics.Append(req.Config.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmID := hm.Name.ValueString()
	// Ensure to keep both in sync since the name represents the ID.
	hm.ID = hm.Name

	data, err := d.client.Get(ctx, proxmoxtypes.TypeDir, hmID)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to read directory mapping %q", hmID),
			err.Error(),
		)

		return
	}

	hm.importFromAPI(ctx, data)
	resp.Diagnostics.Append(resp.State.Set(ctx, &hm)...)
}

// Schema defines the schema for the directory mapping.
func (d *dirDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	comment := dataSourceSchemaBaseAttrComment
	comment.Optional = false
	comment.Computed = true
	comment.Description = "The comment of this directory mapping."

	resp.Schema = schema.Schema{
		Description: "Retrieves a directory mapping from a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameComment: comment,
			schemaAttrNameMap: schema.SetNestedAttribute{
				Computed:    true,
				Description: "The actual map of devices for the directory mapping.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameMapNode: schema.StringAttribute{
							Computed:    true,
							Description: "The node name attribute of the map.",
						},
						schemaAttrNameMapPath: schema.StringAttribute{
							// For directory mappings the path is required and refers
							// to the POSIX path of the directory as visible from the node.
							Computed:    true,
							CustomType:  customtypes.PathType{},
							Description: "The path attribute of the map.",
						},
					},
				},
				Validators: []validator.Set{
					setvalidator.SizeAtLeast(1),
				},
			},
			schemaAttrNameName: schema.StringAttribute{
				Description: "The name of this directory mapping.",
				Required:    true,
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this directory mapping data source.",
			),
		},
	}
}

// NewDirDataSource returns a new data source for a directory mapping.
// This is a helper function to simplify the provider implementation.
func NewDirDataSource() datasource.DataSource {
	return &dirDataSource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/datasource_pci.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	mappings "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the implementation satisfies the required interfaces.
var (
	_ datasource.DataSource              = &pciDataSource{}
	_ datasource.DataSourceWithConfigure = &pciDataSource{}
)

// pciDataSource is the data source implementation for a PCI hardware mapping.
type pciDataSource struct {
	// client is the hardware mapping API client.
	client *mappings.Client
}

// Configure adds the provider-configured client to the data source.
func (d *pciDataSource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HardwareMapping()
}

// Metadata returns the data source type name.
func (d *pciDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mapping_pci"
}

// Read fetches the specified PCI hardware mapping from the Proxmox VE API.
func (d *pciDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var hm modelPCI

	resp.Diagnostics.Append(req.Config.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmID := hm.Name.ValueString()
	// Ensure to keep both in sync since the name represents the ID.
	hm.ID = hm.Name

	data, err := d.client.Get(ctx, proxmoxtypes.TypePCI, hmID)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to read PCI hardware mapping %q", hmID),
			err.Error(),
		)

		return
	}

	hm.importFromAPI(ctx, data)

	resp.Diagnostics.Append(resp.State.Set(ctx, &hm)...)
}

// Schema defines the schema for the PCI hardware mapping.
func (d *pciDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	comment := dataSourceSchemaBaseAttrComment
	comment.Optional = false
	comment.Computed = true
	comment.Description = "The comment of this PCI hardware mapping."
	commentMap := comment
	commentMap.Description = "The comment of the mapped PCI device."

	resp.Schema = schema.Schema{
		Description: "Retrieves a PCI hardware mapping from a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameComment: comment,
			schemaAttrNameMap: schema.SetNestedAttribute{
				Computed:    true,
				Description: "The actual map of devices for the hardware mapping.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameComment: commentMap,
						schemaAttrNameMapIOMMUGroup: schema.Int64Attribute{
							Computed:    true,
							Description: "The IOMMU group attribute of the map.",
						},
						schemaAttrNameMapDeviceID: schema.StringAttribute{
							Computed:    true,
							Description: "The ID attribute of the map.",
							Validators: []validator.String{
								validators.HardwareMappingDeviceIDValidator(),
							},
						},
						schemaAttrNameMapNode: schema.StringAttribute{
							Computed:    true,
							Description: "The node name attribute of the map.",
						},
						schemaAttrNameMapPath: schema.StringAttribute{
							// For hardware mappings of type PCI, the path is required while it is optional for USB.
							Computed:    true,
							CustomType:  customtypes.PathType{},
							Description: "The path attribute of the map.",
						},
						schemaAttrNameMapSubsystemID: schema.StringAttribute{
							Computed: true,
							Description: "The subsystem ID attribute of the map." +
								"Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when " +
								"not set.",
							Validators: []validator.String{
								validators.HardwareMappingDeviceIDValidator(),
							},
						},
					},
				},
				Validators: []validator.Set{
					setvalidator.SizeAtLeast(1),
				},
			},
			schemaAttrNameMediatedDevices: schema.BoolAttribute{
				Computed:    true,
				Description: "Indicates whether to use with mediated devices.",
			},
			schemaAttrNameName: schema.StringAttribute{
				Description: "The name of this PCI hardware mapping.",
				Required:    true,
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this PCI hardware mapping data source.",
			),
		},
	}
}

// NewPCIDataSource returns a new data source for a PCI hardware mapping.
// This is a helper function to simplify the provider implementation.
func NewPCIDataSource() datasource.DataSource {
	return &pciDataSource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/datasource_usb.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	mappings "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the implementation satisfies the required interfaces.
var (
	_ datasource.DataSource              = &usbDataSource{}
	_ datasource.DataSourceWithConfigure = &usbDataSource{}
)

// usbDataSource is the data source implementation for a USB hardware mapping.
type usbDataSource struct {
	client *mappings.Client
}

// Configure adds the provider-configured client to the data source.
func (d *usbDataSource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HardwareMapping()
}

// Metadata returns the data source type name.
func (d *usbDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mapping_usb"
}

// Read fetches the specified USB hardware mapping from the Proxmox VE API.
func (d *usbDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var hm modelUSB

	resp.Diagnostics.Append(req.Config.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmID := hm.Name.ValueString()
	// Ensure to keep both in sync since the name represents the ID.
	hm.ID = hm.Name

	data, err := d.client.Get(ctx, proxmoxtypes.TypeUSB, hmID)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to read USB hardware mapping %q", hmID),
			err.Error(),
		)

		return
	}

	hm.importFromAPI(ctx, data)
	resp.Diagnostics.Append(resp.State.Set(ctx, &hm)...)
}

// Schema defines the schema for the USB hardware mapping.
func (d *usbDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	comment := dataSourceSchemaBaseAttrComment
	comment.Optional = false
	comment.Computed = true
	comment.Description = "The comment of this USB hardware mapping."
	commentMap := comment
	commentMap.Description = "The comment of the mapped USB device."

	resp.Schema = schema.Schema{
		Description: "Retrieves a USB hardware mapping from a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameComment: comment,
			schemaAttrNameMap: schema.SetNestedAttribute{
				Computed:    true,
				Description: "The actual map of devices for the hardware mapping.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameComment: commentMap,
						schemaAttrNameMapDeviceID: schema.StringAttribute{
							Computed:    true,
							Description: "The ID attribute of the map.",
							Validators: []validator.String{
								validators.HardwareMappingDeviceIDValidator(),
							},
						},
						schemaAttrNameMapNode: schema.StringAttribute{
							Computed:    true,
							Description: "The node name attribute of the map.",
						},
						schemaAttrNameMapPath: schema.StringAttribute{
							// For hardware mappings of type USB the path is optional and indicates that the device is mapped through
							// the device ID instead of ports.
							Computed:    true,
							CustomType:  customtypes.PathType{},
							Description: "The path attribute of the map.",
						},
					},
				},
				Validators: []validator.Set{
					setvalidator.SizeAtLeast(1),
				},
			},
			schemaAttrNameName: schema.StringAttribute{
				Description: "The name of this USB hardware mapping.",
				Required:    true,
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this USB hardware mapping data source.",
			),
		},
	}
}

// NewUSBDataSource returns a new data source for a USB hardware mapping.
// This is a helper function to simplify the provider implementation.
func NewUSBDataSource() datasource.DataSource {
	return &usbDataSource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/datasource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"
	"slices"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the implementation satisfies the required interfaces.
var (
	_ datasource.DataSource              = &dataSource{}
	_ datasource.DataSourceWithConfigure = &dataSource{}
)

// dataSource is the data source implementation for a hardware mapping.
type dataSource struct {
	client *mapping.Client
}

// Configure adds the provider-configured client to the data source.
func (d *dataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client.Cluster().HardwareMapping()
}

// Metadata returns the data source type name.
func (d *dataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mappings"
}

// Read fetches the list of hardware mappings from the Proxmox VE API then converts it to a list of strings.
func (d *dataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var hm model

	resp.Diagnostics.Append(req.Config.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmType, err := proxmoxtypes.ParseType(hm.Type.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Could not parse hardware mapping type", err.Error())
		return
	}

	list, err := d.client.List(ctx, hmType, hm.CheckNode.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read hardware mappings",
			err.Error(),
		)

		return
	}

	createCheckDiagnostics := func(hmID string, input []mapping.NodeCheckDiag) []modelNodeCheckDiag {
		checks := make([]modelNodeCheckDiag, len(input))

		for idx, check := range input {
			m := modelNodeCheckDiag{
				MappingID: types.StringValue(hmID),
				Severity:  types.StringPointerValue(check.Severity),
			}
			// Strip the unnecessary new line control character (\n) from the end of the message that is, for whatever reason,
			// returned this way by the Proxmox VE API.
			msg := strings.TrimSuffix(types.StringPointerValue(check.Message).ValueString(), "\n")
			m.Message = types.StringPointerValue(&msg)
			checks[idx] = m
		}

		return checks
	}

	mappings := make([]attr.Value, len(list))
	for idx, data := range list {
		mappings[idx] = types.StringValue(data.ID)
		// One of the fields only exists when the "check-node" option was passed to the Proxmox VE API with a valid node
		// name.
		// Note that the Proxmox VE API, for whatever reason, only returns one error at a time, even though the field is an
		// array.
		if (len(data.Checks) > 0) || len(data.ChecksUSB) > 0 {
			switch data.Type {
			case proxmoxtypes.TypeDir:
				hm.Checks = append(hm.Checks, createCheckDiagnostics(data.ID, data.Checks)...)
			case proxmoxtypes.TypePCI:
				hm.Checks = append(hm.Checks, createCheckDiagnostics(data.ID, data.Checks)...)
			case proxmoxtypes.TypeUSB:
				hm.Checks = append(hm.Checks, createCheckDiagnostics(data.ID, data.ChecksUSB)...)
			}
		}
		// Ensure to keep the order of the diagnostic entries to prevent random plan changes.
		slices.SortStableFunc(
			hm.Checks, func(a, b modelNodeCheckDiag) int {
				return strings.Compare(a.MappingID.ValueString(), b.MappingID.ValueString())
			},
		)
	}

	values, diags := types.SetValue(types.StringType, mappings)

	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	hm.MappingIDs = values
	hm.ID = types.StringValue("hardware_mappings")

	resp.Diagnostics.Append(resp.State.Set(ctx, &hm)...)
}

// Schema returns the schema for the data source.
func (d *dataSource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves a list of hardware mapping resources.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameChecks: schema.ListNestedAttribute{
				Computed:    true,
				Description: `Might contain relevant diagnostics about incorrect configurations.`,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameChecksDiagsMappingID: schema.StringAttribute{
							Computed:    true,
							Description: "The corresponding hardware mapping ID of the node check diagnostic entry.",
						},
						schemaAttrNameChecksDiagsMessage: schema.StringAttribute{
							Computed:    true,
							Description: "The message of the node check diagnostic entry.",
						},
						schemaAttrNameChecksDiagsSeverity: schema.StringAttribute{
							Computed:    true,
							Description: "The severity of the node check diagnostic entry.",
						},
					},
				},
			},
			schemaAttrNameCheckNode: schema.StringAttribute{
				Description: "The name of the node whose configurations should be checked for correctness.",
				Optional:    true,
			},
			schemaAttrNameHWMIDs: schema.SetAttribute{
				ElementType: types.StringType,
				Computed:    true,
				Description: "The identifiers of the hardware mappings.",
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this hardware mappings data source.",
			),
			schemaAttrNameType: schema.StringAttribute{
				Description: "The type of the hardware mappings.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						[]string{
							proxmoxtypes.TypeDir.String(),
							proxmoxtypes.TypePCI.String(),
							proxmoxtypes.TypeUSB.String(),
						}...,
					),
				},
			},
		},
	}
}

// NewDataSource returns a new data source for hardware mappings.
// This is a helper function to simplify the provider implementation.
func NewDataSource() datasource.DataSource {
	return &dataSource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/errors.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"fmt"

	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// ErrResourceMessageInvalidPath is the error message for an invalid Linux device path for a hardware mapping of the
// specified type.
// Extracting the message helps to reduce duplicated code and allows to use it in automated unit and acceptance tests.
//
//nolint:gochecknoglobals
var ErrResourceMessageInvalidPath = func(hmType proxmoxtypes.Type) string {
	return fmt.Sprintf("not a valid Linux device path for hardware mapping of type %q", hmType)
}
`````

## File: fwprovider/cluster/hardwaremapping/models.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/types"

	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	apitypes "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

const (
	// schemaAttrNameComment is the name of the schema attribute for the comment of a hardware mapping.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	schemaAttrNameComment = "comment"

	// schemaAttrNameMap is the name of the schema attribute for the map of a hardware mapping.
	schemaAttrNameMap = "map"

	// schemaAttrNameMapDeviceID is the name of the schema attribute for the device ID in a map of a hardware mapping.
	schemaAttrNameMapDeviceID = "id"

	// schemaAttrNameMapIOMMUGroup is the name of the schema attribute for the IOMMU group in a map of a hardware mapping.
	schemaAttrNameMapIOMMUGroup = "iommu_group"

	// schemaAttrNameMapNode is the name of the schema attribute for the node in a map of a hardware mapping.
	schemaAttrNameMapNode = "node"

	// schemaAttrNameMapPath is the name of the schema attribute for the path in a map of a hardware mapping.
	schemaAttrNameMapPath = "path"

	// schemaAttrNameMapSubsystemID is the name of the schema attribute for the subsystem ID in a map of a hardware
	// mapping.
	schemaAttrNameMapSubsystemID = "subsystem_id"

	// schemaAttrNameMediatedDevices is the name of the schema attribute for the mediated devices in a map of a hardware
	// mapping.
	schemaAttrNameMediatedDevices = "mediated_devices"

	// schemaAttrNameName is the name of the schema attribute for the name of a hardware mapping.
	schemaAttrNameName = "name"

	// schemaAttrNameTerraformID is the name of the schema attribute for the Terraform ID of a hardware mapping.
	schemaAttrNameTerraformID = "id"

	// schemaAttrNameType is the name of the schema attribute for the [proxmoxtypes.Type].
	schemaAttrNameType = "type"

	// schemaAttrNameCheckNode is the name of the schema attribute for the "check node" option of a
	// dataSource.
	schemaAttrNameCheckNode = "check_node"

	// schemaAttrNameChecks is the name of the schema attribute for the node checks diagnostics of a hardware mapping data
	// source.
	// Note that the Proxmox VE API attribute for [proxmoxtypes.TypeUSB] is named "errors", but we map it as "checks"
	// since this naming is generally across the Proxmox VE web UI and API documentations, including the attribute for
	// [proxmoxtypes.TypePCI].
	// This still follows the [Terraform "best practices"] as it improves the user experience by matching the field name
	// to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	schemaAttrNameChecks = "checks"

	// schemaAttrNameChecksDiagsMappingID is the name of the schema attribute for a node check diagnostic mapping ID of a
	// dataSource.
	schemaAttrNameChecksDiagsMappingID = "mapping_id"

	// schemaAttrNameChecksDiagsMessage is the name of the schema attribute for a node check diagnostic message of a
	// dataSource.
	schemaAttrNameChecksDiagsMessage = "message"

	// schemaAttrNameChecksDiagsSeverity is the name of the schema attribute for a node check diagnostic severity of a
	// dataSource.
	schemaAttrNameChecksDiagsSeverity = "severity"

	// schemaAttrNameHWMIDs is the name of the schema attribute for the hardware mapping IDs of a
	// dataSource.
	schemaAttrNameHWMIDs = "ids"
)

// modelDirMap maps the schema data for the map of a directory mapping.
type modelDirMap struct {
	// Node is the "node name" for the map.
	Node types.String `tfsdk:"node"`

	// Path is the "path" for the map.
	Path customtypes.PathValue `tfsdk:"path"`
}

// modelPCIMap maps the schema data for the map of a PCI hardware mapping.
type modelPCIMap struct {
	// Comment is the "comment" for the map.
	// This field is optional and is omitted by the Proxmox VE API when not set.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	Comment types.String `tfsdk:"comment"`

	// ID is the identifier of the map.
	ID types.String `tfsdk:"id"`

	// IOMMUGroup is the "IOMMU group" for the map.
	// This field is optional and is omitted by the Proxmox VE API when not set.
	IOMMUGroup types.Int64 `tfsdk:"iommu_group"`

	// Node is the "node name" for the map.
	Node types.String `tfsdk:"node"`

	// Path is the "path" for the map.
	Path customtypes.PathValue `tfsdk:"path"`

	// SubsystemID is the "subsystem ID" for the map.
	// This field is not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when
	// not set.
	SubsystemID types.String `tfsdk:"subsystem_id"`
}

// modelUSBMap maps the schema data for the map of a USB hardware mapping.
type modelUSBMap struct {
	// Comment is the "comment" for the map.
	// This field is optional and is omitted by the Proxmox VE API when not set.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	Comment types.String `tfsdk:"comment"`

	// ID is the identifier of the map.
	ID types.String `tfsdk:"id"`

	// Node is the "node name" for the map.
	Node types.String `tfsdk:"node"`

	// Path is the "path" for the map.
	Path customtypes.PathValue `tfsdk:"path"`
}

// modelDir maps the schema data for a directory mapping.
type modelDir struct {
	// Comment is the comment of the directory mapping.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	Comment types.String `tfsdk:"comment"`

	// ID is the Terraform identifier.
	ID types.String `tfsdk:"id"`

	// Name is the name of the directory mapping.
	Name types.String `tfsdk:"name"`

	// Map is the map of the directory mapping.
	Map []modelDirMap `tfsdk:"map"`
}

// modelPCI maps the schema data for a PCI hardware mapping.
type modelPCI struct {
	// Comment is the comment of the PCI hardware mapping.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	Comment types.String `tfsdk:"comment"`

	// ID is the Terraform identifier.
	ID types.String `tfsdk:"id"`

	// Name is the name of the PCI hardware mapping.
	Name types.String `tfsdk:"name"`

	// Map is the map of the PCI hardware mapping.
	Map []modelPCIMap `tfsdk:"map"`

	// MediatedDevices is the indicator for mediated devices of the PCI hardware mapping.
	MediatedDevices types.Bool `tfsdk:"mediated_devices"`
}

// modelUSB maps the schema data for a USB hardware mapping.
type modelUSB struct {
	// Comment is the comment of the USB hardware mapping.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	Comment types.String `tfsdk:"comment"`

	// ID is the Terraform identifier.
	ID types.String `tfsdk:"id"`

	// Name is the name of the USB hardware mapping.
	Name types.String `tfsdk:"name"`

	// Map is the map of the USB hardware mapping.
	Map []modelUSBMap `tfsdk:"map"`
}

// model maps the schema data for a hardware mappings data source.
type model struct {
	// Checks might contain relevant hardware mapping diagnostics about incorrect configurations for the node name set
	// defined by CheckNode.
	// Note that the Proxmox VE API attribute for [proxmoxtypes.TypeUSB] is named "errors", but we map it as "checks"
	// since this naming is generally across the Proxmox VE web UI and API documentations, including the attribute for
	// [proxmoxtypes.TypePCI].
	// Also note that the Proxmox VE API, for whatever reason, only returns one error at a time, even though the field is
	// an array.
	// This still follows the [Terraform "best practices"] as it improves the user experience by matching the field name
	// to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	Checks []modelNodeCheckDiag `tfsdk:"checks"`

	// CheckNode is the name of the node whose configuration should be checked for correctness.
	CheckNode types.String `tfsdk:"check_node"`

	// ID is the Terraform identifier.
	ID types.String `tfsdk:"id"`

	// MappingIDs is the set of hardware mapping identifiers.
	MappingIDs types.Set `tfsdk:"ids"`

	// Type is the [proxmoxtypes.Type].
	Type types.String `tfsdk:"type"`
}

// modelNodeCheckDiag maps the schema data for hardware mapping node check diagnostic data.
type modelNodeCheckDiag struct {
	// MappingID is the corresponding hardware mapping ID of this node check diagnostic entry.
	MappingID types.String `tfsdk:"mapping_id"`

	// Message is the message of the node check diagnostic entry.
	Message types.String `tfsdk:"message"`

	// Severity is the severity of the node check diagnostic entry.
	Severity types.String `tfsdk:"severity"`
}

// importFromAPI imports the contents of a directory mapping model from the Proxmox VE API's response data.
func (hm *modelDir) importFromAPI(_ context.Context, data *apitypes.GetResponseData) {
	// Ensure that both the ID and name are in sync.
	hm.Name = hm.ID
	// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations.
	hm.Comment = types.StringPointerValue(data.Description)
	maps := make([]modelDirMap, len(data.Map))

	for idx, pveMap := range data.Map {
		tfMap := modelDirMap{
			Node: types.StringValue(pveMap.Node),
			Path: customtypes.NewPathPointerValue(pveMap.Path),
		}

		maps[idx] = tfMap
	}

	hm.Map = maps
}

// toCreateRequest builds the request data structure for creating a new directory mapping.
func (hm *modelDir) toCreateRequest() *apitypes.CreateRequestBody {
	return &apitypes.CreateRequestBody{
		DataBase: hm.toRequestBase(),
		ID:       hm.ID.ValueString(),
	}
}

// toRequestBase builds the common request data structure for the directory mapping creation or update API calls.
func (hm *modelDir) toRequestBase() apitypes.DataBase {
	dataBase := apitypes.DataBase{
		// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
		// generally across the Proxmox VE web UI and API documentations.
		Description: hm.Comment.ValueStringPointer(),
	}
	maps := make([]proxmoxtypes.Map, len(hm.Map))

	for idx, tfMap := range hm.Map {
		pveMap := proxmoxtypes.Map{
			Node: tfMap.Node.ValueString(),
			Path: tfMap.Path.ValueStringPointer(),
		}

		maps[idx] = pveMap
	}

	dataBase.Map = maps

	return dataBase
}

// toUpdateRequest builds the request data structure for updating an existing USB hardware mapping.
func (hm *modelDir) toUpdateRequest(currentState *modelDir) *apitypes.UpdateRequestBody {
	var del []string

	if hm.Comment.IsNull() && !currentState.Comment.IsNull() {
		// The Proxmox VE API attribute is named "description" while we name it "comment" internally since this naming is
		// generally used across the Proxmox VE web UI and API documentations.
		// This still follows the Terraform "best practices" [1] as it improves the user experience by matching the field
		// name to the naming used in the human-facing interfaces.
		// References:
		//   1. https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
		del = append(del, proxmoxtypes.AttrNameDescription)
	}

	return &apitypes.UpdateRequestBody{
		DataBase: hm.toRequestBase(),
		Delete:   del,
	}
}

// importFromAPI imports the contents of a PCI hardware mapping model from the Proxmox VE API's response data.
func (hm *modelPCI) importFromAPI(_ context.Context, data *apitypes.GetResponseData) {
	// Ensure that both the ID and name are in sync.
	hm.Name = hm.ID
	// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations.
	hm.Comment = types.StringPointerValue(data.Description)
	maps := make([]modelPCIMap, len(data.Map))

	for idx, pveMap := range data.Map {
		tfMap := modelPCIMap{
			ID:   pveMap.ID.ToValue(),
			Node: types.StringValue(pveMap.Node),
			Path: customtypes.NewPathPointerValue(pveMap.Path),
		}

		if pveMap.Description != nil {
			tfMap.Comment = types.StringPointerValue(pveMap.Description)
		}

		if pveMap.SubsystemID != "" {
			tfMap.SubsystemID = pveMap.SubsystemID.ToValue()
		}

		if pveMap.IOMMUGroup != nil {
			tfMap.IOMMUGroup = types.Int64Value(*pveMap.IOMMUGroup)
		}

		maps[idx] = tfMap
	}

	hm.MediatedDevices = data.MediatedDevices.ToValue()
	hm.Map = maps
}

// toCreateRequest builds the request data structure for creating a new PCI hardware mapping.
func (hm *modelPCI) toCreateRequest() *apitypes.CreateRequestBody {
	return &apitypes.CreateRequestBody{
		DataBase: hm.toRequestBase(),
		ID:       hm.ID.ValueString(),
	}
}

// toRequestBase builds the common request data structure for the PCI hardware mapping creation or update API calls.
func (hm *modelPCI) toRequestBase() apitypes.DataBase {
	dataBase := apitypes.DataBase{
		// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
		// generally across the Proxmox VE web UI and API documentations.
		Description: hm.Comment.ValueStringPointer(),
	}
	maps := make([]proxmoxtypes.Map, len(hm.Map))

	for idx, tfMap := range hm.Map {
		pveMap := proxmoxtypes.Map{
			// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
			// generally across the Proxmox VE web UI and API documentations.
			Description: tfMap.Comment.ValueStringPointer(),
			ID:          proxmoxtypes.DeviceID(tfMap.ID.ValueString()),
			IOMMUGroup:  tfMap.IOMMUGroup.ValueInt64Pointer(),
			Node:        tfMap.Node.ValueString(),
			Path:        tfMap.Path.ValueStringPointer(),
			SubsystemID: proxmoxtypes.DeviceID(tfMap.SubsystemID.ValueString()),
		}
		maps[idx] = pveMap
	}

	dataBase.Map = maps
	dataBase.MediatedDevices.FromValue(hm.MediatedDevices)

	return dataBase
}

// toUpdateRequest builds the request data structure for updating an existing PCI hardware mapping.
func (hm *modelPCI) toUpdateRequest(currentState *modelPCI) *apitypes.UpdateRequestBody {
	var del []string

	baseRequest := hm.toRequestBase()

	if hm.Comment.IsNull() && !currentState.Comment.IsNull() {
		// The Proxmox VE API attribute is named "description" while we name it "comment" internally since this naming is
		// generally used across the Proxmox VE web UI and API documentations.
		// This still follows theTerraform "best practices" [1] as it improves the user experience by matching the field
		// name to the naming used in the human-facing interfaces.
		// References:
		//   1. https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
		del = append(del, proxmoxtypes.AttrNameDescription)
	}

	if hm.MediatedDevices.IsNull() || !hm.MediatedDevices.ValueBool() {
		del = append(del, apitypes.APIParamNamePCIMediatedDevices)

		baseRequest.MediatedDevices.FromValue(types.BoolValue(false))
	}

	return &apitypes.UpdateRequestBody{
		DataBase: baseRequest,
		Delete:   del,
	}
}

// importFromAPI imports the contents of a USB hardware mapping model from the Proxmox VE API's response data.
func (hm *modelUSB) importFromAPI(_ context.Context, data *apitypes.GetResponseData) {
	// Ensure that both the ID and name are in sync.
	hm.Name = hm.ID
	// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations.
	hm.Comment = types.StringPointerValue(data.Description)
	maps := make([]modelUSBMap, len(data.Map))

	for idx, pveMap := range data.Map {
		tfMap := modelUSBMap{
			ID:   pveMap.ID.ToValue(),
			Node: types.StringValue(pveMap.Node),
			Path: customtypes.NewPathPointerValue(pveMap.Path),
		}
		if pveMap.Description != nil {
			tfMap.Comment = types.StringPointerValue(pveMap.Description)
		}

		maps[idx] = tfMap
	}

	hm.Map = maps
}

// toCreateRequest builds the request data structure for creating a new USB hardware mapping.
func (hm *modelUSB) toCreateRequest() *apitypes.CreateRequestBody {
	return &apitypes.CreateRequestBody{
		DataBase: hm.toRequestBase(),
		ID:       hm.ID.ValueString(),
	}
}

// toRequestBase builds the common request data structure for the USB hardware mapping creation or update API calls.
func (hm *modelUSB) toRequestBase() apitypes.DataBase {
	dataBase := apitypes.DataBase{
		// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
		// generally across the Proxmox VE web UI and API documentations.
		Description: hm.Comment.ValueStringPointer(),
	}
	maps := make([]proxmoxtypes.Map, len(hm.Map))

	for idx, tfMap := range hm.Map {
		pveMap := proxmoxtypes.Map{
			ID:   proxmoxtypes.DeviceID(tfMap.ID.ValueString()),
			Node: tfMap.Node.ValueString(),
			Path: tfMap.Path.ValueStringPointer(),
		}
		if !tfMap.Comment.IsNull() {
			// The attribute is named "description" by the Proxmox VE API, but we map it as a comment since this naming is
			// generally across the Proxmox VE web UI and API documentations.
			pveMap.Description = tfMap.Comment.ValueStringPointer()
		}

		maps[idx] = pveMap
	}

	dataBase.Map = maps

	return dataBase
}

// toUpdateRequest builds the request data structure for updating an existing USB hardware mapping.
func (hm *modelUSB) toUpdateRequest(currentState *modelUSB) *apitypes.UpdateRequestBody {
	var del []string

	if hm.Comment.IsNull() && !currentState.Comment.IsNull() {
		// The Proxmox VE API attribute is named "description" while we name it "comment" internally since this naming is
		// generally used across the Proxmox VE web UI and API documentations.
		// This still follows the Terraform "best practices" [1] as it improves the user experience by matching the field
		// name to the naming used in the human-facing interfaces.
		// References:
		//   1. https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
		del = append(del, proxmoxtypes.AttrNameDescription)
	}

	return &apitypes.UpdateRequestBody{
		DataBase: hm.toRequestBase(),
		Delete:   del,
	}
}
`````

## File: fwprovider/cluster/hardwaremapping/resource_dir.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	mappings "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the resource implements the required interfaces.
var (
	_ resource.Resource                = &dirResource{}
	_ resource.ResourceWithConfigure   = &dirResource{}
	_ resource.ResourceWithImportState = &dirResource{}
)

// dirResource contains the directory mapping resource's internal data.
type dirResource struct {
	// client is the hardware mapping API client.
	client *mappings.Client
}

// read reads information about a directory mapping from the Proxmox VE API.
func (r *dirResource) read(ctx context.Context, hm *modelDir) (bool, diag.Diagnostics) {
	diags := diag.Diagnostics{}

	hmName := hm.Name.ValueString()

	data, err := r.client.Get(ctx, proxmoxtypes.TypeDir, hmName)
	if err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			diags.AddError("Could not read directory mapping", err.Error())
		}

		return false, diags
	}

	hm.importFromAPI(ctx, data)

	return true, nil
}

// readBack reads information about a created or modified directory mapping from the Proxmox VE API then updates the
// response state accordingly.
// The Terraform resource identifier must have been set in the state before this method is called!
func (r *dirResource) readBack(ctx context.Context, hm *modelDir, respDiags *diag.Diagnostics, respState *tfsdk.State) {
	found, diags := r.read(ctx, hm)

	respDiags.Append(diags...)

	if !found {
		respDiags.AddError(
			"directory mapping resource not found after update",
			"Failed to find the resource when trying to read back the updated directory mapping's data.",
		)
	}

	if !respDiags.HasError() {
		respDiags.Append(respState.Set(ctx, *hm)...)
	}
}

// Configure adds the provider-configured client to the resource.
func (r *dirResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().HardwareMapping()
}

// Create creates a new directory mapping.
func (r *dirResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var hm modelDir

	resp.Diagnostics.Append(req.Plan.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmName := hm.Name.ValueString()
	// Ensure to keep both in sync since the name represents the ID.
	hm.ID = hm.Name

	apiReq := hm.toCreateRequest()

	if err := r.client.Create(ctx, proxmoxtypes.TypeDir, apiReq); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not create directory mapping %q.", hmName),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &hm, &resp.Diagnostics, &resp.State)
}

// Delete deletes an existing directory mapping.
func (r *dirResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var hm modelDir

	resp.Diagnostics.Append(req.State.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmID := hm.Name.ValueString()

	if err := r.client.Delete(ctx, proxmoxtypes.TypeDir, hmID); err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			resp.Diagnostics.AddWarning(
				"directory mapping does not exist",
				fmt.Sprintf(
					"Could not delete directory mapping %q, it does not exist or has been deleted outside of Terraform.",
					hmID,
				),
			)
		} else {
			resp.Diagnostics.AddError(fmt.Sprintf("Could not delete directory mapping %q.", hmID), err.Error())
		}
	}
}

// ImportState imports a directory mapping from the Proxmox VE API.
func (r *dirResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	data := modelDir{
		ID:   types.StringValue(req.ID),
		Name: types.StringValue(req.ID),
	}

	resource.ImportStatePassthroughID(ctx, path.Root(schemaAttrNameTerraformID), req, resp)
	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// Metadata defines the name of the directory mapping.
func (r *dirResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mapping_dir"
}

// Read reads the directory mapping.
//

func (r *dirResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data modelDir

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Schema defines the schema for the directory mapping.
func (r *dirResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	comment := resourceSchemaBaseAttrComment
	comment.Description = "The comment of this directory mapping."

	resp.Schema = schema.Schema{
		Description: "Manages a directory mapping in a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameComment: comment,
			schemaAttrNameMap: schema.SetNestedAttribute{
				Description: "The actual map of devices for the hardware mapping.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameMapNode: schema.StringAttribute{
							Description: "The node this mapping applies to.",
							Required:    true,
						},
						schemaAttrNameMapPath: schema.StringAttribute{
							CustomType: customtypes.PathType{},
							Description: "The path of the map. For directory mappings the path is required and refers" +
								" to the POSIX path of the directory as visible from the node.",
							Required: true,
							Validators: []validator.String{
								stringvalidator.RegexMatches(
									customtypes.PathDirValueRegEx,
									ErrResourceMessageInvalidPath(proxmoxtypes.TypeDir),
								),
							},
						},
					},
				},
				Required: true,
				Validators: []validator.Set{
					setvalidator.SizeAtLeast(1),
				},
			},
			schemaAttrNameName: schema.StringAttribute{
				Description: "The name of this directory mapping.",
				Required:    true,
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this directory mapping resource.",
			),
		},
	}
}

// Update updates an existing directory mapping.
func (r *dirResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var hmCurrent, hmPlan modelDir

	resp.Diagnostics.Append(req.Plan.Get(ctx, &hmPlan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &hmCurrent)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmName := hmPlan.Name.ValueString()

	apiReq := hmPlan.toUpdateRequest(&hmCurrent)

	if err := r.client.Update(ctx, proxmoxtypes.TypeDir, hmName, apiReq); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not update directory mapping %q.", hmName),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &hmPlan, &resp.Diagnostics, &resp.State)
}

// NewDirResource returns a new resource for managing a directory mapping.
// This is a helper function to simplify the provider implementation.
func NewDirResource() resource.Resource {
	return &dirResource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/resource_hardware_mapping_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping_test

import (
	"fmt"
	"regexp"
	"strconv"
	"testing"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/knownvalue"
	"github.com/hashicorp/terraform-plugin-testing/statecheck"
	"github.com/hashicorp/terraform-plugin-testing/tfjsonpath"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

const (
	accTestHardwareMappingNameDir = "proxmox_virtual_environment_hardware_mapping_dir.test"
	accTestHardwareMappingNamePCI = "proxmox_virtual_environment_hardware_mapping_pci.test"
	accTestHardwareMappingNameUSB = "proxmox_virtual_environment_hardware_mapping_usb.test"
)

type accTestHardwareMappingFakeData struct {
	Comments       []string `fake:"{sentence:3}"         fakesize:"2"`
	MapComments    []string `fake:"{sentence:3}"         fakesize:"2"`
	MapDeviceIDs   []string `fake:"{linuxdeviceid}"      fakesize:"2"`
	MapIOMMUGroups []uint   `fake:"{number:1,20}"        fakesize:"2"`
	// These paths must exist on the host system, use a hardcoded list
	MapPathsDir     []string `fake:"{randomstring:[/home,/root,/mnt,/tmp]}" fakesize:"2"`
	MapPathsPCI     []string `fake:"{linuxdevicepathpci}" fakesize:"2"`
	MapPathsUSB     []string `fake:"{linuxdevicepathusb}" fakesize:"2"`
	MapSubsystemIDs []string `fake:"{linuxdeviceid}"      fakesize:"2"`
	MediatedDevices bool     `fake:"{bool}"`
	Names           []string `fake:"{noun}"               fakesize:"2"`
}

func testAccResourceHardwareMappingInit(t *testing.T) (*accTestHardwareMappingFakeData, *test.Environment) {
	t.Helper()

	// Register a new custom function to generate random Linux device IDs.
	gofakeit.AddFuncLookup(
		"linuxdeviceid", gofakeit.Info{
			Category:    "custom",
			Description: "Random Linux device ID",
			Example:     "8086:5916",
			Output:      "string",
			Generate: func(f *gofakeit.Faker, _ *gofakeit.MapParams, _ *gofakeit.Info) (any, error) {
				return f.Regex(proxmoxtypes.DeviceIDAttrValueRegEx.String()), nil
			},
		},
	)
	// Register a new custom function to generate random Linux PCI device paths.
	gofakeit.AddFuncLookup(
		"linuxdevicepathpci", gofakeit.Info{
			Category:    "custom",
			Description: "Random Linux PCI device path",
			Example:     "0000:00:02.0",
			Output:      "string",
			Generate: func(f *gofakeit.Faker, _ *gofakeit.MapParams, _ *gofakeit.Info) (any, error) {
				return f.Regex(customtypes.PathPCIValueRegEx.String()), nil
			},
		},
	)
	// Register a new custom function to generate random Linux USB device paths.
	gofakeit.AddFuncLookup(
		"linuxdevicepathusb", gofakeit.Info{
			Category:    "custom",
			Description: "Random Linux USB device path",
			Example:     "1-5.2",
			Output:      "string",
			Generate: func(f *gofakeit.Faker, _ *gofakeit.MapParams, _ *gofakeit.Info) (any, error) {
				return f.Regex(customtypes.PathUSBValueRegEx.String()), nil
			},
		},
	)

	te := test.InitEnvironment(t)

	var data accTestHardwareMappingFakeData

	if err := gofakeit.Struct(&data); err != nil {
		t.Fatalf("could not create fake data for hardware mapping: %s", err)
	}

	return &data, te
}

// TestAccResourceHardwareMappingDirValidInput runs tests for directory mapping resource definitions with valid input
// where all possible attributes are
// specified.
// All implementations of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested
// in sequential steps.
func TestAccResourceHardwareMappingDirValidInput(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations where all possible attributes are specified.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_dir" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								node    = "%s"
								path    = "%s"
							},
						]
					}
					`,
						data.Comments[0],
						data.Names[0],
						te.NodeName,
						data.MapPathsDir[0],
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "comment", data.Comments[0]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameDir, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameDir, "map.*", map[string]string{
								"node": te.NodeName,
								"path": data.MapPathsDir[0],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "name", data.Names[0]),
					),
				},

				// Test the "ImportState" implementation and ensure that PCI-only attributes are not set.
				{
					ImportState:       true,
					ImportStateId:     data.Names[0],
					ImportStateVerify: true,
					ResourceName:      accTestHardwareMappingNameDir,
				},

				// Test the "Update" implementation where all possible attributes are specified.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_dir" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								node    = "%s"
								path    = "%s"
							},
						]
					}
					`,
						data.Comments[1],
						data.Names[0],
						te.NodeName,
						data.MapPathsDir[1],
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "comment", data.Comments[1]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameDir, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameDir, "map.*", map[string]string{
								"node": te.NodeName,
								"path": data.MapPathsDir[1],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "name", data.Names[0]),
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingDirValidInputMinimal runs tests for directory mapping resource definitions with
// valid input that only have the minimum
// amount of attributes set to test computed and default values within the resulting plan and state. The last step sets
// the undefined values to test the update
// logic.
// All implementations of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested
// in sequential steps.
func TestAccResourceHardwareMappingDirValidInputMinimal(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations with only the minimum amount of attributes being set.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_dir" "test" {
						name    = "%s"
						map     = [
							{
								node = "%s"
								path = "%s"
							},
						]
					}
					`,
						data.Names[0],
						te.NodeName,
						data.MapPathsDir[0],
					),
					ConfigStateChecks: []statecheck.StateCheck{
						// Optional attributes should all be unset.
						statecheck.ExpectKnownValue(accTestHardwareMappingNameDir,
							tfjsonpath.New("comment"),
							knownvalue.Null()),
					},
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameDir, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameDir, "map.*", map[string]string{
								"node": te.NodeName,
								"path": data.MapPathsDir[0],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "name", data.Names[0]),
					),
				},

				// Test the "Update" implementation by setting all previously undefined attributes.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_dir" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								node    = "%s"
								path    = "%s"
							},
						]
					}
					`,
						data.Comments[0],
						data.Names[0],
						te.NodeName,
						data.MapPathsDir[0],
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "comment", data.Comments[0]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameDir, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameDir, "map.*", map[string]string{
								"node": te.NodeName,
								"path": data.MapPathsDir[0],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameDir, "name", data.Names[0]),
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingDirInvalidInput runs tests for directory mapping resource definitions where all
// possible attributes are specified.
// Only the "Create" method implementation of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource]
// interface is tested in sequential steps.
func TestAccResourceHardwareMappingDirInvalidInput(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" method implementation where all possible attributes are specified, but an error is expected
				// when using an invalid device path.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_usb" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment = "%s"
								id      = "%s"
								node    = "%s"
								# Only valid Linux USB device paths should pass the verification.
								path    = "xyz3:1337foobar"
							},
						]
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.Comments[1],
						data.MapDeviceIDs[0],
						te.NodeName,
					),
					ExpectError: regexp.MustCompile(`valid Linux device path for hardware mapping of type "usb"`),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingPCIValidInput runs tests for PCI hardware mapping resource definitions with valid input
// where all possible attributes are
// specified.
// All implementations of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested
// in sequential steps.
func TestAccResourceHardwareMappingPCIValidInput(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations where all possible attributes are specified.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_pci" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment      = "%s"
								id           = "%s"
								iommu_group  = %d
								node         = "%s"
								path         = "%s"
								subsystem_id = "%s"
							},
						]
						mediated_devices = %t
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.MapComments[0],
						data.MapDeviceIDs[0],
						data.MapIOMMUGroups[0],
						te.NodeName,
						data.MapPathsPCI[0],
						data.MapSubsystemIDs[0],
						data.MediatedDevices,
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "comment", data.Comments[0]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNamePCI, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNamePCI, "map.*", map[string]string{
								"comment":      data.MapComments[0],
								"id":           data.MapDeviceIDs[0],
								"iommu_group":  strconv.Itoa(int(data.MapIOMMUGroups[0])),
								"node":         te.NodeName,
								"path":         data.MapPathsPCI[0],
								"subsystem_id": data.MapSubsystemIDs[0],
							},
						),
						resource.TestCheckResourceAttr(
							accTestHardwareMappingNamePCI,
							"mediated_devices",
							strconv.FormatBool(data.MediatedDevices),
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "name", data.Names[0]),
					),
				},

				// Test the "ImportState" implementation.
				{
					ImportState:       true,
					ImportStateId:     data.Names[0],
					ImportStateVerify: true,
					ResourceName:      accTestHardwareMappingNamePCI,
				},

				// Test the "Update" implementation where all possible attributes are specified.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_pci" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment      = "%s"
								id           = "%s"
								iommu_group  = %d
								node         = "%s"
								path         = "%s"
								subsystem_id = "%s"
							},
						]
						mediated_devices = %t
					}
					`,
						data.Comments[1],
						data.Names[0],
						data.MapComments[1],
						data.MapDeviceIDs[0],
						data.MapIOMMUGroups[1],
						te.NodeName,
						data.MapPathsPCI[1],
						data.MapSubsystemIDs[1],
						!data.MediatedDevices,
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "comment", data.Comments[1]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNamePCI, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNamePCI, "map.*", map[string]string{
								"comment":      data.MapComments[1],
								"id":           data.MapDeviceIDs[0],
								"iommu_group":  strconv.Itoa(int(data.MapIOMMUGroups[1])),
								"node":         te.NodeName,
								"path":         data.MapPathsPCI[1],
								"subsystem_id": data.MapSubsystemIDs[1],
							},
						),
						resource.TestCheckResourceAttr(
							accTestHardwareMappingNamePCI,
							"mediated_devices",
							strconv.FormatBool(!data.MediatedDevices),
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "name", data.Names[0]),
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingPCIValidInputMinimal runs tests for PCI hardware mapping resource definitions with
// valid input that only have the minimum
// amount of attributes set to test computed and default values within the resulting plan and state. The last step sets
// the undefined values to test the update
// logic.
// All implementations of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested
// in sequential steps.
func TestAccResourceHardwareMappingPCIValidInputMinimal(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations with only the minimum amount of attributes being set.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_pci" "test" {
						name    = "%s"
						map     = [
							{
								id   = "%s"
								node = "%s"
								path = "%s"
							},
						]
					}
					`,
						data.Names[0],
						data.MapDeviceIDs[0],
						te.NodeName,
						data.MapPathsPCI[0],
					),
					ConfigStateChecks: []statecheck.StateCheck{
						// Optional attributes should all be unset.
						statecheck.ExpectKnownValue(
							accTestHardwareMappingNamePCI,
							tfjsonpath.New("map").AtSliceIndex(0),
							knownvalue.MapPartial(
								map[string]knownvalue.Check{
									"comment":      knownvalue.Null(),
									"iommu_group":  knownvalue.Null(),
									"subsystem_id": knownvalue.Null(),
								},
							),
						),
					},
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNamePCI, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNamePCI, "map.*", map[string]string{
								"id":   data.MapDeviceIDs[0],
								"node": te.NodeName,
								"path": data.MapPathsPCI[0],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "name", data.Names[0]),
					),
				},

				// Test the "ImportState" implementation.
				{
					ImportState:       true,
					ImportStateId:     data.Names[0],
					ImportStateVerify: true,
					ResourceName:      accTestHardwareMappingNamePCI,
				},

				// Test the "Update" implementation by setting all previously undefined attributes.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_pci" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment      = "%s"
								id           = "%s"
								iommu_group  = %d
								node         = "%s"
								path         = "%s"
								subsystem_id = "%s"
							},
						]
						mediated_devices = %t
					}
					`,
						data.Comments[1],
						data.Names[0],
						data.MapComments[1],
						data.MapDeviceIDs[0],
						data.MapIOMMUGroups[1],
						te.NodeName,
						data.MapPathsPCI[1],
						data.MapSubsystemIDs[1],
						!data.MediatedDevices,
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "comment", data.Comments[1]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNamePCI, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNamePCI, "map.*", map[string]string{
								"comment":      data.MapComments[1],
								"id":           data.MapDeviceIDs[0],
								"iommu_group":  strconv.Itoa(int(data.MapIOMMUGroups[1])),
								"node":         te.NodeName,
								"path":         data.MapPathsPCI[1],
								"subsystem_id": data.MapSubsystemIDs[1],
							},
						),
						resource.TestCheckResourceAttr(
							accTestHardwareMappingNamePCI,
							"mediated_devices",
							strconv.FormatBool(!data.MediatedDevices),
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNamePCI, "name", data.Names[0]),
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingPCIInvalidInput runs tests for PCI hardware mapping resource definitions with invalid
// input where all possible attributes are
// specified.
// Only the "Create" method implementation of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource]
// interface is tested in sequential steps.
func TestAccResourceHardwareMappingPCIInvalidInput(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" method implementation where all possible attributes are specified, but an error is expected
				// when using an invalid device path.
				{
					ExpectError: regexp.MustCompile(
						fmt.Sprintf(
							// The error line is, for whatever reason, broken down into multiple lines in acceptance tests, so we need
							// to capture newline characters.
							// Note that the regular expression syntax used by Go does not capture newlines with the "." matcher,
							// so we need to enable the "s" flag that enabled "."
							// to match "\n".
							// References:
							//   1. https://pkg.go.dev/regexp/syntax
							`(?s).*%s(?s).*`,
							`not a valid Linux device path for hardware mapping of type "`+proxmoxtypes.TypePCI.String()+`"`,
						),
					),
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_pci" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment      = "%s"
								id           = "%s"
								iommu_group  = %d
								node         = "%s"
								# Only valid Linux PCI device paths should pass the verification.
								path         = "wxyz:1337"
								subsystem_id = "%s"
							},
						]
						mediated_devices = %t
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.Comments[1],
						data.MapDeviceIDs[0],
						data.MapIOMMUGroups[0],
						te.NodeName,
						data.MapSubsystemIDs[0],
						data.MediatedDevices,
					),
				},
			},
		},
	)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" method implementation where all possible attributes are specified, but an error is expected
				// when using an invalid device subsystem
				// ID.
				{
					ExpectError: regexp.MustCompile(fmt.Sprintf(`.*%s.*`, validators.HardwareMappingDeviceIDValidatorErrMessage)),
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_pci" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment      = "%s"
								id           = "%s"
								iommu_group  = %d
								node         = "%s"
								path         = "%s"
								# Only valid Linux device subsystem IDs should pass the verification.
								subsystem_id = "x1y2:1337"
							},
						]
						mediated_devices = %t
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.Comments[1],
						data.MapDeviceIDs[0],
						data.MapIOMMUGroups[0],
						te.NodeName,
						data.MapPathsPCI[0],
						data.MediatedDevices,
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingUSBValidInput runs tests for USB hardware mapping resource definitions with valid input
// where all possible attributes are
// specified.
// All implementations of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested
// in sequential steps.
func TestAccResourceHardwareMappingUSBValidInput(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations where all possible attributes are specified.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_usb" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment = "%s"
								id      = "%s"
								node    = "%s"
								path    = "%s"
							},
						]
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.MapComments[0],
						data.MapDeviceIDs[0],
						te.NodeName,
						data.MapPathsUSB[0],
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "comment", data.Comments[0]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameUSB, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameUSB, "map.*", map[string]string{
								"comment": data.MapComments[0],
								"id":      data.MapDeviceIDs[0],
								"node":    te.NodeName,
								"path":    data.MapPathsUSB[0],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "name", data.Names[0]),
					),
				},

				// Test the "ImportState" implementation and ensure that PCI-only attributes are not set.
				{
					ImportState:       true,
					ImportStateId:     data.Names[0],
					ImportStateVerify: true,
					ResourceName:      accTestHardwareMappingNameUSB,
				},

				// Test the "Update" implementation where all possible attributes are specified.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_usb" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment = "%s"
								id      = "%s"
								node    = "%s"
								path    = "%s"
							},
						]
					}
					`,
						data.Comments[1],
						data.Names[0],
						data.MapComments[1],
						data.MapDeviceIDs[0],
						te.NodeName,
						data.MapPathsUSB[1],
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "comment", data.Comments[1]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameUSB, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameUSB, "map.*", map[string]string{
								"comment": data.MapComments[1],
								"id":      data.MapDeviceIDs[0],
								"node":    te.NodeName,
								"path":    data.MapPathsUSB[1],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "name", data.Names[0]),
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingUSBValidInputMinimal runs tests for USB hardware mapping resource definitions with
// valid input that only have the minimum
// amount of attributes set to test computed and default values within the resulting plan and state. The last step sets
// the undefined values to test the update
// logic.
// All implementations of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested
// in sequential steps.
func TestAccResourceHardwareMappingUSBValidInputMinimal(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations with only the minimum amount of attributes being set.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_usb" "test" {
						name    = "%s"
						map     = [
							{
								id   = "%s"
								node = "%s"
							},
						]
					}
					`,
						data.Names[0],
						data.MapDeviceIDs[0],
						te.NodeName,
					),
					ConfigStateChecks: []statecheck.StateCheck{
						// Optional attributes should all be unset.
						statecheck.ExpectKnownValue(
							accTestHardwareMappingNameUSB,
							tfjsonpath.New("map").AtSliceIndex(0),
							knownvalue.MapPartial(
								map[string]knownvalue.Check{
									"path": knownvalue.Null(),
								},
							),
						),
					},
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameUSB, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameUSB, "map.*", map[string]string{
								"id":   data.MapDeviceIDs[0],
								"node": te.NodeName,
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "name", data.Names[0]),
					),
				},

				// Test the "Update" implementation by setting all previously undefined attributes.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_usb" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment = "%s"
								id      = "%s"
								node    = "%s"
								path    = "%s"
							},
						]
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.Comments[1],
						data.MapDeviceIDs[1],
						te.NodeName,
						data.MapPathsUSB[0],
					),
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "comment", data.Comments[0]),
						resource.TestCheckResourceAttrSet(accTestHardwareMappingNameUSB, "id"),
						resource.TestCheckTypeSetElemNestedAttrs(
							accTestHardwareMappingNameUSB, "map.*", map[string]string{
								"comment": data.Comments[1],
								"id":      data.MapDeviceIDs[1],
								"node":    te.NodeName,
								"path":    data.MapPathsUSB[0],
							},
						),
						resource.TestCheckResourceAttr(accTestHardwareMappingNameUSB, "name", data.Names[0]),
					),
				},
			},
		},
	)
}

// TestAccResourceHardwareMappingUSBInvalidInput runs tests for USB hardware mapping resource definitions where all
// possible attributes are specified.
// Only the "Create" method implementation of the [github.com/hashicorp/terraform-plugin-framework/resource.Resource]
// interface is tested in sequential steps.
func TestAccResourceHardwareMappingUSBInvalidInput(t *testing.T) {
	data, te := testAccResourceHardwareMappingInit(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" method implementation where all possible attributes are specified, but an error is expected
				// when using an invalid device path.
				{
					Config: fmt.Sprintf(
						`
					resource "proxmox_virtual_environment_hardware_mapping_usb" "test" {
						comment = "%s"
						name    = "%s"
						map     = [
							{
								comment = "%s"
								id      = "%s"
								node    = "%s"
								# Only valid Linux USB device paths should pass the verification.
								path    = "xyz3:1337foobar"
							},
						]
					}
					`,
						data.Comments[0],
						data.Names[0],
						data.Comments[1],
						data.MapDeviceIDs[0],
						te.NodeName,
					),
					ExpectError: regexp.MustCompile(`valid Linux device path for hardware mapping of type "usb"`),
				},
			},
		},
	)
}
`````

## File: fwprovider/cluster/hardwaremapping/resource_pci.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	mappings "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the resource implements the required interfaces.
var (
	_ resource.Resource                = &pciResource{}
	_ resource.ResourceWithConfigure   = &pciResource{}
	_ resource.ResourceWithImportState = &pciResource{}
)

// pciResource contains the PCI hardware mapping resource's internal data.
type pciResource struct {
	// client is the hardware mapping API client.
	client *mappings.Client
}

// read reads information about a PCI hardware mapping from the Proxmox VE API.
func (r *pciResource) read(ctx context.Context, hm *modelPCI) (bool, diag.Diagnostics) {
	diags := diag.Diagnostics{}

	hmName := hm.Name.ValueString()

	data, err := r.client.Get(ctx, proxmoxtypes.TypePCI, hmName)
	if err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			diags.AddError("Could not read PCI hardware mapping", err.Error())
		}

		return false, diags
	}

	hm.importFromAPI(ctx, data)

	return true, nil
}

// readBack reads information about a created or modified PCI hardware mapping from the Proxmox VE API then updates the
// response state accordingly.
// The Terraform resource identifier must have been set in the state before this method is called!
func (r *pciResource) readBack(ctx context.Context, hm *modelPCI, respDiags *diag.Diagnostics, respState *tfsdk.State) {
	found, diags := r.read(ctx, hm)

	respDiags.Append(diags...)

	if !found {
		respDiags.AddError(
			"PCI hardware mapping resource not found after update",
			"Failed to find the resource when trying to read back the updated PCI hardware mapping's data.",
		)
	}

	if !respDiags.HasError() {
		respDiags.Append(respState.Set(ctx, *hm)...)
	}
}

// Configure adds the provider-configured client to the resource.
func (r *pciResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().HardwareMapping()
}

// Create creates a new PCI hardware mapping.
func (r *pciResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var hm modelPCI

	resp.Diagnostics.Append(req.Plan.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmName := hm.Name.ValueString()
	// Ensure to keep both in sync since the name represents the ID.
	hm.ID = hm.Name

	if err := r.client.Create(ctx, proxmoxtypes.TypePCI, hm.toCreateRequest()); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not create PCI hardware mapping %q.", hmName),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &hm, &resp.Diagnostics, &resp.State)
}

// Delete deletes an existing PCI hardware mapping.
func (r *pciResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var hm modelPCI

	resp.Diagnostics.Append(req.State.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmID := hm.Name.ValueString()

	if err := r.client.Delete(ctx, proxmoxtypes.TypePCI, hmID); err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			resp.Diagnostics.AddWarning(
				"PCI hardware mapping does not exist",
				fmt.Sprintf(
					"Could not delete PCI hardware mapping %q, it does not exist or has been deleted outside of Terraform.",
					hmID,
				),
			)
		} else {
			resp.Diagnostics.AddError(fmt.Sprintf("Could not delete PCI hardware mapping %q.", hmID), err.Error())
		}
	}
}

// ImportState imports a PCI hardware mapping from the Proxmox VE API.
func (r *pciResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	data := modelPCI{
		ID:   types.StringValue(req.ID),
		Name: types.StringValue(req.ID),
	}

	resource.ImportStatePassthroughID(ctx, path.Root(schemaAttrNameTerraformID), req, resp)
	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// Metadata defines the name of the PCI hardware mapping.
func (r *pciResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mapping_pci"
}

// Read reads the PCI hardware mapping.
func (r *pciResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data modelPCI

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Schema defines the schema for the PCI hardware mapping.
func (r *pciResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	comment := resourceSchemaBaseAttrComment
	comment.Description = "The comment of this PCI hardware mapping."
	commentMap := comment
	commentMap.Description = "The comment of the mapped PCI device."

	resp.Schema = schema.Schema{
		Description: "Manages a PCI hardware mapping in a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameComment: comment,
			schemaAttrNameMap: schema.SetNestedAttribute{
				Description: "The actual map of devices for the PCI hardware mapping.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameComment: commentMap,
						schemaAttrNameMapDeviceID: schema.StringAttribute{
							Description: "The ID of the map.",
							Required:    true,
							Validators: []validator.String{
								validators.HardwareMappingDeviceIDValidator(),
							},
						},
						schemaAttrNameMapIOMMUGroup: schema.Int64Attribute{
							Description: "The IOMMU group of the map. Not mandatory for the Proxmox VE API call, " +
								"but causes a PCI hardware mapping to be incomplete when not set",
							Optional: true,
						},
						schemaAttrNameMapNode: schema.StringAttribute{
							Description: "The node name of the map.",
							Required:    true,
						},
						schemaAttrNameMapPath: schema.StringAttribute{
							CustomType:  customtypes.PathType{},
							Description: "The path of the map.",
							// For hardware mappings of type PCI, the path is required while it is optional for USB.
							Required: true,
							Validators: []validator.String{
								stringvalidator.RegexMatches(
									customtypes.PathPCIValueRegEx,
									ErrResourceMessageInvalidPath(proxmoxtypes.TypePCI),
								),
							},
						},
						schemaAttrNameMapSubsystemID: schema.StringAttribute{
							Description: "The subsystem ID group of the map. Not mandatory for the Proxmox VE API call, " +
								"but causes a PCI hardware mapping to be incomplete when not set",
							Optional: true,
							Validators: []validator.String{
								validators.HardwareMappingDeviceIDValidator(),
							},
						},
					},
				},
				Required: true,
				Validators: []validator.Set{
					setvalidator.SizeAtLeast(1),
				},
			},
			schemaAttrNameMediatedDevices: schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: "Indicates whether to enable mediated devices.",
			},
			schemaAttrNameName: schema.StringAttribute{
				Description: "The name of this PCI hardware mapping.",
				Required:    true,
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this PCI hardware mapping resource.",
			),
		},
	}
}

// Update updates an existing PCI hardware mapping.
func (r *pciResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var hmCurrent, hmPlan modelPCI

	resp.Diagnostics.Append(req.Plan.Get(ctx, &hmPlan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &hmCurrent)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmName := hmPlan.Name.ValueString()

	if err := r.client.Update(
		ctx,
		proxmoxtypes.TypePCI,
		hmName,
		hmPlan.toUpdateRequest(&hmCurrent),
	); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not update PCI hardware mapping %q.", hmName),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &hmPlan, &resp.Diagnostics, &resp.State)
}

// NewPCIResource returns a new resource for managing a PCI hardware mapping.
// This is a helper function to simplify the provider implementation.
func NewPCIResource() resource.Resource {
	return &pciResource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/resource_usb.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/hardwaremapping"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	mappings "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the resource implements the required interfaces.
var (
	_ resource.Resource                = &usbResource{}
	_ resource.ResourceWithConfigure   = &usbResource{}
	_ resource.ResourceWithImportState = &usbResource{}
)

// usbResource contains the USB hardware mapping resource's internal data.
type usbResource struct {
	// client is the hardware mapping API client.
	client *mappings.Client
}

// read reads information about a USB hardware mapping from the Proxmox VE API.
func (r *usbResource) read(ctx context.Context, hm *modelUSB) (bool, diag.Diagnostics) {
	diags := diag.Diagnostics{}

	hmName := hm.Name.ValueString()

	data, err := r.client.Get(ctx, proxmoxtypes.TypeUSB, hmName)
	if err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			diags.AddError("Could not read USB hardware mapping", err.Error())
		}

		return false, diags
	}

	hm.importFromAPI(ctx, data)

	return true, nil
}

// readBack reads information about a created or modified USB hardware mapping from the Proxmox VE API then updates the
// response state accordingly.
// The Terraform resource identifier must have been set in the state before this method is called!
func (r *usbResource) readBack(ctx context.Context, hm *modelUSB, respDiags *diag.Diagnostics, respState *tfsdk.State) {
	found, diags := r.read(ctx, hm)

	respDiags.Append(diags...)

	if !found {
		respDiags.AddError(
			"USB hardware mapping resource not found after update",
			"Failed to find the resource when trying to read back the updated USB hardware mapping's data.",
		)
	}

	if !respDiags.HasError() {
		respDiags.Append(respState.Set(ctx, *hm)...)
	}
}

// Configure adds the provider-configured client to the resource.
func (r *usbResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().HardwareMapping()
}

// Create creates a new USB hardware mapping.
func (r *usbResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var hm modelUSB

	resp.Diagnostics.Append(req.Plan.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmName := hm.Name.ValueString()
	// Ensure to keep both in sync since the name represents the ID.
	hm.ID = hm.Name

	apiReq := hm.toCreateRequest()

	if err := r.client.Create(ctx, proxmoxtypes.TypeUSB, apiReq); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not create USB hardware mapping %q.", hmName),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &hm, &resp.Diagnostics, &resp.State)
}

// Delete deletes an existing USB hardware mapping.
func (r *usbResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var hm modelUSB

	resp.Diagnostics.Append(req.State.Get(ctx, &hm)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmID := hm.Name.ValueString()

	if err := r.client.Delete(ctx, proxmoxtypes.TypeUSB, hmID); err != nil {
		if strings.Contains(err.Error(), "no such resource") {
			resp.Diagnostics.AddWarning(
				"USB hardware mapping does not exist",
				fmt.Sprintf(
					"Could not delete USB hardware mapping %q, it does not exist or has been deleted outside of Terraform.",
					hmID,
				),
			)
		} else {
			resp.Diagnostics.AddError(fmt.Sprintf("Could not delete USB hardware mapping %q.", hmID), err.Error())
		}
	}
}

// ImportState imports a USB hardware mapping from the Proxmox VE API.
func (r *usbResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	data := modelUSB{
		ID:   types.StringValue(req.ID),
		Name: types.StringValue(req.ID),
	}

	resource.ImportStatePassthroughID(ctx, path.Root(schemaAttrNameTerraformID), req, resp)
	r.readBack(ctx, &data, &resp.Diagnostics, &resp.State)
}

// Metadata defines the name of the USB hardware mapping.
func (r *usbResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hardware_mapping_usb"
}

// Read reads the USB hardware mapping.
//

func (r *usbResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data modelUSB

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Schema defines the schema for the USB hardware mapping.
func (r *usbResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	comment := resourceSchemaBaseAttrComment
	comment.Description = "The comment of this USB hardware mapping."
	commentMap := comment
	commentMap.Description = "The comment of the mapped USB device."

	resp.Schema = schema.Schema{
		Description: "Manages a USB hardware mapping in a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			schemaAttrNameComment: comment,
			schemaAttrNameMap: schema.SetNestedAttribute{
				Description: "The actual map of devices for the hardware mapping.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						schemaAttrNameComment: commentMap,
						schemaAttrNameMapDeviceID: schema.StringAttribute{
							Description: "The ID of the map.",
							Required:    true,
							Validators: []validator.String{
								validators.HardwareMappingDeviceIDValidator(),
							},
						},
						schemaAttrNameMapNode: schema.StringAttribute{
							Description: "The node name of the map.",
							Required:    true,
						},
						schemaAttrNameMapPath: schema.StringAttribute{
							CustomType: customtypes.PathType{},
							Description: "The path of the map. For hardware mappings of type USB the path is optional and indicates" +
								" that the device is mapped through the device ID instead of ports.",
							Optional: true,
							Validators: []validator.String{
								stringvalidator.RegexMatches(
									customtypes.PathUSBValueRegEx,
									ErrResourceMessageInvalidPath(proxmoxtypes.TypeUSB),
								),
							},
						},
					},
				},
				Required: true,
				Validators: []validator.Set{
					setvalidator.SizeAtLeast(1),
				},
			},
			schemaAttrNameName: schema.StringAttribute{
				Description: "The name of this hardware mapping.",
				Required:    true,
			},
			schemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this USB hardware mapping resource.",
			),
		},
	}
}

// Update updates an existing USB hardware mapping.
func (r *usbResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var hmCurrent, hmPlan modelUSB

	resp.Diagnostics.Append(req.Plan.Get(ctx, &hmPlan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &hmCurrent)...)

	if resp.Diagnostics.HasError() {
		return
	}

	hmName := hmPlan.Name.ValueString()

	apiReq := hmPlan.toUpdateRequest(&hmCurrent)

	if err := r.client.Update(ctx, proxmoxtypes.TypeUSB, hmName, apiReq); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not update USB hardware mapping %q.", hmName),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &hmPlan, &resp.Diagnostics, &resp.State)
}

// NewUSBResource returns a new resource for managing a USB hardware mapping.
// This is a helper function to simplify the provider implementation.
func NewUSBResource() resource.Resource {
	return &usbResource{}
}
`````

## File: fwprovider/cluster/hardwaremapping/shared.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	datasourceschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	resourceschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

//nolint:gochecknoglobals
var (
	// dataSourceSchemaBaseAttrComment is the base comment attribute for a hardware mapping data source.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	dataSourceSchemaBaseAttrComment = datasourceschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthAtLeast(1),
			stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
			stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
		},
	}

	// dataSourceSchemaBaseAttrComment is the base comment attribute for a hardware mapping resource.
	// Note that the Proxmox VE API attribute is named "description", but we map it as a comment since this naming is
	// generally across the Proxmox VE web UI and API documentations. This still follows the [Terraform "best practices"]
	// as it improves the user experience by matching the field name to the naming used in the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	resourceSchemaBaseAttrComment = resourceschema.StringAttribute{
		Optional: true,
		Validators: []validator.String{
			stringvalidator.UTF8LengthAtLeast(1),
			stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
			stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
		},
	}
)
`````

## File: fwprovider/cluster/metrics/datasource_metrics_server.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/metrics"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &metricsServerDatasource{}
	_ datasource.DataSourceWithConfigure = &metricsServerDatasource{}
)

type metricsServerDatasource struct {
	client *metrics.Client
}

// NewMetricsServerDatasource creates new metrics server data source.
func NewMetricsServerDatasource() datasource.DataSource {
	return &metricsServerDatasource{}
}

func (r *metricsServerDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_metrics_server"
}

func (r *metricsServerDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *proxmox.Client, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().Metrics()
}

func (r *metricsServerDatasource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves information about a specific PVE metric server.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"name": schema.StringAttribute{
				Description: "Unique name that will be ID of this metric server in PVE.",
				Required:    true,
			},
			"disable": schema.BoolAttribute{
				Description: "Indicates if the metric server is disabled.",
				Computed:    true,
			},
			"port": schema.Int64Attribute{
				Description: "Server network port.",
				Computed:    true,
			},
			"server": schema.StringAttribute{
				Description: "Server dns name or IP address.",
				Computed:    true,
			},
			"type": schema.StringAttribute{
				Description: "Plugin type. Either `graphite` or `influxdb`.",
				Computed:    true,
			},
		},
	}
}

func (r *metricsServerDatasource) Read(
	ctx context.Context,
	req datasource.ReadRequest,
	resp *datasource.ReadResponse,
) {
	var state metricsServerDatasourceModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	state.ID = state.Name

	data, err := r.client.GetServer(ctx, state.ID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Refresh Resource",
			"An unexpected error occurred while attempting to refresh datasource state. "+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				"Error: "+err.Error(),
		)

		return
	}

	readModel := &metricsServerDatasourceModel{}
	readModel.importFromAPI(state.ID.ValueString(), data)

	resp.Diagnostics.Append(resp.State.Set(ctx, readModel)...)
}
`````

## File: fwprovider/cluster/metrics/metrics_server_model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics

import (
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/metrics"
)

type metricsServerModel struct {
	ID                  types.String `tfsdk:"id"`
	Name                types.String `tfsdk:"name"`
	Disable             types.Bool   `tfsdk:"disable"`
	MTU                 types.Int64  `tfsdk:"mtu"`
	Port                types.Int64  `tfsdk:"port"`
	Server              types.String `tfsdk:"server"`
	Timeout             types.Int64  `tfsdk:"timeout"`
	Type                types.String `tfsdk:"type"`
	InfluxAPIPathPrefix types.String `tfsdk:"influx_api_path_prefix"`
	InfluxBucket        types.String `tfsdk:"influx_bucket"`
	InfluxDBProto       types.String `tfsdk:"influx_db_proto"`
	InfluxMaxBodySize   types.Int64  `tfsdk:"influx_max_body_size"`
	InfluxOrganization  types.String `tfsdk:"influx_organization"`
	InfluxToken         types.String `tfsdk:"influx_token"`
	InfluxVerify        types.Bool   `tfsdk:"influx_verify"`
	GraphitePath        types.String `tfsdk:"graphite_path"`
	GraphiteProto       types.String `tfsdk:"graphite_proto"`
}

func boolToInt64Ptr(boolPtr *bool) *int64 {
	if boolPtr != nil {
		var result int64

		if *boolPtr {
			result = int64(1)
		} else {
			result = int64(0)
		}

		return &result
	}

	return nil
}

func int64ToBoolPtr(int64ptr *int64) *bool {
	if int64ptr != nil {
		var result bool

		if *int64ptr == 0 {
			result = false
		} else {
			result = true
		}

		return &result
	}

	return nil
}

// importFromAPI takes data from metrics server PVE API response and set fields based on it.
// Note: API response does not contain name so it must be passed directly.
func (m *metricsServerModel) importFromAPI(name string, data *metrics.ServerData) {
	m.ID = types.StringValue(name)
	m.Name = types.StringValue(name)

	m.Disable = types.BoolPointerValue(int64ToBoolPtr(data.Disable))
	m.MTU = types.Int64PointerValue(data.MTU)
	m.Port = types.Int64Value(data.Port)
	m.Server = types.StringValue(data.Server)
	m.Timeout = types.Int64PointerValue(data.Timeout)
	m.Type = types.StringPointerValue(data.Type)
	m.InfluxAPIPathPrefix = types.StringPointerValue(data.APIPathPrefix)
	m.InfluxBucket = types.StringPointerValue(data.Bucket)
	m.InfluxDBProto = types.StringPointerValue(data.InfluxDBProto)
	m.InfluxMaxBodySize = types.Int64PointerValue(data.MaxBodySize)
	m.InfluxOrganization = types.StringPointerValue(data.Organization)
	m.InfluxToken = types.StringPointerValue(data.Token)
	m.InfluxVerify = types.BoolPointerValue(int64ToBoolPtr(data.Verify))
	m.GraphitePath = types.StringPointerValue(data.Path)
	m.GraphiteProto = types.StringPointerValue(data.Proto)
}

// toAPIRequestBody creates metrics server request data for PUT and POST requests.
func (m *metricsServerModel) toAPIRequestBody() *metrics.ServerRequestData {
	data := &metrics.ServerRequestData{}

	data.ID = m.Name.ValueString()

	data.Disable = boolToInt64Ptr(m.Disable.ValueBoolPointer())
	data.MTU = m.MTU.ValueInt64Pointer()
	data.Port = m.Port.ValueInt64()
	data.Server = m.Server.ValueString()
	data.Timeout = m.Timeout.ValueInt64Pointer()
	data.Type = m.Type.ValueStringPointer()
	data.APIPathPrefix = m.InfluxAPIPathPrefix.ValueStringPointer()
	data.Bucket = m.InfluxBucket.ValueStringPointer()
	data.InfluxDBProto = m.InfluxDBProto.ValueStringPointer()
	data.MaxBodySize = m.InfluxMaxBodySize.ValueInt64Pointer()
	data.Organization = m.InfluxOrganization.ValueStringPointer()
	data.Token = m.InfluxToken.ValueStringPointer()
	data.Verify = boolToInt64Ptr(m.InfluxVerify.ValueBoolPointer())
	data.Path = m.GraphitePath.ValueStringPointer()
	data.Proto = m.GraphiteProto.ValueStringPointer()

	return data
}

type metricsServerDatasourceModel struct {
	ID      types.String `tfsdk:"id"`
	Name    types.String `tfsdk:"name"`
	Disable types.Bool   `tfsdk:"disable"`
	Port    types.Int64  `tfsdk:"port"`
	Server  types.String `tfsdk:"server"`
	Type    types.String `tfsdk:"type"`
}

// importFromAPI takes data from metrics server PVE API response and set fields based on it.
// Note: API response does not contain name so it must be passed directly.
func (m *metricsServerDatasourceModel) importFromAPI(name string, data *metrics.ServerData) {
	m.ID = types.StringValue(name)
	m.Name = types.StringValue(name)

	m.Disable = types.BoolPointerValue(int64ToBoolPtr(data.Disable))
	m.Port = types.Int64Value(data.Port)
	m.Server = types.StringValue(data.Server)
	m.Type = types.StringPointerValue(data.Type)
}
`````

## File: fwprovider/cluster/metrics/resource_metrics_server_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics_test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccResourceMetricsServer(t *testing.T) {
	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create influxdb udp server & update it & again to default mtu", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_metrics_server" "acc_influxdb_server" {
					name   = "acc_example_influxdb_server"
					server = "192.168.3.2"
					port   = 18089
					type   = "influxdb"
					mtu    = 1000
				  }`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_metrics_server.acc_influxdb_server", map[string]string{
						"id":     "acc_example_influxdb_server",
						"name":   "acc_example_influxdb_server",
						"mtu":    "1000",
						"port":   "18089",
						"server": "192.168.3.2",
						"type":   "influxdb",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_metrics_server.acc_influxdb_server", []string{
						"disable",
						"timeout",
						"influx_api_path_prefix",
						"influx_bucket",
						"influx_db_proto",
						"influx_max_body_size",
						"influx_organization",
						"influx_token",
						"influx_verify",
						"graphite_path",
						"graphite_proto",
					}),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_metrics_server" "acc_influxdb_server" {
					name   			 = "acc_example_influxdb_server"
					server 			 = "192.168.3.2"
					port   			 = 18089
					type   			 = "influxdb"
					mtu    			 = 1000
					influx_bucket    = "xxxxx"
				  }`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_metrics_server.acc_influxdb_server", map[string]string{
						"id":            "acc_example_influxdb_server",
						"name":          "acc_example_influxdb_server",
						"mtu":           "1000",
						"port":          "18089",
						"server":        "192.168.3.2",
						"type":          "influxdb",
						"influx_bucket": "xxxxx",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_metrics_server.acc_influxdb_server", []string{
						"disable",
						"timeout",
						"influx_api_path_prefix",
						"influx_db_proto",
						"influx_max_body_size",
						"influx_organization",
						"influx_token",
						"influx_verify",
						"graphite_path",
						"graphite_proto",
					}),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_metrics_server" "acc_influxdb_server" {
					name   			 = "acc_example_influxdb_server"
					server 			 = "192.168.3.2"
					port   			 = 18089
					type   			 = "influxdb"
					influx_bucket    = "xxxxx"
				  }`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_metrics_server.acc_influxdb_server", map[string]string{
						"id":            "acc_example_influxdb_server",
						"name":          "acc_example_influxdb_server",
						"port":          "18089",
						"server":        "192.168.3.2",
						"type":          "influxdb",
						"influx_bucket": "xxxxx",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_metrics_server.acc_influxdb_server", []string{
						"disable",
						"timeout",
						"mtu",
						"influx_api_path_prefix",
						"influx_db_proto",
						"influx_max_body_size",
						"influx_organization",
						"influx_token",
						"influx_verify",
						"graphite_path",
						"graphite_proto",
					}),
				),
			},
		}},
		{"create graphite udp metrics server & import it", []resource.TestStep{
			{
				ResourceName: "proxmox_virtual_environment_metrics_server.acc_graphite_server",
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_metrics_server" "acc_graphite_server" {
					name   = "acc_example_graphite_server"
					server = "192.168.3.2"
					port   = 18089
					type   = "graphite"
				  }`),
			},
			{
				ResourceName:      "proxmox_virtual_environment_metrics_server.acc_graphite_server",
				ImportState:       true,
				ImportStateVerify: true,
			},
		}},
		{"create graphite udp metrics server & test datasource", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_metrics_server" "acc_graphite_server2" {
					name   = "acc_example_graphite_server2"
					server = "192.168.3.2"
					port   = 18089
					type   = "graphite"
				  }
				data "proxmox_virtual_environment_metrics_server" "acc_graphite_server2" {
					name = proxmox_virtual_environment_metrics_server.acc_graphite_server2.name
				  }`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("data.proxmox_virtual_environment_metrics_server.acc_graphite_server2", map[string]string{
						"id":     "acc_example_graphite_server2",
						"name":   "acc_example_graphite_server2",
						"port":   "18089",
						"server": "192.168.3.2",
						"type":   "graphite",
					}),
				),
			},
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/cluster/metrics/resource_metrics_server.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics

import (
	"context"
	"errors"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/metrics"
)

var (
	_ resource.Resource                = &metricsServerResource{}
	_ resource.ResourceWithConfigure   = &metricsServerResource{}
	_ resource.ResourceWithImportState = &metricsServerResource{}
)

type metricsServerResource struct {
	client *metrics.Client
}

// NewMetricsServerResource creates new metrics server resource.
func NewMetricsServerResource() resource.Resource {
	return &metricsServerResource{}
}

func (r *metricsServerResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_metrics_server"
}

func (r *metricsServerResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *proxmox.Client, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client.Cluster().Metrics()
}

func (r *metricsServerResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages PVE metrics server.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"name": schema.StringAttribute{
				Description: "Unique name that will be ID of this metric server in PVE.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"disable": schema.BoolAttribute{
				Description: "Set this to `true` to disable this metric server.",
				Optional:    true,
				Default:     nil,
			},
			"mtu": schema.Int64Attribute{
				Description: "MTU (maximum transmission unit) for metrics transmission over UDP. " +
					"If not set, PVE default is `1500` (allowed `512` - `65536`).",
				Validators: []validator.Int64{int64validator.Between(512, 65536)},
				Optional:   true,
				Default:    nil,
			},
			"port": schema.Int64Attribute{
				Description: "Server network port.",
				Required:    true,
				Validators:  []validator.Int64{int64validator.Between(1, 65536)},
			},
			"server": schema.StringAttribute{
				Description: "Server dns name or IP address.",
				Required:    true,
			},
			"timeout": schema.Int64Attribute{
				Description: "TCP socket timeout in seconds. If not set, PVE default is `1`.",
				Optional:    true,
				Default:     nil,
			},
			"type": schema.StringAttribute{
				Description: "Plugin type. Choice is between `graphite` | `influxdb`.",
				Required:    true,
				Validators:  []validator.String{stringvalidator.OneOf("graphite", "influxdb")},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"influx_api_path_prefix": schema.StringAttribute{
				Description: "An API path prefix inserted between `<host>:<port>/` and `/api2/`." +
					" Can be useful if the InfluxDB service runs behind a reverse proxy.",
				Optional: true,
				Default:  nil,
			},
			"influx_bucket": schema.StringAttribute{
				Description: "The InfluxDB bucket/db. Only necessary when using the http v2 api.",
				Optional:    true,
				Default:     nil,
			},
			"influx_db_proto": schema.StringAttribute{
				Description: "Protocol for InfluxDB. Choice is between `udp` | `http` | `https`. " +
					"If not set, PVE default is `udp`.",
				Validators: []validator.String{stringvalidator.OneOf("udp", "http", "https")},
				Optional:   true,
				Default:    nil,
			},
			"influx_max_body_size": schema.Int64Attribute{
				Description: "InfluxDB max-body-size in bytes. Requests are batched up to this " +
					"size. If not set, PVE default is `25000000`.",
				Optional: true,
				Default:  nil,
			},
			"influx_organization": schema.StringAttribute{
				Description: "The InfluxDB organization. Only necessary when using the http v2 " +
					"api. Has no meaning when using v2 compatibility api.",
				Optional: true,
				Default:  nil,
			},
			"influx_token": schema.StringAttribute{
				Description: "The InfluxDB access token. Only necessary when using the http v2 " +
					"api. If the v2 compatibility api is used, use `user:password` instead.",
				Optional:  true,
				Default:   nil,
				Sensitive: true,
			},
			"influx_verify": schema.BoolAttribute{
				Description: "Set to `false` to disable certificate verification for https " +
					"endpoints.",
				Optional: true,
				Default:  nil,
			},
			"graphite_path": schema.StringAttribute{
				Description: "Root graphite path (ex: `proxmox.mycluster.mykey`).",
				Optional:    true,
				Default:     nil,
			},
			"graphite_proto": schema.StringAttribute{
				Description: "Protocol to send graphite data. Choice is between `udp` | `tcp`. " +
					"If not set, PVE default is `udp`.",
				Validators: []validator.String{stringvalidator.OneOf("udp", "tcp")},
				Optional:   true,
				Default:    nil,
			},
		},
	}
}

func (r *metricsServerResource) Read(
	ctx context.Context,
	req resource.ReadRequest,
	resp *resource.ReadResponse,
) {
	var state metricsServerModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	data, err := r.client.GetServer(ctx, state.ID.ValueString())
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			resp.State.RemoveResource(ctx)

			return
		}

		resp.Diagnostics.AddError(
			"Unable to Refresh Resource",
			"An unexpected error occurred while attempting to refresh resource state. "+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				"Error: "+err.Error(),
		)

		return
	}

	readModel := &metricsServerModel{}
	readModel.importFromAPI(state.ID.ValueString(), data)

	resp.Diagnostics.Append(resp.State.Set(ctx, readModel)...)
}

func (r *metricsServerResource) Create(
	ctx context.Context,
	req resource.CreateRequest,
	resp *resource.CreateResponse,
) {
	var plan metricsServerModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	reqData := plan.toAPIRequestBody()

	err := r.client.CreateServer(ctx, reqData)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Create Resource",
			"An unexpected error occurred while creating the resource create request.\n\n"+
				"Error: "+err.Error(),
		)

		return
	}

	plan.ID = plan.Name

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func checkDelete(planField, stateField attr.Value, toDelete *[]string, apiName string) {
	// we need to remove field via api field if there is value in state
	// but someone decided to use PVE default and removed value from resource
	if planField.IsNull() && !stateField.IsNull() {
		*toDelete = append(*toDelete, apiName)
	}
}

func (r *metricsServerResource) Update(
	ctx context.Context,
	req resource.UpdateRequest,
	resp *resource.UpdateResponse,
) {
	var plan metricsServerModel

	var state metricsServerModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	var toDelete []string

	checkDelete(plan.Disable, state.Disable, &toDelete, "disable")
	checkDelete(plan.MTU, state.MTU, &toDelete, "mtu")
	checkDelete(plan.Timeout, state.Timeout, &toDelete, "timeout")
	checkDelete(plan.InfluxAPIPathPrefix, state.InfluxAPIPathPrefix, &toDelete, "api-path-prefix")
	checkDelete(plan.InfluxBucket, state.InfluxBucket, &toDelete, "bucket")
	checkDelete(plan.InfluxDBProto, state.InfluxDBProto, &toDelete, "influxdbproto")
	checkDelete(plan.InfluxMaxBodySize, state.InfluxMaxBodySize, &toDelete, "max-body-size")
	checkDelete(plan.InfluxOrganization, state.InfluxOrganization, &toDelete, "organization")
	checkDelete(plan.InfluxToken, state.InfluxToken, &toDelete, "token")
	checkDelete(plan.InfluxVerify, state.InfluxVerify, &toDelete, "verify-certificate")
	checkDelete(plan.GraphitePath, state.GraphitePath, &toDelete, "path")
	checkDelete(plan.GraphiteProto, state.GraphiteProto, &toDelete, "proto")

	reqData := plan.toAPIRequestBody()
	reqData.Delete = &toDelete

	err := r.client.UpdateServer(ctx, reqData)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Update Resource",
			"An unexpected error occurred while creating the resource update request.\n\n"+
				"Error: "+err.Error(),
		)

		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *metricsServerResource) Delete(
	ctx context.Context,
	req resource.DeleteRequest,
	resp *resource.DeleteResponse,
) {
	var state metricsServerModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.DeleteServer(ctx, state.ID.ValueString())
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			return
		}

		resp.Diagnostics.AddError(
			"Unable to Delete Resource",
			"An unexpected error occurred while creating the resource delete request.\n\n"+
				"Error: "+err.Error(),
		)

		return
	}
}

func (r *metricsServerResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	data, err := r.client.GetServer(ctx, req.ID)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			resp.Diagnostics.AddError(
				"Resource does not exist",
				"Resource you try to import does not exist.\n\n"+
					"Error: "+err.Error(),
			)

			return
		}

		resp.Diagnostics.AddError(
			"Unable to Import Resource",
			"An unexpected error occurred while attempting to import resource state.\n\n"+
				"Error: "+err.Error(),
		)

		return
	}

	readModel := &metricsServerModel{}
	readModel.importFromAPI(req.ID, data)

	resp.Diagnostics.Append(resp.State.Set(ctx, readModel)...)
}
`````

## File: fwprovider/cluster/options/resource_options_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package options_test

import (
	"fmt"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

const accTestClusterOptionsName = "proxmox_virtual_environment_cluster_options.test_options"

func TestAccResourceClusterOptions(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Create and Read testing
				{
					Config: testAccResourceClusterOptionsCreatedConfig(),
					Check:  testAccResourceClusterOptionsCreatedCheck(),
				},
				// ImportState testing
				{
					ResourceName:      accTestClusterOptionsName,
					ImportState:       true,
					ImportStateVerify: true,
				},
				// Update testing
				{
					Config: testAccResourceClusterOptionsUpdatedConfig(),
					Check:  testAccResourceClusterOptionsUpdatedCheck(),
				},
			},
		},
	)
}

func testAccResourceClusterOptionsCreatedConfig() string {
	return fmt.Sprintf(
		`
	resource "proxmox_virtual_environment_cluster_options" "test_options" {
		bandwidth_limit_default   = 666666
		bandwidth_limit_migration = 555554
		crs_ha                    = "static"
		email_from                = "example@example.com"
		ha_shutdown_policy        = "freeze"
		http_proxy                = "http://example.com"
		keyboard                  = "pl"
		language                  = "en"
		max_workers               = 5
		migration_cidr            = "10.0.0.0/8"
		migration_type            = "secure"
    bandwidth_limit_restore   = 777777
		next_id = {
		  lower = %d
			upper = %d
		}
		notify = {
      ha_fencing_mode            = "never"
      ha_fencing_target          = "default-matcher"
      package_updates            = "always"
      package_updates_target     = "default-matcher"
      replication        = "always"
      replication_target = "default-matcher"
    }
	}
	`,
		100,
		999999999,
	)
}

func testAccResourceClusterOptionsCreatedCheck() resource.TestCheckFunc {
	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "bandwidth_limit_default", "666666"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "bandwidth_limit_migration", "555554"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "bandwidth_limit_restore", "777777"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "crs_ha", "static"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "email_from", "example@example.com"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "ha_shutdown_policy", "freeze"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "http_proxy", "http://example.com"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "id", "cluster"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "keyboard", "pl"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "language", "en"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "max_workers", "5"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "migration_cidr", "10.0.0.0/8"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "migration_type", "secure"),
		resource.TestCheckResourceAttr(
			accTestClusterOptionsName,
			"next_id.lower",
			fmt.Sprintf("%d", 100),
		),
		resource.TestCheckResourceAttr(
			accTestClusterOptionsName,
			"next_id.upper",
			fmt.Sprintf("%d", 999999999),
		),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.ha_fencing_mode", "never"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.ha_fencing_target", "default-matcher"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.package_updates", "always"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.package_updates_target", "default-matcher"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.replication", "always"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.replication_target", "default-matcher"),
		resource.TestCheckNoResourceAttr(accTestClusterOptionsName, "bandwidth_limit_move"),
	)
}

func testAccResourceClusterOptionsUpdatedConfig() string {
	return `
  resource "proxmox_virtual_environment_cluster_options" "test_options" {
    bandwidth_limit_default   = 333333
    bandwidth_limit_migration = 111111
    email_from                = "ged@gont.earthsea"
    language                  = "en"
    max_workers               = 6
    migration_cidr            = "10.0.0.1/8"
    migration_type            = "secure"
		next_id = {
		  lower = 555
			upper = 666
		}
    notify = {
      ha_fencing_mode        = "always"
      ha_fencing_target      = "custom-matcher"
      package_updates        = "auto"
      package_updates_target = "custom-matcher"
      replication            = "never"
      replication_target     = "custom-matcher"
    }
  }
	`
}

func testAccResourceClusterOptionsUpdatedCheck() resource.TestCheckFunc {
	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "bandwidth_limit_default", "333333"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "bandwidth_limit_migration", "111111"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "email_from", "ged@gont.earthsea"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "id", "cluster"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "language", "en"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "max_workers", "6"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "migration_cidr", "10.0.0.1/8"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "migration_type", "secure"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "next_id.lower", "555"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "next_id.upper", "666"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.ha_fencing_mode", "always"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.ha_fencing_target", "custom-matcher"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.package_updates", "auto"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.package_updates_target", "custom-matcher"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.replication", "never"),
		resource.TestCheckResourceAttr(accTestClusterOptionsName, "notify.replication_target", "custom-matcher"),
		resource.TestCheckNoResourceAttr(accTestClusterOptionsName, "bandwidth_limit_move"),
		resource.TestCheckNoResourceAttr(accTestClusterOptionsName, "crs_ha"),
		resource.TestCheckNoResourceAttr(accTestClusterOptionsName, "ha_shutdown_policy"),
		resource.TestCheckNoResourceAttr(accTestClusterOptionsName, "http_proxy"),
		resource.TestCheckNoResourceAttr(accTestClusterOptionsName, "keyboard"),
	)
}
`````

## File: fwprovider/cluster/options/resource_options.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package options

import (
	"context"
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
)

const (
	// ClusterOptionsNextIDLowerMaximum is the maximum number for the "lower" range for the next VM ID option.
	// Note that this value is not documented in the section about the cluster options in the Proxmox VE API explorer but
	// [in the sections about QEMU (POST)] as well as [the dedicated Proxmox VE documentations about QEMU/KVM].
	//
	// [in the sections about QEMU (POST)]: https://pve.proxmox.com/pve-docs/api-viewer/#/nodes/{node}/qemu
	// [the dedicated Proxmox VE documentations about QEMU/KVM]: https://pve.proxmox.com/pve-docs/pve-admin-guide.html#_strong_qm_strong_qemu_kvm_virtual_machine_manager
	ClusterOptionsNextIDLowerMaximum = 999999999

	// ClusterOptionsNextIDLowerMinimum is the minimum number for the "lower" range for the next VM ID option.
	// Note that this value is not documented in the section about the cluster options in the Proxmox VE API explorer but
	// [in the sections about QEMU (POST)] as well as [the dedicated Proxmox VE documentations about QEMU/KVM].
	//
	// [in the sections about QEMU (POST)]: https://pve.proxmox.com/pve-docs/api-viewer/#/nodes/{node}/qemu
	// [the dedicated Proxmox VE documentations about QEMU/KVM]: https://pve.proxmox.com/pve-docs/pve-admin-guide.html#_strong_qm_strong_qemu_kvm_virtual_machine_manager
	ClusterOptionsNextIDLowerMinimum = 100
)

var (
	_ resource.Resource                = &clusterOptionsResource{}
	_ resource.ResourceWithConfigure   = &clusterOptionsResource{}
	_ resource.ResourceWithImportState = &clusterOptionsResource{}
)

type clusterOptionsModel struct {
	ID                      types.String               `tfsdk:"id"`
	BandwidthLimitClone     types.Int64                `tfsdk:"bandwidth_limit_clone"`
	BandwidthLimitDefault   types.Int64                `tfsdk:"bandwidth_limit_default"`
	BandwidthLimitMigration types.Int64                `tfsdk:"bandwidth_limit_migration"`
	BandwidthLimitMove      types.Int64                `tfsdk:"bandwidth_limit_move"`
	BandwidthLimitRestore   types.Int64                `tfsdk:"bandwidth_limit_restore"`
	Console                 types.String               `tfsdk:"console"`
	CrsHA                   types.String               `tfsdk:"crs_ha"`
	CrsHARebalanceOnStart   types.Bool                 `tfsdk:"crs_ha_rebalance_on_start"`
	Description             types.String               `tfsdk:"description"`
	EmailFrom               types.String               `tfsdk:"email_from"`
	HAShutdownPolicy        types.String               `tfsdk:"ha_shutdown_policy"`
	HTTPProxy               types.String               `tfsdk:"http_proxy"`
	Keyboard                types.String               `tfsdk:"keyboard"`
	Language                types.String               `tfsdk:"language"`
	MacPrefix               types.String               `tfsdk:"mac_prefix"`
	MaxWorkers              types.Int64                `tfsdk:"max_workers"`
	MigrationNetwork        types.String               `tfsdk:"migration_cidr"`
	MigrationType           types.String               `tfsdk:"migration_type"`
	NextID                  *clusterOptionsNextIDModel `tfsdk:"next_id"`
	Notify                  *clusterOptionsNotifyModel `tfsdk:"notify"`
}

type clusterOptionsNextIDModel struct {
	Lower types.Int64 `tfsdk:"lower"`
	Upper types.Int64 `tfsdk:"upper"`
}

type clusterOptionsNotifyModel struct {
	HAFencingMode        types.String `tfsdk:"ha_fencing_mode"`
	HAFencingTarget      types.String `tfsdk:"ha_fencing_target"`
	PackageUpdates       types.String `tfsdk:"package_updates"`
	PackageUpdatesTarget types.String `tfsdk:"package_updates_target"`
	Replication          types.String `tfsdk:"replication"`
	ReplicationTarget    types.String `tfsdk:"replication_target"`
}

// haData returns HA settings parameter string for API, HA settings are
// defined, otherwise empty string is returned.
func (m *clusterOptionsModel) haData() string {
	var haDataParams []string

	if !m.HAShutdownPolicy.IsNull() && m.HAShutdownPolicy.ValueString() != "" {
		haDataParams = append(haDataParams, fmt.Sprintf("shutdown_policy=%s", m.HAShutdownPolicy.ValueString()))
	}

	if len(haDataParams) > 0 {
		return strings.Join(haDataParams, ",")
	}

	return ""
}

// migrationData returns migration settings parameter string for API, if any of migration
// settings are defined, otherwise empty string is returned.
func (m *clusterOptionsModel) migrationData() string {
	var migrationDataParams []string

	if !m.MigrationType.IsNull() && m.MigrationType.ValueString() != "" {
		migrationDataParams = append(migrationDataParams, fmt.Sprintf("type=%s", m.MigrationType.ValueString()))
	}

	if !m.MigrationNetwork.IsNull() && m.MigrationNetwork.ValueString() != "" {
		migrationDataParams = append(migrationDataParams, fmt.Sprintf("network=%s", m.MigrationNetwork.ValueString()))
	}

	if len(migrationDataParams) > 0 {
		return strings.Join(migrationDataParams, ",")
	}

	return ""
}

// nextIDData returns settings for the "next-id" parameter string of the Proxmox VE API, if defined, otherwise an empty
// string is returned.
func (m *clusterOptionsModel) nextIDData() string {
	var nextIDDataParams []string

	if m.NextID == nil {
		return ""
	}

	if !m.NextID.Lower.IsNull() {
		nextIDDataParams = append(nextIDDataParams, fmt.Sprintf("lower=%d", m.NextID.Lower.ValueInt64()))
	}

	if !m.NextID.Upper.IsNull() {
		nextIDDataParams = append(nextIDDataParams, fmt.Sprintf("upper=%d", m.NextID.Upper.ValueInt64()))
	}

	if len(nextIDDataParams) > 0 {
		return strings.Join(nextIDDataParams, ",")
	}

	return ""
}

// notifyData returns settings for the "notify" parameter string of the Proxmox VE API, if defined, otherwise an empty
// string is returned.
func (m *clusterOptionsModel) notifyData() string {
	var notifyDataParams []string

	if m.Notify == nil {
		return ""
	}

	if !m.Notify.HAFencingMode.IsNull() {
		notifyDataParams = append(notifyDataParams, fmt.Sprintf("fencing=%s", m.Notify.HAFencingMode.ValueString()))
	}

	if !m.Notify.HAFencingTarget.IsNull() {
		notifyDataParams = append(
			notifyDataParams,
			fmt.Sprintf("target-fencing=%s", m.Notify.HAFencingTarget.ValueString()),
		)
	}

	if !m.Notify.PackageUpdates.IsNull() {
		notifyDataParams = append(
			notifyDataParams,
			fmt.Sprintf("package-updates=%s", m.Notify.PackageUpdates.ValueString()),
		)
	}

	if !m.Notify.PackageUpdatesTarget.IsNull() {
		notifyDataParams = append(
			notifyDataParams,
			fmt.Sprintf("target-package-updates=%s", m.Notify.PackageUpdatesTarget.ValueString()),
		)
	}

	if !m.Notify.Replication.IsNull() {
		notifyDataParams = append(notifyDataParams, fmt.Sprintf("replication=%s", m.Notify.Replication.ValueString()))
	}

	if !m.Notify.ReplicationTarget.IsNull() {
		notifyDataParams = append(
			notifyDataParams,
			fmt.Sprintf("target-replication=%s", m.Notify.ReplicationTarget.ValueString()),
		)
	}

	if len(notifyDataParams) > 0 {
		return strings.Join(notifyDataParams, ",")
	}

	return ""
}

// crsData returns cluster resource scheduling settings parameter string for API, if any of cluster resource scheduling
// settings are defined, otherwise empty string is returned.
func (m *clusterOptionsModel) crsData() string {
	var crsDataParams []string

	if !m.CrsHA.IsNull() && m.CrsHA.ValueString() != "" {
		crsDataParams = append(crsDataParams, fmt.Sprintf("ha=%s", m.CrsHA.ValueString()))
	}

	if !m.CrsHARebalanceOnStart.IsNull() {
		var haRebalanceOnStart string
		if m.CrsHARebalanceOnStart.ValueBool() {
			haRebalanceOnStart = "1"
		} else {
			haRebalanceOnStart = "0"
		}

		crsDataParams = append(crsDataParams, fmt.Sprintf("ha-rebalance-on-start=%s", haRebalanceOnStart))
	}

	if len(crsDataParams) > 0 {
		return strings.Join(crsDataParams, ",")
	}

	return ""
}

// bandwidthData returns bandwidth limit settings parameter string for API, if any of bandwidth
// limit settings are defined, otherwise empty string is returned.
func (m *clusterOptionsModel) bandwidthData() string {
	var bandwidthParams []string

	if !m.BandwidthLimitClone.IsNull() && m.BandwidthLimitClone.ValueInt64() != 0 {
		bandwidthParams = append(bandwidthParams, fmt.Sprintf("clone=%d", m.BandwidthLimitClone.ValueInt64()))
	}

	if !m.BandwidthLimitDefault.IsNull() && m.BandwidthLimitDefault.ValueInt64() != 0 {
		bandwidthParams = append(bandwidthParams, fmt.Sprintf("default=%d", m.BandwidthLimitDefault.ValueInt64()))
	}

	if !m.BandwidthLimitMigration.IsNull() && m.BandwidthLimitMigration.ValueInt64() != 0 {
		bandwidthParams = append(bandwidthParams, fmt.Sprintf("migration=%d", m.BandwidthLimitMigration.ValueInt64()))
	}

	if !m.BandwidthLimitMove.IsNull() && m.BandwidthLimitMove.ValueInt64() != 0 {
		bandwidthParams = append(bandwidthParams, fmt.Sprintf("move=%d", m.BandwidthLimitMove.ValueInt64()))
	}

	if !m.BandwidthLimitRestore.IsNull() && m.BandwidthLimitRestore.ValueInt64() != 0 {
		bandwidthParams = append(bandwidthParams, fmt.Sprintf("restore=%d", m.BandwidthLimitRestore.ValueInt64()))
	}

	if len(bandwidthParams) > 0 {
		return strings.Join(bandwidthParams, ",")
	}

	return ""
}

func (m *clusterOptionsModel) toOptionsRequestBody() *cluster.OptionsRequestData {
	body := &cluster.OptionsRequestData{}

	if !m.EmailFrom.IsUnknown() {
		body.EmailFrom = m.EmailFrom.ValueStringPointer()
	}

	if !m.Keyboard.IsUnknown() {
		body.Keyboard = m.Keyboard.ValueStringPointer()
	}

	if !m.Language.IsUnknown() {
		body.Language = m.Language.ValueStringPointer()
	}

	if !m.MaxWorkers.IsUnknown() {
		body.MaxWorkers = m.MaxWorkers.ValueInt64Pointer()
	}

	nextIDData := m.nextIDData()
	if nextIDData != "" {
		body.NextID = &nextIDData
	}

	notifyData := m.notifyData()
	if notifyData != "" {
		body.Notify = &notifyData
	}

	if !m.Console.IsUnknown() {
		body.Console = m.Console.ValueStringPointer()
	}

	if !m.HTTPProxy.IsUnknown() {
		body.HTTPProxy = m.HTTPProxy.ValueStringPointer()
	}

	if !m.MacPrefix.IsUnknown() {
		body.MacPrefix = m.MacPrefix.ValueStringPointer()
	}

	if !m.MacPrefix.IsUnknown() {
		body.Description = m.Description.ValueStringPointer()
	}

	haData := m.haData()
	if haData != "" {
		body.HASettings = &haData
	}

	bandwidthData := m.bandwidthData()
	if bandwidthData != "" {
		body.BandwidthLimit = &bandwidthData
	}

	crsData := m.crsData()
	if crsData != "" {
		body.ClusterResourceScheduling = &crsData
	}

	migrationData := m.migrationData()
	if migrationData != "" {
		body.Migration = &migrationData
	}

	return body
}

func (m *clusterOptionsModel) importFromOptionsAPI(_ context.Context, opts *cluster.OptionsResponseData) error {
	m.BandwidthLimitClone = types.Int64Null()
	m.BandwidthLimitDefault = types.Int64Null()
	m.BandwidthLimitMigration = types.Int64Null()
	m.BandwidthLimitMove = types.Int64Null()
	m.BandwidthLimitRestore = types.Int64Null()

	//nolint:nestif
	if opts.BandwidthLimit != nil {
		for _, bandwidth := range strings.Split(*opts.BandwidthLimit, ",") {
			bandwidthData := strings.SplitN(bandwidth, "=", 2)
			bandwidthName := bandwidthData[0]

			bandwidthLimit, err := strconv.ParseInt(bandwidthData[1], 10, 64)
			if err != nil {
				return fmt.Errorf("failed to parse bandwidth limit: %s", *opts.BandwidthLimit)
			}

			if bandwidthName == "clone" {
				m.BandwidthLimitClone = types.Int64Value(bandwidthLimit)
			}

			if bandwidthName == "default" {
				m.BandwidthLimitDefault = types.Int64Value(bandwidthLimit)
			}

			if bandwidthName == "migration" {
				m.BandwidthLimitMigration = types.Int64Value(bandwidthLimit)
			}

			if bandwidthName == "move" {
				m.BandwidthLimitMove = types.Int64Value(bandwidthLimit)
			}

			if bandwidthName == "restore" {
				m.BandwidthLimitRestore = types.Int64Value(bandwidthLimit)
			}
		}
	}

	m.EmailFrom = types.StringPointerValue(opts.EmailFrom)
	m.Keyboard = types.StringPointerValue(opts.Keyboard)
	m.Language = types.StringPointerValue(opts.Language)

	if opts.MaxWorkers != nil {
		value := int64(*opts.MaxWorkers)
		m.MaxWorkers = types.Int64PointerValue(&value)
	} else {
		m.MaxWorkers = types.Int64Null()
	}

	m.Console = types.StringPointerValue(opts.Console)
	m.HTTPProxy = types.StringPointerValue(opts.HTTPProxy)
	m.MacPrefix = types.StringPointerValue(opts.MacPrefix)

	if opts.Description != nil && *opts.Description != "" {
		m.Description = types.StringPointerValue(opts.Description)
	} else {
		m.Description = types.StringNull()
	}

	if opts.HASettings != nil {
		m.HAShutdownPolicy = types.StringPointerValue(opts.HASettings.ShutdownPolicy)
	} else {
		m.HAShutdownPolicy = types.StringNull()
	}

	if opts.Migration != nil {
		m.MigrationType = types.StringPointerValue(opts.Migration.Type)
		m.MigrationNetwork = types.StringPointerValue(opts.Migration.Network)
	} else {
		m.MigrationType = types.StringNull()
		m.MigrationNetwork = types.StringNull()
	}

	if opts.NextID != nil {
		m.NextID = &clusterOptionsNextIDModel{}
		m.NextID.Lower = types.Int64PointerValue(opts.NextID.Lower.PointerInt64())
		m.NextID.Upper = types.Int64PointerValue(opts.NextID.Upper.PointerInt64())
	}

	if opts.Notify != nil {
		m.Notify = &clusterOptionsNotifyModel{}
		m.Notify.HAFencingMode = types.StringPointerValue(opts.Notify.HAFencingMode)
		m.Notify.HAFencingTarget = types.StringPointerValue(opts.Notify.HAFencingTarget)
		m.Notify.PackageUpdates = types.StringPointerValue(opts.Notify.PackageUpdates)
		m.Notify.PackageUpdatesTarget = types.StringPointerValue(opts.Notify.PackageUpdatesTarget)
		m.Notify.Replication = types.StringPointerValue(opts.Notify.Replication)
		m.Notify.ReplicationTarget = types.StringPointerValue(opts.Notify.ReplicationTarget)
	}

	if opts.ClusterResourceScheduling != nil {
		m.CrsHARebalanceOnStart = types.BoolPointerValue(opts.ClusterResourceScheduling.HaRebalanceOnStart.PointerBool())
		m.CrsHA = types.StringPointerValue(opts.ClusterResourceScheduling.HA)
	} else {
		m.CrsHARebalanceOnStart = types.BoolNull()
		m.CrsHA = types.StringNull()
	}

	return nil
}

// NewClusterOptionsResource manages cluster options resource.
func NewClusterOptionsResource() resource.Resource {
	return &clusterOptionsResource{}
}

type clusterOptionsResource struct {
	client proxmox.Client
}

func (r *clusterOptionsResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_cluster_options"
}

// Schema defines the schema for the resource.
func (r *clusterOptionsResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages Proxmox VE Cluster Datacenter options.",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"email_from": schema.StringAttribute{
				Description: "email address to send notification from (default is root@$hostname).",
				Optional:    true,
			},
			"keyboard": schema.StringAttribute{
				Description: "Default keyboard layout for vnc server.",
				MarkdownDescription: "Default keyboard layout for vnc server. Must be `de` | " +
					"`de-ch` | `da` | `en-gb` | `en-us` | `es` | `fi` | `fr` | `fr-be` | `fr-ca` " +
					"| `fr-ch` | `hu` | `is` | `it` | `ja` | `lt` | `mk` | `nl` | `no` | `pl` | " +
					"`pt` | `pt-br` | `sv` | `sl` | `tr`.",
				Optional: true,
				Validators: []validator.String{
					validators.KeyboardLayoutValidator(),
				},
			},
			"max_workers": schema.Int64Attribute{
				Description: "Defines how many workers (per node) are maximal started on" +
					" actions like 'stopall VMs' or task from the ha-manager.",
				Optional: true,
			},
			"language": schema.StringAttribute{
				Description: "Default GUI language.",
				MarkdownDescription: "Default GUI language. Must be `ca` | `da` | `de` " +
					"| `en` | `es` | `eu` | `fa` | `fr` | `he` | `it` | `ja` | `nb` | " +
					"`nn` | `pl` | `pt_BR` | `ru` | `sl` | `sv` | `tr` | `zh_CN` | `zh_TW`.",
				Optional: true,
				Validators: []validator.String{
					validators.LanguageValidator(),
				},
			},
			"console": schema.StringAttribute{
				Description: "Select the default Console viewer.",
				MarkdownDescription: "Select the default Console viewer. " +
					"Must be `applet` | `vv`| `html5` | `xtermjs`. " +
					"You can either use the builtin java applet (VNC; deprecated and maps to html5), " +
					"an external virt-viewer compatible application (SPICE), " +
					"an HTML5 based vnc viewer (noVNC), " +
					"or an HTML5 based console client (xtermjs). " +
					"If the selected viewer is not available " +
					"(e.g. SPICE not activated for the VM), " +
					"the fallback is noVNC.",
				Optional: true,
				Validators: []validator.String{stringvalidator.OneOf([]string{
					"applet",
					"vv",
					"html5",
					"xtermjs",
				}...)},
			},
			"http_proxy": schema.StringAttribute{
				Description: "Specify external http proxy which is used for downloads.",
				MarkdownDescription: "Specify external http proxy which is used for downloads " +
					"(example: `http://username:password@host:port/`).",
				Optional: true,
			},
			"mac_prefix": schema.StringAttribute{
				Description: "Prefix for autogenerated MAC addresses.",
				Optional:    true,
				Computed:    true,
			},
			"description": schema.StringAttribute{
				Description: "Datacenter description. Shown in the web-interface datacenter notes panel. " +
					"This is saved as comment inside the configuration file.",
				Optional: true,
			},
			"ha_shutdown_policy": schema.StringAttribute{
				Description: "Cluster wide HA shutdown policy.",
				MarkdownDescription: "Cluster wide HA shutdown policy (). " +
					"Must be `freeze` | `failover` | `migrate` | `conditional` (default is `conditional`).",
				Optional: true,
				Validators: []validator.String{stringvalidator.OneOf([]string{
					"freeze",
					"failover",
					"migrate",
					"conditional",
				}...)},
			},
			"migration_type": schema.StringAttribute{
				Description: "Cluster wide migration type.",
				MarkdownDescription: "Cluster wide migration type. Must be `secure` | `insecure` " +
					"(default is `secure`).",
				Optional: true,
				Validators: []validator.String{stringvalidator.OneOf([]string{
					"secure",
					"insecure",
				}...)},
			},
			"migration_cidr": schema.StringAttribute{
				Description: "Cluster wide migration network CIDR.",
				Optional:    true,
			},
			"next_id": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"lower": schema.Int64Attribute{
						Description: "The minimum number for the next free VM ID.",
						MarkdownDescription: "The minimum number for the next free VM ID. " +
							fmt.Sprintf("Must be higher or equal to %d", ClusterOptionsNextIDLowerMinimum),
						Optional: true,
						Validators: []validator.Int64{
							int64validator.AtLeast(ClusterOptionsNextIDLowerMinimum),
						},
					},
					"upper": schema.Int64Attribute{
						Description: "The maximum number for the next free VM ID.",
						MarkdownDescription: "The maximum number for the next free VM ID. " +
							fmt.Sprintf("Must be less or equal to %d", ClusterOptionsNextIDLowerMaximum),
						Optional: true,
						Validators: []validator.Int64{
							int64validator.AtMost(ClusterOptionsNextIDLowerMaximum),
						},
					},
				},
				Description: "The ranges for the next free VM ID auto-selection pool.",
				Optional:    true,
			},
			"notify": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ha_fencing_mode": schema.StringAttribute{
						Description:         "Cluster-wide notification settings for the HA fencing mode.",
						MarkdownDescription: "Cluster-wide notification settings for the HA fencing mode. Must be `always` | `never`.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								[]string{
									"always",
									"never",
								}...,
							),
						},
					},
					"ha_fencing_target": schema.StringAttribute{
						Description:         "Cluster-wide notification settings for the HA fencing target.",
						MarkdownDescription: "Cluster-wide notification settings for the HA fencing target.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(1),
							stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
							stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
						},
					},
					"package_updates": schema.StringAttribute{
						Description: "Cluster-wide notification settings for package updates.",
						MarkdownDescription: "Cluster-wide notification settings for package updates. " +
							"Must be `auto` | `always` | `never`. ",
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								[]string{
									"auto",
									"always",
									"never",
								}...,
							),
						},
					},
					"package_updates_target": schema.StringAttribute{
						Description:         "Cluster-wide notification settings for the package updates target.",
						MarkdownDescription: "Cluster-wide notification settings for the package updates target.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(1),
							stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
							stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
						},
					},
					"replication": schema.StringAttribute{
						Description: "Cluster-wide notification settings for replication.",
						MarkdownDescription: "Cluster-wide notification settings for replication. " +
							"Must be `always` | `never`. ",
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								[]string{
									"always",
									"never",
								}...,
							),
						},
					},
					"replication_target": schema.StringAttribute{
						Description:         "Cluster-wide notification settings for the replication target.",
						MarkdownDescription: "Cluster-wide notification settings for the replication target.",
						Optional:            true,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(1),
							stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
							stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
						},
					},
				},
				Description: "Cluster-wide notification settings.",
				Optional:    true,
			},
			"crs_ha": schema.StringAttribute{
				Description:         "Cluster resource scheduling setting for HA.",
				MarkdownDescription: "Cluster resource scheduling setting for HA. Must be `static` | `basic` (default is `basic`).",
				Optional:            true,
				Computed:            true,
				Validators: []validator.String{stringvalidator.OneOf([]string{
					"static",
					"basic",
				}...)},
			},
			"crs_ha_rebalance_on_start": schema.BoolAttribute{
				Description: "Cluster resource scheduling setting for HA rebalance on start.",
				Optional:    true,
			},
			"bandwidth_limit_clone": schema.Int64Attribute{
				Description: "Clone I/O bandwidth limit in KiB/s.",
				Optional:    true,
			},
			"bandwidth_limit_default": schema.Int64Attribute{
				Description: "Default I/O bandwidth limit in KiB/s.",
				Optional:    true,
			},
			"bandwidth_limit_migration": schema.Int64Attribute{
				Description: "Migration I/O bandwidth limit in KiB/s.",
				Optional:    true,
			},
			"bandwidth_limit_move": schema.Int64Attribute{
				Description: "Move I/O bandwidth limit in KiB/s.",
				Optional:    true,
			},
			"bandwidth_limit_restore": schema.Int64Attribute{
				Description: "Restore I/O bandwidth limit in KiB/s.",
				Optional:    true,
			},
		},
	}
}

func (r *clusterOptionsResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *proxmox.Client, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

// Create update must-existing cluster options.
func (r *clusterOptionsResource) Create(
	ctx context.Context,
	req resource.CreateRequest,
	resp *resource.CreateResponse,
) {
	var plan clusterOptionsModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.toOptionsRequestBody()

	err := r.client.Cluster().CreateUpdateOptions(ctx, body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating cluster options",
			"Could not create cluster options, unexpected error: "+err.Error(),
		)

		return
	}

	plan.ID = types.StringValue("cluster")

	r.read(ctx, &plan, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

func (r *clusterOptionsResource) read(ctx context.Context, model *clusterOptionsModel, diags *diag.Diagnostics) {
	options, err := r.client.Cluster().GetOptions(ctx)
	if err != nil {
		diags.AddError(
			"Error get cluster options",
			"Could not get cluster options, unexpected error: "+err.Error(),
		)

		return
	}

	err = model.importFromOptionsAPI(ctx, options)
	if err != nil {
		diags.AddError(
			"Error converting cluster options to a model",
			"Could not import cluster options from API response, unexpected error: "+err.Error(),
		)

		return
	}
}

// Read reads cluster options.
func (r *clusterOptionsResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	// Get current state
	var state clusterOptionsModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	r.read(ctx, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

// Update updates cluster options.
func (r *clusterOptionsResource) Update(
	ctx context.Context,
	req resource.UpdateRequest,
	resp *resource.UpdateResponse,
) {
	var plan, state clusterOptionsModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.toOptionsRequestBody()

	var toDelete []string

	if !plan.Keyboard.Equal(state.Keyboard) && plan.Keyboard.ValueString() == "" {
		toDelete = append(toDelete, "keyboard")
	}

	if plan.bandwidthData() != state.bandwidthData() && plan.bandwidthData() == "" {
		toDelete = append(toDelete, "bwlimit")
	}

	if plan.crsData() != state.crsData() && plan.crsData() == "" {
		toDelete = append(toDelete, "crs")
	}

	if plan.haData() != state.haData() && plan.haData() == "" {
		toDelete = append(toDelete, "ha")
	}

	if plan.migrationData() != state.migrationData() && plan.migrationData() == "" {
		toDelete = append(toDelete, "migration")
	}

	if plan.nextIDData() != state.nextIDData() && plan.nextIDData() == "" {
		toDelete = append(toDelete, "next-id")
	}

	if plan.notifyData() != state.notifyData() && plan.notifyData() == "" {
		toDelete = append(toDelete, "notify")
	}

	if !plan.EmailFrom.Equal(state.EmailFrom) && plan.EmailFrom.ValueString() == "" {
		toDelete = append(toDelete, "email_from")
	}

	if !plan.Language.Equal(state.Language) && plan.Language.ValueString() == "" {
		toDelete = append(toDelete, "language")
	}

	if !plan.Console.Equal(state.Console) && plan.Console.ValueString() == "" {
		toDelete = append(toDelete, "console")
	}

	if !plan.HTTPProxy.Equal(state.HTTPProxy) && plan.HTTPProxy.ValueString() == "" {
		toDelete = append(toDelete, "http_proxy")
	}

	if !plan.MacPrefix.Equal(state.MacPrefix) && plan.MacPrefix.ValueString() == "" {
		toDelete = append(toDelete, "mac_prefix")
	}

	if !plan.Description.Equal(state.Description) && plan.Description.ValueString() == "" {
		toDelete = append(toDelete, "description")
	}

	if !plan.MaxWorkers.Equal(state.MaxWorkers) && plan.MaxWorkers.ValueInt64() == 0 {
		toDelete = append(toDelete, "max_workers")
	}

	if len(toDelete) > 0 {
		d := strings.Join(toDelete, ",")
		body.Delete = &d
	}

	err := r.client.Cluster().CreateUpdateOptions(ctx, body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating cluster options",
			"Could not update cluster options, unexpected error: "+err.Error(),
		)

		return
	}

	r.read(ctx, &plan, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Delete deletes cluster options.
func (r *clusterOptionsResource) Delete(
	ctx context.Context,
	req resource.DeleteRequest,
	resp *resource.DeleteResponse,
) {
	var state clusterOptionsModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	var toDelete []string

	if !state.Keyboard.IsNull() && state.Keyboard.ValueString() != "" {
		toDelete = append(toDelete, "keyboard")
	}

	if state.bandwidthData() != "" {
		toDelete = append(toDelete, "bwlimit")
	}

	if state.crsData() != "" {
		toDelete = append(toDelete, "crs")
	}

	if state.haData() != "" {
		toDelete = append(toDelete, "ha")
	}

	if state.migrationData() != "" {
		toDelete = append(toDelete, "migration")
	}

	if state.nextIDData() != "" {
		toDelete = append(toDelete, "next-id")
	}

	if state.notifyData() != "" {
		toDelete = append(toDelete, "notify")
	}

	if !state.EmailFrom.IsNull() && state.EmailFrom.ValueString() != "" {
		toDelete = append(toDelete, "email_from")
	}

	if !state.Language.IsNull() && state.Language.ValueString() != "" {
		toDelete = append(toDelete, "language")
	}

	if !state.Console.IsNull() && state.Console.ValueString() != "" {
		toDelete = append(toDelete, "console")
	}

	if !state.HTTPProxy.IsNull() && state.HTTPProxy.ValueString() != "" {
		toDelete = append(toDelete, "http_proxy")
	}

	if !state.MacPrefix.IsNull() && state.MacPrefix.ValueString() != "" {
		toDelete = append(toDelete, "mac_prefix")
	}

	if !state.Description.IsNull() && state.Description.ValueString() != "" {
		toDelete = append(toDelete, "description")
	}

	if !state.MaxWorkers.IsNull() && state.MaxWorkers.ValueInt64() != 0 {
		toDelete = append(toDelete, "max_workers")
	}

	if len(toDelete) > 0 {
		d := strings.Join(toDelete, ",")
		body := &cluster.OptionsRequestData{
			Delete: &d,
		}

		err := r.client.Cluster().CreateUpdateOptions(ctx, body)
		if err != nil {
			resp.Diagnostics.AddError(
				"Error updating cluster options",
				"Could not update cluster options, unexpected error: "+err.Error(),
			)
		}
	}
}

// ImportState imports cluster options.
func (r *clusterOptionsResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	state := clusterOptionsModel{ID: types.StringValue(req.ID)}
	r.read(ctx, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	diags := resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}
`````

## File: fwprovider/config/datasource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package config

import "github.com/bpg/terraform-provider-proxmox/proxmox"

// DataSource is the global configuration for all datasources.
type DataSource struct {
	Client proxmox.Client
}
`````

## File: fwprovider/config/doc.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

// Package config provides the global provider's configuration for all resources and datasources.
package config
`````

## File: fwprovider/config/resource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package config

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
)

// Resource is the global configuration for all resources.
type Resource struct {
	Client proxmox.Client

	IDGenerator cluster.IDGenerator
}
`````

## File: fwprovider/nodes/apt/datasource_repo.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
)

// Ensure the implementation satisfies the required interfaces.
var (
	_ datasource.DataSource              = &repositoryDataSource{}
	_ datasource.DataSourceWithConfigure = &repositoryDataSource{}
)

// repositoryDataSource is the data source implementation for an APT repository.
type repositoryDataSource struct {
	// client is the Proxmox VE API client.
	client proxmox.Client
}

// Configure adds the provider-configured client to the data source.
func (d *repositoryDataSource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client
}

// Metadata returns the data source type name.
func (d *repositoryDataSource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_apt_repository"
}

// Read fetches the specified APT repository from the Proxmox VE API.
func (d *repositoryDataSource) Read(
	ctx context.Context,
	req datasource.ReadRequest,
	resp *datasource.ReadResponse,
) {
	var rp modelRepo

	resp.Diagnostics.Append(req.Config.Get(ctx, &rp)...)

	if resp.Diagnostics.HasError() {
		return
	}

	data, err := d.client.Node(rp.Node.ValueString()).APT().Repositories().Get(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Could not read APT repository", err.Error())

		return
	}

	resp.Diagnostics.Append(rp.importFromAPI(ctx, data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &rp)...)
}

// Schema defines the schema for the APT repository.
func (d *repositoryDataSource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves an APT repository from a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			SchemaAttrNameComment: schema.StringAttribute{
				Computed:    true,
				Description: "The associated comment.",
			},
			SchemaAttrNameComponents: schema.ListAttribute{
				Computed:    true,
				Description: "The list of components.",
				ElementType: types.StringType,
			},
			SchemaAttrNameEnabled: schema.BoolAttribute{
				Computed:    true,
				Description: "Indicates the activation status.",
			},
			SchemaAttrNameFilePath: schema.StringAttribute{
				Description: "The absolute path of the source list file that contains this repository.",
				Required:    true,
				Validators: []validator.String{
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNameFileType: schema.StringAttribute{
				Computed:    true,
				Description: "The format of the defining source list file.",
			},
			SchemaAttrNameIndex: schema.Int64Attribute{
				Description: "The index within the defining source list file.",
				Required:    true,
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
			SchemaAttrNameNode: schema.StringAttribute{
				Description: "The name of the target Proxmox VE node.",
				Required:    true,
				Validators: []validator.String{
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNamePackageTypes: schema.ListAttribute{
				Computed:    true,
				Description: "The list of package types.",
				ElementType: types.StringType,
			},
			SchemaAttrNameSuites: schema.ListAttribute{
				Computed:    true,
				Description: "The list of package distributions.",
				ElementType: types.StringType,
			},
			SchemaAttrNameTerraformID: attribute.ResourceID("The unique identifier of this APT repository data source."),
			SchemaAttrNameURIs: schema.ListAttribute{
				Computed:    true,
				Description: "The list of repository URIs.",
				ElementType: types.StringType,
			},
		},
	}
}

// NewRepositoryDataSource returns a new data source for an APT repository.
// This is a helper function to simplify the provider implementation.
func NewRepositoryDataSource() datasource.DataSource {
	return &repositoryDataSource{}
}
`````

## File: fwprovider/nodes/apt/datasource_standard_repo.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/nodes/apt"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
)

// Ensure the implementation satisfies the required interfaces.
var (
	_ datasource.DataSource              = &standardRepositoryDataSource{}
	_ datasource.DataSourceWithConfigure = &standardRepositoryDataSource{}
)

// standardRepositoryDataSource is the data source implementation for an APT standard repository.
type standardRepositoryDataSource struct {
	// client is the Proxmox VE API client.
	client proxmox.Client
}

// Configure adds the provider-configured client to the data source.
func (d *standardRepositoryDataSource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client
}

// Metadata returns the data source type name.
func (d *standardRepositoryDataSource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_apt_standard_repository"
}

// Read fetches the specified APT standard repository from the Proxmox VE API.
func (d *standardRepositoryDataSource) Read(
	ctx context.Context,
	req datasource.ReadRequest,
	resp *datasource.ReadResponse,
) {
	var srp modelStandardRepo

	resp.Diagnostics.Append(req.Config.Get(ctx, &srp)...)

	if resp.Diagnostics.HasError() {
		return
	}

	data, err := d.client.Node(srp.Node.ValueString()).APT().Repositories().Get(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Could not read APT standard repository", err.Error())

		return
	}

	srp.importFromAPI(ctx, data)

	resp.Diagnostics.Append(resp.State.Set(ctx, &srp)...)
}

// Schema defines the schema for the APT standard repository.
func (d *standardRepositoryDataSource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves an APT standard repository from a Proxmox VE cluster.",
		Attributes: map[string]schema.Attribute{
			SchemaAttrNameStandardDescription: schema.StringAttribute{
				Computed:    true,
				Description: "The description of the APT standard repository.",
			},
			SchemaAttrNameFilePath: schema.StringAttribute{
				Computed:    true,
				Description: "The absolute path of the source list file that contains this standard repository.",
			},
			SchemaAttrNameStandardHandle: schema.StringAttribute{
				CustomType:  customtypes.StandardRepoHandleType{},
				Description: "The handle of the APT standard repository.",
				Required:    true,
			},
			SchemaAttrNameIndex: schema.Int64Attribute{
				Computed:    true,
				Description: "The index within the defining source list file.",
			},
			SchemaAttrNameStandardName: schema.StringAttribute{
				Computed:    true,
				Description: "The name of the APT standard repository.",
			},
			SchemaAttrNameNode: schema.StringAttribute{
				Description: "The name of the target Proxmox VE node.",
				Required:    true,
				Validators: []validator.String{
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNameStandardStatus: schema.Int64Attribute{
				Computed:    true,
				Description: "Indicates the activation status.",
			},
			SchemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this APT standard repository data source.",
			),
		},
	}
}

// NewStandardRepositoryDataSource returns a new data source for an APT standard repository.
// This is a helper function to simplify the provider implementation.
func NewStandardRepositoryDataSource() datasource.DataSource {
	return &standardRepositoryDataSource{}
}
`````

## File: fwprovider/nodes/apt/models.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"context"
	"fmt"
	"regexp"
	"slices"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"

	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/nodes/apt"
	api "github.com/bpg/terraform-provider-proxmox/proxmox/nodes/apt/repositories"
)

// Note that most constants are exported to allow the usage in (acceptance) tests.
const (
	// SchemaAttrNameComment is the name of the APT repository schema attribute for the associated comment.
	SchemaAttrNameComment = "comment"

	// SchemaAttrNameComponents is the name of the APT repository schema attribute for the list of components.
	SchemaAttrNameComponents = "components"

	// SchemaAttrNameEnabled is the name of the APT repository schema attribute that indicates the activation status.
	SchemaAttrNameEnabled = "enabled"

	// SchemaAttrNameFilePath is the name of the APT repository schema attribute for the path of the defining source list
	// file.
	SchemaAttrNameFilePath = "file_path"

	// SchemaAttrNameFileType is the name of the APT repository schema attribute for the format of the defining source
	// list file.
	SchemaAttrNameFileType = "file_type"

	// SchemaAttrNameIndex is the name of the APT repository schema attribute for the index within the defining source
	// list file.
	SchemaAttrNameIndex = "index"

	// SchemaAttrNameNode is the name of the APT repository schema attribute for the name of the Proxmox VE node.
	SchemaAttrNameNode = "node"

	// SchemaAttrNamePackageTypes is the name of the APT repository schema attribute for the list of package types.
	SchemaAttrNamePackageTypes = "package_types"

	// SchemaAttrNameStandardDescription is the name of the APT repository schema attribute for the description.
	SchemaAttrNameStandardDescription = "description"

	// SchemaAttrNameStandardHandle is the name of the APT repository schema attribute for the standard repository
	// handle.
	SchemaAttrNameStandardHandle = "handle"

	// SchemaAttrNameStandardName is the name of the APT repository schema attribute for the human-readable name.
	SchemaAttrNameStandardName = "name"

	// SchemaAttrNameStandardStatus is the name of the APT standard repository schema attribute that indicates the
	// configuration and activation status.
	SchemaAttrNameStandardStatus = "status"

	// SchemaAttrNameSuites is the name of the APT repository schema attribute for the list of package distributions.
	SchemaAttrNameSuites = "suites"

	// SchemaAttrNameTerraformID is the name of the APT repository schema attribute for the Terraform ID.
	SchemaAttrNameTerraformID = "id"

	// SchemaAttrNameURIs is the name of the APT repository schema attribute for the list of repository URIs.
	SchemaAttrNameURIs = "uris"
)

// RepoIDCharReplaceRegEx is a regular expression to replace characters in a Terraform resource/data source ID.
// The "^" at the beginning of the character group selects all characters not matching the group.
var RepoIDCharReplaceRegEx = regexp.MustCompile(`([^a-zA-Z1-9_])`)

// modelRepo maps the schema data for an APT repository from a parsed source list file.
type modelRepo struct {
	// Comment is the comment of the APT repository.
	Comment types.String `tfsdk:"comment"`

	// Components is the list of repository components.
	Components types.List `tfsdk:"components"`

	// Enabled indicates whether the APT repository is enabled.
	Enabled types.Bool `tfsdk:"enabled"`

	// FilePath is the path of the source list file that contains the APT repository.
	FilePath types.String `tfsdk:"file_path"`

	// FileType is the format of the packages.
	FileType types.String `tfsdk:"file_type"`

	// ID is the Terraform identifier of the APT repository.
	ID types.String `tfsdk:"id"`

	// Index is the index of the APT repository within the defining source list.
	Index types.Int64 `tfsdk:"index"`

	// Node is the name of the Proxmox VE node for the APT repository.
	Node types.String `tfsdk:"node"`

	// PackageTypes is the list of package types.
	PackageTypes types.List `tfsdk:"package_types"`

	// Suites is the list of package distributions.
	Suites types.List `tfsdk:"suites"`

	// URIs is the list of repository URIs.
	URIs types.List `tfsdk:"uris"`
}

// modelStandardRepo maps the schema data for an APT standard repository.
type modelStandardRepo struct {
	// Description is the description of the APT standard repository.
	Description types.String `tfsdk:"description"`

	// FilePath is the path of the source list file that contains the APT standard repository.
	FilePath types.String `tfsdk:"file_path"`

	// ID is the Terraform identifier of the APT standard repository.
	ID types.String `tfsdk:"id"`

	// Index is the index of the APT standard repository within the defining source list file.
	Index types.Int64 `tfsdk:"index"`

	// Handle is the handle of the APT standard repository.
	Handle customtypes.StandardRepoHandleValue `tfsdk:"handle"`

	// Name is the name of the APT standard repository.
	Name types.String `tfsdk:"name"`

	// Node is the name of the Proxmox VE node for the APT standard repository.
	Node types.String `tfsdk:"node"`

	// Status is the configuration and activation status of the APT standard repository.
	Status types.Int64 `tfsdk:"status"`
}

// importFromAPI imports the contents of an APT repository model from the Proxmox VE API's response data.
func (rp *modelRepo) importFromAPI(ctx context.Context, data *api.GetResponseData) diag.Diagnostics {
	diags := diag.Diagnostics{}

	// We can only ensure a unique ID by using the name of the Proxmox VE node and the absolute file path because custom
	// source list files can be loaded by Proxmox VE from every path on a node.
	rp.ID = types.StringValue(
		fmt.Sprintf(
			"%s_%s_%s_%d",
			ResourceRepoIDPrefix,
			strings.ToLower(rp.Node.ValueString()),
			strings.ToLower(RepoIDCharReplaceRegEx.ReplaceAllString(strings.TrimPrefix(rp.FilePath.ValueString(), "/"), "_")),
			rp.Index.ValueInt64(),
		),
	)

	// We must ensure that the type definitions for lists and other attributes are set since Terraform must know these
	// during the planning phase. This is important when the resource was imported where only the ID is known.
	rp.Comment = types.StringNull()
	rp.Enabled = types.BoolNull()
	rp.FileType = types.StringNull()
	rp.Components = types.ListNull(types.StringType)
	rp.PackageTypes = types.ListNull(types.StringType)
	rp.Suites = types.ListNull(types.StringType)
	rp.URIs = types.ListNull(types.StringType)

	// Iterate through all repository files‚Ä¶
	for _, repoFile := range data.Files {
		// ‚Ä¶and the defined repositories when the file path matches.
		if repoFile.Path == rp.FilePath.ValueString() {
			// Handle situations where an APT repository might have been removed manually which is currently the only way to
			// solve this with the capabilities of the Proxmox VE API.
			if int64(len(repoFile.Repositories)) > rp.Index.ValueInt64() {
				repo := repoFile.Repositories[rp.Index.ValueInt64()]

				// Strip the unnecessary new line control character (\n) from the end of the comment that is, for whatever
				// reason, returned this way by the Proxmox VE API.
				if repo.Comment != nil {
					rp.Comment = types.StringValue(strings.TrimSuffix(*repo.Comment, "\n"))
				}

				rp.Enabled = repo.Enabled.ToValue()
				rp.FileType = types.StringValue(repo.FileType)

				components, convDiags := types.ListValueFrom(ctx, types.StringType, repo.Components)
				if convDiags.HasError() {
					diags.AddError("Terraform list value conversion", "Convert list of APT repository components")
				} else {
					rp.Components = components
				}

				pkgTypes, convDiags := types.ListValueFrom(ctx, types.StringType, repo.PackageTypes)
				if convDiags.HasError() {
					diags.AddError("Terraform list value conversion", "Convert list of APT repository package types")
				} else {
					rp.PackageTypes = pkgTypes
				}

				suites, convDiags := types.ListValueFrom(ctx, types.StringType, repo.Suites)
				if convDiags.HasError() {
					diags.AddError("Terraform list value conversion", "Convert list of APT repository suites")
				} else {
					rp.Suites = suites
				}

				uris, convDiags := types.ListValueFrom(ctx, types.StringType, repo.URIs)
				if convDiags.HasError() {
					diags.AddError("Terraform list value conversion", "Convert list of APT repository URIs")
				} else {
					rp.URIs = uris
				}
			}
		}
	}

	return diags
}

// importFromAPI imports the contents of an APT standard repository from the Proxmox VE API's response data.
func (srp *modelStandardRepo) importFromAPI(_ context.Context, data *api.GetResponseData) {
	for _, repo := range data.StandardRepos {
		if repo.Handle == srp.Handle.ValueString() {
			srp.Description = types.StringPointerValue(repo.Description)
			// We can only ensure a unique ID by using the name of the Proxmox VE node in combination with the unique standard
			// handle.
			srp.ID = types.StringValue(
				fmt.Sprintf(
					"%s_%s_%s",
					ResourceStandardRepoIDPrefix,
					strings.ToLower(srp.Node.ValueString()),
					RepoIDCharReplaceRegEx.ReplaceAllString(srp.Handle.ValueString(), "_"),
				),
			)

			srp.Name = types.StringValue(repo.Name)
			srp.Status = types.Int64PointerValue(repo.Status)
		}
	}

	// Set the index‚Ä¶
	srp.setIndex(data)
	// ‚Ä¶ and then the file path when the index is valid‚Ä¶
	if !srp.Index.IsNull() {
		// ‚Ä¶by iterating through all repository files‚Ä¶
		for _, repoFile := range data.Files {
			// ‚Ä¶and get the repository when the file path matches.
			if srp.Handle.IsSupportedFilePath(repoFile.Path) {
				srp.FilePath = types.StringValue(repoFile.Path)
			}
		}
	}
}

// setIndex sets the index of the APT standard repository derived from the defining source list file.
func (srp *modelStandardRepo) setIndex(data *api.GetResponseData) {
	for _, file := range data.Files {
		for idx, repo := range file.Repositories {
			if slices.Contains(repo.Components, srp.Handle.ComponentName()) {
				// Return early for non-Ceph repositories‚Ä¶
				if !srp.Handle.IsCephHandle() {
					srp.Index = types.Int64Value(int64(idx))

					return
				}

				// ‚Ä¶and find the index for Ceph repositories based on the version name within the list of URIs.
				for _, uri := range repo.URIs {
					if strings.Contains(uri, srp.Handle.CephVersionName().String()) {
						srp.Index = types.Int64Value(int64(idx))

						return
					}
				}
			}
		}
	}

	srp.Index = types.Int64Null()
}
`````

## File: fwprovider/nodes/apt/repo_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt_test

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/knownvalue"
	"github.com/hashicorp/terraform-plugin-testing/statecheck"
	"github.com/hashicorp/terraform-plugin-testing/tfjsonpath"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/apt"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	apitypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/nodes/apt/repositories"
)

// Note that some "hard-coded" values must be used because of the way how the Proxmox VE API for APT repositories works.
const (
	testAccResourceRepoSelector = "proxmox_virtual_environment_" + apt.ResourceRepoIDPrefix + ".test"

	// By default, this should be the main Debian package repository on any (new) Proxmox VE node.
	testAccResourceRepoIndex = 0

	testAccResourceStandardRepoSelector = "proxmox_virtual_environment_" + apt.ResourceStandardRepoIDPrefix + ".test"

	// Use an APT standard repository handle that is not enabled by default on any new Proxmox VE node.
	testAccResourceStandardRepoHandle = "no-subscription"
)

func TestAccDataSourceRepo(t *testing.T) {
	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{
			"read APT repository attributes",
			[]resource.TestStep{
				{
					Config: te.RenderConfig(`
					data "proxmox_virtual_environment_apt_repository" "test" {
						file_path = "/etc/apt/sources.list"
						index = 0
						node = "{{.NodeName}}"
					}`),
					// The provided attributes and computed attributes should be set.
					Check: resource.ComposeTestCheckFunc(
						resource.TestMatchResourceAttr(
							"data.proxmox_virtual_environment_apt_repository.test",
							apt.SchemaAttrNameComment,
							// Expect any value or an empty string.
							regexp.MustCompile(`(.*|^$)`),
						),
						resource.TestCheckResourceAttr(
							"data.proxmox_virtual_environment_apt_repository.test",
							apt.SchemaAttrNameTerraformID,
							"apt_repository_"+strings.ToLower(te.NodeName)+"_etc_apt_sources_list_0",
						),
						test.ResourceAttributesSet("data.proxmox_virtual_environment_apt_repository.test", []string{
							"components.#",
							"enabled",
							"file_path",
							"index",
							"node",
							"package_types.#",
							"suites.#",
							"uris.#",
						}),
					),
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				resource.ParallelTest(
					t, resource.TestCase{
						ProtoV6ProviderFactories: te.AccProviders,
						Steps:                    tt.steps,
					},
				)
			},
		)
	}
}

func TestAccDataSourceStandardRepo(t *testing.T) {
	t.Helper()
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{
			"read APT standard repository attributes",
			[]resource.TestStep{
				{
					Config: te.RenderConfig(`
					data "proxmox_virtual_environment_apt_standard_repository" "test" {
						handle = "no-subscription"
						node   = "{{.NodeName}}"
					}`),
					// The provided attributes and computed attributes should be set.
					Check: resource.ComposeTestCheckFunc(
						test.ResourceAttributes("data.proxmox_virtual_environment_apt_standard_repository.test", map[string]string{
							"id": fmt.Sprintf("apt_standard_repository_%s_no_subscription", strings.ToLower(te.NodeName)),
						}),
						test.ResourceAttributesSet("data.proxmox_virtual_environment_apt_standard_repository.test", []string{
							// Note that we can not check for the following attributes because they are only available when the
							// standard repository has been added to a source list:
							//
							// - apt.SchemaAttrNameFilePath (file_path) - will be set when parsing all configured repositories in all
							//   source list files.
							// - apt.SchemaAttrNameIndex (index) - will be set when finding the repository within a source list file,
							//   based on the detected file path.
							// - apt.SchemaAttrNameStandardStatus (status) - is only available when the standard has been configured.

							apt.SchemaAttrNameStandardDescription,
							apt.SchemaAttrNameStandardHandle,
							apt.SchemaAttrNameStandardName,
							apt.SchemaAttrNameNode,
						}),
					),
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(
			tt.name, func(t *testing.T) {
				resource.ParallelTest(
					t, resource.TestCase{
						ProtoV6ProviderFactories: te.AccProviders,
						Steps:                    tt.steps,
					},
				)
			},
		)
	}
}

// Run tests for APT repository resource definitions with valid input where all required attributes are specified.
// Only the [Create], [Read] and [Update] method implementations of the
// [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested in sequential steps because
// [Delete] is no-op due to the non-existing capability of the Proxmox VE API of deleting configured APT repository.
//
// [Create]: https://developer.hashicorp.com/terraform/plugin/framework/resources/create
// [Delete]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete
// [Read]: https://developer.hashicorp.com/terraform/plugin/framework/resources/read
// [Update]: https://developer.hashicorp.com/terraform/plugin/framework/resources/update
func TestAccResourceRepoValidInput(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations.
				{
					Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_apt_repository" "test" {
						enabled   = true
						file_path = "/etc/apt/sources.list"
						index     = 0
						node      = "{{.NodeName}}"
					}`),
					// The computed attributes should be set.
					ConfigStateChecks: []statecheck.StateCheck{
						statecheck.ExpectKnownValue(
							testAccResourceRepoSelector,
							tfjsonpath.New(apt.SchemaAttrNameComponents),
							knownvalue.ListPartial(
								map[int]knownvalue.Check{
									// Use the same check for both entries because the sort order cannot be guaranteed.
									0: knownvalue.StringRegexp(regexp.MustCompile(`(contrib|main)`)),
									1: knownvalue.StringRegexp(regexp.MustCompile(`(contrib|main)`)),
								},
							),
						),
						statecheck.ExpectKnownValue(
							testAccResourceRepoSelector,
							tfjsonpath.New(apt.SchemaAttrNamePackageTypes),
							knownvalue.ListPartial(
								map[int]knownvalue.Check{
									0: knownvalue.StringRegexp(regexp.MustCompile(`(deb)`)),
								},
							),
						),
						statecheck.ExpectKnownValue(
							testAccResourceRepoSelector,
							tfjsonpath.New(apt.SchemaAttrNameSuites),
							knownvalue.ListPartial(
								map[int]knownvalue.Check{
									// The possible Debian version is based on the official table of the Proxmox VE FAQ page:
									// - https://pve.proxmox.com/wiki/FAQ#faq-support-table
									// - https://www.thomas-krenn.com/en/wiki/Proxmox_VE#Proxmox_VE_8.x
									//
									// The required Proxmox VE version for this provider is of course also taken into account:
									// - https://github.com/bpg/terraform-provider-proxmox?tab=readme-ov-file#requirements
									0: knownvalue.StringRegexp(regexp.MustCompile(`(bookworm)`)),
								},
							),
						),
						statecheck.ExpectKnownValue(
							testAccResourceRepoSelector,
							tfjsonpath.New(apt.SchemaAttrNameURIs),
							knownvalue.ListPartial(
								map[int]knownvalue.Check{
									0: knownvalue.StringRegexp(regexp.MustCompile(`https?://ftp\.([a-z]+\.)?debian\.org/debian`)),
								},
							),
						),
					},
					// The provided attributes and computed attributes should be set.
					Check: resource.ComposeTestCheckFunc(
						test.ResourceAttributes("proxmox_virtual_environment_apt_repository.test", map[string]string{
							"enabled":   strconv.FormatBool(true),
							"file_path": "/etc/apt/sources.list",
							"index":     strconv.FormatInt(0, 10),
							"node":      te.NodeName,
							"id": fmt.Sprintf(
								"apt_repository_%s_%s_%d",
								strings.ToLower(te.NodeName),
								apt.RepoIDCharReplaceRegEx.ReplaceAllString(
									strings.TrimPrefix("/etc/apt/sources.list", "/"),
									"_",
								),
								0,
							),
						}),
						resource.TestMatchResourceAttr("proxmox_virtual_environment_apt_repository.test", "comment", regexp.MustCompile(`(.*|^$)`)),
						resource.TestCheckResourceAttrSet("proxmox_virtual_environment_apt_repository.test", "file_type"),
					),
				},

				// Test the "ImportState" implementation.
				{
					ImportState: true,
					ImportStateId: fmt.Sprintf(
						"%s,%s,%d",
						strings.ToLower(te.NodeName),
						apitypes.StandardRepoFilePathMain,
						testAccResourceRepoIndex,
					),
					ImportStateVerify: true,
					ResourceName:      testAccResourceRepoSelector,
				},

				// Test the "Update" implementation by toggling the activation status.
				{
					Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_apt_repository" "test" {
						enabled    = false
						file_path  = "/etc/apt/sources.list"
						index     = 0
						node      = "{{.NodeName}}"
					}`),
					// The provides attributes and some computed attributes should be set.
					Check: resource.ComposeTestCheckFunc(
						resource.TestCheckResourceAttr("proxmox_virtual_environment_apt_repository.test", "enabled", "false"),
					),
				},
			},
		},
	)
}

// Run tests for APT standard repository resource definitions with valid input where all required attributes are
// specified.
// Only the [Create] and [Read] method implementations of the
// [github.com/hashicorp/terraform-plugin-framework/resource.Resource] interface are tested in sequential steps because
// [Delete] and [Update] are no-op due to the non-existing capability of the Proxmox VE API of deleting or updating a
// configured APT standard repository.
//
// [Create]: https://developer.hashicorp.com/terraform/plugin/framework/resources/create
// [Delete]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete
// [Read]: https://developer.hashicorp.com/terraform/plugin/framework/resources/read
// [Update]: https://developer.hashicorp.com/terraform/plugin/framework/resources/update
func TestAccResourceStandardRepoValidInput(t *testing.T) {
	t.Helper()
	t.Parallel()

	te := test.InitEnvironment(t)

	resource.Test(
		t, resource.TestCase{
			ProtoV6ProviderFactories: te.AccProviders,
			Steps: []resource.TestStep{
				// Test the "Create" and "Read" implementations.
				{
					// 	PUT /api2/json/nodes/{node}/apt/repositories with handle = "no-subscription" will create a new
					// entry in /etc/apt/sources.list on each call :/
					SkipFunc: func() (bool, error) {
						return true, nil
					},
					Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_apt_standard_repository" "test" {
						handle = "no-subscription"
						node   = "{{.NodeName}}"
					}`),
					// The provided attributes and computed attributes should be set.
					Check: resource.ComposeTestCheckFunc(
						test.ResourceAttributes("proxmox_virtual_environment_apt_standard_repository.test", map[string]string{
							"file_path": "/etc/apt/sources.list",
							"handle":    "no-subscription",
							"node":      te.NodeName,
							"status":    "1",
							"id":        fmt.Sprintf("apt_standard_repository_%s_no_subscription", strings.ToLower(te.NodeName)),
						}),
						test.ResourceAttributesSet("proxmox_virtual_environment_apt_standard_repository.test", []string{
							"description",
							"index",
							"name",
						}),
					),
				},

				// Test the "ImportState" implementation.
				{
					// 	PUT /api2/json/nodes/{node}/apt/repositories with handle = "no-subscription" will create a new
					// entry in /etc/apt/sources.list on each call :/
					SkipFunc: func() (bool, error) {
						return true, nil
					},
					ImportState:       true,
					ImportStateId:     fmt.Sprintf("%s,no-subscription", strings.ToLower(te.NodeName)),
					ImportStateVerify: true,
					ResourceName:      "proxmox_virtual_environment_apt_standard_repository.test",
				},
			},
		},
	)
}
`````

## File: fwprovider/nodes/apt/resource_repo.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	api "github.com/bpg/terraform-provider-proxmox/proxmox/nodes/apt/repositories"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

const (
	// ResourceRepoIDPrefix is the prefix for the resource ID of repositoryResource.
	ResourceRepoIDPrefix = "apt_repository"

	// ResourceRepoActivationStatus is the default activation status for newly created or imported APT repositories.
	// This reflects the same default value used by the Proxmox VE API when the "enabled" parameter is not set.
	ResourceRepoActivationStatus = true
)

// Ensure the resource implements the required interfaces.
var (
	_ resource.Resource                = &repositoryResource{}
	_ resource.ResourceWithConfigure   = &repositoryResource{}
	_ resource.ResourceWithImportState = &repositoryResource{}
)

// repositoryResource contains the APT repository resource's internal data.
type repositoryResource struct {
	// client is the Proxmox VE API client.
	client proxmox.Client
}

// read reads information about an APT repository from the Proxmox VE API.
// Note that the name of the node must be set before this method is called!
func (r *repositoryResource) read(ctx context.Context, rp *modelRepo) (bool, diag.Diagnostics) {
	diags := diag.Diagnostics{}

	data, err := r.client.Node(rp.Node.ValueString()).APT().Repositories().Get(ctx)
	if err != nil {
		diags.AddError(fmt.Sprintf("Could not read APT repositories on node %v", rp.Node), err.Error())

		return false, diags
	}

	diags.Append(rp.importFromAPI(ctx, data)...)

	if diags.HasError() {
		return false, diags
	}

	return true, nil
}

// readBack reads information about an APT repository from the Proxmox VE API and then updates the response state
// accordingly.
// Note that the Terraform resource identifier must be set in the state before this method is called!
func (r *repositoryResource) readBack(ctx context.Context, rp *modelRepo, diags *diag.Diagnostics, state *tfsdk.State) {
	found, readDiags := r.read(ctx, rp)

	diags.Append(readDiags...)

	if !found {
		diags.AddError(
			"APT repository resource not found after update",
			"Failed to find the resource when trying to read back the updated APT repository's data.",
		)
	}

	if !diags.HasError() {
		diags.Append(state.Set(ctx, *rp)...)
	}
}

// Configure adds the provider-configured client to the resource.
func (r *repositoryResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

// Create modifies the activation state of an existing APT repository, including the addition of standard repositories
// to the repository lists.
// The name of this method might be a bit confusing for this resource, but this is due to the way how the Proxmox VE API
// works for APT repositories.
func (r *repositoryResource) Create(
	ctx context.Context,
	req resource.CreateRequest,
	resp *resource.CreateResponse,
) {
	var rp modelRepo

	resp.Diagnostics.Append(req.Plan.Get(ctx, &rp)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := &api.ModifyRequestBody{
		Enabled: proxmoxtypes.CustomBool(rp.Enabled.ValueBool()),
		Index:   rp.Index.ValueInt64(),
		Path:    rp.FilePath.ValueString(),
	}

	if err := r.client.Node(rp.Node.ValueString()).APT().Repositories().Modify(ctx, body); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not modify APT repository in file %v at index %v on node %v", rp.FilePath, rp.Index, rp.Node),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &rp, &resp.Diagnostics, &resp.State)
}

// Delete is currently a no-op for APT repositories due to the non-existing capability of the Proxmox VE API of deleting
// a configured APT repository.
// Also see Terraform's "Delete" framework documentation about [recommendations] and [caveats].
//
// [caveats]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete#caveats
// [recommendations]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete#recommendations
func (r *repositoryResource) Delete(_ context.Context, _ resource.DeleteRequest, _ *resource.DeleteResponse) {
}

// ImportState imports an APT repository from the Proxmox VE API.
func (r *repositoryResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	rp := modelRepo{
		Enabled: types.BoolValue(ResourceRepoActivationStatus),
		ID:      types.StringValue(req.ID),
	}

	idFormatErrMsg := "expected import ID as comma-separated list in format " +
		"PROXMOX_VE_NODE_NAME,SOURCE_LIST_FILE_PATH,INDEX (e.g. pve,/etc/apt/sources.list,0)"

	parts := strings.Split(rp.ID.ValueString(), ",")
	if len(parts) != 3 {
		resp.Diagnostics.AddError("Invalid resource ID", fmt.Sprintf("%s, but got %v", idFormatErrMsg, rp.ID))

		return
	}

	rp.Node = types.StringValue(parts[0])

	if !strings.HasPrefix(parts[1], "/") {
		resp.Diagnostics.AddError(
			"Invalid resource ID",
			fmt.Sprintf("given source list file path %q is not an absolute path: %s", parts[1], idFormatErrMsg),
		)

		return
	}

	rp.FilePath = types.StringValue(parts[1])

	index, err := strconv.Atoi(parts[2])
	if err != nil {
		resp.Diagnostics.AddError(
			"Parse resource ID",
			fmt.Sprintf("Failed to parse given import ID index parameter %q as number: %s", parts[2], idFormatErrMsg),
		)

		return
	}

	rp.Index = types.Int64Value(int64(index))

	resource.ImportStatePassthroughID(ctx, path.Root(SchemaAttrNameTerraformID), req, resp)
	r.readBack(ctx, &rp, &resp.Diagnostics, &resp.State)
}

// Metadata defines the name of the APT repository resource.
func (r *repositoryResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_" + ResourceRepoIDPrefix
}

// Read reads the APT repository.
func (r *repositoryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var rp modelRepo

	resp.Diagnostics.Append(req.State.Get(ctx, &rp)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &rp)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, rp)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Schema defines the schema for the APT repository.
func (r *repositoryResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages an APT repository of a Proxmox VE node.",
		Attributes: map[string]schema.Attribute{
			SchemaAttrNameComment: schema.StringAttribute{
				Computed:    true,
				Description: "The associated comment.",
			},
			SchemaAttrNameComponents: schema.ListAttribute{
				Computed:    true,
				Description: "The list of components.",
				ElementType: types.StringType,
			},
			SchemaAttrNameEnabled: schema.BoolAttribute{
				Computed:    true,
				Default:     booldefault.StaticBool(ResourceRepoActivationStatus),
				Description: "Indicates the activation status.",
				Optional:    true,
			},
			SchemaAttrNameFilePath: schema.StringAttribute{
				Description: "The absolute path of the source list file that contains this repository.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Required: true,
				Validators: []validator.String{
					validators.AbsoluteFilePathValidator(),
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNameFileType: schema.StringAttribute{
				Computed:    true,
				Description: "The format of the defining source list file.",
			},
			SchemaAttrNameIndex: schema.Int64Attribute{
				Description: "The index within the defining source list file.",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
				Required: true,
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
			SchemaAttrNameNode: schema.StringAttribute{
				Description: "The name of the target Proxmox VE node.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Required: true,
				Validators: []validator.String{
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNamePackageTypes: schema.ListAttribute{
				Computed:    true,
				Description: "The list of package types.",
				ElementType: types.StringType,
			},
			SchemaAttrNameSuites: schema.ListAttribute{
				Computed:    true,
				Description: "The list of package distributions.",
				ElementType: types.StringType,
			},
			SchemaAttrNameTerraformID: attribute.ResourceID("The unique identifier of this APT repository resource."),
			SchemaAttrNameURIs: schema.ListAttribute{
				Computed:    true,
				Description: "The list of repository URIs.",
				ElementType: types.StringType,
			},
		},
	}
}

// Update updates an existing APT repository.
func (r *repositoryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var rpPlan modelRepo

	resp.Diagnostics.Append(req.Plan.Get(ctx, &rpPlan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := &api.ModifyRequestBody{
		Enabled: proxmoxtypes.CustomBool(rpPlan.Enabled.ValueBool()),
		Index:   rpPlan.Index.ValueInt64(),
		Path:    rpPlan.FilePath.ValueString(),
	}

	err := r.client.Node(rpPlan.Node.ValueString()).APT().Repositories().Modify(ctx, body)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf(
				"Could not modify APT repository in file %v at index %v on node %v",
				rpPlan.FilePath,
				rpPlan.Index,
				rpPlan.Node,
			),
			err.Error(),
		)

		return
	}

	r.readBack(ctx, &rpPlan, &resp.Diagnostics, &resp.State)
}

// NewRepositoryResource returns a new resource for managing an APT repository.
// This is a helper function to simplify the provider implementation.
func NewRepositoryResource() resource.Resource {
	return &repositoryResource{}
}
`````

## File: fwprovider/nodes/apt/resource_standard_repo.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types/nodes/apt"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	api "github.com/bpg/terraform-provider-proxmox/proxmox/nodes/apt/repositories"
)

const (
	// ResourceStandardRepoIDPrefix is the prefix for the resource ID of standardRepositoryResource.
	ResourceStandardRepoIDPrefix = "apt_standard_repository"
)

// Ensure the resource implements the required interfaces.
var (
	_ resource.Resource                = &standardRepositoryResource{}
	_ resource.ResourceWithConfigure   = &standardRepositoryResource{}
	_ resource.ResourceWithImportState = &standardRepositoryResource{}
)

// standardRepositoryResource contains the APT standard repository resource's internal data.
type standardRepositoryResource struct {
	// client is the Proxmox VE API client.
	client proxmox.Client
}

// read reads information about an APT standard repository from the Proxmox VE API.
// Note that the name of the node must be set before this method is called!
func (r *standardRepositoryResource) read(ctx context.Context, srp *modelStandardRepo) (bool, diag.Diagnostics) {
	diags := diag.Diagnostics{}

	data, err := r.client.Node(srp.Node.ValueString()).APT().Repositories().Get(ctx)
	if err != nil {
		diags.AddError("Could not read APT repositories", err.Error())

		return false, diags
	}

	for _, stdRepo := range data.StandardRepos {
		// Check if the APT standard repository is configured‚Ä¶
		if stdRepo.Handle == srp.Handle.ValueString() && stdRepo.Status == nil {
			// ‚Ä¶handle the situation gracefully if not to signal that the repository has been removed outside of Terraform and
			// must be added back again.
			return false, diags
		}
	}

	srp.importFromAPI(ctx, data)

	return true, nil
}

// readBack reads information about an APT standard repository from the Proxmox VE API and then updates the response
// state accordingly.
func (r *standardRepositoryResource) readBack(
	ctx context.Context,
	srp *modelStandardRepo,
	diags *diag.Diagnostics,
	state *tfsdk.State,
) {
	found, readDiags := r.read(ctx, srp)

	diags.Append(readDiags...)

	if !found {
		diags.AddError(
			"APT standard repository resource not found after update",
			"Failed to find the resource when trying to read back the updated APT standard repository's data.",
		)
	}

	if !diags.HasError() {
		diags.Append(state.Set(ctx, *srp)...)
	}
}

// Configure adds the provider-configured client to the resource.
func (r *standardRepositoryResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

// Create adds an APT standard repository to the repository source lists.
// The name of this method might be a bit confusing for this resource, but this is due to the way how the Proxmox VE API
// works for APT standard repositories.
func (r *standardRepositoryResource) Create(
	ctx context.Context,
	req resource.CreateRequest,
	resp *resource.CreateResponse,
) {
	var srp modelStandardRepo

	resp.Diagnostics.Append(req.Plan.Get(ctx, &srp)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := &api.AddRequestBody{
		Handle: srp.Handle.ValueString(),
		Node:   srp.Node.ValueString(),
	}

	if err := r.client.Node(srp.Node.ValueString()).APT().Repositories().Add(ctx, body); err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Could not add APT standard repository with handle %v on node %v", srp.Handle, srp.Node),
			err.Error(),
		)
	}

	r.readBack(ctx, &srp, &resp.Diagnostics, &resp.State)
}

// Delete is currently a no-op for APT standard repositories due to the non-existing capability of the Proxmox VE API
// of deleting a configured APT standard repository.
// Also see Terraform's "Delete" framework documentation about [recommendations] and [caveats].
//
// [caveats]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete#caveats
// [recommendations]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete#recommendations
func (r *standardRepositoryResource) Delete(_ context.Context, _ resource.DeleteRequest, _ *resource.DeleteResponse) {
}

// ImportState imports an APT standard repository from the Proxmox VE API.
func (r *standardRepositoryResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	srp := modelStandardRepo{
		ID: types.StringValue(req.ID),
	}

	idFormatErrMsg := "expected import ID as comma-separated list in format " +
		"PROXMOX_VE_NODE_NAME,STANDARD_REPOSITORY_HANDLE (e.g. pve,no-subscription)"

	parts := strings.Split(srp.ID.ValueString(), ",")
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Invalid resource ID", fmt.Sprintf("%s, but got %v", idFormatErrMsg, srp.ID))

		return
	}

	srp.Node = types.StringValue(parts[0])
	srp.Handle = customtypes.StandardRepoHandleValue{StringValue: types.StringValue(parts[1])}

	resource.ImportStatePassthroughID(ctx, path.Root(SchemaAttrNameTerraformID), req, resp)
	r.readBack(ctx, &srp, &resp.Diagnostics, &resp.State)
}

// Metadata defines the name of the APT standard repository resource.
func (r *standardRepositoryResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_" + ResourceStandardRepoIDPrefix
}

// Read reads the APT standard repository.
func (r *standardRepositoryResource) Read(
	ctx context.Context,
	req resource.ReadRequest,
	resp *resource.ReadResponse,
) {
	var srp modelStandardRepo

	resp.Diagnostics.Append(req.State.Get(ctx, &srp)...)

	if resp.Diagnostics.HasError() {
		return
	}

	found, diags := r.read(ctx, &srp)
	resp.Diagnostics.Append(diags...)

	if !resp.Diagnostics.HasError() {
		if found {
			resp.Diagnostics.Append(resp.State.Set(ctx, srp)...)
		} else {
			resp.State.RemoveResource(ctx)
		}
	}
}

// Schema defines the schema for the APT standard repository.
func (r *standardRepositoryResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages an APT standard repository of a Proxmox VE node.",
		Attributes: map[string]schema.Attribute{
			SchemaAttrNameStandardDescription: schema.StringAttribute{
				Computed:    true,
				Description: "The description of the APT standard repository.",
			},
			SchemaAttrNameFilePath: schema.StringAttribute{
				Computed:    true,
				Description: "The absolute path of the source list file that contains this standard repository.",
			},
			SchemaAttrNameStandardHandle: schema.StringAttribute{
				CustomType:  customtypes.StandardRepoHandleType{},
				Description: "The handle of the APT standard repository.",
				MarkdownDescription: "The handle of the APT standard repository. Must be `ceph-quincy-enterprise` | " +
					"`ceph-quincy-no-subscription` | `ceph-quincy-test` | `ceph-reef-enterprise` | `ceph-reef-no-subscription` " +
					"| `ceph-reef-test` | `enterprise` | `no-subscription` | `test`.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Required: true,
				Validators: []validator.String{
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNameIndex: schema.Int64Attribute{
				Computed:    true,
				Description: "The index within the defining source list file.",
			},
			SchemaAttrNameStandardName: schema.StringAttribute{
				Computed:    true,
				Description: "The name of the APT standard repository.",
			},
			SchemaAttrNameNode: schema.StringAttribute{
				Description: "The name of the target Proxmox VE node.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Required: true,
				Validators: []validator.String{
					validators.NonEmptyString(),
				},
			},
			SchemaAttrNameStandardStatus: schema.Int64Attribute{
				Computed:    true,
				Description: "Indicates the activation status.",
			},
			SchemaAttrNameTerraformID: attribute.ResourceID(
				"The unique identifier of this APT standard repository resource.",
			),
		},
	}
}

// Update is currently a no-op for APT repositories due to the non-existing capability of the Proxmox VE API of updating
// a configured APT standard repository.
// Also see Terraform's "Delete" framework documentation about [recommendations] and [caveats].
//
// [caveats]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete#caveats
// [recommendations]: https://developer.hashicorp.com/terraform/plugin/framework/resources/delete#recommendations
func (r *standardRepositoryResource) Update(_ context.Context, _ resource.UpdateRequest, _ *resource.UpdateResponse) {
}

// NewStandardRepositoryResource returns a new resource for managing an APT standard repository.
// This is a helper function to simplify the provider implementation.
func NewStandardRepositoryResource() resource.Resource {
	return &standardRepositoryResource{}
}
`````

## File: fwprovider/nodes/datastores/datasource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datastores

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/types/stringset"
)

// Schema defines the schema for the resource.
func (d *Datasource) Schema(
	_ context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Retrieves information about all the datastores available to a specific node.",
		Attributes: map[string]schema.Attribute{
			"node_name": schema.StringAttribute{
				Description: "The name of the node to retrieve the stores from.",
				Required:    true,
			},
			"filters": schema.SingleNestedAttribute{
				Description: "The filters to apply to the stores.",
				Optional:    true,
				Attributes: map[string]schema.Attribute{
					"content_types": stringset.DataSourceAttribute("Only list stores with the given content types.", "", true),
					"id": schema.StringAttribute{
						Description: "Only list stores with the given ID.",
						Optional:    true,
					},
					"target": schema.StringAttribute{
						Description: "If `target` is different to `node_name`, then only lists shared stores which " +
							"content is accessible on this node and the specified `target` node.",
						Optional: true,
					},
				},
			},
			"datastores": schema.ListNestedAttribute{
				Description: "The list of datastores.",
				Optional:    true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"active": schema.BoolAttribute{
							Description: "Whether the store is active.",
							Optional:    true,
						},
						"content_types": stringset.DataSourceAttribute("Allowed store content types.", "", false),
						"enabled": schema.BoolAttribute{
							Description: "Whether the store is enabled.",
							Optional:    true,
						},
						"id": schema.StringAttribute{
							Description: "The ID of the store.",
							Required:    true,
						},
						"node_name": schema.StringAttribute{
							Description: "The name of the node the store is on.",
							Required:    true,
						},
						"shared": schema.BoolAttribute{
							Description: "Shared flag from store configuration.",
							Optional:    true,
						},
						"space_available": schema.Int64Attribute{
							Description: "Available store space in bytes.",
							Optional:    true,
						},
						"space_total": schema.Int64Attribute{
							Description: "Total store space in bytes.",
							Optional:    true,
						},
						"space_used": schema.Int64Attribute{
							Description: "Used store space in bytes.",
							Optional:    true,
						},
						"space_used_fraction": schema.Float64Attribute{
							Description: "Used fraction (used/total).",
							Optional:    true,
						},
						"type": schema.StringAttribute{
							Description: "Store type.",
							Required:    true,
						},
					},
				},
			},
		},
	}
}
`````

## File: fwprovider/nodes/datastores/datasource_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datastores_test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccDatasourceDatastores(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"read datastores attributes", []resource.TestStep{{
			Config: te.RenderConfig(`data "proxmox_virtual_environment_datastores" "test" {
				node_name = "{{.NodeName}}"
				filters = {
					content_types = ["iso"]
				}
			}`),

			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributesSet("data.proxmox_virtual_environment_datastores.test", []string{
					"node_name",
				}),
				test.ResourceAttributes("data.proxmox_virtual_environment_datastores.test", map[string]string{
					"datastores.#":        "1",
					"datastores.0.active": "true",
					"datastores.0.id":     "local",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/nodes/datastores/datasource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datastores

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/types/stringset"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/storage"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &Datasource{}
	_ datasource.DataSourceWithConfigure = &Datasource{}
)

// Datasource is the implementation of datastores datasource.
type Datasource struct {
	client proxmox.Client
}

// NewDataSource creates a new datastores datasource.
func NewDataSource() datasource.DataSource {
	return &Datasource{}
}

// Metadata defines the name of the resource.
func (d *Datasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_datastores"
}

// Configure sets the client for the resource.
func (d *Datasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client
}

func (d *Datasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var model Model

	resp.Diagnostics.Append(req.Config.Get(ctx, &model)...)

	if resp.Diagnostics.HasError() {
		return
	}

	storageAPI := d.client.Node(model.NodeName.ValueString()).Storage("")

	r := storage.DatastoreListRequestBody{}
	if model.Filters != nil {
		r.ContentTypes = model.Filters.ContentTypes.ValueList(ctx, &resp.Diagnostics)
		r.ID = model.Filters.ID.ValueStringPointer()
		r.Target = model.Filters.Target.ValueStringPointer()
	}

	dsList, err := storageAPI.ListDatastores(ctx, &r)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to read datastores",
			err.Error(),
		)

		return
	}

	model.Datastores = make([]Datastore, 0, len(dsList))

	for _, ds := range dsList {
		datastore := Datastore{}

		if ds.ContentTypes != nil {
			datastore.ContentTypes = stringset.NewValueList(*ds.ContentTypes, &resp.Diagnostics)
		}

		datastore.Active = types.BoolPointerValue(ds.Active.PointerBool())
		datastore.Enabled = types.BoolPointerValue(ds.Enabled.PointerBool())
		datastore.ID = types.StringValue(ds.ID)
		datastore.NodeName = types.StringValue(model.NodeName.ValueString())
		datastore.Shared = types.BoolPointerValue(ds.Shared.PointerBool())
		datastore.SpaceAvailable = types.Int64PointerValue(ds.SpaceAvailable.PointerInt64())
		datastore.SpaceTotal = types.Int64PointerValue(ds.SpaceTotal.PointerInt64())
		datastore.SpaceUsed = types.Int64PointerValue(ds.SpaceUsed.PointerInt64())
		datastore.SpaceUsedFraction = types.Float64PointerValue(ds.SpaceUsedPercentage.PointerFloat64())
		datastore.Type = types.StringValue(ds.Type)

		model.Datastores = append(model.Datastores, datastore)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, model)...)
}
`````

## File: fwprovider/nodes/datastores/model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datastores

import (
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/types/stringset"
)

type Model struct {
	NodeName types.String `tfsdk:"node_name"`
	Filters  *struct {
		ContentTypes stringset.Value `tfsdk:"content_types"`
		ID           types.String    `tfsdk:"id"`
		Target       types.String    `tfsdk:"target"`
	} `tfsdk:"filters"`
	Datastores []Datastore `tfsdk:"datastores"`
}

type Datastore struct {
	Active            types.Bool      `tfsdk:"active"`
	ContentTypes      stringset.Value `tfsdk:"content_types"`
	Enabled           types.Bool      `tfsdk:"enabled"`
	ID                types.String    `tfsdk:"id"`
	NodeName          types.String    `tfsdk:"node_name"`
	Shared            types.Bool      `tfsdk:"shared"`
	SpaceAvailable    types.Int64     `tfsdk:"space_available"`
	SpaceTotal        types.Int64     `tfsdk:"space_total"`
	SpaceUsed         types.Int64     `tfsdk:"space_used"`
	SpaceUsedFraction types.Float64   `tfsdk:"space_used_fraction"`
	Type              types.String    `tfsdk:"type"`
}
`````

## File: fwprovider/nodes/network/resource_linux_bridge_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package network_test

import (
	"fmt"
	"testing"

	"github.com/brianvoe/gofakeit/v7"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccResourceLinuxBridge(t *testing.T) {
	te := test.InitEnvironment(t)

	iface := fmt.Sprintf("vmbr%d", gofakeit.Number(10, 9999))
	ipV4cidr1 := fmt.Sprintf("%s/24", gofakeit.IPv4Address())
	ipV4cidr2 := fmt.Sprintf("%s/24", gofakeit.IPv4Address())
	ipV6cidr := "FE80:0000:0000:0000:0202:B3FF:FE1E:8329/64"

	resource.Test(t, resource.TestCase{
		ProtoV6ProviderFactories: te.AccProviders,
		Steps: []resource.TestStep{
			// Create and Read testing
			{
				Config: te.RenderConfig(fmt.Sprintf(`
				resource "proxmox_virtual_environment_network_linux_bridge" "test" {
					address = "%s"
					autostart = true
					comment = "created by terraform"
					mtu = 1499
					name = "%s"
					node_name = "{{.NodeName}}"
					vlan_aware = true
				}
				`, ipV4cidr1, iface)),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_network_linux_bridge.test", map[string]string{
						"address":    ipV4cidr1,
						"autostart":  "true",
						"comment":    "created by terraform",
						"mtu":        "1499",
						"name":       iface,
						"vlan_aware": "true",
					}),
					test.ResourceAttributesSet("proxmox_virtual_environment_network_linux_bridge.test", []string{
						"id",
					}),
				),
			},
			// Update testing
			{
				Config: te.RenderConfig(fmt.Sprintf(`
				resource "proxmox_virtual_environment_network_linux_bridge" "test" {
					address = "%s"
					address6 = "%s"
					autostart = false
					comment = ""
					mtu = null
					name = "%s"
					node_name = "{{.NodeName}}"
					vlan_aware = false
				}`, ipV4cidr2, ipV6cidr, iface)),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_network_linux_bridge.test", map[string]string{
						"address":    ipV4cidr2,
						"address6":   ipV6cidr,
						"autostart":  "false",
						"comment":    "",
						"name":       iface,
						"vlan_aware": "false",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_network_linux_bridge.test", []string{
						"mtu",
					}),
					test.ResourceAttributesSet("proxmox_virtual_environment_network_linux_bridge.test", []string{
						"id",
					}),
				),
			},
			// ImportState testing
			{
				ResourceName:      "proxmox_virtual_environment_network_linux_bridge.test",
				ImportState:       true,
				ImportStateVerify: true,
				ImportStateVerifyIgnore: []string{
					"comment", // "" comments translates to null in the PVE, but nulls are not imported as empty strings.
				},
			},
		},
	})
}
`````

## File: fwprovider/nodes/network/resource_linux_bridge.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package network

import (
	"context"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	_ resource.Resource                = &linuxBridgeResource{}
	_ resource.ResourceWithConfigure   = &linuxBridgeResource{}
	_ resource.ResourceWithImportState = &linuxBridgeResource{}
)

type linuxBridgeResourceModel struct {
	// Base attributes
	ID        types.String            `tfsdk:"id"`
	NodeName  types.String            `tfsdk:"node_name"`
	Name      types.String            `tfsdk:"name"`
	Address   customtypes.IPCIDRValue `tfsdk:"address"`
	Gateway   customtypes.IPAddrValue `tfsdk:"gateway"`
	Address6  customtypes.IPCIDRValue `tfsdk:"address6"`
	Gateway6  customtypes.IPAddrValue `tfsdk:"gateway6"`
	Autostart types.Bool              `tfsdk:"autostart"`
	MTU       types.Int64             `tfsdk:"mtu"`
	Comment   types.String            `tfsdk:"comment"`
	// Linux bridge attributes
	Ports     []types.String `tfsdk:"ports"`
	VLANAware types.Bool     `tfsdk:"vlan_aware"`
}

//nolint:lll
func (m *linuxBridgeResourceModel) exportToNetworkInterfaceCreateUpdateBody() *nodes.NetworkInterfaceCreateUpdateRequestBody {
	body := &nodes.NetworkInterfaceCreateUpdateRequestBody{
		Iface:     m.Name.ValueString(),
		Type:      "bridge",
		Autostart: proxmoxtypes.CustomBool(m.Autostart.ValueBool()).Pointer(),
	}

	body.CIDR = m.Address.ValueStringPointer()
	body.Gateway = m.Gateway.ValueStringPointer()
	body.CIDR6 = m.Address6.ValueStringPointer()
	body.Gateway6 = m.Gateway6.ValueStringPointer()

	if !m.MTU.IsUnknown() {
		body.MTU = m.MTU.ValueInt64Pointer()
	}

	body.Comments = m.Comment.ValueStringPointer()

	var sanitizedPorts []string

	for _, port := range m.Ports {
		port := strings.TrimSpace(port.ValueString())
		if len(port) > 0 {
			sanitizedPorts = append(sanitizedPorts, port)
		}
	}

	sort.Strings(sanitizedPorts)
	bridgePorts := strings.Join(sanitizedPorts, " ")

	if len(bridgePorts) > 0 {
		body.BridgePorts = &bridgePorts
	}

	if m.VLANAware.ValueBool() {
		body.BridgeVLANAware = proxmoxtypes.CustomBool(true).Pointer()
	}

	return body
}

func (m *linuxBridgeResourceModel) importFromNetworkInterfaceList(
	ctx context.Context,
	iface *nodes.NetworkInterfaceListResponseData,
) error {
	m.Address = customtypes.NewIPCIDRPointerValue(iface.CIDR)
	m.Gateway = customtypes.NewIPAddrPointerValue(iface.Gateway)
	m.Address6 = customtypes.NewIPCIDRPointerValue(iface.CIDR6)
	m.Gateway6 = customtypes.NewIPAddrPointerValue(iface.Gateway6)

	m.Autostart = types.BoolPointerValue(iface.Autostart.PointerBool())
	if m.Autostart.IsNull() {
		m.Autostart = types.BoolValue(false)
	}

	if iface.MTU != nil {
		if v, err := strconv.Atoi(*iface.MTU); err == nil {
			m.MTU = types.Int64Value(int64(v))
		}
	} else {
		m.MTU = types.Int64Null()
	}

	// Comments can be set to an empty string in plant, which will translate to a "no value" in PVE
	// So we don't want to set it to null if it's empty, as this will be indicated as a plan drift
	if iface.Comments != nil {
		m.Comment = types.StringValue(strings.TrimSpace(*iface.Comments))
	}

	if iface.BridgeVLANAware != nil {
		m.VLANAware = types.BoolPointerValue(iface.BridgeVLANAware.PointerBool())
	} else {
		m.VLANAware = types.BoolValue(false)
	}

	if iface.BridgePorts != nil && len(*iface.BridgePorts) > 0 {
		ports, diags := types.ListValueFrom(ctx, types.StringType, strings.Split(*iface.BridgePorts, " "))
		if diags.HasError() {
			return fmt.Errorf("failed to parse bridge ports: %s", *iface.BridgePorts)
		}

		diags = ports.ElementsAs(ctx, &m.Ports, false)
		if diags.HasError() {
			return fmt.Errorf("failed to build bridge ports list: %s", *iface.BridgePorts)
		}
	}

	return nil
}

// NewLinuxBridgeResource creates a new resource for managing Linux Bridge network interfaces.
func NewLinuxBridgeResource() resource.Resource {
	return &linuxBridgeResource{}
}

type linuxBridgeResource struct {
	client proxmox.Client
}

func (r *linuxBridgeResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_network_linux_bridge"
}

// Schema defines the schema for the resource.
func (r *linuxBridgeResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages a Linux Bridge network interface in a Proxmox VE node.",
		Attributes: map[string]schema.Attribute{
			// Base attributes
			"id": attribute.ResourceID("A unique identifier with format `<node name>:<iface>`"),
			"node_name": schema.StringAttribute{
				Description: "The name of the node.",
				Required:    true,
			},
			"name": schema.StringAttribute{
				Description: "The interface name.",
				MarkdownDescription: "The interface name. Commonly vmbr[N], where 0 ‚â§ N ‚â§ 4094 (vmbr0 - vmbr4094), but " +
					"can be any alphanumeric string that starts with a character and is at most 10 characters long.",
				Required: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^[A-Za-z][A-Za-z0-9]{0,9}$`),
						`must be an alphanumeric string that starts with a character and is at most 10 characters long`,
					),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"address": schema.StringAttribute{
				Description: "The interface IPv4/CIDR address.",
				CustomType:  customtypes.IPCIDRType{},
				Optional:    true,
			},
			"gateway": schema.StringAttribute{
				Description: "Default gateway address.",
				CustomType:  customtypes.IPAddrType{},
				Optional:    true,
			},
			"address6": schema.StringAttribute{
				Description: "The interface IPv6/CIDR address.",
				CustomType:  customtypes.IPCIDRType{},
				Optional:    true,
			},
			"gateway6": schema.StringAttribute{
				Description: "Default IPv6 gateway address.",
				CustomType:  customtypes.IPAddrType{},
				Optional:    true,
			},
			"autostart": schema.BoolAttribute{
				Description: "Automatically start interface on boot (defaults to `true`).",
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(true),
			},
			"mtu": schema.Int64Attribute{
				Description: "The interface MTU.",
				Optional:    true,
			},
			"comment": schema.StringAttribute{
				Description: "Comment for the interface.",
				Optional:    true,
			},
			// Linux Bridge attributes
			"ports": schema.ListAttribute{
				Description: "The interface bridge ports.",
				Optional:    true,
				ElementType: types.StringType,
			},
			"vlan_aware": schema.BoolAttribute{
				Description: "Whether the interface bridge is VLAN aware (defaults to `false`).",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func (r *linuxBridgeResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

//nolint:dupl
func (r *linuxBridgeResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan linuxBridgeResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.exportToNetworkInterfaceCreateUpdateBody()

	err := r.client.Node(plan.NodeName.ValueString()).CreateNetworkInterface(ctx, body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating Linux Bridge interface",
			"Could not create Linux Bridge, unexpected error: "+err.Error(),
		)

		return
	}

	plan.ID = types.StringValue(plan.NodeName.ValueString() + ":" + plan.Name.ValueString())

	r.read(ctx, &plan, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)

	err = r.client.Node(plan.NodeName.ValueString()).ReloadNetworkConfiguration(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reloading network configuration",
			fmt.Sprintf("Could not reload network configuration on node '%s', unexpected error: %s",
				plan.NodeName.ValueString(), err.Error()),
		)
	}
}

func (r *linuxBridgeResource) read(ctx context.Context, model *linuxBridgeResourceModel, diags *diag.Diagnostics) {
	ifaces, err := r.client.Node(model.NodeName.ValueString()).ListNetworkInterfaces(ctx)
	if err != nil {
		diags.AddError(
			"Error listing network interfaces",
			"Could not list network interfaces, unexpected error: "+err.Error(),
		)

		return
	}

	for _, iface := range ifaces {
		if iface.Iface != model.Name.ValueString() {
			continue
		}

		err = model.importFromNetworkInterfaceList(ctx, iface)
		if err != nil {
			diags.AddError(
				"Error converting network interface to a model",
				"Could not import network interface from API response, unexpected error: "+err.Error(),
			)

			return
		}

		break
	}
}

// Read reads a Linux Bridge interface.
func (r *linuxBridgeResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	// Get current state
	var state linuxBridgeResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	r.read(ctx, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

// Update updates a Linux Bridge interface.
func (r *linuxBridgeResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state linuxBridgeResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.exportToNetworkInterfaceCreateUpdateBody()

	var toDelete []string

	if !plan.MTU.Equal(state.MTU) && plan.MTU.ValueInt64() == 0 {
		toDelete = append(toDelete, "mtu")
		body.MTU = nil
	}

	if !plan.Gateway.Equal(state.Gateway) && plan.Gateway.ValueString() == "" {
		toDelete = append(toDelete, "gateway")
		body.Gateway = nil
	}

	if !plan.Gateway6.Equal(state.Gateway6) && plan.Gateway6.ValueString() == "" {
		toDelete = append(toDelete, "gateway6")
		body.Gateway6 = nil
	}

	// VLANAware is computed, will never be null
	if !plan.VLANAware.Equal(state.VLANAware) && !plan.VLANAware.ValueBool() {
		toDelete = append(toDelete, "bridge_vlan_aware")
		body.BridgeVLANAware = nil
	}

	if len(toDelete) > 0 {
		body.Delete = &toDelete
	}

	err := r.client.Node(plan.NodeName.ValueString()).UpdateNetworkInterface(ctx, plan.Name.ValueString(), body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating Linux Bridge interface",
			"Could not update Linux Bridge, unexpected error: "+err.Error(),
		)

		return
	}

	r.read(ctx, &plan, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)

	err = r.client.Node(state.NodeName.ValueString()).ReloadNetworkConfiguration(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reloading network configuration",
			fmt.Sprintf("Could not reload network configuration on node '%s', unexpected error: %s",
				state.NodeName.ValueString(), err.Error()),
		)
	}
}

// Delete deletes a Linux Bridge interface.
//
//nolint:dupl
func (r *linuxBridgeResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state linuxBridgeResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.Node(state.NodeName.ValueString()).DeleteNetworkInterface(ctx, state.Name.ValueString())
	if err != nil {
		if strings.Contains(err.Error(), "interface does not exist") {
			resp.Diagnostics.AddWarning(
				"Linux Bridge interface does not exist",
				fmt.Sprintf("Could not delete Linux Bridge '%s', interface does not exist, "+
					"or has already been deleted outside of Terraform.", state.Name.ValueString()),
			)
		} else {
			resp.Diagnostics.AddError(
				"Error deleting Linux Bridge interface",
				fmt.Sprintf("Could not delete Linux Bridge '%s', unexpected error: %s",
					state.Name.ValueString(), err.Error()),
			)
		}

		return
	}

	err = r.client.Node(state.NodeName.ValueString()).ReloadNetworkConfiguration(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reloading network configuration",
			fmt.Sprintf("Could not reload network configuration on node '%s', unexpected error: %s",
				state.NodeName.ValueString(), err.Error()),
		)
	}
}

func (r *linuxBridgeResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	idParts := strings.Split(req.ID, ":")
	if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: `node_name:iface`. Got: %q", req.ID),
		)

		return
	}

	nodeName := idParts[0]
	iface := idParts[1]

	state := linuxBridgeResourceModel{
		ID:       types.StringValue(req.ID),
		NodeName: types.StringValue(nodeName),
		Name:     types.StringValue(iface),
	}
	r.read(ctx, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	diags := resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}
`````

## File: fwprovider/nodes/network/resource_linux_vlan_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package network_test

import (
	"fmt"
	"os"
	"strconv"
	"testing"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

const (
	accTestLinuxVLANName = "proxmox_virtual_environment_network_linux_vlan.test"
)

func TestAccResourceLinuxVLAN(t *testing.T) {
	te := test.InitEnvironment(t)

	iface := os.Getenv("PROXMOX_VE_ACC_IFACE_NAME")
	if iface == "" {
		iface = "ens18"
	}

	vlan1 := gofakeit.Number(10, 4094)
	customName := fmt.Sprintf("iface_%s", gofakeit.Word())
	vlan2 := gofakeit.Number(10, 4094)
	ipV4cidr := fmt.Sprintf("%s/24", gofakeit.IPv4Address())

	resource.Test(t, resource.TestCase{
		ProtoV6ProviderFactories: te.AccProviders,
		Steps: []resource.TestStep{
			// Create and Read testing
			{
				Config: te.RenderConfig(testAccResourceLinuxVLANCreatedConfig(iface, vlan1)),
				Check:  testAccResourceLinuxVLANCreatedCheck(iface, vlan1),
			},
			// ImportState testing
			{
				ResourceName:      accTestLinuxVLANName,
				ImportState:       true,
				ImportStateVerify: true,
			},
			// Create and Read with a custom name
			{
				Config: te.RenderConfig(testAccResourceLinuxVLANCustomNameCreatedConfig(customName, iface, vlan2)),
				Check:  testAccResourceLinuxVLANCustomNameCreatedCheck(customName, iface, vlan2),
				// PVE API is unreliable. Sometimes it returns a wrong VLAN ID for this second interface.
				SkipFunc: func() (bool, error) {
					return true, nil
				},
			},
			// Update testing
			{
				Config: te.RenderConfig(testAccResourceLinuxVLANUpdatedConfig(iface, vlan1, ipV4cidr)),
				Check:  testAccResourceLinuxVLANUpdatedCheck(iface, vlan1, ipV4cidr),
			},
		},
	})
}

func testAccResourceLinuxVLANCreatedConfig(iface string, vlan int) string {
	return fmt.Sprintf(`
	resource "proxmox_virtual_environment_network_linux_vlan" "test" {
		comment = "created by terraform"
		mtu = 1499
		name = "%s.%d"
		node_name = "{{.NodeName}}"
	}
	`, iface, vlan)
}

func testAccResourceLinuxVLANCreatedCheck(iface string, vlan int) resource.TestCheckFunc {
	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "comment", "created by terraform"),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "interface", iface),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "name", fmt.Sprintf("%s.%d", iface, vlan)),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "vlan", strconv.Itoa(vlan)),
		resource.TestCheckResourceAttrSet(accTestLinuxVLANName, "id"),
	)
}

func testAccResourceLinuxVLANCustomNameCreatedConfig(name string, iface string, vlan int) string {
	return fmt.Sprintf(`
	resource "proxmox_virtual_environment_network_linux_vlan" "%s" {
		comment = "created by terraform"
		interface = "%s"
		mtu = 1499
		name = "%s"
		node_name = "{{.NodeName}}"
		vlan = %d
	}
	`, name, iface, name, vlan)
}

func testAccResourceLinuxVLANCustomNameCreatedCheck(name string, iface string, vlan int) resource.TestCheckFunc {
	resourceName := fmt.Sprintf("proxmox_virtual_environment_network_linux_vlan.%s", name)

	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr(resourceName, "comment", "created by terraform"),
		resource.TestCheckResourceAttr(resourceName, "interface", iface),
		resource.TestCheckResourceAttr(resourceName, "name", name),
		resource.TestCheckResourceAttr(resourceName, "vlan", strconv.Itoa(vlan)),
		resource.TestCheckResourceAttrSet(resourceName, "id"),
	)
}

func testAccResourceLinuxVLANUpdatedConfig(iface string, vlan int, ipV4cidr string) string {
	return fmt.Sprintf(`
	resource "proxmox_virtual_environment_network_linux_vlan" "test" {
		address = "%s"
		address6 = "FE80:0000:0000:0000:0202:B3FF:FE1E:8329/64"
		comment = "updated by terraform"
		name = "%s.%d"
		node_name = "{{.NodeName}}"
	}
	`, ipV4cidr, iface, vlan)
}

func testAccResourceLinuxVLANUpdatedCheck(iface string, vlan int, ipV4cidr string) resource.TestCheckFunc {
	return resource.ComposeTestCheckFunc(
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "address", ipV4cidr),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "address6", "FE80:0000:0000:0000:0202:B3FF:FE1E:8329/64"),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "comment", "updated by terraform"),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "interface", iface),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "name", fmt.Sprintf("%s.%d", iface, vlan)),
		resource.TestCheckResourceAttr(accTestLinuxVLANName, "vlan", strconv.Itoa(vlan)),
		resource.TestCheckNoResourceAttr(accTestLinuxVLANName, "mtu"),
		resource.TestCheckResourceAttrSet(accTestLinuxVLANName, "id"),
	)
}
`````

## File: fwprovider/nodes/network/resource_linux_vlan.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package network

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	customtypes "github.com/bpg/terraform-provider-proxmox/fwprovider/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	_ resource.Resource                = &linuxVLANResource{}
	_ resource.ResourceWithConfigure   = &linuxVLANResource{}
	_ resource.ResourceWithImportState = &linuxVLANResource{}
)

type linuxVLANResourceModel struct {
	// Base attributes
	ID        types.String            `tfsdk:"id"`
	NodeName  types.String            `tfsdk:"node_name"`
	Name      types.String            `tfsdk:"name"`
	Address   customtypes.IPCIDRValue `tfsdk:"address"`
	Gateway   customtypes.IPAddrValue `tfsdk:"gateway"`
	Address6  customtypes.IPCIDRValue `tfsdk:"address6"`
	Gateway6  customtypes.IPAddrValue `tfsdk:"gateway6"`
	Autostart types.Bool              `tfsdk:"autostart"`
	MTU       types.Int64             `tfsdk:"mtu"`
	Comment   types.String            `tfsdk:"comment"`
	// Linux VLAN attributes
	Interface types.String `tfsdk:"interface"`
	VLAN      types.Int64  `tfsdk:"vlan"`
}

//nolint:lll
func (m *linuxVLANResourceModel) exportToNetworkInterfaceCreateUpdateBody() *nodes.NetworkInterfaceCreateUpdateRequestBody {
	body := &nodes.NetworkInterfaceCreateUpdateRequestBody{
		Iface:     m.Name.ValueString(),
		Type:      "vlan",
		Autostart: proxmoxtypes.CustomBool(m.Autostart.ValueBool()).Pointer(),
	}

	body.CIDR = m.Address.ValueStringPointer()
	body.Gateway = m.Gateway.ValueStringPointer()
	body.CIDR6 = m.Address6.ValueStringPointer()
	body.Gateway6 = m.Gateway6.ValueStringPointer()
	body.Comments = m.Comment.ValueStringPointer()

	if !m.MTU.IsUnknown() {
		body.MTU = m.MTU.ValueInt64Pointer()
	}

	if !m.Interface.IsUnknown() {
		body.VLANRawDevice = m.Interface.ValueStringPointer()
	}

	if !m.VLAN.IsUnknown() {
		body.VLANID = m.VLAN.ValueInt64Pointer()
	}

	return body
}

func (m *linuxVLANResourceModel) importFromNetworkInterfaceList(iface *nodes.NetworkInterfaceListResponseData) {
	m.Address = customtypes.NewIPCIDRPointerValue(iface.CIDR)
	m.Gateway = customtypes.NewIPAddrPointerValue(iface.Gateway)
	m.Address6 = customtypes.NewIPCIDRPointerValue(iface.CIDR6)
	m.Gateway6 = customtypes.NewIPAddrPointerValue(iface.Gateway6)
	m.Autostart = types.BoolPointerValue(iface.Autostart.PointerBool())

	if iface.MTU != nil {
		if v, err := strconv.Atoi(*iface.MTU); err == nil {
			m.MTU = types.Int64Value(int64(v))
		}
	} else {
		m.MTU = types.Int64Null()
	}

	if iface.Comments != nil {
		m.Comment = types.StringValue(strings.TrimSpace(*iface.Comments))
	} else {
		m.Comment = types.StringNull()
	}

	if iface.VLANID != nil {
		if v, err := strconv.Atoi(*iface.VLANID); err == nil {
			m.VLAN = types.Int64Value(int64(v))
		}
	} else {
		// in reality, this should never happen
		m.VLAN = types.Int64Unknown()
	}

	if iface.VLANRawDevice != nil {
		m.Interface = types.StringValue(strings.TrimSpace(*iface.VLANRawDevice))
	} else {
		m.Interface = types.StringNull()
	}
}

// NewLinuxVLANResource creates a new resource for managing Linux VLAN network interfaces.
func NewLinuxVLANResource() resource.Resource {
	return &linuxVLANResource{}
}

type linuxVLANResource struct {
	client proxmox.Client
}

func (r *linuxVLANResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_network_linux_vlan"
}

// Schema defines the schema for the resource.
func (r *linuxVLANResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages a Linux VLAN network interface in a Proxmox VE node.",
		Attributes: map[string]schema.Attribute{
			// Base attributes
			"id": attribute.ResourceID("A unique identifier with format `<node name>:<iface>`."),
			"node_name": schema.StringAttribute{
				Description: "The name of the node.",
				Required:    true,
			},
			"name": schema.StringAttribute{
				Description: "The interface name.",
				MarkdownDescription: "The interface name. Either add the VLAN tag number to an existing interface name, " +
					"e.g. `ens18.21` (and do not set `interface` and `vlan`), or use custom name, e.g. `vlan_lab` " +
					"(`interface` and `vlan` are then required).",
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(3),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"address": schema.StringAttribute{
				Description: "The interface IPv4/CIDR address.",
				CustomType:  customtypes.IPCIDRType{},
				Optional:    true,
			},
			"gateway": schema.StringAttribute{
				Description: "Default gateway address.",
				CustomType:  customtypes.IPAddrType{},
				Optional:    true,
			},
			"address6": schema.StringAttribute{
				Description: "The interface IPv6/CIDR address.",
				CustomType:  customtypes.IPCIDRType{},
				Optional:    true,
			},
			"gateway6": schema.StringAttribute{
				Description: "Default IPv6 gateway address.",
				CustomType:  customtypes.IPAddrType{},
				Optional:    true,
			},
			"autostart": schema.BoolAttribute{
				Description: "Automatically start interface on boot (defaults to `true`).",
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(true),
			},
			"mtu": schema.Int64Attribute{
				Description: "The interface MTU.",
				Optional:    true,
			},
			"comment": schema.StringAttribute{
				Description: "Comment for the interface.",
				Optional:    true,
			},
			// Linux VLAN attributes
			"interface": schema.StringAttribute{
				Description: "The VLAN raw device. See also `name`.",
				Optional:    true,
				Computed:    true,
			},
			"vlan": schema.Int64Attribute{
				Description: "The VLAN tag. See also `name`.",
				Optional:    true,
				Computed:    true,
				// 4,094
			},
		},
	}
}

func (r *linuxVLANResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.Resource, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

//nolint:dupl
func (r *linuxVLANResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan linuxVLANResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.exportToNetworkInterfaceCreateUpdateBody()

	err := r.client.Node(plan.NodeName.ValueString()).CreateNetworkInterface(ctx, body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating Linux VLAN interface",
			"Could not create Linux VLAN, unexpected error: "+err.Error(),
		)

		return
	}

	plan.ID = types.StringValue(plan.NodeName.ValueString() + ":" + plan.Name.ValueString())

	r.read(ctx, &plan, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)

	err = r.client.Node(plan.NodeName.ValueString()).ReloadNetworkConfiguration(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reloading network configuration",
			fmt.Sprintf("Could not reload network configuration on node '%s', unexpected error: %s",
				plan.NodeName.ValueString(), err.Error()),
		)
	}
}

func (r *linuxVLANResource) read(ctx context.Context, model *linuxVLANResourceModel, diags *diag.Diagnostics) {
	ifaces, err := r.client.Node(model.NodeName.ValueString()).ListNetworkInterfaces(ctx)
	if err != nil {
		diags.AddError(
			"Error listing network interfaces",
			"Could not list network interfaces, unexpected error: "+err.Error(),
		)

		return
	}

	for _, iface := range ifaces {
		if iface.Iface != model.Name.ValueString() {
			continue
		}

		model.importFromNetworkInterfaceList(iface)

		break
	}
}

// Read reads a Linux VLAN interface.
func (r *linuxVLANResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	// Get current state
	var state linuxVLANResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	r.read(ctx, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

// Update updates a Linux VLAN interface.
func (r *linuxVLANResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state linuxVLANResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	body := plan.exportToNetworkInterfaceCreateUpdateBody()

	var toDelete []string

	if !plan.MTU.Equal(state.MTU) && (plan.MTU.IsUnknown() || plan.MTU.ValueInt64() == 0) {
		toDelete = append(toDelete, "mtu")
		body.MTU = nil
	}

	if len(toDelete) > 0 {
		body.Delete = &toDelete
	}

	err := r.client.Node(plan.NodeName.ValueString()).UpdateNetworkInterface(ctx, plan.Name.ValueString(), body)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating Linux VLAN interface",
			"Could not update Linux VLAN, unexpected error: "+err.Error(),
		)

		return
	}

	r.read(ctx, &plan, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)

	err = r.client.Node(state.NodeName.ValueString()).ReloadNetworkConfiguration(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reloading network configuration",
			fmt.Sprintf("Could not reload network configuration on node '%s', unexpected error: %s",
				state.NodeName.ValueString(), err.Error()),
		)
	}
}

// Delete deletes a Linux VLAN interface.
//
//nolint:dupl
func (r *linuxVLANResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state linuxVLANResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.Node(state.NodeName.ValueString()).DeleteNetworkInterface(ctx, state.Name.ValueString())
	if err != nil {
		if strings.Contains(err.Error(), "interface does not exist") {
			resp.Diagnostics.AddWarning(
				"Linux VLAN interface does not exist",
				fmt.Sprintf("Could not delete Linux VLAN '%s', interface does not exist, "+
					"or has already been deleted outside of Terraform.", state.Name.ValueString()),
			)
		} else {
			resp.Diagnostics.AddError(
				"Error deleting Linux VLAN interface",
				fmt.Sprintf("Could not delete Linux VLAN '%s', unexpected error: %s",
					state.Name.ValueString(), err.Error()),
			)
		}

		return
	}

	err = r.client.Node(state.NodeName.ValueString()).ReloadNetworkConfiguration(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reloading network configuration",
			fmt.Sprintf("Could not reload network configuration on node '%s', unexpected error: %s",
				state.NodeName.ValueString(), err.Error()),
		)
	}
}

func (r *linuxVLANResource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	idParts := strings.Split(req.ID, ":")
	if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: node_name:iface. Got: %q", req.ID),
		)

		return
	}

	nodeName := idParts[0]
	iface := idParts[1]

	state := linuxVLANResourceModel{
		ID:       types.StringValue(req.ID),
		NodeName: types.StringValue(nodeName),
		Name:     types.StringValue(iface),
	}
	r.read(ctx, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	diags := resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}
`````

## File: fwprovider/nodes/vm/cdrom/model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cdrom

import (
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
)

// Model represents the CD-ROM model.
type Model struct {
	FileID types.String `tfsdk:"file_id"`
}

func attributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"file_id": types.StringType,
	}
}

func (m *Model) exportToCustomStorageDevice() vms.CustomStorageDevice {
	return vms.CustomStorageDevice{
		FileVolume: m.FileID.ValueString(),
		Media:      ptr.Ptr("cdrom"),
	}
}

func (m *Model) importFromCustomStorageDevice(d vms.CustomStorageDevice) {
	m.FileID = types.StringValue(d.FileVolume)
}
`````

## File: fwprovider/nodes/vm/cdrom/resource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cdrom

import (
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/validators"
)

// ResourceSchema defines the schema for the CD-ROM resource.
func ResourceSchema() schema.Attribute {
	return schema.MapNestedAttribute{
		Description: "The CD-ROM configuration",
		MarkdownDescription: "The CD-ROM configuration. The key is the interface of the CD-ROM, " +
			"could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. " +
			"Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.",
		Optional: true,
		Computed: true,
		Validators: []validator.Map{
			mapvalidator.KeysAre(
				stringvalidator.RegexMatches(
					regexp.MustCompile(`^(ide[0-3]|sata[0-5]|scsi([0-9]|1[0-3]))$`),
					"one of `ide[0-3]`, `sata[0-5]`, `scsi[0-13]`",
				),
			),
		},
		NestedObject: schema.NestedAttributeObject{
			Attributes: map[string]schema.Attribute{
				"file_id": schema.StringAttribute{
					Description: "The file ID of the CD-ROM",
					MarkdownDescription: "The file ID of the CD-ROM, or `cdrom|none`." +
						" Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.",
					Optional: true,
					Computed: true,
					Default:  stringdefault.StaticString("cdrom"),
					Validators: []validator.String{
						stringvalidator.Any(
							stringvalidator.OneOf("cdrom", "none"),
							validators.FileID(),
						),
					},
				},
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/cdrom/resource_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cdrom_test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

const resourceName = "proxmox_virtual_environment_vm2.test_vm"

func TestAccResourceVM2CDROM(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create VM default CDROM", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cdrom"
				cdrom = {
					"ide3" = {}
				}
			}`),
			Check: test.ResourceAttributes(resourceName, map[string]string{
				"cdrom.%":            "1",
				"cdrom.ide3.file_id": "cdrom",
			}),
		}}},
		{"create VM multiple CDROMs", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cdrom"
				cdrom = {
					"ide3" = {},
					"ide1" = {
						file_id   = "none"
					}
				}
			}`),
			Check: test.ResourceAttributes(resourceName, map[string]string{
				"cdrom.%":            "2",
				"cdrom.ide3.file_id": "cdrom",
				"cdrom.ide1.file_id": "none",
			}),
		}}},
		{"create VM with CDROM and then update it", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-cdrom"
					cdrom = {
						"scsi2" = {
							file_id   = "none"
						},
						"ide2" = {
							file_id   = "cdrom"
						}
					}
				}`),
				Check: test.ResourceAttributes(resourceName, map[string]string{
					"cdrom.%":             "2",
					"cdrom.scsi2.file_id": "none",
					"cdrom.ide2.file_id":  "cdrom",
				}),
			},
			{ // now update the cdrom params and check if they are updated
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-cdrom"
					cdrom = {
						"scsi2" = {
							file_id   = "cdrom"
						}
					}
				}`),
				Check: test.ResourceAttributes(resourceName, map[string]string{
					"cdrom.%":             "1",
					"cdrom.scsi2.file_id": "cdrom",
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone VM with CDROM", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-cdrom"
				cdrom = {
					"ide3" = {
						file_id   = "cdrom"
					}
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cdrom"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
			}`),
			Check: test.ResourceAttributes(resourceName, map[string]string{
				"cdrom.%":            "1",
				"cdrom.ide3.file_id": "cdrom",
			}),
		}}},
		{"clone VM with some CDROM params and updating them in the clone", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-cdrom"
				cdrom = {
					"ide1" = {
						file_id   = "none"
					},
					"ide2" = {
						file_id   = "cdrom"
					}
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cpu"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
				cdrom = {
					"ide1" = {
						file_id   = "cdrom"
					}
				}
			}`),
			Check: test.ResourceAttributes(resourceName, map[string]string{
				"cdrom.%":            "1",
				"cdrom.ide1.file_id": "cdrom",
			}),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/nodes/vm/cdrom/resource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cdrom

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

// Value represents the type for CD-ROM settings.
type Value = types.Map

// NewValue returns a new Value with the given CD-ROM settings from the PVE API.
func NewValue(ctx context.Context, config *vms.GetResponseData, diags *diag.Diagnostics) Value {
	// find storage devices with media=cdrom
	cdroms := config.StorageDevices.Filter(func(device *vms.CustomStorageDevice) bool {
		return device.Media != nil && *device.Media == "cdrom"
	})

	elements := make(map[string]Model, len(cdroms))

	for iface, cdrom := range cdroms {
		m := Model{}
		m.importFromCustomStorageDevice(*cdrom)
		elements[iface] = m
	}

	obj, d := types.MapValueFrom(ctx, types.ObjectType{}.WithAttributeTypes(attributeTypes()), elements)
	diags.Append(d...)

	return obj
}

// FillCreateBody fills the CreateRequestBody with the CD-ROM settings from the Value.
//
// In the 'create' context, v is the plan.
func FillCreateBody(ctx context.Context, planValue Value, body *vms.CreateRequestBody, diags *diag.Diagnostics) {
	if planValue.IsNull() || planValue.IsUnknown() {
		return
	}

	var plan map[string]Model
	d := planValue.ElementsAs(ctx, &plan, false)
	diags.Append(d...)

	if d.HasError() {
		return
	}

	for iface, cdrom := range plan {
		body.AddCustomStorageDevice(iface, cdrom.exportToCustomStorageDevice())
	}
}

// FillUpdateBody fills the UpdateRequestBody with the CD-ROM settings from the Value.
//
// In the 'update' context, v is the plan and stateValue is the current state.
func FillUpdateBody(
	ctx context.Context,
	planValue, stateValue Value,
	updateBody *vms.UpdateRequestBody,
	_ bool,
	diags *diag.Diagnostics,
) {
	if planValue.IsNull() || planValue.IsUnknown() || planValue.Equal(stateValue) {
		return
	}

	var plan, state map[string]Model
	d := planValue.ElementsAs(ctx, &plan, false)
	diags.Append(d...)
	d = stateValue.ElementsAs(ctx, &state, false)
	diags.Append(d...)

	if diags.HasError() {
		return
	}

	toCreate, toUpdate, toDelete := utils.MapDiff(plan, state)

	for iface, dev := range toCreate {
		updateBody.AddCustomStorageDevice(iface, dev.exportToCustomStorageDevice())
	}

	for iface, dev := range toUpdate {
		// for CD-ROMs, the update fully override the existing device, we don't do per-attribute check
		updateBody.AddCustomStorageDevice(iface, dev.exportToCustomStorageDevice())
	}

	for iface := range toDelete {
		updateBody.Delete = append(updateBody.Delete, iface)
	}
}
`````

## File: fwprovider/nodes/vm/cpu/datasource_schema.go
`````go
package cpu

import (
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// DataSourceSchema defines the schema for the CPU datasource.
func DataSourceSchema() schema.Attribute {
	return schema.SingleNestedAttribute{
		CustomType: basetypes.ObjectType{
			AttrTypes: attributeTypes(),
		},
		Description: "The CPU configuration.",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]schema.Attribute{
			"affinity": schema.StringAttribute{
				Description: "List of host cores used to execute guest processes, for example: '0,5,8-11'",
				Optional:    true,
				Computed:    true,
			},
			"architecture": schema.StringAttribute{
				Description: "The CPU architecture.",
				Optional:    true,
				Computed:    true,
			},
			"cores": schema.Int64Attribute{
				Description: "The number of CPU cores per socket.",
				Optional:    true,
				Computed:    true,
			},
			"flags": schema.SetAttribute{
				Description: "Set of additional CPU flags.",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
			},
			"hotplugged": schema.Int64Attribute{
				Description: "The number of hotplugged vCPUs.",
				Optional:    true,
				Computed:    true,
			},
			"limit": schema.Int64Attribute{
				Description: "Limit of CPU usage.",
				Optional:    true,
				Computed:    true,
			},
			"numa": schema.BoolAttribute{
				Description: "Enable NUMA.",
				Optional:    true,
				Computed:    true,
			},
			"sockets": schema.Int64Attribute{
				Description: "The number of CPU sockets.",
				Optional:    true,
				Computed:    true,
			},
			"type": schema.StringAttribute{
				Description: "Emulated CPU type.",
				Optional:    true,
				Computed:    true,
			},
			"units": schema.Int64Attribute{
				Description: "CPU weight for a VM",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/cpu/model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cpu

import (
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Model represents the CPU model.
type Model struct {
	Affinity     types.String `tfsdk:"affinity"`
	Architecture types.String `tfsdk:"architecture"`
	Cores        types.Int64  `tfsdk:"cores"`
	Flags        types.Set    `tfsdk:"flags"`
	Hotplugged   types.Int64  `tfsdk:"hotplugged"`
	Limit        types.Int64  `tfsdk:"limit"`
	Numa         types.Bool   `tfsdk:"numa"`
	Sockets      types.Int64  `tfsdk:"sockets"`
	Type         types.String `tfsdk:"type"`
	Units        types.Int64  `tfsdk:"units"`
}

func attributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"affinity":     types.StringType,
		"architecture": types.StringType,
		"cores":        types.Int64Type,
		"flags":        types.SetType{ElemType: types.StringType},
		"hotplugged":   types.Int64Type,
		"limit":        types.Int64Type,
		"numa":         types.BoolType,
		"sockets":      types.Int64Type,
		"type":         types.StringType,
		"units":        types.Int64Type,
	}
}
`````

## File: fwprovider/nodes/vm/cpu/resource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cpu

import (
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// ResourceSchema defines the schema for the CPU resource.
func ResourceSchema() schema.Attribute {
	return schema.SingleNestedAttribute{
		Description: "The CPU configuration.",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]schema.Attribute{
			"affinity": schema.StringAttribute{
				Description: "List of host cores used to execute guest processes, for example: '0,5,8-11'",
				MarkdownDescription: "The CPU cores that are used to run the VM‚Äôs vCPU. The value is a list of CPU IDs, " +
					"separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` " +
					"(which also can be shortened to `0-3`) means that the VM‚Äôs vCPUs are run on the first " +
					"four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.",
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^\d+[\d-,]*$`),
						"must contain numbers or number ranges separated by ','"),
				},
			},
			"architecture": schema.StringAttribute{
				Description: "The CPU architecture.",
				MarkdownDescription: "The CPU architecture `<aarch64 | x86_64>` (defaults to the host). " +
					"Setting `affinity` is only allowed for `root@pam` authenticated user.",
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf("aarch64", "x86_64"),
				},
			},
			"cores": schema.Int64Attribute{
				Description:         "The number of CPU cores per socket.",
				MarkdownDescription: "The number of CPU cores per socket (defaults to `1`).",
				Optional:            true,
				Computed:            true,
				Validators: []validator.Int64{
					int64validator.Between(1, 1024),
				},
			},
			"flags": schema.SetAttribute{
				Description: "Set of additional CPU flags.",
				MarkdownDescription: "Set of additional CPU flags. " +
					"Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag " +
					"supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: " +
					"`pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, " +
					"`md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
				Validators: []validator.Set{
					setvalidator.AlsoRequires(path.MatchRelative().AtParent().AtName("type")),
					setvalidator.ValueStringsAre(
						stringvalidator.RegexMatches(
							regexp.MustCompile(`(.|\s)*\S(.|\s)*`),
							"must be a non-empty and non-whitespace string",
						),
						stringvalidator.LengthAtLeast(1),
					),
				},
			},
			"hotplugged": schema.Int64Attribute{
				Description:         "The number of hotplugged vCPUs.",
				MarkdownDescription: "The number of hotplugged vCPUs (defaults to `0`).",
				Optional:            true,
				Computed:            true,
				Validators: []validator.Int64{
					int64validator.Between(1, 1024),
				},
			},
			"limit": schema.Int64Attribute{
				Description:         "Limit of CPU usage.",
				MarkdownDescription: "Limit of CPU usage (defaults to `0` which means no limit).",
				Optional:            true,
				Computed:            true,
				Validators: []validator.Int64{
					int64validator.Between(1, 128),
				},
			},
			"numa": schema.BoolAttribute{
				Description:         "Enable NUMA.",
				MarkdownDescription: "Enable NUMA (defaults to `false`).",
				Optional:            true,
				Computed:            true,
			},
			"sockets": schema.Int64Attribute{
				Description:         "The number of CPU sockets.",
				MarkdownDescription: "The number of CPU sockets (defaults to `1`).",
				Optional:            true,
				Computed:            true,
				Validators: []validator.Int64{
					int64validator.Between(1, 16),
				},
			},
			"type": schema.StringAttribute{
				Description: "Emulated CPU type.",
				MarkdownDescription: "Emulated CPU type, " +
					"it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). " +
					"See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings " +
					"for more information.",
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"486",
						"Broadwell",
						"Broadwell-IBRS",
						"Broadwell-noTSX",
						"Broadwell-noTSX-IBRS",
						"Cascadelake-Server",
						"Cascadelake-Server-noTSX",
						"Cascadelake-Server-v2",
						"Cascadelake-Server-v4",
						"Cascadelake-Server-v5",
						"Conroe",
						"Cooperlake",
						"Cooperlake-v2",
						"EPYC",
						"EPYC-IBPB",
						"EPYC-Milan",
						"EPYC-Rome",
						"EPYC-Rome-v2",
						"EPYC-v3",
						"EPYC-v4",
						"Haswell",
						"Haswell-IBRS",
						"Haswell-noTSX",
						"Haswell-noTSX-IBRS",
						"Icelake-Client",
						"Icelake-Client-noTSX",
						"Icelake-Server",
						"Icelake-Server-noTSX",
						"Icelake-Server-v3",
						"Icelake-Server-v4",
						"Icelake-Server-v5",
						"Icelake-Server-v6",
						"IvyBridge",
						"IvyBridge-IBRS",
						"KnightsMill",
						"Nehalem",
						"Nehalem-IBRS",
						"Opteron_G1",
						"Opteron_G2",
						"Opteron_G3",
						"Opteron_G4",
						"Opteron_G5",
						"Penryn",
						"SandyBridge",
						"SandyBridge-IBRS",
						"SapphireRapids",
						"Skylake-Client",
						"Skylake-Client-IBRS",
						"Skylake-Client-noTSX-IBRS",
						"Skylake-Client-v4",
						"Skylake-Server",
						"Skylake-Server-IBRS",
						"Skylake-Server-noTSX-IBRS",
						"Skylake-Server-v4",
						"Skylake-Server-v5",
						"Westmere",
						"Westmere-IBRS",
						"athlon",
						"core2duo",
						"coreduo",
						"host",
						"kvm32",
						"kvm64",
						"max",
						"pentium",
						"pentium2",
						"pentium3",
						"phenom",
						"qemu32",
						"qemu64",
						"x86-64-v2",
						"x86-64-v2-AES",
						"x86-64-v3",
						"x86-64-v4",
					),
				},
			},
			"units": schema.Int64Attribute{
				Description: "CPU weight for a VM.",
				MarkdownDescription: "CPU weight for a VM. Argument is used in the kernel fair scheduler. " +
					"The larger the number is, the more CPU time this VM gets. " +
					"Number is relative to weights of all the other running VMs.",
				Optional: true,
				Computed: true,
				Validators: []validator.Int64{
					int64validator.Between(2, 262144),
				},
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/cpu/resource_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cpu_test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccResourceVM2CPU(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create VM with no cpu params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cpu"
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					// default values that are set by PVE if not specified
					"cpu.cores":   "1",
					"cpu.sockets": "1",
					"cpu.type":    "kvm64",
				}),
			),
		}}},
		{"create VM with some cpu params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cpu"
				cpu = {
					cores = 2
					sockets = 2
					type = "host"
					flags = ["+aes"]
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"cpu.cores":   "2",
					"cpu.sockets": "2",
					"cpu.type":    "host",
					"cpu.flags.#": "1",
					"cpu.flags.0": `\+aes`,
				}),
			),
		}}},
		{"create VM with all cpu params and then update them", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-cpu"
					cpu = {
						# affinity = "0-1"          only root can set affinity
						# architecture = "x86_64"   only root can set architecture
						cores = 2
						hotplugged = 2
						limit = 64
						numa = false
						sockets = 2
						type = "host"
						units = 1024
						flags = ["+aes"]
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"cpu.cores":      "2",
						"cpu.hotplugged": "2",
						"cpu.limit":      "64",
						"cpu.numa":       "false",
						"cpu.sockets":    "2",
						"cpu.type":       "host",
						"cpu.units":      "1024",
					}),
				),
			},
			{ // now update the cpu params and check if they are updated
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-cpu"
					cpu = {
						cores = 4
						hotplugged = 2
						limit = null     # setting to null is the same as removal
						# numa = false
						# sockets = 2    remove sockets, so it should fall back to 1 (PVE default)
						# type = "host"  remove type, so it should fall back to kvm64 (PVE default)
						units = 2048
						# flags = ["+aes"]
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"cpu.cores":      "4",
						"cpu.hotplugged": "2",
						"cpu.sockets":    "1",     // default value, but it is a special case.
						"cpu.type":       "kvm64", // default value, but it is a special case.
						"cpu.units":      "2048",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
						"cpu.limit", // other defaults are not set in the state
						"cpu.numa",
						"cpu.flags",
					}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone VM with some cpu params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-cpu"
				cpu = {
					cores = 2
					sockets = 2
					type = "host"
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cpu"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}	
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"cpu.cores":   "2",
					"cpu.sockets": "2",
					"cpu.type":    "host",
				}),
			),
		}}},
		{"clone VM with some cpu params and updating them in the clone", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-cpu"
				cpu = {
					cores = 2
					sockets = 2
					type = "host"
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cpu"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
				cpu = {
					cores = 4
					units = 1024
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"cpu.cores":   "4",
					"cpu.sockets": "2",
					"cpu.type":    "host",
					"cpu.units":   "1024",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/nodes/vm/cpu/resource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cpu

import (
	"context"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// Value represents the type for CPU settings.
type Value = types.Object

// NewValue returns a new Value with the given CPU settings from the PVE API.
func NewValue(ctx context.Context, config *vms.GetResponseData, diags *diag.Diagnostics) Value {
	cpu := Model{}

	cpu.Affinity = types.StringPointerValue(config.CPUAffinity)
	cpu.Architecture = types.StringPointerValue(config.CPUArchitecture)
	cpu.Hotplugged = types.Int64PointerValue(config.VirtualCPUCount)
	cpu.Limit = types.Int64PointerValue(config.CPULimit.PointerInt64())
	cpu.Numa = types.BoolPointerValue(config.NUMAEnabled.PointerBool())
	cpu.Units = types.Int64PointerValue(config.CPUUnits)

	// special cases: PVE does not return actual value for cores VM, etc is using default (i.e. a value is not specified)

	if config.CPUCores != nil {
		cpu.Cores = types.Int64PointerValue(config.CPUCores)
	} else {
		cpu.Cores = types.Int64Value(1)
	}

	if config.CPUSockets != nil {
		cpu.Sockets = types.Int64PointerValue(config.CPUSockets)
	} else {
		cpu.Sockets = types.Int64Value(1)
	}

	if config.CPUEmulation != nil {
		cpu.Type = types.StringValue(config.CPUEmulation.Type)

		flags, d := types.SetValueFrom(ctx, basetypes.StringType{}, config.CPUEmulation.Flags)
		diags.Append(d...)

		cpu.Flags = flags
	} else {
		cpu.Type = types.StringValue("kvm64")
		cpu.Flags = types.SetNull(basetypes.StringType{})
	}

	obj, d := types.ObjectValueFrom(ctx, attributeTypes(), cpu)
	diags.Append(d...)

	return obj
}

// FillCreateBody fills the CreateRequestBody with the CPU settings from the Value.
//
// In the 'create' context, v is the plan.
func FillCreateBody(ctx context.Context, planValue Value, body *vms.CreateRequestBody, diags *diag.Diagnostics) {
	var plan Model

	if planValue.IsNull() || planValue.IsUnknown() {
		return
	}

	d := planValue.As(ctx, &plan, basetypes.ObjectAsOptions{})
	diags.Append(d...)

	if d.HasError() {
		return
	}

	// for computed fields, we need to check if they are unknown
	if !plan.Affinity.IsUnknown() {
		body.CPUAffinity = plan.Affinity.ValueStringPointer()
	}

	if !plan.Architecture.IsUnknown() {
		body.CPUArchitecture = plan.Architecture.ValueStringPointer()
	}

	if !plan.Cores.IsUnknown() {
		body.CPUCores = plan.Cores.ValueInt64Pointer()
	}

	if !plan.Limit.IsUnknown() {
		body.CPULimit = plan.Limit.ValueInt64Pointer()
	}

	if !plan.Sockets.IsUnknown() {
		body.CPUSockets = plan.Sockets.ValueInt64Pointer()
	}

	if !plan.Units.IsUnknown() {
		body.CPUUnits = plan.Units.ValueInt64Pointer()
	}

	if !plan.Numa.IsUnknown() {
		body.NUMAEnabled = proxmoxtypes.CustomBoolPtr(plan.Numa.ValueBoolPointer())
	}

	if !plan.Hotplugged.IsUnknown() {
		body.VirtualCPUCount = plan.Hotplugged.ValueInt64Pointer()
	}

	body.CPUEmulation = &vms.CustomCPUEmulation{}

	if !plan.Type.IsUnknown() {
		body.CPUEmulation.Type = plan.Type.ValueString()
	}

	if !plan.Flags.IsUnknown() {
		d = plan.Flags.ElementsAs(ctx, &body.CPUEmulation.Flags, false)
		diags.Append(d...)
	}
}

// FillUpdateBody fills the UpdateRequestBody with the CPU settings from the Value.
//
// In the 'update' context, v is the plan and stateValue is the current state.
func FillUpdateBody(
	ctx context.Context,
	planValue, stateValue Value,
	updateBody *vms.UpdateRequestBody,
	isClone bool,
	diags *diag.Diagnostics,
) {
	var plan, state Model

	if planValue.IsNull() || planValue.IsUnknown() || planValue.Equal(stateValue) {
		return
	}

	d := planValue.As(ctx, &plan, basetypes.ObjectAsOptions{})
	diags.Append(d...)
	d = stateValue.As(ctx, &state, basetypes.ObjectAsOptions{})
	diags.Append(d...)

	if diags.HasError() {
		return
	}

	var errs []error

	del := func(field string) {
		errs = append(errs, updateBody.ToDelete(field))
	}

	if !plan.Affinity.Equal(state.Affinity) {
		if attribute.ShouldBeRemoved(plan.Affinity, state.Affinity, isClone) {
			del("CPUAffinity")
		} else if attribute.IsDefined(plan.Affinity) {
			updateBody.CPUAffinity = plan.Affinity.ValueStringPointer()
		}
	}

	if !plan.Architecture.Equal(state.Architecture) {
		if attribute.ShouldBeRemoved(plan.Architecture, state.Architecture, isClone) {
			del("CPUArchitecture")
		} else if attribute.IsDefined(plan.Architecture) {
			updateBody.CPUArchitecture = plan.Architecture.ValueStringPointer()
		}
	}

	if !plan.Cores.Equal(state.Cores) {
		if attribute.ShouldBeRemoved(plan.Cores, state.Cores, isClone) {
			del("CPUCores")
		} else if attribute.IsDefined(plan.Cores) {
			updateBody.CPUCores = plan.Cores.ValueInt64Pointer()
		}
	}

	if !plan.Limit.Equal(state.Limit) {
		if attribute.ShouldBeRemoved(plan.Limit, state.Limit, isClone) {
			del("CPULimit")
		} else if attribute.IsDefined(plan.Sockets) {
			updateBody.CPULimit = plan.Limit.ValueInt64Pointer()
		}
	}

	if !plan.Sockets.Equal(state.Sockets) {
		if attribute.ShouldBeRemoved(plan.Sockets, state.Sockets, isClone) {
			del("CPUSockets")
		} else if attribute.IsDefined(plan.Sockets) {
			updateBody.CPUSockets = plan.Sockets.ValueInt64Pointer()
		}
	}

	if !plan.Units.Equal(state.Units) {
		if attribute.ShouldBeRemoved(plan.Units, state.Units, isClone) {
			del("CPUUnits")
		} else if attribute.IsDefined(plan.Units) {
			updateBody.CPUUnits = plan.Units.ValueInt64Pointer()
		}
	}

	if !plan.Numa.Equal(state.Numa) {
		if attribute.ShouldBeRemoved(plan.Numa, state.Numa, isClone) {
			del("NUMAEnabled")
		} else if attribute.IsDefined(plan.Numa) {
			updateBody.NUMAEnabled = proxmoxtypes.CustomBoolPtr(plan.Numa.ValueBoolPointer())
		}
	}

	if !plan.Hotplugged.Equal(state.Hotplugged) {
		if attribute.ShouldBeRemoved(plan.Hotplugged, state.Hotplugged, isClone) {
			del("VirtualCPUCount")
		} else if attribute.IsDefined(plan.Hotplugged) {
			updateBody.VirtualCPUCount = plan.Hotplugged.ValueInt64Pointer()
		}
	}

	var delType, delFlags bool

	cpuEmulation := &vms.CustomCPUEmulation{}

	if !plan.Type.Equal(state.Type) {
		if attribute.ShouldBeRemoved(plan.Type, state.Type, isClone) {
			delType = true
		} else if attribute.IsDefined(plan.Type) {
			cpuEmulation.Type = plan.Type.ValueString()
		}
	}

	if !plan.Flags.Equal(state.Flags) {
		if attribute.ShouldBeRemoved(plan.Flags, state.Flags, isClone) {
			delFlags = true
		} else if attribute.IsDefined(plan.Flags) {
			d = plan.Flags.ElementsAs(ctx, &cpuEmulation.Flags, false)
			diags.Append(d...)
		}
	}

	switch {
	case delType && !delFlags:
		diags.AddError("Cannot have CPU flags without explicit definition of CPU type", "")
	case delType:
		del("CPUEmulation")
	case !reflect.DeepEqual(cpuEmulation, &vms.CustomCPUEmulation{}):
		updateBody.CPUEmulation = cpuEmulation
	}
}
`````

## File: fwprovider/nodes/vm/rng/datasource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package rng

import (
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// DataSourceSchema defines the schema for the RNG datasource.
func DataSourceSchema() schema.Attribute {
	return schema.SingleNestedAttribute{
		CustomType: basetypes.ObjectType{
			AttrTypes: attributeTypes(),
		},
		Description: "The RNG (Random Number Generator) configuration.",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]schema.Attribute{
			"source": schema.StringAttribute{
				Description: "The entropy source for the RNG device.",
				Optional:    true,
				Computed:    true,
			},
			"max_bytes": schema.Int64Attribute{
				Description: "Maximum bytes of entropy allowed to get injected into the guest every period.",
				Optional:    true,
				Computed:    true,
			},
			"period": schema.Int64Attribute{
				Description: "Period in milliseconds to limit entropy injection to the guest.",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/rng/model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package rng

import (
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Model represents the RNG model.
type Model struct {
	Source   types.String `tfsdk:"source"`
	MaxBytes types.Int64  `tfsdk:"max_bytes"`
	Period   types.Int64  `tfsdk:"period"`
}

func attributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"source":    types.StringType,
		"max_bytes": types.Int64Type,
		"period":    types.Int64Type,
	}
}
`````

## File: fwprovider/nodes/vm/rng/resource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package rng

import (
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// ResourceSchema defines the schema for the RNG resource.
func ResourceSchema() schema.Attribute {
	return schema.SingleNestedAttribute{
		CustomType: basetypes.ObjectType{
			AttrTypes: attributeTypes(),
		},
		Description: "The RNG (Random Number Generator) configuration. Can only be set by `root@pam.`",
		MarkdownDescription: "Configure the RNG (Random Number Generator) device. The RNG device provides entropy " +
			"to guests to ensure good quality random numbers for guest applications that require them. " +
			"Can only be set by `root@pam.`" +
			"See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) " +
			"for more information.",
		Optional: true,
		Computed: true,
		PlanModifiers: []planmodifier.Object{
			objectplanmodifier.UseStateForUnknown(),
		},
		Attributes: map[string]schema.Attribute{
			"source": schema.StringAttribute{
				Description: "The entropy source for the RNG device.",
				MarkdownDescription: "The file on the host to gather entropy from. " +
					"In most cases, `/dev/urandom` should be preferred over `/dev/random` " +
					"to avoid entropy-starvation issues on the host.",
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"max_bytes": schema.Int64Attribute{
				Description: "Maximum bytes of entropy allowed to get injected into the guest every period.",
				MarkdownDescription: "Maximum bytes of entropy allowed to get injected into the guest every period. " +
					"Use 0 to disable limiting (potentially dangerous).",
				Optional: true,
				Computed: true,
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
			"period": schema.Int64Attribute{
				Description: "Period in milliseconds to limit entropy injection to the guest.",
				MarkdownDescription: "Period in milliseconds to limit entropy injection to the guest. " +
					"Use 0 to disable limiting (potentially dangerous).",
				Optional: true,
				Computed: true,
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/rng/resource_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package rng_test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccResourceVM2RNG(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create VM with no rng params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-rng"
			}`),
			Check: test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
				"rng.source",
				"rng.max_bytes",
				"rng.period",
			}),
		}}},
		{"create VM with some rng params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-rng"
				rng = {
					source = "/dev/urandom"
				}
			}`, test.WithRootUser()),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"rng.source": "/dev/urandom",
				}),
				test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
					"rng.max_bytes",
					"rng.period",
				}),
			),
		}}},
		{"create VM with RNG params and then update them", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-rng"
					rng = {
						source = "/dev/urandom"
						max_bytes = 1024
					}
				}`, test.WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"rng.source":    "/dev/urandom",
						"rng.max_bytes": "1024",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
						"rng.period",
					}),
				),
			},
			{ // now update the rng params and check if they are updated
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-rng"
					rng = {
						source = "/dev/random"
						period = 1000
					}
				}`, test.WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"rng.source": "/dev/random",
						"rng.period": "1000",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
						"rng.max_bytes",
					}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone VM with some rng params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-rng"
				rng = {
					source = "/dev/urandom"
					max_bytes = 1024
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-rng"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
			}`, test.WithRootUser()),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"rng.source":    "/dev/urandom",
					"rng.max_bytes": "1024",
				}),
			),
		}}},
		{"clone VM with some rng params and updating them in the clone", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-rng"
				rng = {
					source = "/dev/urandom"
					max_bytes = 1024
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-rng"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
				rng = {
					source = "/dev/random"
					period = 2000
				}
			}`, test.WithRootUser()),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"rng.source":    "/dev/random",
					"rng.period":    "2000",
					"rng.max_bytes": "1024",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/nodes/vm/rng/resource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package rng

import (
	"context"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
)

// Value represents the type for RNG settings.
type Value = types.Object

// NewValue returns a new Value with the given RNG settings from the PVE API.
func NewValue(ctx context.Context, config *vms.GetResponseData, diags *diag.Diagnostics) Value {
	rng := Model{}

	if config.RNGDevice != nil {
		rng.Source = types.StringValue(config.RNGDevice.Source)

		if config.RNGDevice.MaxBytes != nil {
			rng.MaxBytes = types.Int64Value(int64(*config.RNGDevice.MaxBytes))
		}

		if config.RNGDevice.Period != nil {
			rng.Period = types.Int64Value(int64(*config.RNGDevice.Period))
		}
	}

	obj, d := types.ObjectValueFrom(ctx, attributeTypes(), rng)
	diags.Append(d...)

	return obj
}

// createRNGDevice creates a new CustomRNGDevice from the given Model.
func createRNGDevice(model Model, setSource bool) *vms.CustomRNGDevice {
	rngDevice := &vms.CustomRNGDevice{}

	if setSource && !model.Source.IsUnknown() {
		rngDevice.Source = model.Source.ValueString()
	}

	if !model.MaxBytes.IsUnknown() && model.MaxBytes.ValueInt64() != 0 {
		maxBytes := int(model.MaxBytes.ValueInt64())
		rngDevice.MaxBytes = &maxBytes
	}

	if !model.Period.IsUnknown() && model.Period.ValueInt64() != 0 {
		period := int(model.Period.ValueInt64())
		rngDevice.Period = &period
	}

	return rngDevice
}

// FillCreateBody fills the CreateRequestBody with the RNG settings from the Value.
//
// In the 'create' context, v is the plan.
func FillCreateBody(ctx context.Context, planValue Value, body *vms.CreateRequestBody, diags *diag.Diagnostics) {
	var plan Model

	if planValue.IsNull() || planValue.IsUnknown() {
		return
	}

	d := planValue.As(ctx, &plan, basetypes.ObjectAsOptions{})
	diags.Append(d...)

	if d.HasError() {
		return
	}

	rngDevice := createRNGDevice(plan, true)

	if !reflect.DeepEqual(rngDevice, &vms.CustomRNGDevice{}) {
		body.RNGDevice = rngDevice
	}
}

// FillUpdateBody fills the UpdateRequestBody with the RNG settings from the Value.
//
// In the 'update' context, v is the plan and stateValue is the current state.
func FillUpdateBody(
	ctx context.Context,
	planValue, stateValue Value,
	updateBody *vms.UpdateRequestBody,
	isClone bool,
	diags *diag.Diagnostics,
) {
	var plan, state Model

	if planValue.IsNull() || planValue.IsUnknown() || planValue.Equal(stateValue) {
		return
	}

	d := planValue.As(ctx, &plan, basetypes.ObjectAsOptions{})
	diags.Append(d...)
	d = stateValue.As(ctx, &state, basetypes.ObjectAsOptions{})
	diags.Append(d...)

	if diags.HasError() {
		return
	}

	rngDevice := createRNGDevice(state, true)

	if !plan.Source.Equal(state.Source) {
		if attribute.ShouldBeRemoved(plan.Source, state.Source, isClone) {
			rngDevice.Source = ""
		} else if attribute.IsDefined(plan.Source) {
			rngDevice.Source = plan.Source.ValueString()
		}
	}

	if !plan.MaxBytes.Equal(state.MaxBytes) {
		if attribute.ShouldBeRemoved(plan.MaxBytes, state.MaxBytes, isClone) {
			rngDevice.MaxBytes = nil
		} else if attribute.IsDefined(plan.MaxBytes) {
			maxBytes := int(plan.MaxBytes.ValueInt64())
			rngDevice.MaxBytes = &maxBytes
		}
	}

	if !plan.Period.Equal(state.Period) {
		if attribute.ShouldBeRemoved(plan.Period, state.Period, isClone) {
			rngDevice.Period = nil
		} else if attribute.IsDefined(plan.Period) {
			period := int(plan.Period.ValueInt64())
			rngDevice.Period = &period
		}
	}

	if !reflect.DeepEqual(rngDevice, &vms.CustomRNGDevice{}) {
		updateBody.RNGDevice = rngDevice
	}
}
`````

## File: fwprovider/nodes/vm/vga/datasource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vga

import (
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// DataSourceSchema defines the schema for the VGA datasource.
func DataSourceSchema() schema.Attribute {
	return schema.SingleNestedAttribute{
		CustomType: basetypes.ObjectType{
			AttrTypes: attributeTypes(),
		},
		Description: "The VGA configuration.",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]schema.Attribute{
			"clipboard": schema.StringAttribute{
				Description: "Enable a specific clipboard.",
				Optional:    true,
				Computed:    true,
			},
			"type": schema.StringAttribute{
				Description: "The VGA type.",
				Optional:    true,
				Computed:    true,
			},
			"memory": schema.Int64Attribute{
				Description:         "The VGA memory in megabytes (4-512 MB)",
				MarkdownDescription: "The VGA memory in megabytes (4-512 MB). Has no effect with serial display. ",
				Optional:            true,
				Computed:            true,
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/vga/model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vga

import (
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Model represents the VGA model.
type Model struct {
	Clipboard types.String `tfsdk:"clipboard"`
	Type      types.String `tfsdk:"type"`
	Memory    types.Int64  `tfsdk:"memory"`
}

func attributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"clipboard": types.StringType,
		"type":      types.StringType,
		"memory":    types.Int64Type,
	}
}
`````

## File: fwprovider/nodes/vm/vga/resource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vga

import (
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// ResourceSchema defines the schema for the CPU resource.
func ResourceSchema() schema.Attribute {
	return schema.SingleNestedAttribute{
		CustomType: basetypes.ObjectType{
			AttrTypes: attributeTypes(),
		},
		Description: "The VGA configuration.",
		MarkdownDescription: "Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) " +
			"you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` " +
			"for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option " +
			"enables the SPICE display server. For win* OS you can select how many independent displays you want, " +
			"Linux guests can add displays themself. You can also run without any graphic card, using a serial device " +
			"as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#" +
			"qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.",
		Optional: true,
		Computed: true,
		PlanModifiers: []planmodifier.Object{
			objectplanmodifier.UseStateForUnknown(),
		},
		Attributes: map[string]schema.Attribute{
			"clipboard": schema.StringAttribute{
				Description: "Enable a specific clipboard.",
				MarkdownDescription: "Enable a specific clipboard. If not set, depending on the display type the SPICE " +
					"one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not " +
					"supported by Proxmox.",
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf("vnc"),
				},
			},
			"type": schema.StringAttribute{
				Description:         "The VGA type.",
				MarkdownDescription: "The VGA type (defaults to `std`).",
				Optional:            true,
				Computed:            true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"cirrus",
						"none",
						"qxl",
						"qxl2",
						"qxl3",
						"qxl4",
						"serial0",
						"serial1",
						"serial2",
						"serial3",
						"std",
						"virtio",
						"virtio-gl",
						"vmware",
					),
				},
			},
			"memory": schema.Int64Attribute{
				Description:         "The VGA memory in megabytes (4-512 MB)",
				MarkdownDescription: "The VGA memory in megabytes (4-512 MB). Has no effect with serial display. ",
				Optional:            true,
				Computed:            true,
				Validators: []validator.Int64{
					int64validator.Between(4, 512),
				},
			},
		},
	}
}
`````

## File: fwprovider/nodes/vm/vga/resource_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vga_test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccResourceVM2VGA(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create VM with no vga params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-vga"
			}`),
			Check: test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
				// PVE does not set / return anything by default
				"vga.type",
			}),
		}}},
		{"create VM with some vga params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-vga"
				vga = {
					type = "std"
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"vga.type": "std",
				}),
				test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
					"vga.clipboard",
					"vga.memory",
				}),
			),
		}}},
		{"create VM with VGA params and then update them", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-vga"
					vga = {
						type = "std"
						memory = 16
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"vga.type":   "std",
						"vga.memory": "16",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
						"vga.clipboard",
					}),
				),
			},
			{ // now update the vga params and check if they are updated
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-cpu"
					vga = {
						type = "qxl"
						clipboard = "vnc"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"vga.type":      "qxl",
						"vga.clipboard": "vnc",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
						"vga.memory",
					}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone VM with some vga params", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-vga"
				vga = {
					type = "qxl"
					clipboard = "vnc"
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-vga"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"vga.type":      "qxl",
					"vga.clipboard": "vnc",
				}),
			),
		}}},
		{"clone VM with some vga params and updating them in the clone", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "template_vm" {
				node_name = "{{.NodeName}}"
				name = "template-vga"
				vga = {
					type = "qxl"
					clipboard = "vnc"
				}
			}
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "test-cpu"
				clone = {
					id = proxmox_virtual_environment_vm2.template_vm.id
				}
				vga = {
					type = "std"
					memory = 16
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"vga.type":      "std",
					"vga.memory":    "16",
					"vga.clipboard": "vnc",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/nodes/vm/vga/resource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vga

import (
	"context"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
)

// Value represents the type for VGA settings.
type Value = types.Object

// NewValue returns a new Value with the given VGA settings from the PVE API.
func NewValue(ctx context.Context, config *vms.GetResponseData, diags *diag.Diagnostics) Value {
	vga := Model{}

	if config.VGADevice != nil {
		vga.Clipboard = types.StringPointerValue(config.VGADevice.Clipboard)
		vga.Type = types.StringPointerValue(config.VGADevice.Type)
		vga.Memory = types.Int64PointerValue(config.VGADevice.Memory)
	}

	obj, d := types.ObjectValueFrom(ctx, attributeTypes(), vga)
	diags.Append(d...)

	return obj
}

// FillCreateBody fills the CreateRequestBody with the VGA settings from the Value.
//
// In the 'create' context, v is the plan.
func FillCreateBody(ctx context.Context, planValue Value, body *vms.CreateRequestBody, diags *diag.Diagnostics) {
	var plan Model

	if planValue.IsNull() || planValue.IsUnknown() {
		return
	}

	d := planValue.As(ctx, &plan, basetypes.ObjectAsOptions{})
	diags.Append(d...)

	if d.HasError() {
		return
	}

	vgaDevice := &vms.CustomVGADevice{}

	// for computed fields, we need to check if they are unknown
	if !plan.Clipboard.IsUnknown() {
		vgaDevice.Clipboard = plan.Clipboard.ValueStringPointer()
	}

	if !plan.Type.IsUnknown() {
		vgaDevice.Type = plan.Type.ValueStringPointer()
	}

	if !plan.Memory.IsUnknown() {
		vgaDevice.Memory = plan.Memory.ValueInt64Pointer()
	}

	if !reflect.DeepEqual(vgaDevice, &vms.CustomVGADevice{}) {
		body.VGADevice = vgaDevice
	}
}

// FillUpdateBody fills the UpdateRequestBody with the VGA settings from the Value.
//
// In the 'update' context, v is the plan and stateValue is the current state.
func FillUpdateBody(
	ctx context.Context,
	planValue, stateValue Value,
	updateBody *vms.UpdateRequestBody,
	isClone bool,
	diags *diag.Diagnostics,
) {
	var plan, state Model

	if planValue.IsNull() || planValue.IsUnknown() || planValue.Equal(stateValue) {
		return
	}

	d := planValue.As(ctx, &plan, basetypes.ObjectAsOptions{})
	diags.Append(d...)
	d = stateValue.As(ctx, &state, basetypes.ObjectAsOptions{})
	diags.Append(d...)

	if diags.HasError() {
		return
	}

	vgaDevice := &vms.CustomVGADevice{
		Clipboard: state.Clipboard.ValueStringPointer(),
		Type:      state.Type.ValueStringPointer(),
		Memory:    state.Memory.ValueInt64Pointer(),
	}

	if !plan.Clipboard.Equal(state.Clipboard) {
		if attribute.ShouldBeRemoved(plan.Clipboard, state.Clipboard, isClone) {
			vgaDevice.Clipboard = nil
		} else if attribute.IsDefined(plan.Clipboard) {
			vgaDevice.Clipboard = plan.Clipboard.ValueStringPointer()
		}
	}

	if !plan.Type.Equal(state.Type) {
		if attribute.ShouldBeRemoved(plan.Type, state.Type, isClone) {
			vgaDevice.Type = nil
		} else if attribute.IsDefined(plan.Type) {
			vgaDevice.Type = plan.Type.ValueStringPointer()
		}
	}

	if !plan.Memory.Equal(state.Memory) {
		if attribute.ShouldBeRemoved(plan.Memory, state.Memory, isClone) {
			vgaDevice.Memory = nil
		} else if attribute.IsDefined(plan.Memory) {
			vgaDevice.Memory = plan.Memory.ValueInt64Pointer()
		}
	}

	if !reflect.DeepEqual(vgaDevice, &vms.CustomVGADevice{}) {
		updateBody.VGADevice = vgaDevice
	}
}
`````

## File: fwprovider/nodes/vm/concurrency_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm_test

import (
	"context"
	"sync"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

func TestBatchCreate(t *testing.T) {
	t.Parallel()

	const (
		numVMs = 30
	)

	if utils.GetAnyStringEnv("TF_ACC") == "" {
		t.Skip("Acceptance tests are disabled")
	}

	te := test.InitEnvironment(t)

	ctx := context.Background()

	gen := cluster.NewIDGenerator(te.ClusterClient(), cluster.IDGeneratorConfig{RandomIDs: false})

	sourceID, err := gen.NextID(ctx)
	require.NoError(t, err)

	err = te.NodeClient().VM(0).CreateVM(ctx, &vms.CreateRequestBody{VMID: sourceID})

	require.NoError(t, err, "failed to create VM %d", sourceID)

	ids := make([]int, numVMs)

	t.Cleanup(func() {
		_ = te.NodeClient().VM(sourceID).DeleteVM(ctx) //nolint:errcheck

		var wg sync.WaitGroup
		for _, id := range ids {
			wg.Add(1)

			go func() {
				defer wg.Done()

				if id > 0 {
					_ = te.NodeClient().VM(id).DeleteVM(ctx) //nolint:errcheck
				}
			}()
		}

		wg.Wait()
	})

	var wg sync.WaitGroup

	for i := range numVMs {
		wg.Add(1)

		go func() {
			defer wg.Done()

			id := 999900 + i
			if err == nil {
				err = te.NodeClient().VM(sourceID).CloneVM(ctx, 5, &vms.CloneRequestBody{VMIDNew: id})
				ids[i] = id
			}

			assert.NoError(t, err)
		}()
	}

	wg.Wait()
}
`````

## File: fwprovider/nodes/vm/datasource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cpu"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/rng"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/vga"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/types/stringset"
)

// Schema defines the schema for the resource.
func (d *Datasource) Schema(
	ctx context.Context,
	_ datasource.SchemaRequest,
	resp *datasource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "This is an experimental implementation of a Proxmox VM datasource using Plugin Framework.",
		Attributes: map[string]schema.Attribute{
			"clone": schema.SingleNestedAttribute{
				Description: "The cloning configuration.",
				Optional:    true,
				Attributes: map[string]schema.Attribute{
					"id": schema.Int64Attribute{
						Description: "The ID of the VM to clone.",
						Required:    true,
					},
					"retries": schema.Int64Attribute{
						Description: "The number of retries to perform when cloning the VM (default: 3).",
						Optional:    true,
						Computed:    true,
					},
				},
			},
			"cpu": cpu.DataSourceSchema(),
			"description": schema.StringAttribute{
				Description: "The description of the VM.",
				Optional:    true,
			},
			"id": schema.Int64Attribute{
				Required:    true,
				Description: "The unique identifier of the VM in the Proxmox cluster.",
			},
			"name": schema.StringAttribute{
				Description: "The name of the VM.",
				Optional:    true,
			},
			"node_name": schema.StringAttribute{
				Description: "The name of the node where the VM is provisioned.",
				Required:    true,
			},
			"rng":  rng.DataSourceSchema(),
			"tags": stringset.ResourceAttribute("The tags assigned to the VM.", ""),
			"template": schema.BoolAttribute{
				Description: "Whether the VM is a template.",
				Optional:    true,
			},
			"timeouts": timeouts.Attributes(ctx, timeouts.Opts{
				Read: true,
			}),
			"vga": vga.DataSourceSchema(),
		},
	}
}
`````

## File: fwprovider/nodes/vm/datasource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &Datasource{}
	_ datasource.DataSourceWithConfigure = &Datasource{}
)

// Datasource is the implementation of VM datasource.
type Datasource struct {
	client proxmox.Client
}

// NewDataSource creates a new VM datasource.
func NewDataSource() datasource.DataSource {
	return &Datasource{}
}

// Metadata defines the name of the resource.
func (d *Datasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_vm2"
}

// Configure sets the client for the resource.
func (d *Datasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client
}

//nolint:dupl
func (d *Datasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var model Model

	resp.Diagnostics.Append(req.Config.Get(ctx, &model)...)

	if resp.Diagnostics.HasError() {
		return
	}

	timeout, diags := model.Timeouts.Read(ctx, defaultReadTimeout)
	resp.Diagnostics.Append(diags...)

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	exists := read(ctx, d.client, &model, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	if !exists {
		tflog.Info(ctx, "VM does not exist, removing from the state", map[string]interface{}{
			"id": model.ID.ValueInt64(),
		})
		resp.State.RemoveResource(ctx)

		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, model)...)
}
`````

## File: fwprovider/nodes/vm/model.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm

import (
	"context"
	"errors"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cdrom"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cpu"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/rng"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/vga"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/types/stringset"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Model represents the VM model.
//
// Note: for computed fields / blocks we have to use an Object type (or an alias),
// or a custom type in order to hold an unknown value.
type Model struct {
	Description types.String `tfsdk:"description"`
	CDROM       cdrom.Value  `tfsdk:"cdrom"`
	CPU         cpu.Value    `tfsdk:"cpu"`
	Clone       *struct {
		ID      types.Int64 `tfsdk:"id"`
		Retries types.Int64 `tfsdk:"retries"`
	} `tfsdk:"clone"`
	ID            types.Int64     `tfsdk:"id"`
	Name          types.String    `tfsdk:"name"`
	NodeName      types.String    `tfsdk:"node_name"`
	RNG           rng.Value       `tfsdk:"rng"`
	StopOnDestroy types.Bool      `tfsdk:"stop_on_destroy"`
	Tags          stringset.Value `tfsdk:"tags"`
	Template      types.Bool      `tfsdk:"template"`
	Timeouts      timeouts.Value  `tfsdk:"timeouts"`
	VGA           vga.Value       `tfsdk:"vga"`
}

// read retrieves the current state of the resource from the API and updates the state.
// Returns false if the resource does not exist, so the caller can remove it from the state if necessary.
func read(ctx context.Context, client proxmox.Client, model *Model, diags *diag.Diagnostics) bool {
	vmAPI := client.Node(model.NodeName.ValueString()).VM(int(model.ID.ValueInt64()))

	// Retrieve the entire configuration in order to compare it to the state.
	config, err := vmAPI.GetVM(ctx)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			tflog.Info(ctx, "VM does not exist, removing from the state", map[string]interface{}{
				"vm_id": vmAPI.VMID,
			})
		} else {
			diags.AddError("Failed to get VM", err.Error())
		}

		return false
	}

	status, err := vmAPI.GetVMStatus(ctx)
	if err != nil {
		diags.AddError("Failed to get VM status", err.Error())
		return false
	}

	if status.VMID == nil {
		diags.AddError("VM ID is missing in status API response", "")
		return false
	}

	model.ID = types.Int64Value(int64(*status.VMID))

	// Optional fields can be removed from the model, use StringPointerValue to handle removal on nil
	model.Description = types.StringPointerValue(config.Description)
	model.Name = types.StringPointerValue(config.Name)
	model.Tags = stringset.NewValueString(config.Tags, diags)
	model.Template = types.BoolPointerValue(config.Template.PointerBool())

	// Blocks
	model.CPU = cpu.NewValue(ctx, config, diags)
	model.RNG = rng.NewValue(ctx, config, diags)
	model.VGA = vga.NewValue(ctx, config, diags)

	model.CDROM = cdrom.NewValue(ctx, config, diags)

	return true
}
`````

## File: fwprovider/nodes/vm/resource_schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cdrom"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cpu"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/rng"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/vga"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/types/stringset"
)

// Schema defines the schema for the resource.
func (r *Resource) Schema(
	ctx context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "This is an experimental implementation of a Proxmox VM resource using Plugin Framework.",
		MarkdownDescription: "This is an experimental implementation of a Proxmox VM resource using Plugin Framework." +
			"<br><br>It is a Proof of Concept, highly experimental and **will** change in future. " +
			"It does not support all features of the Proxmox API for VMs and **MUST NOT** be used in production.",
		Attributes: map[string]schema.Attribute{
			"clone": schema.SingleNestedAttribute{
				Description: "The cloning configuration.",
				Optional:    true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
				Attributes: map[string]schema.Attribute{
					"id": schema.Int64Attribute{
						Description: "The ID of the VM to clone.",
						Required:    true,
					},
					"retries": schema.Int64Attribute{
						Description: "The number of retries to perform when cloning the VM (default: 3).",
						Optional:    true,
						Computed:    true,
						Default:     int64default.StaticInt64(3),
					},
				},
			},
			"cdrom": cdrom.ResourceSchema(),
			"cpu":   cpu.ResourceSchema(),
			"description": schema.StringAttribute{
				Description: "The description of the VM.",
				Optional:    true,
			},
			"id": schema.Int64Attribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
					int64planmodifier.RequiresReplace(),
				},
				Description: "The unique identifier of the VM in the Proxmox cluster.",
			},
			"name": schema.StringAttribute{
				Description:         "The name of the VM.",
				MarkdownDescription: "The name of the VM. Doesn't have to be unique.",
				Optional:            true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^([a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$`),
						"must be a valid DNS name",
					),
				},
			},
			"node_name": schema.StringAttribute{
				Description: "The name of the node where the VM is provisioned.",
				Required:    true,
			},
			"rng": rng.ResourceSchema(),
			"stop_on_destroy": schema.BoolAttribute{
				Description:         "Set to true to stop (rather than shutdown) the VM on destroy.",
				MarkdownDescription: "Set to true to stop (rather than shutdown) the VM on destroy (defaults to `false`).",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(false),
			},
			"tags": stringset.ResourceAttribute("The tags assigned to the VM.", ""),
			"template": schema.BoolAttribute{
				Description: "Set to true to create a VM template.",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"timeouts": timeouts.Attributes(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"vga": vga.ResourceSchema(),
		},
	}
}
`````

## File: fwprovider/nodes/vm/resource_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm_test

import (
	"math/rand"
	"regexp"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
)

func TestAccResourceVM(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)
	te.AddTemplateVars(map[string]interface{}{
		"TestVMID": 100000 + rand.Intn(99999),
	})

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create minimal VM", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"node_name": te.NodeName,
				}),
				test.ResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
					"id",
				}),
			),
		}}},
		{"create minimal VM with ID", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				id = {{.TestVMID}}
			}`),
		}}},
		{"set an invalid VM name", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "not a valid DNS name"
			}`),
			ExpectError: regexp.MustCompile(`name must be a valid DNS name`),
		}}},
		{"set, update, import with primitive fields", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-vm"
					description = "test description"
				}`),
				Check: test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"name":        "test-vm",
					"description": "test description",
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-vm"
				}`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
						"name": "test-vm",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm", []string{
						"description",
					}),
				),
			},
			{
				ResourceName:        "proxmox_virtual_environment_vm2.test_vm",
				ImportState:         true,
				ImportStateVerify:   true,
				ImportStateIdPrefix: te.NodeName + "/",
			},
		}},
		{"set, update, import with tags", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-tags"
					tags = ["tag2", "tag1"]
				}`),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckTypeSetElemAttr("proxmox_virtual_environment_vm2.test_vm", "tags.*", "tag1"),
					resource.TestCheckTypeSetElemAttr("proxmox_virtual_environment_vm2.test_vm", "tags.*", "tag2"),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-tags"
					tags = ["tag1"]
				}`),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttr("proxmox_virtual_environment_vm2.test_vm", "tags.#", "1"),
					resource.TestCheckTypeSetElemAttr("proxmox_virtual_environment_vm2.test_vm", "tags.*", "tag1"),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-tags"
					// no tags
				}`),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttr("proxmox_virtual_environment_vm2.test_vm", "tags.#", "1"),
					resource.TestCheckTypeSetElemAttr("proxmox_virtual_environment_vm2.test_vm", "tags.*", "tag1"),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					name = "test-tags"
					tags = []
				}`),
				Check: resource.ComposeTestCheckFunc(
					resource.TestCheckResourceAttr("proxmox_virtual_environment_vm2.test_vm", "tags.#", "0"),
				),
			},
		}},
		{"a VM can't have empty tags", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				tags = ["", "tag1"]
			}`),
			ExpectError: regexp.MustCompile(`string length must be at least 1, got: 0`),
		}}},
		{"a VM can't have empty tags", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				tags = [" ", "tag1"]
			}`),
			ExpectError: regexp.MustCompile(`must be a non-empty and non-whitespace string`),
		}}},
		{"multiline description", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm2" "test_vm" {
					node_name = "{{.NodeName}}"
					description = trimspace(<<-EOT
						my
						description
						value
					EOT
					)
				}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"description": "my\ndescription\nvalue",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}

func TestAccResourceVM2Clone(t *testing.T) {
	t.Parallel()

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create a clone from template", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				name = "template"
				description = "template description"
				template = true
			}
			resource "proxmox_virtual_environment_vm2" "test_vm_clone" {
				node_name = "{{.NodeName}}"
				name = "clone"
				clone = {
					id = proxmox_virtual_environment_vm2.test_vm.id	
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm", map[string]string{
					"template": "true",
				}),
				test.ResourceAttributes("proxmox_virtual_environment_vm2.test_vm_clone", map[string]string{
					// name is overwritten
					"name": "clone",
				}),
				test.NoResourceAttributesSet("proxmox_virtual_environment_vm2.test_vm_clone", []string{
					// description is not copied
					"description",
				}),
			),
		}}},
		{"tags are copied to the clone", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_vm2" "test_vm" {
				node_name = "{{.NodeName}}"
				template = true
				tags = ["tag1", "tag2"]
			}
			resource "proxmox_virtual_environment_vm2" "test_vm_clone" {
				node_name = "{{.NodeName}}"
				clone = {
					id = proxmox_virtual_environment_vm2.test_vm.id
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				resource.TestCheckTypeSetElemAttr("proxmox_virtual_environment_vm2.test_vm_clone", "tags.*", "tag1"),
				resource.TestCheckTypeSetElemAttr("proxmox_virtual_environment_vm2.test_vm_clone", "tags.*", "tag2"),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/nodes/vm/resource.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vm

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cdrom"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/cpu"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/rng"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm/vga"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

const (
	defaultCreateTimeout = 30 * time.Minute
	defaultReadTimeout   = 5 * time.Minute
	defaultUpdateTimeout = 30 * time.Minute
	defaultDeleteTimeout = 10 * time.Minute

	// these timeouts are for individual PVE operations.
	defaultShutdownTimeout = 5 * time.Minute
)

var (
	_ resource.Resource                = &Resource{}
	_ resource.ResourceWithConfigure   = &Resource{}
	_ resource.ResourceWithImportState = &Resource{}
)

// Resource implements the resource.Resource interface for managing VMs.
type Resource struct {
	client      proxmox.Client
	idGenerator cluster.IDGenerator
}

// NewResource creates a new resource for managing VMs.
func NewResource() resource.Resource {
	return &Resource{}
}

// Metadata defines the name of the resource.
func (r *Resource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_vm2"
}

// Configure sets the client for the resource.
func (r *Resource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *proxmox.Client, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
	r.idGenerator = cfg.IDGenerator
}

// Create creates a new VM.
func (r *Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan Model

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	timeout, d := plan.Timeouts.Create(ctx, defaultCreateTimeout)
	resp.Diagnostics.Append(d...)

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	if plan.ID.ValueInt64() == 0 {
		id, err := r.idGenerator.NextID(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Failed to generate VM ID", err.Error())
			return
		}

		plan.ID = types.Int64Value(int64(id))
	}

	if resp.Diagnostics.HasError() {
		return
	}

	if plan.Clone != nil {
		r.clone(ctx, plan, &resp.Diagnostics)
	} else {
		r.create(ctx, plan, &resp.Diagnostics)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// read back the VM from the PVE API to populate computed fields
	exists := read(ctx, r.client, &plan, &resp.Diagnostics)
	if !exists {
		resp.Diagnostics.AddError("VM does not exist after creation", "")
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// set state to the updated plan data
	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

func (r *Resource) create(ctx context.Context, plan Model, diags *diag.Diagnostics) {
	createBody := &vms.CreateRequestBody{
		Description: plan.Description.ValueStringPointer(),
		Name:        plan.Name.ValueStringPointer(),
		Tags:        plan.Tags.ValueStringPointer(ctx, diags),
		Template:    proxmoxtypes.CustomBoolPtr(plan.Template.ValueBoolPointer()),
		VMID:        int(plan.ID.ValueInt64()),
	}

	// fill out create body fields with values from other resource blocks
	cdrom.FillCreateBody(ctx, plan.CDROM, createBody, diags)
	cpu.FillCreateBody(ctx, plan.CPU, createBody, diags)
	rng.FillCreateBody(ctx, plan.RNG, createBody, diags)
	vga.FillCreateBody(ctx, plan.VGA, createBody, diags)

	if diags.HasError() {
		return
	}

	// .VM(0) is used to create a new VM, the VM ID is not used in the API URL
	vmAPI := r.client.Node(plan.NodeName.ValueString()).VM(0)

	err := vmAPI.CreateVM(ctx, createBody)
	if err != nil {
		diags.AddError("Failed to create VM", err.Error())
	}
}

func (r *Resource) clone(ctx context.Context, plan Model, diags *diag.Diagnostics) {
	if plan.Clone == nil {
		diags.AddError("Clone configuration is missing", "")
		return
	}

	sourceID := int(plan.Clone.ID.ValueInt64())
	vmAPI := r.client.Node(plan.NodeName.ValueString()).VM(sourceID)

	// name and description for the clone are optional, but they are not copied from the source VM.
	cloneBody := &vms.CloneRequestBody{
		Description: plan.Description.ValueStringPointer(),
		Name:        plan.Name.ValueStringPointer(),
		VMIDNew:     int(plan.ID.ValueInt64()),
	}

	err := vmAPI.CloneVM(ctx, int(plan.Clone.Retries.ValueInt64()), cloneBody)
	if err != nil {
		diags.AddError("Failed to clone VM", err.Error())
	}

	if diags.HasError() {
		return
	}

	// now load the clone's configuration into a temporary model and update what is needed comparing to the plan
	clone := Model{
		ID:          plan.ID,
		CPU:         plan.CPU,
		Name:        plan.Name,
		Description: plan.Description,
		NodeName:    plan.NodeName,
		RNG:         plan.RNG,
		VGA:         plan.VGA,
	}

	read(ctx, r.client, &clone, diags)

	if diags.HasError() {
		return
	}

	r.update(ctx, plan, clone, true, diags)
}

//nolint:dupl
func (r *Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state Model

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	timeout, d := state.Timeouts.Read(ctx, defaultReadTimeout)
	resp.Diagnostics.Append(d...)

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	exists := read(ctx, r.client, &state, &resp.Diagnostics)

	if resp.Diagnostics.HasError() {
		return
	}

	if !exists {
		tflog.Info(ctx, "VM does not exist, removing from the state", map[string]interface{}{
			"id": state.ID.ValueInt64(),
		})
		resp.State.RemoveResource(ctx)

		return
	}

	// store updated state
	resp.Diagnostics.Append(resp.State.Set(ctx, state)...)
}

// Update updates the VM with the new configuration.
func (r *Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state Model

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	timeout, d := plan.Timeouts.Update(ctx, defaultUpdateTimeout)
	resp.Diagnostics.Append(d...)

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	r.update(ctx, plan, state, false, &resp.Diagnostics)

	// read back the VM from the PVE API to populate computed fields
	exists := read(ctx, r.client, &plan, &resp.Diagnostics)
	if !exists {
		resp.Diagnostics.AddError("VM does not exist after update", "")
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// set state to the updated plan data
	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// update updates the VM with the new configuration.
//
// The isClone parameter is used to determine if the VM is being updated as part of a clone operation.
// During a clone operation, the attributes are copied from the source VM to the clone, so for computed attributes
// that are optional, we need to handle them differently. If they are not set in the clone configuration, we keep the
// source VM's values.
// During the normal update operation, if a computed attribute is not set in the plan, we remove it from the VM, so it
// can assume its default PVE-provided value.
func (r *Resource) update(ctx context.Context, plan, state Model, isClone bool, diags *diag.Diagnostics) {
	vmAPI := r.client.Node(plan.NodeName.ValueString()).VM(int(plan.ID.ValueInt64()))

	updateBody := &vms.UpdateRequestBody{}

	var errs []error

	del := func(field string) {
		errs = append(errs, updateBody.ToDelete(field))
	}

	if !plan.Description.Equal(state.Description) {
		if plan.Description.IsNull() {
			del("Description")
		} else {
			updateBody.Description = plan.Description.ValueStringPointer()
		}
	}

	if !plan.Name.Equal(state.Name) {
		if plan.Name.IsNull() {
			del("Name")
		} else {
			updateBody.Name = plan.Name.ValueStringPointer()
		}
	}

	// For optional computed fields only:
	// The first condition is for the clone case, where the tags (captured in `state.Tags`)
	// have already been copied from the source VM to the clone during the cloning process.
	// Then, if the clone config does not have tags, we keep the cloned ones in the VM.
	// Otherwise, if the clone config has empty tags we remove them from the VM.
	// And finally, if the clone config has tags we update them in th VM
	if !plan.Tags.Equal(state.Tags) && !plan.Tags.IsUnknown() {
		if plan.Tags.IsNull() || len(plan.Tags.Elements()) == 0 {
			del("Tags")
		} else {
			updateBody.Tags = plan.Tags.ValueStringPointer(ctx, diags)
		}
	}

	// fill out update body fields with values from other resource blocks
	cdrom.FillUpdateBody(ctx, plan.CDROM, state.CDROM, updateBody, isClone, diags)
	cpu.FillUpdateBody(ctx, plan.CPU, state.CPU, updateBody, isClone, diags)
	rng.FillUpdateBody(ctx, plan.RNG, state.RNG, updateBody, isClone, diags)
	vga.FillUpdateBody(ctx, plan.VGA, state.VGA, updateBody, isClone, diags)

	if !updateBody.IsEmpty() {
		updateBody.VMID = int(plan.ID.ValueInt64())

		err := vmAPI.UpdateVM(ctx, updateBody)
		if err != nil {
			diags.AddError("Failed to update VM", err.Error())
			return
		}
	}
}

// Delete deletes the VM.
func (r *Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state Model

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	timeout, d := state.Timeouts.Delete(ctx, defaultDeleteTimeout)
	resp.Diagnostics.Append(d...)

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	vmAPI := r.client.Node(state.NodeName.ValueString()).VM(int(state.ID.ValueInt64()))

	// Stop or shut down the virtual machine before deleting it.
	status, err := vmAPI.GetVMStatus(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Failed to get VM status", err.Error())
	}

	if resp.Diagnostics.HasError() || status == nil {
		return
	}

	if status.Status != "stopped" {
		if state.StopOnDestroy.ValueBool() {
			if e := vmStop(ctx, vmAPI); e != nil {
				resp.Diagnostics.AddWarning("Failed to stop VM", e.Error())
			}
		} else {
			if e := vmShutdown(ctx, vmAPI); e != nil {
				resp.Diagnostics.AddWarning("Failed to shut down VM", e.Error())
			}
		}
	}

	err = vmAPI.DeleteVM(ctx)
	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		resp.Diagnostics.AddError("Failed to delete VM", err.Error())
	}

	if resp.Diagnostics.HasError() {
		return
	}

	resp.State.RemoveResource(ctx)
}

// ImportState imports the state of the VM from the API.
func (r *Resource) ImportState(
	ctx context.Context,
	req resource.ImportStateRequest,
	resp *resource.ImportStateResponse,
) {
	ctx, cancel := context.WithTimeout(ctx, defaultReadTimeout)
	defer cancel()

	nodeName, vmid, found := strings.Cut(req.ID, "/")

	id, err := strconv.Atoi(vmid)
	if !found || err != nil || id == 0 {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: `node_name/id`. Got: %q", req.ID),
		)

		return
	}

	var ts timeouts.Value

	resp.Diagnostics.Append(resp.State.GetAttribute(ctx, path.Root("timeouts"), &ts)...)

	if resp.Diagnostics.HasError() {
		return
	}

	state := Model{
		ID:       types.Int64Value(int64(id)),
		NodeName: types.StringValue(nodeName),
		Timeouts: ts,
	}

	exists := read(ctx, r.client, &state, &resp.Diagnostics)
	if !exists {
		resp.Diagnostics.AddError(fmt.Sprintf("VM %d does not exist on node %s", id, nodeName), "")
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// not clear why this is needed, but ImportStateVerify fails without it
	state.StopOnDestroy = types.BoolValue(false)

	diags := resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

// Shutdown the VM, then wait for it to actually shut down (it may not be shut down immediately if
// running in HA mode).
func vmShutdown(ctx context.Context, vmAPI *vms.Client) error {
	tflog.Debug(ctx, "Shutting down VM")

	shutdownTimeoutSec := int(defaultShutdownTimeout.Seconds())

	if dl, ok := ctx.Deadline(); ok {
		time.Until(dl)
		shutdownTimeoutSec = int(time.Until(dl).Seconds())
	}

	err := vmAPI.ShutdownVM(ctx, &vms.ShutdownRequestBody{
		ForceStop: proxmoxtypes.CustomBool(true).Pointer(),
		Timeout:   &shutdownTimeoutSec,
	})
	if err != nil {
		return fmt.Errorf("failed to initiate shut down of VM: %w", err)
	}

	err = vmAPI.WaitForVMStatus(ctx, "stopped")
	if err != nil {
		return fmt.Errorf("failed to wait for VM to shut down: %w", err)
	}

	return nil
}

// Forcefully stop the VM, then wait for it to actually stop.
func vmStop(ctx context.Context, vmAPI *vms.Client) error {
	tflog.Debug(ctx, "Stopping VM")

	err := vmAPI.StopVM(ctx)
	if err != nil {
		return fmt.Errorf("failed to initiate stop of VM: %w", err)
	}

	err = vmAPI.WaitForVMStatus(ctx, "stopped")
	if err != nil {
		return fmt.Errorf("failed to wait for VM to stop: %w", err)
	}

	return nil
}
`````

## File: fwprovider/nodes/resource_download_file_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes_test

import (
	"context"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
	"time"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/plancheck"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/storage"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

const (
	fakeFileISO   = "https://cdn.githubraw.com/rafsaf/a4b19ea5e3485f8da6ca4acf46d09650/raw/d340ec3ddcef9b907ede02f64b5d3f694da5d081/fake_file.iso"
	fakeFileQCOW2 = "https://cdn.githubraw.com/rafsaf/036eece601975a3ad632a77fc2809046/raw/10500012fca9b4425b50de67a7258a12cba0c076/fake_file.qcow2"
)

func TestAccResourceDownloadFile(t *testing.T) {
	te := test.InitEnvironment(t)

	te.AddTemplateVars(map[string]interface{}{
		"FakeFileISO":   fakeFileISO,
		"FakeFileQCOW2": fakeFileQCOW2,
	})

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"missing url", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "qcow2_image" {
					content_type       = "iso"
					node_name          = "{{.NodeName}}"
					datastore_id       = "{{.DatastoreID}}"
					file_name          = "fake_qcow2_file.img"
					url                =  ""
				  }`),
			ExpectError: regexp.MustCompile(`Attribute url must match HTTP URL regex`),
		}}},
		{"download qcow2 file", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "qcow2_image" {
					content_type       = "iso"
					node_name          = "{{.NodeName}}"
					datastore_id       = "{{.DatastoreID}}"
					file_name          = "fake_qcow2_file.img"
					url                =  "{{.FakeFileQCOW2}}"
					checksum           = "688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6"
					checksum_algorithm = "sha256"
					overwrite_unmanaged = true
				  }`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_download_file.qcow2_image", map[string]string{
					"id":                 "local:iso/fake_qcow2_file.img",
					"content_type":       "iso",
					"node_name":          te.NodeName,
					"datastore_id":       te.DatastoreID,
					"url":                fakeFileQCOW2,
					"file_name":          "fake_qcow2_file.img",
					"upload_timeout":     "600",
					"size":               "3",
					"verify":             "true",
					"checksum":           "688787d8ff144c502c7f5cffaafe2cc588d86079f9de88304c26b0cb99ce91c6",
					"checksum_algorithm": "sha256",
				}),
				test.NoResourceAttributesSet("proxmox_virtual_environment_download_file.qcow2_image", []string{
					"decompression_algorithm",
				}),
			),
		}}},
		{"download & update iso file", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "iso_image" {
					content_type = "iso"
					node_name    = "{{.NodeName}}"
					datastore_id = "{{.DatastoreID}}"
					url          = "{{.FakeFileISO}}"
					overwrite_unmanaged = true
				  }`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_download_file.iso_image", map[string]string{
						"id":             "local:iso/fake_file.iso",
						"node_name":      te.NodeName,
						"datastore_id":   te.DatastoreID,
						"url":            fakeFileISO,
						"file_name":      "fake_file.iso",
						"upload_timeout": "600",
						"size":           "3",
						"verify":         "true",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_download_file.iso_image", []string{
						"checksum",
						"checksum_algorithm",
						"decompression_algorithm",
					}),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "iso_image" {
					content_type   = "iso"
					node_name      = "{{.NodeName}}"
					datastore_id   = "{{.DatastoreID}}"
					file_name      = "fake_iso_file.img"
					url            = "{{.FakeFileISO}}"
					upload_timeout = 10000
					overwrite_unmanaged = true
				  }`),
				Check: resource.ComposeTestCheckFunc(
					test.ResourceAttributes("proxmox_virtual_environment_download_file.iso_image", map[string]string{
						"id":             "local:iso/fake_iso_file.img",
						"content_type":   "iso",
						"node_name":      te.NodeName,
						"datastore_id":   te.DatastoreID,
						"url":            fakeFileISO,
						"file_name":      "fake_iso_file.img",
						"upload_timeout": "10000",
						"size":           "3",
						"verify":         "true",
					}),
					test.NoResourceAttributesSet("proxmox_virtual_environment_download_file.iso_image", []string{
						"checksum",
						"checksum_algorithm",
						"decompression_algorithm",
					}),
				),
			},
		}},
		{"override file", []resource.TestStep{{
			Destroy: false,
			PreConfig: func() {
				ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
				defer cancel()

				_ = te.NodeStorageClient().DeleteDatastoreFile(ctx, "iso/fake_file.iso") //nolint: errcheck

				err := te.NodeStorageClient().DownloadFileByURL(ctx, &storage.DownloadURLPostRequestBody{
					Content:  ptr.Ptr("iso"),
					FileName: ptr.Ptr("fake_file.iso"),
					Node:     ptr.Ptr(te.NodeName),
					Storage:  ptr.Ptr(te.DatastoreID),
					URL:      ptr.Ptr(fakeFileISO),
					Verify:   ptr.Ptr(types.CustomBool(false)),
				})
				require.NoError(t, err)

				t.Cleanup(func() {
					e := te.NodeStorageClient().DeleteDatastoreFile(context.Background(), "iso/fake_file.iso")
					require.NoError(t, e)
				})
			},
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "iso_image3" {
					content_type        = "iso"
					node_name           = "{{.NodeName}}"
					datastore_id        = "{{.DatastoreID}}"
					url 		        = "{{.FakeFileISO}}"
					file_name           = "fake_iso_file3.iso"
					overwrite_unmanaged = true
					overwrite           = false
				  }`),
			Check: resource.ComposeTestCheckFunc(
				test.ResourceAttributes("proxmox_virtual_environment_download_file.iso_image3", map[string]string{
					"id":           "local:iso/fake_iso_file3.iso",
					"content_type": "iso",
					"node_name":    te.NodeName,
					"datastore_id": te.DatastoreID,
					"url":          fakeFileISO,
					"file_name":    "fake_iso_file3.iso",
					"size":         "3",
					"verify":       "true",
				}),
				test.NoResourceAttributesSet("proxmox_virtual_environment_download_file.iso_image3", []string{
					"checksum",
					"checksum_algorithm",
					"decompression_algorithm",
				}),
			),
		}, {
			Destroy: false,
			PreConfig: func() {
				isoFile := strings.ReplaceAll(createFile(t, "fake_iso_file3.iso", "updated iso").Name(), `\`, `/`)
				uploadIsoFile(t, isoFile)
			},
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "iso_image3" {
					content_type        = "iso"
					node_name           = "{{.NodeName}}"
					datastore_id        = "{{.DatastoreID}}"
					url 		        = "{{.FakeFileISO}}"
					file_name           = "fake_iso_file3.iso"
					overwrite_unmanaged = true
					overwrite           = false
				}`),
			ConfigPlanChecks: resource.ConfigPlanChecks{
				PreApply: []plancheck.PlanCheck{
					plancheck.ExpectEmptyPlan(),
				},
			},
		}, {
			PreConfig: func() {
				isoFile := strings.ReplaceAll(createFile(t, "fake_iso_file3.iso", "updated iso again").Name(), `\`, `/`)
				uploadIsoFile(t, isoFile)
			},
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "iso_image3" {
					content_type        = "iso"
					node_name           = "{{.NodeName}}"
					datastore_id        = "{{.DatastoreID}}"
					url 		        = "{{.FakeFileISO}}"
					file_name           = "fake_iso_file3.iso"
					overwrite_unmanaged = true
					overwrite           = true
				}`),
			ConfigPlanChecks: resource.ConfigPlanChecks{
				PreApply: []plancheck.PlanCheck{
					plancheck.ExpectResourceAction("proxmox_virtual_environment_download_file.iso_image3", plancheck.ResourceActionDestroyBeforeCreate),
				},
			},
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}

func uploadIsoFile(t *testing.T, fileName string) {
	t.Helper()

	endpoint := utils.GetAnyStringEnv("PROXMOX_VE_ENDPOINT")
	u, err := url.ParseRequestURI(endpoint)
	require.NoError(t, err)

	sshAgent := utils.GetAnyBoolEnv("PROXMOX_VE_SSH_AGENT")
	sshUsername := utils.GetAnyStringEnv("PROXMOX_VE_SSH_USERNAME")
	sshPassword := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PASSWORD")
	sshAgentSocket := utils.GetAnyStringEnv("SSH_AUTH_SOCK", "PROXMOX_VE_SSH_AUTH_SOCK")
	sshPrivateKey := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PRIVATE_KEY")
	sshPort := utils.GetAnyIntEnv("PROXMOX_VE_ACC_NODE_SSH_PORT")
	sshClient, err := ssh.NewClient(
		sshUsername, sshPassword, sshAgent, sshAgentSocket, sshPrivateKey,
		"", "", "",
		&nodeResolver{
			node: ssh.ProxmoxNode{
				Address: u.Hostname(),
				Port:    int32(sshPort),
			},
		},
	)
	require.NoError(t, err)

	f, err := os.Open(fileName)
	require.NoError(t, err)

	defer func(f *os.File) {
		_ = f.Close()
	}(f)

	fname := filepath.Base(fileName)
	err = sshClient.NodeStreamUpload(context.Background(), "pve", "/var/lib/vz/template",
		&api.FileUploadRequest{
			ContentType: "iso",
			FileName:    fname,
			File:        f,
		})
	require.NoError(t, err)
}

type nodeResolver struct {
	node ssh.ProxmoxNode
}

func (c *nodeResolver) Resolve(_ context.Context, _ string) (ssh.ProxmoxNode, error) {
	return c.node, nil
}

func createFile(t *testing.T, namePattern string, content string) *os.File {
	t.Helper()

	f, err := os.Create(path.Join(os.TempDir(), namePattern))
	require.NoError(t, err)

	_, err = f.WriteString(content)
	require.NoError(t, err)

	defer func(f *os.File) {
		_ = f.Close()
	}(f)

	t.Cleanup(func() {
		_ = os.Remove(f.Name())
	})

	return f
}
`````

## File: fwprovider/nodes/resource_download_file.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/attribute"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/storage"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	_         resource.Resource              = &downloadFileResource{}
	_         resource.ResourceWithConfigure = &downloadFileResource{}
	httpRegex                                = regexp.MustCompile(`https?://.*`)
)

type sizeRequiresReplaceModifier struct{}

func (r sizeRequiresReplaceModifier) PlanModifyInt64(
	ctx context.Context,
	req planmodifier.Int64Request,
	resp *planmodifier.Int64Response,
) {
	// Do not replace on resource creation.
	if req.State.Raw.IsNull() {
		return
	}

	// Do not replace on resource destroy.
	if req.Plan.Raw.IsNull() {
		return
	}

	var plan, state downloadFileModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	originalStateSizeBytes, diags := req.Private.GetKey(ctx, "original_state_size")

	resp.Diagnostics.Append(diags...)

	if originalStateSizeBytes != nil {
		originalStateSize, err := strconv.ParseInt(string(originalStateSizeBytes), 10, 64)
		if err != nil {
			resp.Diagnostics.AddError(
				"Unable to convert original state file size to int64",
				"Unexpected error in parsing string to int64, key original_state_size. "+
					"Please retry the operation or report this issue to the provider developers.\n\n"+
					"Error: "+err.Error(),
			)

			return
		}

		if state.Size.ValueInt64() != originalStateSize && plan.Overwrite.ValueBool() {
			resp.RequiresReplace = true
			resp.PlanValue = types.Int64Value(originalStateSize)

			resp.Diagnostics.AddWarning(
				"The file size in datastore has changed outside of terraform.",
				fmt.Sprintf(
					"Previous size: %d saved in state does not match current size from datastore: %d. "+
						"You can disable this behaviour by using overwrite=false",
					originalStateSize,
					state.Size.ValueInt64(),
				),
			)

			return
		}
	}
}

func (r sizeRequiresReplaceModifier) Description(_ context.Context) string {
	return "Triggers resource force replacement if `size` in state does not match remote value."
}

func (r sizeRequiresReplaceModifier) MarkdownDescription(_ context.Context) string {
	return "Triggers resource force replacement if `size` in state does not match remote value."
}

type downloadFileModel struct {
	ID                     types.String `tfsdk:"id"`
	Content                types.String `tfsdk:"content_type"`
	FileName               types.String `tfsdk:"file_name"`
	Storage                types.String `tfsdk:"datastore_id"`
	Node                   types.String `tfsdk:"node_name"`
	Size                   types.Int64  `tfsdk:"size"`
	URL                    types.String `tfsdk:"url"`
	Checksum               types.String `tfsdk:"checksum"`
	DecompressionAlgorithm types.String `tfsdk:"decompression_algorithm"`
	UploadTimeout          types.Int64  `tfsdk:"upload_timeout"`
	ChecksumAlgorithm      types.String `tfsdk:"checksum_algorithm"`
	Verify                 types.Bool   `tfsdk:"verify"`
	Overwrite              types.Bool   `tfsdk:"overwrite"`
	OverwriteUnmanaged     types.Bool   `tfsdk:"overwrite_unmanaged"`
}

// NewDownloadFileResource manages files downloaded using Proxmox API.
func NewDownloadFileResource() resource.Resource {
	return &downloadFileResource{}
}

type downloadFileResource struct {
	client proxmox.Client
}

func (r *downloadFileResource) Metadata(
	_ context.Context,
	req resource.MetadataRequest,
	resp *resource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_download_file"
}

// Schema defines the schema for the resource.
func (r *downloadFileResource) Schema(
	_ context.Context,
	_ resource.SchemaRequest,
	resp *resource.SchemaResponse,
) {
	resp.Schema = schema.Schema{
		Description: "Manages files upload using PVE download-url API. ",
		MarkdownDescription: "Manages files upload using PVE download-url API. " +
			"It can be fully compatible and faster replacement for image files created using " +
			"`proxmox_virtual_environment_file`. Supports images for VMs (ISO images) and LXC (CT Templates).",
		Attributes: map[string]schema.Attribute{
			"id": attribute.ResourceID(),
			"content_type": schema.StringAttribute{
				Description: "The file content type. Must be `iso` for VM images or `vztmpl` for LXC images.",
				Required:    true,
				Validators: []validator.String{stringvalidator.OneOf([]string{
					"iso",
					"vztmpl",
				}...)},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"file_name": schema.StringAttribute{
				Description: "The file name. If not provided, it is calculated " +
					"using `url`. PVE will raise 'wrong file extension' error for some popular " +
					"extensions file `.raw` or `.qcow2`. Workaround is to use e.g. `.img` instead.",
				Computed: true,
				Required: false,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"datastore_id": schema.StringAttribute{
				Description: "The identifier for the target datastore.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"node_name": schema.StringAttribute{
				Description: "The node name.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"size": schema.Int64Attribute{
				Description: "The file size in PVE.",
				Optional:    false,
				Required:    false,
				Computed:    true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
					sizeRequiresReplaceModifier{},
				},
			},
			"upload_timeout": schema.Int64Attribute{
				Description: "The file download timeout seconds. Default is 600 (10min).",
				Optional:    true,
				Computed:    true,
				Default:     int64default.StaticInt64(600),
			},
			"url": schema.StringAttribute{
				Description: "The URL to download the file from. Must match regex: `" + httpRegex.String() + "`.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(httpRegex, "must match HTTP URL regex `"+httpRegex.String()+"`"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"checksum": schema.StringAttribute{
				Description: "The expected checksum of the file.",
				Optional:    true,
				Default:     nil,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.AlsoRequires(path.MatchRoot("checksum_algorithm")),
				},
			},
			"decompression_algorithm": schema.StringAttribute{
				Description: "Decompress the downloaded file using the " +
					"specified compression algorithm. Must be one of `gz` | `lzo` | `zst` | `bz2`.",
				Optional: true,
				Default:  nil,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"gz",
						"lzo",
						"zst",
						"bz2",
					}...),
				},
			},
			"checksum_algorithm": schema.StringAttribute{
				Description: "The algorithm to calculate the checksum of the file. " +
					"Must be `md5` | `sha1` | `sha224` | `sha256` | `sha384` | `sha512`.",
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"md5",
						"sha1",
						"sha224",
						"sha256",
						"sha384",
						"sha512",
					}...),
					stringvalidator.AlsoRequires(path.MatchRoot("checksum")),
				},
				Default: nil,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"verify": schema.BoolAttribute{
				Description: "By default `true`. If `false`, no SSL/TLS certificates will be verified.",
				Optional:    true,
				Computed:    true,
				Default:     booldefault.StaticBool(true),
			},
			"overwrite": schema.BoolAttribute{
				Description: "By default `true`. If `true` and file size has changed in the datastore, " +
					"it will be replaced. If `false`, there will be no check.",
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(true),
			},
			"overwrite_unmanaged": schema.BoolAttribute{
				Description: "If `true` and a file with the same name already exists in the datastore, " +
					"it will be deleted and the new file will be downloaded. If `false` and the file already exists, " +
					"an error will be returned.",
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
		},
	}
}

func (r *downloadFileResource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	resp *resource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.Resource)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *proxmox.Client, got: %T", req.ProviderData),
		)

		return
	}

	r.client = cfg.Client
}

func (r *downloadFileResource) Create(
	ctx context.Context,
	req resource.CreateRequest,
	resp *resource.CreateResponse,
) {
	var plan downloadFileModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	timeout := time.Duration(plan.UploadTimeout.ValueInt64()) * time.Second

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	fileMetadata, err := r.getURLMetadata(
		ctx,
		&plan,
	)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error initiating file download",
			"Could not get file metadata, unexpected error: "+err.Error(),
		)

		return
	}

	if plan.FileName.IsUnknown() {
		plan.FileName = types.StringValue(*fileMetadata.Filename)
	}

	nodesClient := r.client.Node(plan.Node.ValueString())
	verify := proxmoxtypes.CustomBool(plan.Verify.ValueBool())

	downloadFileReq := storage.DownloadURLPostRequestBody{
		Node:              plan.Node.ValueStringPointer(),
		Storage:           plan.Storage.ValueStringPointer(),
		Content:           plan.Content.ValueStringPointer(),
		Checksum:          plan.Checksum.ValueStringPointer(),
		ChecksumAlgorithm: plan.ChecksumAlgorithm.ValueStringPointer(),
		Compression:       plan.DecompressionAlgorithm.ValueStringPointer(),
		FileName:          plan.FileName.ValueStringPointer(),
		URL:               plan.URL.ValueStringPointer(),
		Verify:            &verify,
	}

	storageClient := nodesClient.Storage(plan.Storage.ValueString())

	err = storageClient.DownloadFileByURL(ctx, &downloadFileReq)

	if isErrFileAlreadyExists(err) && plan.OverwriteUnmanaged.ValueBool() {
		fileID := plan.Content.ValueString() + "/" + plan.FileName.ValueString()

		err = storageClient.DeleteDatastoreFile(ctx, fileID)
		if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
			resp.Diagnostics.AddError("Error deleting file from datastore",
				fmt.Sprintf("Could not delete file '%s', unexpected error: %s", fileID, err.Error()),
			)
		}

		err = storageClient.DownloadFileByURL(ctx, &downloadFileReq)
	}

	if err != nil {
		if isErrFileAlreadyExists(err) {
			resp.Diagnostics.AddError(
				"File already exists in the datastore, it was created outside of Terraform "+
					"or is managed by another resource.",
				fmt.Sprintf("File already exists in the datastore: '%s', error: %s",
					plan.FileName.ValueString(), err.Error(),
				),
			)
		} else {
			resp.Diagnostics.AddError(
				"Error downloading file from url",
				fmt.Sprintf("Could not download file '%s', unexpected error: %s",
					plan.FileName.ValueString(),
					err.Error(),
				),
			)
		}

		return
	}

	plan.ID = types.StringValue(plan.Storage.ValueString() + ":" +
		plan.Content.ValueString() + "/" + plan.FileName.ValueString())

	err = r.read(ctx, &plan)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error when reading file from datastore", err.Error(),
		)
	}

	resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

func (r *downloadFileResource) getURLMetadata(
	ctx context.Context,
	model *downloadFileModel,
) (*nodes.QueryURLMetadataGetResponseData, error) {
	nodesClient := r.client.Node(model.Node.ValueString())
	verify := proxmoxtypes.CustomBool(model.Verify.ValueBool())

	queryURLMetadataReq := nodes.QueryURLMetadataGetRequestBody{
		URL:    model.URL.ValueString(),
		Verify: &verify,
	}

	fileMetadata, err := nodesClient.GetQueryURLMetadata(
		ctx,
		&queryURLMetadataReq,
	)
	if err != nil {
		return nil, fmt.Errorf(
			"error fetching metadata from download url, "+
				"unexpected error in GetQueryURLMetadata: %w",
			err,
		)
	}

	return fileMetadata, nil
}

func (r *downloadFileResource) read(
	ctx context.Context,
	model *downloadFileModel,
) error {
	nodesClient := r.client.Node(model.Node.ValueString())
	storageClient := nodesClient.Storage(model.Storage.ValueString())

	datastoresFiles, err := storageClient.ListDatastoreFiles(ctx)
	if err != nil {
		return fmt.Errorf("unexpected error when listing datastore files: %w", err)
	}

	for _, file := range datastoresFiles {
		if file != nil {
			if file.VolumeID != model.ID.ValueString() {
				continue
			}

			model.Size = types.Int64Value(file.FileSize)

			return nil
		}
	}

	return fmt.Errorf("file does not exists in datastore")
}

// Read reads file from datastore.
func (r *downloadFileResource) Read(
	ctx context.Context,
	req resource.ReadRequest,
	resp *resource.ReadResponse,
) {
	var state downloadFileModel
	diags := req.State.Get(ctx, &state)

	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	setOriginalValue := []byte(strconv.FormatInt(state.Size.ValueInt64(), 10))
	resp.Private.SetKey(ctx, "original_state_size", setOriginalValue)

	err := r.read(ctx, &state)
	if err != nil {
		if strings.Contains(err.Error(), "failed to authenticate") {
			resp.Diagnostics.AddError("Failed to authenticate", err.Error())

			return
		}

		resp.Diagnostics.AddWarning(
			"The file does not exist in datastore and resource must be recreated.",
			err.Error(),
		)
		resp.State.RemoveResource(ctx)

		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, state)...)
}

// Update file resource.
func (r *downloadFileResource) Update(
	ctx context.Context,
	req resource.UpdateRequest,
	resp *resource.UpdateResponse,
) {
	var plan, state downloadFileModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	err := r.read(ctx, &plan)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error when reading file from datastore", err.Error(),
		)

		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}

// Delete removes file resource.
func (r *downloadFileResource) Delete(
	ctx context.Context,
	req resource.DeleteRequest,
	resp *resource.DeleteResponse,
) {
	var state downloadFileModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	nodesClient := r.client.Node(state.Node.ValueString())
	storageClient := nodesClient.Storage(state.Storage.ValueString())

	err := storageClient.DeleteDatastoreFile(
		ctx,
		state.ID.ValueString(),
	)
	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		if strings.Contains(err.Error(), "unable to parse") {
			resp.Diagnostics.AddWarning(
				"Datastore file does not exists",
				fmt.Sprintf(
					"Could not delete datastore file '%s', it does not exist or has been deleted outside of Terraform.",
					state.ID.ValueString(),
				),
			)
		} else {
			resp.Diagnostics.AddError(
				"Error deleting datastore file",
				fmt.Sprintf("Could not delete datastore file '%s', unexpected error: %s",
					state.ID.ValueString(), err.Error()),
			)
		}
	}
}

func isErrFileAlreadyExists(err error) bool {
	if err == nil {
		return false
	}

	return strings.Contains(err.Error(), "refusing to override existing file")
}
`````

## File: fwprovider/test/datasource_node_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func TestAccDatasourceNode(t *testing.T) {
	t.Parallel()

	te := InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"read node attributes", []resource.TestStep{{
			Config: te.RenderConfig(`data "proxmox_virtual_environment_node" "test" { node_name = "{{.NodeName}}" }`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributesSet("data.proxmox_virtual_environment_node.test", []string{
					"cpu_count",
					"cpu_sockets",
					"cpu_model",
					"memory_available",
					"memory_used",
					"memory_total",
					"uptime",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/test/datasource_version_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"fmt"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func TestAccDatasourceVersion(t *testing.T) {
	te := InitEnvironment(t)

	datasourceName := "data.proxmox_virtual_environment_version.test"

	resource.ParallelTest(t, resource.TestCase{
		ProtoV6ProviderFactories: te.AccProviders,
		Steps: []resource.TestStep{
			// Read testing
			{
				Config: `data "proxmox_virtual_environment_version" "test" {}`,
				Check: resource.ComposeAggregateTestCheckFunc(
					resource.TestCheckResourceAttr(datasourceName, "release", "8.4"),
					resource.TestCheckResourceAttrSet(datasourceName, "repository_id"),
					resource.TestCheckResourceAttrWith(datasourceName, "version", func(value string) error {
						if strings.HasPrefix(value, "8.4") {
							return nil
						}
						return fmt.Errorf("version %s does not start with 8.4", value)
					}),
					resource.TestCheckResourceAttrSet(datasourceName, "id"),
				),
			},
		},
	})
}
`````

## File: fwprovider/test/resource_container_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"context"
	"fmt"
	"math/rand"
	"testing"
	"time"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/storage"
)

const (
	accTestContainerName = "proxmox_virtual_environment_container.test_container"
)

func TestAccResourceContainer(t *testing.T) {
	t.Parallel()

	te := InitEnvironment(t)

	imageFileName := gofakeit.Word() + "-ubuntu-23.04-standard_23.04-1_amd64.tar.zst"
	accTestContainerID := 100000 + rand.Intn(99999)
	accTestContainerIDClone := 100000 + rand.Intn(99999)

	te.AddTemplateVars(map[string]interface{}{
		"ImageFileName":        imageFileName,
		"TestContainerID":      accTestContainerID,
		"TestContainerIDClone": accTestContainerIDClone,
	})

	err := te.NodeStorageClient().DownloadFileByURL(context.Background(), &storage.DownloadURLPostRequestBody{
		Content:  ptr.Ptr("vztmpl"),
		FileName: ptr.Ptr(imageFileName),
		Node:     ptr.Ptr(te.NodeName),
		Storage:  ptr.Ptr(te.DatastoreID),
		URL:      ptr.Ptr(fmt.Sprintf("%s/images/system/ubuntu-23.04-standard_23.04-1_amd64.tar.zst", te.ContainerImagesServer)),
	})
	require.NoError(t, err)

	t.Cleanup(func() {
		e := te.NodeStorageClient().DeleteDatastoreFile(context.Background(), fmt.Sprintf("vztmpl/%s", imageFileName))
		require.NoError(t, e)
	})

	tests := []struct {
		name string
		step []resource.TestStep
	}{
		{"create, start and update container", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_container" "test_container" {
					node_name = "{{.NodeName}}"
					vm_id     = {{.TestContainerID}}
					timeout_delete = 10
					unprivileged = true
					disk {
						datastore_id = "local-lvm"
						size         = 4
					}
					mount_point {
						volume = "local-lvm"
						size   = "4G"
						path   = "mnt/local"
					}
					device_passthrough {
						path = "/dev/zero"
					}
					description = <<-EOT
						my
						description
						value
					EOT
					initialization {
						hostname = "test"
						ip_config {
							ipv4 {
							  address = "dhcp"
							}
						}
					}
					network_interface {
						name = "vmbr0"
					}
					operating_system {
						template_file_id = "local:vztmpl/{{.ImageFileName}}"
						type             = "ubuntu"
					}
				}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes(accTestContainerName, map[string]string{
						"unprivileged":              "true",
						"description":               "my\ndescription\nvalue\n",
						"device_passthrough.#":      "1",
						"device_passthrough.0.mode": "0660",
						"initialization.0.dns.#":    "0",
					}),
					func(*terraform.State) error {
						ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
						defer cancel()

						ct := te.NodeClient().Container(accTestContainerID)
						err := ct.WaitForContainerStatus(ctx, "running")
						require.NoError(te.t, err, "container did not start")

						ctInfo, err := ct.GetContainer(ctx)
						require.NoError(te.t, err, "failed to get container")
						dev0, ok := ctInfo.PassthroughDevices["dev0"]
						require.True(te.t, ok, `"dev0" passthrough device not found`)
						require.NotNil(te.t, dev0, `"dev0" passthrough device is <nil>`)
						require.Equal(te.t, "/dev/zero", dev0.Path)

						return nil
					},
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_container" "test_container" {
					node_name = "{{.NodeName}}"
					vm_id     = {{.TestContainerID}}
					timeout_delete = 10
					unprivileged = true
					disk {
						datastore_id = "local-lvm"
						size         = 4
					}
					mount_point {
						volume = "local-lvm"
						size   = "4G"
						path   = "mnt/local"
					}
					device_passthrough {
						path = "/dev/zero"
					}
					description = <<-EOT
						my
						description
						value
					EOT
					initialization {
						hostname = "test"
						ip_config {
							ipv4 {
								address = "172.16.10.10/15"
								gateway = "172.16.0.1"
							}
						}
					}
					network_interface {
						name = "vmbr0"
					}
					operating_system {
						template_file_id = "local:vztmpl/{{.ImageFileName}}"
						type             = "ubuntu"
					}
				}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes(accTestContainerName, map[string]string{
						"description":            "my\ndescription\nvalue\n",
						"device_passthrough.#":   "1",
						"initialization.0.dns.#": "0",
					}),
				),
			},
		}},
		{"update mount points", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_container" "test_container" {
				    node_name = "{{.NodeName}}"
				  	started   = false
				    disk {
						datastore_id = "local-lvm"
						size         = 4
					}
				    mount_point {
						volume = "local-lvm"
						size   = "4G"
						path   = "mnt/local1"
				    }
				    initialization {
				  		hostname = "test"
						ip_config {
						  	ipv4 {
								address = "dhcp"
						  	}
						}
				    }
				    network_interface {
				  	    name = "vmbr0"
				    }
				    operating_system {
						template_file_id = "local:vztmpl/{{.ImageFileName}}"
						type             = "ubuntu"
				    }
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_container.test_container", map[string]string{
					"mount_point.#": "1",
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_container" "test_container" {
				    node_name = "{{.NodeName}}"
				  	started   = false
				    disk {
						datastore_id = "local-lvm"
						size         = 4
					}
				    mount_point {
						volume = "local-lvm"
						size   = "4G"
						path   = "mnt/local1"
				    }
					// add a new mount point
				    mount_point {
						volume = "local-lvm"
						size   = "4G"
						path   = "mnt/local2"
				    }
				    initialization {
				  		hostname = "test"
						ip_config {
						  	ipv4 {
								address = "dhcp"
						  	}
						}
				    }
				    network_interface {
				  	    name = "vmbr0"
				    }
				    operating_system {
						template_file_id = "local:vztmpl/{{.ImageFileName}}"
						type             = "ubuntu"
				    }
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_container.test_container", map[string]string{
					"mount_point.#": "2",
				}),
			},
		}},
		{"ipv4 and ipv6", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_container" "test_container" {
				node_name = "{{.NodeName}}"
				started   = false
				disk {
					datastore_id = "local-lvm"
					size         = 4
				}
				initialization {
					hostname = "test"
					ip_config {
						ipv4 {
							address = "10.0.0.100/24"
							gateway = "10.0.0.1"
						}
					}
					ip_config {
						ipv6 {
							address = "2001:db8::100/64"	
							gateway = "2001:db8::1"
						}
					}
				}
				network_interface {
					name = "vmbr0"
					bridge = "vmbr0"
				}
				network_interface {
					name = "vmbr1"
					bridge = "vmbr1"
				}

				operating_system {
					template_file_id = "local:vztmpl/{{.ImageFileName}}"
					type             = "ubuntu"
				}
			}`),
		}}},
		{"clone container", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_container" "test_container" {
				node_name = "{{.NodeName}}"
				template  = true
				disk {
					datastore_id = "local-lvm"
					size         = 4
				}
				mount_point {
					volume = "local-lvm"
					size   = "4G"
					path   = "mnt/local"
				}
				device_passthrough {
					path = "/dev/zero"
				}
				initialization {
					hostname = "test"
					ip_config {
						ipv4 {
						  address = "dhcp"
						}
					}
				}
				network_interface {
					name = "vmbr0"
				}
				operating_system {
					template_file_id = "local:vztmpl/{{.ImageFileName}}"
					type             = "ubuntu"
				}
			}
			resource "proxmox_virtual_environment_container" "test_container_clone" {
				depends_on = [proxmox_virtual_environment_container.test_container]
				node_name  = "{{.NodeName}}"
				vm_id      = {{.TestContainerIDClone}}
				
				clone {
					vm_id = proxmox_virtual_environment_container.test_container.id
				}
				
				initialization {
					hostname = "test-clone"
				}
			}`, WithRootUser()),
			Check: resource.ComposeTestCheckFunc(
				func(*terraform.State) error {
					ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
					defer cancel()

					ct := te.NodeClient().Container(accTestContainerIDClone)
					err := ct.WaitForContainerStatus(ctx, "running")
					require.NoError(te.t, err, "container did not start")

					ctInfo, err := ct.GetContainer(ctx)
					require.NoError(te.t, err, "failed to get container")
					dev0, ok := ctInfo.PassthroughDevices["dev0"]
					require.True(te.t, ok, `"dev0" passthrough device not found`)
					require.NotNil(te.t, dev0, `"dev0" passthrough device is <nil>`)
					require.Equal(te.t, "/dev/zero", dev0.Path)

					return nil
				},
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.step,
			})
		})
	}
}
`````

## File: fwprovider/test/resource_file_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/brianvoe/gofakeit/v7"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"

	"github.com/bpg/terraform-provider-proxmox/utils"
)

type nodeResolver struct {
	node ssh.ProxmoxNode
}

func (c *nodeResolver) Resolve(_ context.Context, _ string) (ssh.ProxmoxNode, error) {
	return c.node, nil
}

func TestAccResourceFile(t *testing.T) {
	te := InitEnvironment(t)

	snippetRaw := fmt.Sprintf("snippet-raw-%s.txt", gofakeit.Word())
	snippetURL := "https://raw.githubusercontent.com/yaml/yaml-test-suite/main/src/229Q.yaml"
	snippetFile1 := strings.ReplaceAll(CreateTempFile(t, "snippet-file-1-*.yaml", "test snippet 1 - file").Name(), `\`, `/`)
	snippetFile2 := strings.ReplaceAll(CreateTempFile(t, "snippet-file-2-*.yaml", "test snippet 2 - file").Name(), `\`, `/`)
	fileISO := strings.ReplaceAll(CreateTempFile(t, "file-*.iso", "pretend this is an ISO").Name(), `\`, `/`)

	te.AddTemplateVars(map[string]interface{}{
		"SnippetRaw":   snippetRaw,
		"SnippetURL":   snippetURL,
		"SnippetFile1": snippetFile1,
		"SnippetFile2": snippetFile2,
		"FileISO":      fileISO,
	})

	resource.ParallelTest(t, resource.TestCase{
		ProtoV6ProviderFactories: te.AccProviders,
		PreCheck: func() {
			uploadSnippetFile(t, snippetFile2)
			t.Cleanup(func() {
				deleteSnippet(te, filepath.Base(snippetFile1))
				deleteSnippet(te, filepath.Base(snippetFile2))

				_ = os.Remove(snippetFile1)
				_ = os.Remove(snippetFile2)
				_ = os.Remove(fileISO)
			})
		},
		Steps: []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test_raw" {
				content_type = "snippets"
				datastore_id = "local"
				node_name    = "{{.NodeName}}"
				source_raw {
					data = <<EOF
				test snippet
					EOF
					file_name = "{{.SnippetRaw}}"
				}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test_raw", map[string]string{
					"content_type":           "snippets",
					"file_name":              snippetRaw,
					"source_raw.0.file_name": snippetRaw,
					"source_raw.0.data":      "test snippet\n",
					"id":                     fmt.Sprintf("local:snippets/%s", snippetRaw),
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					source_file {
					  path = "{{.SnippetFile1}}"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test", map[string]string{
					"content_type": "snippets",
					"file_name":    filepath.Base(snippetFile1),
					"id":           fmt.Sprintf("local:snippets/%s", filepath.Base(snippetFile1)),
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					source_file {
					  path = "{{.SnippetURL}}"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test", map[string]string{
					"content_type": "snippets",
					"file_name":    filepath.Base(snippetURL),
					"id":           fmt.Sprintf("local:snippets/%s", filepath.Base(snippetURL)),
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					source_file {
					  path = "{{.FileISO}}"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test", map[string]string{
					"content_type": "iso",
					"file_name":    filepath.Base(fileISO),
					"id":           fmt.Sprintf("local:iso/%s", filepath.Base(fileISO)),
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
				  datastore_id = "local"
				  node_name    = "{{.NodeName}}"
				  source_raw {
					data = <<EOF
				test snippet
					EOF
					file_name = "foo.yaml"
				  }
				  source_file {
					path = "bar.yaml"
				  }
				}`),
				ExpectError: regexp.MustCompile("please specify .* - not both"),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					content_type = "iso"
					source_file {
					  path = "https://github.com"
					}
				}`),
				ExpectError: regexp.MustCompile("failed to determine file name from the URL"),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
				  datastore_id = "local"
				  node_name    = "{{.NodeName}}"
				}`),
				ExpectError: regexp.MustCompile("missing argument"),
			},
			// Do not allow to overwrite the file
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					overwrite    = false
					source_file {
					  path = "{{.SnippetFile2}}"
					}
				}`),
				ExpectError: regexp.MustCompile("already exists"),
			},
			// Allow to overwrite the file by default
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					source_file {
					  path = "{{.SnippetFile2}}"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test", map[string]string{
					"content_type": "snippets",
					"file_name":    filepath.Base(snippetFile2),
					"id":           fmt.Sprintf("local:snippets/%s", filepath.Base(snippetFile2)),
				}),
			},
			// Update testing: no original file
			{
				PreConfig: func() {
					_ = os.Remove(snippetFile2)
					deleteSnippet(te, filepath.Base(snippetFile1))
				},
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
				  datastore_id = "local"
				  node_name    = "{{.NodeName}}"
				  source_file {
					path = "{{.SnippetFile1}}"
				  }
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test", map[string]string{
					"content_type": "snippets",
					"file_name":    filepath.Base(snippetFile1),
					"id":           fmt.Sprintf("local:snippets/%s", filepath.Base(snippetFile1)),
				}),
			},
			// Update testing: original file
			{
				PreConfig: func() {
					deleteSnippet(te, filepath.Base(snippetFile1))
				},
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "test" {
				  datastore_id = "local"
				  node_name    = "{{.NodeName}}"
				  source_file {
					path = "{{.SnippetFile1}}"
				  }
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_file.test", map[string]string{
					"content_type": "snippets",
					"file_name":    filepath.Base(snippetFile1),
					"id":           fmt.Sprintf("local:snippets/%s", filepath.Base(snippetFile1)),
				}),
			},
		},
	})
}

func uploadSnippetFile(t *testing.T, fileName string) {
	t.Helper()

	endpoint := utils.GetAnyStringEnv("PROXMOX_VE_ENDPOINT")
	u, err := url.ParseRequestURI(endpoint)
	require.NoError(t, err)

	sshAgent := utils.GetAnyBoolEnv("PROXMOX_VE_SSH_AGENT")
	sshUsername := utils.GetAnyStringEnv("PROXMOX_VE_SSH_USERNAME")
	sshPassword := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PASSWORD")
	sshAgentSocket := utils.GetAnyStringEnv("SSH_AUTH_SOCK", "PROXMOX_VE_SSH_AUTH_SOCK")
	sshPrivateKey := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PRIVATE_KEY")
	sshPort := utils.GetAnyIntEnv("PROXMOX_VE_ACC_NODE_SSH_PORT")
	sshClient, err := ssh.NewClient(
		sshUsername, sshPassword, sshAgent, sshAgentSocket, sshPrivateKey,
		"", "", "",
		&nodeResolver{
			node: ssh.ProxmoxNode{
				Address: u.Hostname(),
				Port:    int32(sshPort),
			},
		},
	)
	require.NoError(t, err)

	f, err := os.Open(fileName)
	require.NoError(t, err)

	defer func(f *os.File) {
		_ = f.Close()
	}(f)

	fname := filepath.Base(fileName)
	err = sshClient.NodeStreamUpload(context.Background(), "pve", "/var/lib/vz/",
		&api.FileUploadRequest{
			ContentType: "snippets",
			FileName:    fname,
			File:        f,
		})
	require.NoError(t, err)
}

func deleteSnippet(te *Environment, fname string) {
	te.t.Helper()

	err := te.NodeStorageClient().DeleteDatastoreFile(context.Background(), fmt.Sprintf("snippets/%s", fname))
	require.NoError(te.t, err)
}
`````

## File: fwprovider/test/resource_firewall_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func TestAccResourceClusterFirewall(t *testing.T) {
	te := InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"rules1", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_firewall_rules" "rules1" {
				rule {
					type   = "in"
					action = "ACCEPT"
					iface  = "vmbr0"
					dport = "8006"
					proto = "tcp"
					comment = "PVE Admin Interface"
				}
			}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_firewall_rules.rules1", map[string]string{
					"rule.0.type":    "in",
					"rule.0.action":  "ACCEPT",
					"rule.0.iface":   "vmbr0",
					"rule.0.dport":   "8006",
					"rule.0.proto":   "tcp",
					"rule.0.comment": "PVE Admin Interface",
				}),
				NoResourceAttributesSet("proxmox_virtual_environment_firewall_rules.rules1", []string{
					"node_name",
				}),
			),
		}}},
		{"ipset with ipV4 and ipV6 cidrs", []resource.TestStep{{
			Config: te.RenderConfig(`
			resource "proxmox_virtual_environment_firewall_ipset" "ipset" {
				name = "test"
				cidr {
					name    = "192.168.0.0/24"
					comment = "Local IPv4"
				}
				cidr {
					name    = "2001:db8:ab21:7b00::/64"
					comment = "LAN IPv6"
				}
				cidr {
					name    = "172.10.0.0/24"
					comment = "ext IPv4"
				}
				cidr {
					name    = "2001:db8:5a93:1e00::/64"
					comment = "ext IPv6"
				}
				cidr {
					name    = "2001:0DB8:91AA:7C30::1"
					comment = "ext 2 IPv6"
				}
			}`),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/test/resource_time_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func TestAccResourceTime(t *testing.T) {
	t.Parallel()

	te := InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"change timezone", []resource.TestStep{
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_time" "node_time" {
				  node_name = "{{.NodeName}}"
				  time_zone = "Europe/Amsterdam"
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_time.node_time", map[string]string{
					"time_zone": "Europe/Amsterdam",
				}),
			},
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_time" "node_time" {
				  node_name = "{{.NodeName}}"
				  time_zone = "UTC"
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_time.node_time", map[string]string{
					"time_zone": "UTC",
				}),
			},
			{
				Config: te.RenderConfig(`resource "proxmox_virtual_environment_time" "node_time" {
				  node_name = "{{.NodeName}}"
				  time_zone = "UTC"
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_time.node_time", map[string]string{
					"time_zone": "UTC",
				}),
			},
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/test/resource_vm_cdrom_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

func TestAccResourceVMCDROM(t *testing.T) {
	t.Parallel()

	te := InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"default no cdrom", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cdrom" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-cdrom"
				}`),
			Check: NoResourceAttributesSet("proxmox_virtual_environment_vm.test_cdrom", []string{"cdrom.#"}),
		}}},
		{"none cdrom", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cdrom" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-cdrom"
					cdrom {
						file_id   = "none"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_cdrom", map[string]string{
					"cdrom.0.file_id": "none",
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"sata cdrom", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cdrom" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-cdrom"
					cdrom {
						file_id   = "none"
						interface = "sata3"	
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_cdrom", map[string]string{
					"cdrom.0.interface": "sata3",
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"scsi cdrom", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cdrom" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-cdrom"
					cdrom {
						file_id   = "none"
						interface = "scsi5"	
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_cdrom", map[string]string{
					"cdrom.0.interface": "scsi5",
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"enable cdrom", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cdrom" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-cdrom"
					cdrom {
						file_id   = "none"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_cdrom", map[string]string{
					"cdrom.0.file_id": "none",
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cdrom" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-cdrom"
					cdrom {
						file_id   = "cdrom"
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_cdrom", map[string]string{
					"cdrom.0.file_id": "cdrom",
				}),
			},
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/test/resource_vm_disks_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"regexp"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/plancheck"
)

func TestAccResourceVMDisks(t *testing.T) {
	t.Parallel()

	te := InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"create disk with default parameters, then update it", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 8
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
						"disk.0.aio":               "io_uring",
						"disk.0.backup":            "true",
						"disk.0.cache":             "none",
						"disk.0.discard":           "ignore",
						"disk.0.file_id":           "",
						"disk.0.datastore_id":      "local-lvm",
						"disk.0.file_format":       "raw",
						"disk.0.interface":         "virtio0",
						"disk.0.iothread":          "false",
						"disk.0.path_in_datastore": `vm-\d+-disk-\d+`,
						"disk.0.replicate":         "true",
						"disk.0.size":              "8",
						"disk.0.ssd":               "false",
					}),
				),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"

					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						serial	     = "-dead_beef-"
						size         = 8
						replicate    = false
						aio          = "native"
						backup       = "false"
						speed {
						  iops_read = 100
						  iops_read_burstable = 1000
						  iops_write = 400
						  iops_write_burstable = 800
						}
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
						"disk.0.aio":                          "native",
						"disk.0.backup":                       "false",
						"disk.0.cache":                        "none",
						"disk.0.discard":                      "ignore",
						"disk.0.file_id":                      "",
						"disk.0.datastore_id":                 "local-lvm",
						"disk.0.file_format":                  "raw",
						"disk.0.interface":                    "virtio0",
						"disk.0.iothread":                     "false",
						"disk.0.path_in_datastore":            `vm-\d+-disk-\d+`,
						"disk.0.replicate":                    "false",
						"disk.0.serial":                       "-dead_beef-",
						"disk.0.size":                         "8",
						"disk.0.ssd":                          "false",
						"disk.0.speed.0.iops_read":            "100",
						"disk.0.speed.0.iops_read_burstable":  "1000",
						"disk.0.speed.0.iops_write":           "400",
						"disk.0.speed.0.iops_write_burstable": "800",
					}),
				),
			},
		}},
		{"create disk from an image", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_download_file" "test_disk_image" {
					content_type = "iso"
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					url          = "{{.CloudImagesServer}}/jammy/current/jammy-server-cloudimg-amd64.img"
					overwrite_unmanaged = true
				}
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"	
					disk {
						datastore_id = "local-lvm"
						file_id      = proxmox_virtual_environment_download_file.test_disk_image.id
						interface    = "virtio0"
						iothread     = true
						discard      = "on"
						serial       = "dead_beef"
						size         = 20
					}
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
					"disk.0.cache":             "none",
					"disk.0.datastore_id":      "local-lvm",
					"disk.0.discard":           "on",
					"disk.0.file_format":       "raw",
					"disk.0.interface":         "virtio0",
					"disk.0.iothread":          "true",
					"disk.0.path_in_datastore": `vm-\d+-disk-\d+`,
					"disk.0.serial":            "dead_beef",
					"disk.0.size":              "20",
					"disk.0.ssd":               "false",
				}),
			),
		}}},
		{"clone default disk without overrides", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk_template" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk-template"
					template  = "true"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 8
					}
				}
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"

					clone {
						vm_id = proxmox_virtual_environment_vm.test_disk_template.id
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					// fully cloned disk, does not have any attributes in state
					resource.TestCheckNoResourceAttr("proxmox_virtual_environment_vm.test_disk", "disk.0"),
					ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"multiple disks", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
					template  = "true"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 8
					}
					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 8
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
					"disk.0.interface":         "virtio0",
					"disk.0.path_in_datastore": `base-\d+-disk-1`,
					"disk.1.interface":         "scsi0",
					"disk.1.path_in_datastore": `base-\d+-disk-0`,
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"adding disks", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 8
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
					"disk.0.interface":         "scsi0",
					"disk.0.path_in_datastore": `vm-\d+-disk-0`,
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 8
					}

					disk {
						datastore_id = "local-lvm"
						interface    = "scsi1"
						size         = 8
					}
				}`),
				ConfigPlanChecks: resource.ConfigPlanChecks{
					PreApply: []plancheck.PlanCheck{
						plancheck.ExpectResourceAction("proxmox_virtual_environment_vm.test_disk", plancheck.ResourceActionUpdate),
					},
				},
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
					"disk.0.interface":         "scsi0",
					"disk.0.path_in_datastore": `vm-\d+-disk-0`,
					"disk.1.interface":         "scsi1",
					"disk.1.path_in_datastore": `vm-\d+-disk-1`,
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"removing disks", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 8
					}

					disk {
						datastore_id = "local-lvm"
						interface    = "scsi1"
						size         = 8
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
					"disk.0.interface":         "scsi0",
					"disk.0.path_in_datastore": `vm-\d+-disk-0`,
					"disk.1.interface":         "scsi1",
					"disk.1.path_in_datastore": `vm-\d+-disk-1`,
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 8
					}
				}`),
				ExpectError: regexp.MustCompile(`deletion of disks not supported`),
			},
		}},
		{"efi disk", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_efi_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-efi-disk"

					efi_disk {
						datastore_id = "local-lvm"
						type = "4m"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_efi_disk", map[string]string{
						"efi_disk.0.datastore_id": "local-lvm",
						"efi_disk.0.type":         "4m",
					}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"ide disks", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disks" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disks-ide"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "ide0"
						size         = 8
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disks", map[string]string{
					"disk.0.interface":         "ide0",
					"disk.0.path_in_datastore": `vm-\d+-disk-0`,
				}),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disks" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disks-ide"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "ide0"
						size         = 8
					}
					disk {
						datastore_id = "local-lvm"
						interface    = "ide1"
						size         = 8
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disks", map[string]string{
					"disk.#": "2",
				}),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone disk with overrides", []resource.TestStep{
			{
				SkipFunc: func() (bool, error) {
					// this test is failing because of https://github.com/bpg/terraform-provider-proxmox/issues/873
					return true, nil
				},
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk3_template" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk-template"
					template  = "true"
		
					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 8
						discard      = "on"
						iothread     = true
						ssd          = true
					}
				}
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"
		
					clone {
						vm_id = proxmox_virtual_environment_vm.test_disk_template.id
					}
		
					disk {
						interface    = "scsi0"
						size = 10
					}
				}`),
				Check: ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
					"disk.0.datastore_id":      "local-lvm",
					"disk.0.discard":           "on",
					"disk.0.file_format":       "raw",
					"disk.0.interface":         "scsi0",
					"disk.0.iothread":          "true",
					"disk.0.path_in_datastore": `base-\d+-disk-\d+`,
					"disk.0.size":              "10",
					"disk.0.ssd":               "true",
				}),
			},
			{
				RefreshState: true,
				Destroy:      false,
			},
		}},
		{"clone with disk resize", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk_template" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk-template"
					template  = "true"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 8
					}
				}
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"

					clone {
						vm_id = proxmox_virtual_environment_vm.test_disk_template.id
					}

					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 10
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
						"disk.0.datastore_id": "local-lvm",
						"disk.0.interface":    "virtio0",
						"disk.0.size":         "10",
					}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone with adding disk", []resource.TestStep{
			{
				SkipFunc: func() (bool, error) {
					// this test is failing because of "Attribute 'disk.1.size' expected to be set"
					return true, nil
				},
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_disk_template" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk-template"
					template  = "true"
					
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 8
					}
				}
				resource "proxmox_virtual_environment_vm" "test_disk" {
					node_name = "{{.NodeName}}"
					started   = false
					name 	  = "test-disk"

					clone {
						vm_id = proxmox_virtual_environment_vm.test_disk_template.id
					}

					disk {
						datastore_id = "local-lvm"
						interface    = "scsi0"
						size         = 10
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_disk", map[string]string{
						"disk.1.datastore_id": "local-lvm",
						"disk.1.interface":    "virtio0",
						"disk.1.size":         "8",
						"disk.0.datastore_id": "local-lvm",
						"disk.0.interface":    "scsi0",
						"disk.0.size":         "10",
					}),
				),
			},
			{
				RefreshState: true,
			},
		}},
		{"clone with updating disk attributes", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 20
					}
				}
				resource "proxmox_virtual_environment_vm" "clone" {
					node_name = "{{.NodeName}}"
					started   = false
					clone {
						vm_id = proxmox_virtual_environment_vm.template.vm_id
					}
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						iothread     = true
						discard      = "on"
						size         = 30
						speed {
						  iops_read = 100
						  iops_read_burstable = 1000
						  iops_write = 400
						  iops_write_burstable = 800
						}
					}
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.clone", map[string]string{
					"disk.0.iothread":                     "true",
					"disk.0.discard":                      "on",
					"disk.0.size":                         "30",
					"disk.0.speed.0.iops_read":            "100",
					"disk.0.speed.0.iops_read_burstable":  "1000",
					"disk.0.speed.0.iops_write":           "400",
					"disk.0.speed.0.iops_write_burstable": "800",
				}),
			),
		}}},
		{"clone with moving disk", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
					efi_disk {
						datastore_id = "local-lvm"
						type = "4m"
					}
					disk {
						datastore_id = "local-lvm"
						interface    = "virtio0"
						size         = 20
					}
				}
				resource "proxmox_virtual_environment_vm" "clone" {
					node_name = "{{.NodeName}}"
					started   = false
					clone {
						vm_id = proxmox_virtual_environment_vm.template.vm_id
					}
					disk {
						datastore_id = "tank"
						interface    = "virtio0"
						size         = 20
					}
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.clone", map[string]string{
					"disk.0.datastore_id": "tank",
				}),
			),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/test/resource_vm_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"fmt"
	"regexp"
	"testing"

	"github.com/brianvoe/gofakeit/v7"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/plancheck"

	"github.com/bpg/terraform-provider-proxmox/utils"
)

func TestAccResourceVM(t *testing.T) {
	t.Parallel()

	te := InitEnvironment(t)
	dirName := fmt.Sprintf("dir_%s", gofakeit.Word())
	te.AddTemplateVars(map[string]interface{}{
		"DirName": dirName,
	})

	tests := []struct {
		name string
		step []resource.TestStep
	}{
		{"multiline description", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm1" {
					node_name = "{{.NodeName}}"
					started   = false
					
					description = <<-EOT
						my
						description
						value
					EOT
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.test_vm1", map[string]string{
					"description": "my\ndescription\nvalue",
				}),
			),
		}}},
		{"single line description", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm2" {
					node_name = "{{.NodeName}}"
					started   = false
					
					description = "my description value"
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.test_vm2", map[string]string{
					"description": "my description value",
				}),
			),
		}}},
		{"no description", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm3" {
					node_name = "{{.NodeName}}"
					started   = false
					
					description = ""
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.test_vm3", map[string]string{
					"description": "",
				}),
			),
		}}},
		{"empty node_name", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_empty_node_name" {
					node_name = ""
					started   = false	
				}`),
			ExpectError: regexp.MustCompile(`expected "node_name" to not be an empty string, got `),
		}}},
		{"protection", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm4" {
					node_name = "{{.NodeName}}"
					started   = false
					
					protection = true
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm4", map[string]string{
						"protection": "true",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm4" {
					node_name = "{{.NodeName}}"
					started   = false
					
					protection = false
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm4", map[string]string{
						"protection": "false",
					}),
				),
			},
		}},
		{"update cpu block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm5" {
					node_name = "{{.NodeName}}"
					started   = false
					
					cpu {
						cores = 2
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm5", map[string]string{
						"cpu.0.sockets": "1",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm5" {
					node_name = "{{.NodeName}}"
					started   = false
					
					cpu {
						cores = 1
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm5", map[string]string{
						"cpu.0.sockets": "1",
					}),
				),
			},
		}},
		{"set cpu.architecture as non root is not supported", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_cpu_arch" {
					node_name = "{{.NodeName}}"
					started   = false
					cpu {
						architecture = "x86_64"
					}
				}`, WithAPIToken()),
				ExpectError: regexp.MustCompile(`can only be set by the root account`),
			},
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
					cpu {
						architecture = "x86_64"
					}
				}`, WithRootUser()),
				Destroy: false,
			},
		}},
		{"update memory block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm6" {
					node_name = "{{.NodeName}}"
					started   = false
					
					memory {
						dedicated = 2048
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm6", map[string]string{
						"memory.0.dedicated": "2048",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm6" {
					node_name = "{{.NodeName}}"
					started   = false
					
					memory {
						dedicated = 1024
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm6", map[string]string{
						"memory.0.dedicated": "1024",
					}),
				),
			},
		}},
		{"create vga block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"vga.#": "0",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					vga {
						type = "virtio-gl"
						clipboard = "vnc"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"vga.#": "1",
					}),
				),
			},
		}},
		{"update vga block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					
					vga {
						type = "none"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"vga.0.type":      "none",
						"vga.0.clipboard": "",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					
					vga {
						type = "virtio-gl"
						clipboard = "vnc"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"vga.0.type":      "virtio-gl",
						"vga.0.clipboard": "vnc",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					
					vga {
						type = "virtio-gl"
						clipboard = ""
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"vga.0.type":      "virtio-gl",
						"vga.0.clipboard": "",
					}),
				),
			},
		}},
		{"update watchdog block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					
					watchdog {
						enabled = "true"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"watchdog.0.model":  "i6300esb",
						"watchdog.0.action": "none",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
			
					watchdog {
						enabled = "true"
						model   = "ib700"
						action  = "reset"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"watchdog.0.model":  "ib700",
						"watchdog.0.action": "reset",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
			
					watchdog {
						enabled = "false"
						model   = "ib700"
						action  = "reset"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"watchdog.0.enabled": "false",
						"watchdog.0.model":   "ib700",
						"watchdog.0.action":  "reset",
					}),
				),
			},
		}},
		{"update rng block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					
					rng {
						source = "/dev/urandom"
					}
				}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"rng.0.source":    "/dev/urandom",
						"rng.0.max_bytes": "1024",
						"rng.0.period":    "1000",
					}),
				),
			}, {
				Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_vm" "test_vm" {
						node_name = "{{.NodeName}}"
						started   = false
				
						rng {
							source = "/dev/urandom"
							max_bytes = 2048
							period = 500
						}
					}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"rng.0.source":    "/dev/urandom",
						"rng.0.max_bytes": "2048",
						"rng.0.period":    "500",
					}),
				),
			}, {
				Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_vm" "test_vm" {
						node_name = "{{.NodeName}}"
						started   = false
				
						rng {
							source = "/dev/random"
							max_bytes = 512
							period = 200
						}
					}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"rng.0.source":    "/dev/random",
						"rng.0.max_bytes": "512",
						"rng.0.period":    "200",
					}),
				),
			},
		}},
		{"create virtiofs block", []resource.TestStep{
			{
				Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_hardware_mapping_dir" "test" {
						name      = "{{.DirName}}"

						map = [{
							node = "{{.NodeName}}"
							path = "/mnt"
						}]
					}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_hardware_mapping_dir.test", map[string]string{
						"name":       dirName,
						"map.0.node": te.NodeName,
						"map.0.path": "/mnt",
					}),
				),
			},
			{
				Config: te.RenderConfig(`
					resource "proxmox_virtual_environment_vm" "test_vm" {
						node_name = "{{.NodeName}}"
						started   = false

						virtiofs {
							mapping = "{{.DirName}}"
							cache = "always"
							direct_io = true
							expose_acl = false
							expose_xattr = false
						}
					}`, WithRootUser()),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm", map[string]string{
						"virtiofs.0.mapping":      dirName,
						"virtiofs.0.cache":        "always",
						"virtiofs.0.direct_io":    "true",
						"virtiofs.0.expose_acl":   "false",
						"virtiofs.0.expose_xattr": "false",
					}),
				),
			},
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.step,
			})
		})
	}
}

func TestAccResourceVMInitialization(t *testing.T) {
	te := InitEnvironment(t)

	tests := []struct {
		name string
		step []resource.TestStep
	}{
		{"custom cloud-init: use SCSI interface", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "cloud_config" {
					content_type = "snippets"
					datastore_id = "local"
					node_name = "{{.NodeName}}"
					source_raw {
						data = <<-EOF
						#cloud-config
						runcmd:
						  - apt update
						  - apt install -y qemu-guest-agent
						  - systemctl enable qemu-guest-agent
						  - systemctl start qemu-guest-agent
						EOF
						file_name = "cloud-config.yaml"
					}
				}

				resource "proxmox_virtual_environment_vm" "test_vm_cloudinit1" {
					node_name = "{{.NodeName}}"
					started   = true
					agent {
						enabled = true
					}
					cpu {
						cores = 2
					}
					memory {
						dedicated = 2048
					}
					disk {
						datastore_id = "local-lvm"
						file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
						interface    = "virtio0"
						iothread     = true
						discard      = "on"
						size         = 20
					}

					initialization {
						interface = "scsi1"
						
						ip_config {
							ipv4 {
								address = "dhcp"
							}
						}
						user_data_file_id = proxmox_virtual_environment_file.cloud_config.id
					}
					network_device {
						bridge = "vmbr0"
					}
				}

				resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
					content_type = "iso"
					datastore_id = "local"
					node_name = "{{.NodeName}}"
					url = "{{.CloudImagesServer}}/jammy/current/jammy-server-cloudimg-amd64.img"
					overwrite_unmanaged = true
				}`),
		}}},
		{"native cloud-init: username should not change", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm_cloudinit4" {
					node_name = "{{.NodeName}}"
					started   = false
					initialization {
						user_account {
							keys = ["ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOQCHPhOV9XsJa3uq4bmKymklNy6ktgBB/+2umizgnnY"]
						}
					}
				}`),
			Check: NoResourceAttributesSet("proxmox_virtual_environment_vm.test_vm_cloudinit4", []string{
				"initialization.0.username",
				"initialization.0.password",
			}),
		}}},
		{"native cloud-init: username should not change after update", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm_cloudinit4" {
					node_name = "{{.NodeName}}"
					started   = false
					initialization {
						user_account {
							username = "ubuntu"
							password = "password"
						}
					}
				}`),
			Check: ResourceAttributes("proxmox_virtual_environment_vm.test_vm_cloudinit4", map[string]string{
				"initialization.0.user_account.0.username": "ubuntu",
				// override by PVE, set when reading back from the API
				// have to escape the asterisks because of regex match
				"initialization.0.user_account.0.password": `\*\*\*\*\*\*\*\*\*\*`,
			}),
		}, {
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm_cloudinit4" {
					node_name = "{{.NodeName}}"
					started   = false
					initialization {
						user_account {
							username = "ubuntu"
							password = "password"
						}
						dns {
							servers = ["172.16.0.15", "172.16.0.16"]
							domain = "example.com"
						}
					}
				}`),
			Check: ResourceAttributes("proxmox_virtual_environment_vm.test_vm_cloudinit4", map[string]string{
				"initialization.0.user_account.0.username": "ubuntu",
				"initialization.0.user_account.0.password": `\*\*\*\*\*\*\*\*\*\*`,
			}),
		}}},
		{"native cloud-init: username update should not cause replacement", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					initialization {
						user_account {
							username = "ubuntu"
							password = "password"
						}
					}
				}`),
		}, {
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm" {
					node_name = "{{.NodeName}}"
					started   = false
					initialization {
						user_account {
							username = "ubuntu-updated"
							password = "password"
						}
					}
				}`),
			ConfigPlanChecks: resource.ConfigPlanChecks{
				PreApply: []plancheck.PlanCheck{
					plancheck.ExpectResourceAction("proxmox_virtual_environment_vm.test_vm", plancheck.ResourceActionUpdate),
				},
			},
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.step,
			})
		})
	}
}

func TestAccResourceVMNetwork(t *testing.T) {
	te := InitEnvironment(t)

	tests := []struct {
		name string
		step []resource.TestStep
	}{
		{"network interfaces", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_file" "cloud_config" {
					content_type = "snippets"
					datastore_id = "local"
					node_name = "{{.NodeName}}"
					source_raw {
						data = <<-EOF
						#cloud-config
						runcmd:
						  - apt update
						  - apt install -y qemu-guest-agent
						  - systemctl enable qemu-guest-agent
						  - systemctl start qemu-guest-agent
						EOF
						file_name = "cloud-config.yaml"
					}
				}
				
				resource "proxmox_virtual_environment_vm" "test_vm_network1" {
					node_name = "{{.NodeName}}"
					started   = true
					agent {
						enabled = true
					}
					cpu {
						cores = 2
					}
					memory {
						dedicated = 2048
					}
					disk {
						datastore_id = "local-lvm"
						file_id      = proxmox_virtual_environment_download_file.ubuntu_cloud_image.id
						interface    = "virtio0"
						iothread     = true
						discard      = "on"
						size         = 20
					}
					initialization {
						ip_config {
							ipv4 {
								address = "dhcp"
							}
						}
						user_data_file_id = proxmox_virtual_environment_file.cloud_config.id
					}
					network_device {
						bridge = "vmbr0"
						trunks = "10;20;30"
					}
				}

				resource "proxmox_virtual_environment_download_file" "ubuntu_cloud_image" {
					content_type = "iso"
					datastore_id = "local"
					node_name    = "{{.NodeName}}"
					url = "{{.CloudImagesServer}}/jammy/current/jammy-server-cloudimg-amd64.img"
					overwrite_unmanaged = true
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.test_vm_network1", map[string]string{
					"ipv4_addresses.#":        "2",
					"mac_addresses.#":         "2",
					"network_device.0.bridge": "vmbr0",
					"network_device.0.trunks": "10;20;30",
				}),
			),
		}}},
		{"network device disconnected", []resource.TestStep{
			{
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm_network2" {
					node_name = "{{.NodeName}}"
					started   = false
					
					network_device {
						bridge = "vmbr0"
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm_network2", map[string]string{
						"network_device.0.bridge":       "vmbr0",
						"network_device.0.disconnected": "false",
					}),
				),
			}, {
				Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "test_vm_network2" {
					node_name = "{{.NodeName}}"
					started   = false
					
					network_device {
						bridge = "vmbr0"
						disconnected = true
					}
				}`),
				Check: resource.ComposeTestCheckFunc(
					ResourceAttributes("proxmox_virtual_environment_vm.test_vm_network2", map[string]string{
						"network_device.0.bridge":       "vmbr0",
						"network_device.0.disconnected": "true",
					}),
				),
			},
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.step,
			})
		})
	}
}

func TestAccResourceVMClone(t *testing.T) {
	if utils.GetAnyStringEnv("TF_ACC") == "" {
		t.Skip("Acceptance tests are disabled")
	}

	te := InitEnvironment(t)

	tests := []struct {
		name string
		step []resource.TestStep
	}{
		{"clone cpu.architecture as root", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
					template  = true
					cpu {
						architecture = "x86_64"
					}
				}
				resource "proxmox_virtual_environment_vm" "clone" {
					node_name = "{{.NodeName}}"
					started   = false
					clone {
						vm_id = proxmox_virtual_environment_vm.template.vm_id
					}
				}`, WithRootUser()),
		}}},
		{"clone machine type", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
					template  = true
					machine   = "q35"
				}
				resource "proxmox_virtual_environment_vm" "clone" {
					node_name = "{{.NodeName}}"
					started   = false
					clone {
						vm_id = proxmox_virtual_environment_vm.template.vm_id
					}
					machine = "pc"
				}`),
			Check: ResourceAttributes("proxmox_virtual_environment_vm.clone", map[string]string{
				"machine": "pc",
			}),
		}}},
		{"clone no vga block", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
				}
				resource "proxmox_virtual_environment_vm" "clone" {
					node_name = "{{.NodeName}}"
					started   = false
					clone {
						vm_id = proxmox_virtual_environment_vm.template.vm_id
					}
				}`),
			Check: resource.ComposeTestCheckFunc(
				ResourceAttributes("proxmox_virtual_environment_vm.clone", map[string]string{
					"vga.#": "0",
				}),
			),
		}}},
		{"clone initialization datastore does not exist", []resource.TestStep{{
			Config: te.RenderConfig(`
				resource "proxmox_virtual_environment_vm" "template" {
					node_name = "{{.NodeName}}"
					started   = false
				}
				resource "proxmox_virtual_environment_vm" "clone" {
					node_name = "{{.NodeName}}"
					started   = false
					clone {
						vm_id = proxmox_virtual_environment_vm.template.vm_id
					}
					initialization {
						datastore_id = "doesnotexist"
						ip_config {
							ipv4 {
								address = "172.16.2.57/32"
								gateway = "172.16.2.10"
							}
						}
					}
				}`),
			ExpectError: regexp.MustCompile(`storage 'doesnotexist' does not exist`),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.step,
			})
		})
	}
}
`````

## File: fwprovider/test/test_environment.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"bytes"
	"fmt"
	"net/url"
	"sync"
	"testing"
	"text/template"

	"github.com/hashicorp/terraform-plugin-framework/providerserver"
	"github.com/hashicorp/terraform-plugin-go/tfprotov5"
	"github.com/hashicorp/terraform-plugin-go/tfprotov6"
	"github.com/hashicorp/terraform-plugin-mux/tf5to6server"
	"github.com/hashicorp/terraform-plugin-mux/tf6muxserver"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/fwprovider"
	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/storage"
	sdkV2provider "github.com/bpg/terraform-provider-proxmox/proxmoxtf/provider"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

// Environment is a test environment for acceptance tests.
type Environment struct {
	t            *testing.T
	templateVars map[string]any
	NodeName     string
	DatastoreID  string

	AccProviders          map[string]func() (tfprotov6.ProviderServer, error)
	once                  sync.Once
	c                     api.Client
	CloudImagesServer     string
	ContainerImagesServer string
}

// RenderConfigOption is a configuration option for rendering the provider configuration.
type RenderConfigOption interface {
	apply(rc *renderConfig) error
}

type renderConfig struct {
	providerConfig string
}

// returns the ssh configuration section of the provider config.
func (r *renderConfig) ssh() string {
	nodeName := utils.GetAnyStringEnv("PROXMOX_VE_ACC_NODE_NAME")
	if nodeName == "" {
		nodeName = "pve"
	}

	nodeAddress := utils.GetAnyStringEnv("PROXMOX_VE_ACC_NODE_SSH_ADDRESS")
	if nodeAddress == "" {
		endpoint := utils.GetAnyStringEnv("PROXMOX_VE_ENDPOINT")

		u, err := url.Parse(endpoint)
		if err != nil {
			panic(err)
		}

		nodeAddress = u.Hostname()
	}

	nodePort := utils.GetAnyStringEnv("PROXMOX_VE_ACC_NODE_SSH_PORT")
	if nodePort == "" {
		nodePort = "22"
	}

	// one indent level
	return fmt.Sprintf(`
	ssh {
		node {
			name    = "%s"
			address = "%s"
			port    = %s
		}
  	}`, nodeName, nodeAddress, nodePort)
}

// WithRootUser returns a configuration option that sets the root user in the provider configuration.
func WithRootUser() RenderConfigOption {
	return &rootUserConfigOption{}
}

type rootUserConfigOption struct{}

func (o *rootUserConfigOption) apply(rc *renderConfig) error {
	if utils.GetAnyStringEnv("PROXMOX_VE_USERNAME") == "" || utils.GetAnyStringEnv("PROXMOX_VE_PASSWORD") == "" {
		return fmt.Errorf("PROXMOX_VE_USERNAME and PROXMOX_VE_PASSWORD must be set")
	}

	rootUser := fmt.Sprintf("\tusername = \"%s\"\n\tpassword = \"%s\"\n\tapi_token = \"\"",
		utils.GetAnyStringEnv("PROXMOX_VE_USERNAME"),
		utils.GetAnyStringEnv("PROXMOX_VE_PASSWORD"),
	)

	rc.providerConfig = fmt.Sprintf("provider \"proxmox\" {\n%s\n%s\n}", rootUser, rc.ssh())

	return nil
}

// WithAPIToken returns a configuration option that sets the API token in the provider configuration.
func WithAPIToken() RenderConfigOption {
	return &apiTokenConfigOption{}
}

type apiTokenConfigOption struct{}

func (o *apiTokenConfigOption) apply(rc *renderConfig) error {
	if utils.GetAnyStringEnv("PROXMOX_VE_API_TOKEN") == "" {
		return fmt.Errorf("PROXMOX_VE_API_TOKEN must be set")
	}

	apiToken := fmt.Sprintf("\tapi_token = \"%s\"\n\tusername = \"\"\n\tpassword = \"\"",
		utils.GetAnyStringEnv("PROXMOX_VE_API_TOKEN"))

	rc.providerConfig = fmt.Sprintf("provider \"proxmox\" {\n%s\n%s\n}", apiToken, rc.ssh())

	return nil
}

// InitEnvironment initializes a new test environment for acceptance tests.
func InitEnvironment(t *testing.T) *Environment {
	t.Helper()

	nodeName := utils.GetAnyStringEnv("PROXMOX_VE_ACC_NODE_NAME")
	if nodeName == "" {
		nodeName = "pve"
	}

	const datastoreID = "local"

	cloudImagesServer := utils.GetAnyStringEnv("PROXMOX_VE_ACC_CLOUD_IMAGES_SERVER")
	if cloudImagesServer == "" {
		cloudImagesServer = "https://cloud-images.ubuntu.com"
	}

	containerImagesServer := utils.GetAnyStringEnv("PROXMOX_VE_ACC_CONTAINER_IMAGES_SERVER")
	if containerImagesServer == "" {
		containerImagesServer = "http://download.proxmox.com"
	}

	return &Environment{
		t: t,
		templateVars: map[string]any{
			"NodeName":              nodeName,
			"DatastoreID":           datastoreID,
			"CloudImagesServer":     cloudImagesServer,
			"ContainerImagesServer": containerImagesServer,
		},
		NodeName:              nodeName,
		DatastoreID:           datastoreID,
		CloudImagesServer:     cloudImagesServer,
		ContainerImagesServer: containerImagesServer,

		AccProviders: muxProviders(t),
	}
}

// AddTemplateVars adds the given variables to the template variables of the current test environment.
// Please note that NodeName and ProviderConfig are reserved keys, they are set by the test environment
// and cannot be overridden.
func (e *Environment) AddTemplateVars(vars map[string]any) {
	for k, v := range vars {
		e.templateVars[k] = v
	}
}

// RenderConfig renders the given configuration with for the current test environment using template engine.
func (e *Environment) RenderConfig(cfg string, opt ...RenderConfigOption) string {
	if len(opt) == 0 {
		opt = append(opt, WithAPIToken())
	}

	rc := &renderConfig{}
	for _, o := range opt {
		err := o.apply(rc)
		require.NoError(e.t, err, "configuration error")
	}

	tmpl, err := template.New("config").Parse(cfg)
	require.NoError(e.t, err)

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, e.templateVars)
	require.NoError(e.t, err)

	return rc.providerConfig + "\n" + buf.String()
}

// Client returns a new API client for the test environment.
// The client will be using the credentials from the environment variables, in precedence order:
// 1. API token
// 2. Ticket
// 3. User credentials.
func (e *Environment) Client() api.Client {
	if e.c == nil {
		e.once.Do(
			func() {
				endpoint := utils.GetAnyStringEnv("PROXMOX_VE_ENDPOINT")
				authTicket := utils.GetAnyStringEnv("PROXMOX_VE_AUTH_TICKET")
				csrfPreventionToken := utils.GetAnyStringEnv("PROXMOX_VE_CSRF_PREVENTION_TOKEN")
				apiToken := utils.GetAnyStringEnv("PROXMOX_VE_API_TOKEN")
				username := utils.GetAnyStringEnv("PROXMOX_VE_USERNAME")
				password := utils.GetAnyStringEnv("PROXMOX_VE_PASSWORD")

				creds, err := api.NewCredentials(username, password, "", apiToken, authTicket, csrfPreventionToken)
				if err != nil {
					panic(err)
				}

				conn, err := api.NewConnection(endpoint, true, "")
				if err != nil {
					panic(err)
				}

				e.c, err = api.NewClient(creds, conn)
				if err != nil {
					panic(err)
				}
			})
	}

	return e.c
}

// AccessClient returns a new access client for the test environment.
func (e *Environment) AccessClient() *access.Client {
	return &access.Client{Client: e.Client()}
}

// NodeClient returns a new nodes client for the test environment.
func (e *Environment) NodeClient() *nodes.Client {
	return &nodes.Client{Client: e.Client(), NodeName: e.NodeName}
}

// NodeStorageClient returns a new storage client for the test environment.
func (e *Environment) NodeStorageClient() *storage.Client {
	return &storage.Client{Client: e.NodeClient(), StorageName: e.DatastoreID}
}

// ClusterClient returns a new cluster client for the test environment.
func (e *Environment) ClusterClient() *cluster.Client {
	return &cluster.Client{Client: e.Client()}
}

// muxProviders returns a map of mux servers for the acceptance tests.
func muxProviders(t *testing.T) map[string]func() (tfprotov6.ProviderServer, error) {
	t.Helper()

	// Init mux servers
	return map[string]func() (tfprotov6.ProviderServer, error){
		"proxmox": func() (tfprotov6.ProviderServer, error) {
			return tf6muxserver.NewMuxServer(t.Context(),
				providerserver.NewProtocol6(fwprovider.New("test")()),
				func() tfprotov6.ProviderServer {
					sdkV2Provider, err := tf5to6server.UpgradeServer(
						t.Context(),
						func() tfprotov5.ProviderServer {
							return schema.NewGRPCProviderServer(
								sdkV2provider.ProxmoxVirtualEnvironment(),
							)
						},
					)
					require.NoError(t, err)

					return sdkV2Provider
				},
			)
		},
	}
}
`````

## File: fwprovider/test/test_support.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"fmt"
	"os"
	"regexp"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	"github.com/stretchr/testify/require"
)

// ResourceAttributes is a helper function to test resource attributes.
func ResourceAttributes(res string, attrs map[string]string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		for k, v := range attrs {
			if v == "" {
				if err := resource.TestCheckResourceAttr(res, k, "")(s); err != nil {
					return fmt.Errorf("expected '%s' to be empty: %w", k, err)
				}

				continue
			}

			if err := resource.TestCheckResourceAttrWith(res, k, func(got string) error {
				match, err := regexp.Match(v, []byte(got)) //nolint:mirror
				if err != nil {
					return fmt.Errorf("error matching '%s': %w", v, err)
				}
				if !match {
					return fmt.Errorf("expected '%s' to match '%s'", got, v)
				}
				return nil
			})(s); err != nil {
				return err
			}
		}

		return nil
	}
}

// NoResourceAttributesSet is a helper function to test that no resource attributes are set.
func NoResourceAttributesSet(res string, attrs []string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		for _, k := range attrs {
			if err := resource.TestCheckNoResourceAttr(res, k)(s); err != nil {
				return err
			}
		}

		return nil
	}
}

// ResourceAttributesSet is a helper function to test that all resource attributes are set.
func ResourceAttributesSet(res string, attrs []string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		for _, k := range attrs {
			if err := resource.TestCheckResourceAttrSet(res, k)(s); err != nil {
				return err
			}
		}

		return nil
	}
}

func CreateTempFile(t *testing.T, namePattern string, content string) *os.File {
	t.Helper()

	f, err := os.CreateTemp(t.TempDir(), namePattern)
	require.NoError(t, err)

	_, err = f.WriteString(content)
	require.NoError(t, err)

	defer func(f *os.File) {
		_ = f.Close()
	}(f)

	t.Cleanup(func() {
		_ = os.Remove(f.Name())
	})

	return f
}
`````

## File: fwprovider/types/hardwaremapping/path_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

func TestPathValueFromTerraform(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		val         tftypes.Value
		expected    func(val PathValue) bool
		expectError bool
	}{
		"null value": {
			val: tftypes.NewValue(tftypes.String, nil),
			expected: func(val PathValue) bool {
				return val.IsNull()
			},
		},
		"unknown value": {
			val: tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
			expected: func(val PathValue) bool {
				return val.IsUnknown()
			},
		},
		"valid for PCI type": {
			val: tftypes.NewValue(tftypes.String, "8086:5916"),
			expected: func(val PathValue) bool {
				return val.ValueString() == "8086:5916"
			},
		},
		"valid for USB type": {
			val: tftypes.NewValue(tftypes.String, "1-5.2"),
			expected: func(val PathValue) bool {
				return val.ValueString() == "1-5.2"
			},
		},
	}

	for name, test := range tests {
		t.Run(
			name, func(t *testing.T) {
				t.Parallel()

				ctx := t.Context()
				val, err := PathType{}.ValueFromTerraform(ctx, test.val)

				if err == nil && test.expectError {
					t.Fatal("expected error, got no error")
				}

				if err != nil && !test.expectError {
					t.Fatalf("got unexpected error: %s", err)
				}

				if !test.expected(val.(PathValue)) {
					t.Errorf("unexpected result")
				}
			},
		)
	}
}
`````

## File: fwprovider/types/hardwaremapping/path.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"context"
	"errors"
	"fmt"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/function"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Ensure the implementations satisfy the required interfaces.
var (
	_ basetypes.StringTypable  = PathType{}
	_ basetypes.StringValuable = PathValue{}
)

// ErrValueConversion indicates an error while converting a value for a hardware mapping path.
//
//nolint:gochecknoglobals
var ErrValueConversion = func(format string, attrs ...any) error {
	// bpg: this doesn't seem to be a proper use of the function.NewFuncError
	return function.NewFuncError(fmt.Sprintf(format, attrs...))
}

var (
	// PathDirValueRegEx is the regular expression for a POSIX path.
	PathDirValueRegEx = regexp.MustCompile(`^/.+$`)

	// PathPCIValueRegEx is the regular expression for a PCI hardware mapping path.
	PathPCIValueRegEx = regexp.MustCompile(`^[a-f0-9]{4,}:[a-f0-9]{2}:[a-f0-9]{2}(\.[a-f0-9])?$`)

	// PathUSBValueRegEx is the regular expression for a USB hardware mapping path.
	PathUSBValueRegEx = regexp.MustCompile(`^\d+-(\d+)(\.\d+)?$`)
)

// PathType is a type that represents a path of a hardware mapping.
type PathType struct {
	basetypes.StringType
	Type proxmoxtypes.Type
}

// PathValue is a type that represents the value of a hardware mapping path.
type PathValue struct {
	basetypes.StringValue
}

// Equal returns true if the two types are equal.
func (t PathType) Equal(o attr.Type) bool {
	other, ok := o.(PathType)

	if !ok {
		return false
	}

	return t.StringType.Equal(other.StringType)
}

// String returns a string representation of the type.
func (t PathType) String() string {
	return "PathType"
}

// ValueFromString converts a string value to a StringValuable.
func (t PathType) ValueFromString(_ context.Context, in basetypes.StringValue) (
	basetypes.StringValuable,
	diag.Diagnostics,
) {
	value := PathValue{
		StringValue: in,
	}

	return value, nil
}

// ValueFromTerraform converts a Terraform value to a StringValuable.
func (t PathType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	attrValue, err := t.StringType.ValueFromTerraform(ctx, in)
	if err != nil {
		return nil, errors.Join(
			ErrValueConversion("unexpected error converting Terraform value to StringValue"),
			err,
		)
	}

	stringValue, ok := attrValue.(basetypes.StringValue)
	if !ok {
		return nil, ErrValueConversion("unexpected value type of %T", attrValue)
	}

	stringValuable, diags := t.ValueFromString(ctx, stringValue)
	if diags.HasError() {
		return nil, ErrValueConversion(
			"unexpected error converting StringValue to StringValuable: %v",
			diags,
		)
	}

	return stringValuable, nil
}

// ValueType returns the underlying value type.
func (t PathType) ValueType(_ context.Context) attr.Value {
	return PathValue{}
}

// Equal returns true if the two values are equal.
func (v PathValue) Equal(o attr.Value) bool {
	other, ok := o.(PathValue)

	if !ok {
		return false
	}

	return v.StringValue.Equal(other.StringValue)
}

// IsProxmoxType checks whether the value match the given hardware mapping type.
func (v PathValue) IsProxmoxType(hmType proxmoxtypes.Type) bool {
	switch hmType {
	case proxmoxtypes.TypeDir:
		return PathDirValueRegEx.MatchString(v.ValueString())
	case proxmoxtypes.TypePCI:
		return PathPCIValueRegEx.MatchString(v.ValueString())
	case proxmoxtypes.TypeUSB:
		return PathUSBValueRegEx.MatchString(v.ValueString()) || v.ValueString() == ""
	default:
		return false
	}
}

// Type returns the type of the value.
func (v PathValue) Type(_ context.Context) attr.Type {
	return PathType{}
}

// NewPathPointerValue returns a new PathValue from a string pointer.
func NewPathPointerValue(value *string) PathValue {
	return PathValue{
		StringValue: types.StringPointerValue(value),
	}
}
`````

## File: fwprovider/types/nodes/apt/errors.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package apt

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/function"
)

//nolint:gochecknoglobals
var (
	// ErrValueConversion indicates an error while converting a value for a Proxmox VE API APT entity.
	ErrValueConversion = func(format string, attrs ...any) error {
		return function.NewFuncError(fmt.Sprintf(format, attrs...))
	}
)
`````

## File: fwprovider/types/nodes/apt/standard_repo_handle_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-go/tftypes"

	apitypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/nodes/apt/repositories"
)

func TestStandardRepoHandleValueFromTerraform(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		val         tftypes.Value
		expected    func(val StandardRepoHandleValue) bool
		expectError bool
	}{
		"null value": {
			val: tftypes.NewValue(tftypes.String, nil),
			expected: func(val StandardRepoHandleValue) bool {
				return val.IsNull()
			},
		},
		"unknown value": {
			val: tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
			expected: func(val StandardRepoHandleValue) bool {
				return val.IsUnknown()
			},
		},
		"invalid Ceph APT standard repository handle": {
			val: tftypes.NewValue(tftypes.String, "ceph-foo-enterprise"),
			expected: func(val StandardRepoHandleValue) bool {
				return val.kind == apitypes.StandardRepoHandleKindUnknown &&
					!val.IsCephHandle() &&
					!val.IsSupportedFilePath(apitypes.StandardRepoFilePathCeph) &&
					val.ComponentName() == "unknown" &&
					val.ValueString() == "ceph-foo-enterprise"
			},
		},
		"valid Ceph APT standard repository handle": {
			val: tftypes.NewValue(tftypes.String, "ceph-quincy-enterprise"),
			expected: func(val StandardRepoHandleValue) bool {
				return val.kind == apitypes.StandardRepoHandleKindEnterprise &&
					val.CephVersionName() == apitypes.CephVersionNameQuincy &&
					val.IsCephHandle() &&
					val.IsSupportedFilePath(apitypes.StandardRepoFilePathCeph) &&
					val.ComponentName() == "enterprise" &&
					val.ValueString() == "ceph-quincy-enterprise"
			},
		},
		`valid Ceph "test" APT standard repository handle`: {
			val: tftypes.NewValue(tftypes.String, "ceph-reef-test"),
			expected: func(val StandardRepoHandleValue) bool {
				return val.kind == apitypes.StandardRepoHandleKindTest &&
					val.CephVersionName() == apitypes.CephVersionNameReef &&
					val.IsCephHandle() &&
					val.IsSupportedFilePath(apitypes.StandardRepoFilePathCeph) &&
					val.ComponentName() == "test" &&
					val.ValueString() == "ceph-reef-test"
			},
		},
		"invalid APT repository handle": {
			val: tftypes.NewValue(tftypes.String, "foo-bar"),
			expected: func(val StandardRepoHandleValue) bool {
				return val.kind == apitypes.StandardRepoHandleKindUnknown &&
					!val.IsCephHandle() &&
					!val.IsSupportedFilePath(apitypes.StandardRepoFilePathCeph) &&
					val.ValueString() == "foo-bar"
			},
		},
		`valid APT "no subscription" repository handle`: {
			val: tftypes.NewValue(tftypes.String, "no-subscription"),
			expected: func(val StandardRepoHandleValue) bool {
				return val.kind == apitypes.StandardRepoHandleKindNoSubscription &&
					!val.IsCephHandle() &&
					val.IsSupportedFilePath(apitypes.StandardRepoFilePathMain) &&
					val.ComponentName() == "pve-no-subscription" &&
					val.ValueString() == "no-subscription"
			},
		},
		`valid APT "test" repository handle`: {
			val: tftypes.NewValue(tftypes.String, "test"),
			expected: func(val StandardRepoHandleValue) bool {
				return val.kind == apitypes.StandardRepoHandleKindTest &&
					!val.IsCephHandle() &&
					val.IsSupportedFilePath(apitypes.StandardRepoFilePathMain) &&
					val.ComponentName() == "pvetest" &&
					val.ValueString() == "test"
			},
		},
	}

	for name, test := range tests {
		t.Run(
			name, func(t *testing.T) {
				t.Parallel()

				ctx := t.Context()
				val, err := StandardRepoHandleType{}.ValueFromTerraform(ctx, test.val)

				if err == nil && test.expectError {
					t.Fatal("expected error, got no error")
				}

				if err != nil && !test.expectError {
					t.Fatalf("got unexpected error: %s", err)
				}

				if !test.expected(val.(StandardRepoHandleValue)) {
					t.Errorf("unexpected result")
				}
			},
		)
	}
}
`````

## File: fwprovider/types/nodes/apt/standard_repo_handle.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package apt

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	apitypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/nodes/apt/repositories"
)

// Ensure the implementations satisfy the required interfaces.
var (
	_ basetypes.StringTypable  = StandardRepoHandleType{}
	_ basetypes.StringValuable = StandardRepoHandleValue{}
)

// StandardRepoHandleType is a type that represents an APT standard repository handle.
type StandardRepoHandleType struct {
	basetypes.StringType
}

// StandardRepoHandleValue is a type that represents the value of an APT standard repository handle.
type StandardRepoHandleValue struct {
	basetypes.StringValue
	cvn  apitypes.CephVersionName
	kind apitypes.StandardRepoHandleKind
}

// Equal returns true if the two types are equal.
func (t StandardRepoHandleType) Equal(o attr.Type) bool {
	other, ok := o.(StandardRepoHandleType)

	if !ok {
		return false
	}

	return t.StringType.Equal(other.StringType)
}

// String returns a string representation of the type.
func (t StandardRepoHandleType) String() string {
	return "StandardRepoHandleType"
}

// ValueFromString converts a string value to a basetypes.StringValuable.
func (t StandardRepoHandleType) ValueFromString(_ context.Context, in basetypes.StringValue) (
	basetypes.StringValuable,
	diag.Diagnostics,
) {
	value := StandardRepoHandleValue{
		StringValue: in,
		cvn:         apitypes.CephVersionNameUnknown,
		kind:        apitypes.StandardRepoHandleKindUnknown,
	}

	// Parse the Ceph version name when the handle has the prefix.
	if strings.HasPrefix(value.ValueString(), apitypes.CephStandardRepoHandlePrefix) {
		parts := strings.Split(value.ValueString(), "-")
		// Only continue when there is at least the Ceph prefix and the major version name in the handle.
		if len(parts) > 2 {
			cvn, err := apitypes.ParseCephVersionName(parts[1])
			if err == nil {
				value.cvn = cvn
			}
		}
	}

	// Parse the handle kind‚Ä¶
	handleString := value.ValueString()

	if value.IsCephHandle() {
		// ‚Ä¶but ensure to strip Ceph specific parts from the handle string.
		name, ok := strings.CutPrefix(handleString, fmt.Sprintf("%s-%s-", apitypes.CephStandardRepoHandlePrefix, value.cvn))
		if ok {
			handleString = name
		}
	}

	switch handleString {
	case apitypes.StandardRepoHandleKindEnterprise.String():
		value.kind = apitypes.StandardRepoHandleKindEnterprise
	case apitypes.StandardRepoHandleKindNoSubscription.String():
		value.kind = apitypes.StandardRepoHandleKindNoSubscription
	case apitypes.StandardRepoHandleKindTest.String():
		value.kind = apitypes.StandardRepoHandleKindTest
	}

	return value, nil
}

// ValueFromTerraform converts a Terraform value to a basetypes.StringValuable.
func (t StandardRepoHandleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	attrValue, err := t.StringType.ValueFromTerraform(ctx, in)
	if err != nil {
		return nil, errors.Join(
			ErrValueConversion("unexpected error converting Terraform value to StringValue"),
			err,
		)
	}

	stringValue, ok := attrValue.(basetypes.StringValue)
	if !ok {
		return nil, ErrValueConversion("unexpected value type of %T", attrValue)
	}

	stringValuable, diags := t.ValueFromString(ctx, stringValue)
	if diags.HasError() {
		return nil, ErrValueConversion(
			"unexpected error converting StringValue to StringValuable: %v",
			diags,
		)
	}

	return stringValuable, nil
}

// ValueType returns the underlying value type.
func (t StandardRepoHandleType) ValueType(_ context.Context) attr.Value {
	return StandardRepoHandleValue{}
}

// CephVersionName returns the corresponding Ceph major version name.
// Note that the version will be [apitypes.CephVersionNameUnknown] when not a Ceph specific handle!
func (v StandardRepoHandleValue) CephVersionName() apitypes.CephVersionName {
	return v.cvn
}

// ComponentName returns the corresponding component name.
func (v StandardRepoHandleValue) ComponentName() string {
	if v.cvn == apitypes.CephVersionNameUnknown && v.kind != apitypes.StandardRepoHandleKindUnknown {
		// For whatever reason the non-Ceph handle "test" kind does not use a dash in between the "pve" prefix.
		if v.kind == apitypes.StandardRepoHandleKindTest {
			return fmt.Sprintf("pve%s", v.kind)
		}

		return fmt.Sprintf("pve-%s", v.kind)
	}

	return v.kind.String()
}

// Equal returns true if the two values are equal.
func (v StandardRepoHandleValue) Equal(o attr.Value) bool {
	other, ok := o.(StandardRepoHandleValue)

	if !ok {
		return false
	}

	return v.StringValue.Equal(other.StringValue)
}

// IsCephHandle indicates if this is a Ceph APT standard repository.
func (v StandardRepoHandleValue) IsCephHandle() bool {
	return v.cvn != apitypes.CephVersionNameUnknown
}

// IsSupportedFilePath returns whether the handle is supported for the given source list file path.
func (v StandardRepoHandleValue) IsSupportedFilePath(filePath string) bool {
	switch filePath {
	case apitypes.StandardRepoFilePathCeph:
		return v.IsCephHandle()
	case apitypes.StandardRepoFilePathEnterprise:
		return !v.IsCephHandle() && v.kind == apitypes.StandardRepoHandleKindEnterprise
	case apitypes.StandardRepoFilePathMain:
		return !v.IsCephHandle() && v.kind != apitypes.StandardRepoHandleKindEnterprise
	default:
		return false
	}
}

// Type returns the type of the value.
func (v StandardRepoHandleValue) Type(_ context.Context) attr.Type {
	return StandardRepoHandleType{}
}
`````

## File: fwprovider/types/stringset/attribute.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package stringset

import (
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// ResourceAttribute returns a resource schema attribute for string set.
func ResourceAttribute(desc, markdownDesc string) schema.SetAttribute {
	return schema.SetAttribute{
		CustomType: Type{
			SetType: types.SetType{
				ElemType: types.StringType,
			},
		},
		Description:         desc,
		MarkdownDescription: markdownDesc,
		Optional:            true,
		Computed:            true,
		ElementType:         types.StringType,
		Validators: []validator.Set{
			// NOTE: we allow empty list to remove all previously set values
			setvalidator.ValueStringsAre(
				stringvalidator.RegexMatches(
					regexp.MustCompile(`(.|\s)*\S(.|\s)*`),
					"must be a non-empty and non-whitespace string",
				),
				stringvalidator.LengthAtLeast(1),
			),
		},
	}
}

// DataSourceAttribute returns a data source schema attribute for string set.
func DataSourceAttribute(desc, markdownDesc string, optional bool) schema.SetAttribute {
	attribute := schema.SetAttribute{
		CustomType: Type{
			SetType: types.SetType{
				ElemType: types.StringType,
			},
		},
		Description:         desc,
		MarkdownDescription: markdownDesc,
		ElementType:         types.StringType,
	}

	if optional {
		attribute.Optional = true
	} else {
		attribute.Required = true
	}

	return attribute
}
`````

## File: fwprovider/types/stringset/options.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package stringset

type options struct {
	separator string
}

type Option struct {
	apply func(*options)
}

func defaultOptions(opts ...Option) options {
	opt := options{
		separator: ";",
	}

	for _, o := range opts {
		o.apply(&opt)
	}

	return opt
}

// WithSeparator sets the separator for the string set value.
// For future use, to set the separator to a different value than the default ";".
// Would allow us to replace types.CustomCommaSeparatedList custom type that can only handle commas.
func WithSeparator(separator string) Option {
	return Option{
		apply: func(o *options) {
			o.separator = separator
		},
	}
}
`````

## File: fwprovider/types/stringset/type.go
`````go
package stringset

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

// Ensure the implementations satisfy the required interfaces.
var (
	_ basetypes.SetTypable = Type{}
)

// Type defines the type for string set.
type Type struct {
	basetypes.SetType
}

// Equal returns true if the two types are equal.
func (t Type) Equal(o attr.Type) bool {
	other, ok := o.(Type)

	if !ok {
		return false
	}

	return t.SetType.Equal(other.SetType)
}

// String returns a string representation of the type.
func (t Type) String() string {
	return "StringSetType"
}

// ValueFromSet converts the set value to a SetValuable type.
func (t Type) ValueFromSet(_ context.Context, in basetypes.SetValue) (basetypes.SetValuable, diag.Diagnostics) {
	value := Value{
		SetValue: in,
	}

	return value, nil
}

// ValueFromTerraform converts the Terraform value to a NewValue type.
func (t Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	attrValue, err := t.SetType.ValueFromTerraform(ctx, in)
	if err != nil {
		return nil, fmt.Errorf("error converting Terraform value to NewValue")
	}

	setValue, ok := attrValue.(basetypes.SetValue)
	if !ok {
		return nil, fmt.Errorf("unexpected value type of %T", attrValue)
	}

	setValuable, diags := t.ValueFromSet(ctx, setValue)
	if diags.HasError() {
		return nil, fmt.Errorf("error converting NewValue to SetValuable: %v", diags)
	}

	return setValuable, nil
}

// ValueType returns the underlying value type.
func (t Type) ValueType(_ context.Context) attr.Value {
	return Value{}
}
`````

## File: fwprovider/types/stringset/value.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package stringset

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
)

// Ensure the implementations satisfy the required interfaces.
var (
	_ basetypes.SetValuable = Value{}
)

// Value defines the value for string set.
type Value struct {
	basetypes.SetValue
}

// Type returns the type of the value.
func (v Value) Type(_ context.Context) attr.Type {
	return Type{
		SetType: basetypes.SetType{ElemType: basetypes.StringType{}},
	}
}

// Equal returns true if the two values are equal.
func (v Value) Equal(o attr.Value) bool {
	other, ok := o.(Value)

	if !ok {
		return false
	}

	return v.SetValue.Equal(other.SetValue)
}

// ValueList returns a string slice of set value.
func (v Value) ValueList(ctx context.Context, diags *diag.Diagnostics) []string {
	if v.IsNull() || v.IsUnknown() || len(v.Elements()) == 0 {
		return nil
	}

	elems := make([]types.String, 0, len(v.Elements()))
	d := v.ElementsAs(ctx, &elems, false)
	diags.Append(d...)

	if d.HasError() {
		return nil
	}

	var sanitizedItems []string

	for _, el := range elems {
		if el.IsNull() || el.IsUnknown() {
			continue
		}

		sanitizedItem := strings.TrimSpace(el.ValueString())
		if len(sanitizedItem) > 0 {
			sanitizedItems = append(sanitizedItems, sanitizedItem)
		}
	}

	return sanitizedItems
}

// ValueStringPointer returns a pointer to the string representation of string set value.
func (v Value) ValueStringPointer(ctx context.Context, diags *diag.Diagnostics, opts ...Option) *string {
	elems := v.ValueList(ctx, diags)
	if len(elems) == 0 {
		return nil
	}

	o := defaultOptions(opts...)

	return ptr.Ptr(strings.Join(elems, o.separator))
}

// NewValueList converts a slice of items to a new string set value.
func NewValueList(items []string, diags *diag.Diagnostics) Value {
	if len(items) == 0 {
		return Value{types.SetValueMust(types.StringType, []attr.Value{})}
	}

	elems := make([]attr.Value, len(items))

	for i, item := range items {
		elems[i] = types.StringValue(item)
	}

	setValue, d := types.SetValue(types.StringType, elems)
	diags.Append(d...)

	return Value{setValue}
}

// NewValueString converts a string of items to a new string set value.
func NewValueString(str *string, diags *diag.Diagnostics, opts ...Option) Value {
	if str == nil || *str == "" {
		return Value{types.SetValueMust(types.StringType, []attr.Value{})}
	}

	o := defaultOptions(opts...)

	items := strings.Split(*str, o.separator)

	return NewValueList(items, diags)
}
`````

## File: fwprovider/types/ip_addr_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

func Test_IPAddrTypeValueFromTerraform(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		val         tftypes.Value
		expected    func(val IPAddrValue) bool
		expectError bool
	}{
		"null value": {
			val: tftypes.NewValue(tftypes.String, nil),
			expected: func(val IPAddrValue) bool {
				return val.IsNull()
			},
		},
		"unknown value": {
			val: tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
			expected: func(val IPAddrValue) bool {
				return val.IsUnknown()
			},
		},
		"valid IPv4": {
			val: tftypes.NewValue(tftypes.String, "1.2.3.4"),
			expected: func(val IPAddrValue) bool {
				return val.ValueString() == "1.2.3.4"
			},
		},
		"valid IPv6": {
			val: tftypes.NewValue(tftypes.String, "2001:0db8:85a3:0000:0000:8a2e:0370:7334"),
			expected: func(val IPAddrValue) bool {
				return val.ValueString() == "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
			},
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			ctx := t.Context()
			val, err := IPAddrType{}.ValueFromTerraform(ctx, test.val)

			if err == nil && test.expectError {
				t.Fatal("expected error, got no error")
			}

			if err != nil && !test.expectError {
				t.Fatalf("got unexpected error: %s", err)
			}

			if !test.expected(val.(IPAddrValue)) {
				t.Errorf("unexpected result")
			}
		})
	}
}

func Test_IPAddrTypeValidate(t *testing.T) {
	t.Parallel()

	type testCase struct {
		val         tftypes.Value
		expectError bool
	}

	tests := map[string]testCase{
		"not a string": {
			val:         tftypes.NewValue(tftypes.Bool, true),
			expectError: true,
		},
		"unknown string": {
			val: tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
		},
		"null string": {
			val: tftypes.NewValue(tftypes.String, nil),
		},
		"valid IPv4 string": {
			val: tftypes.NewValue(tftypes.String, "1.2.3.4"),
		},
		"valid IPv6 string": {
			val: tftypes.NewValue(tftypes.String, "2001:0db8:85a3:0000:0000:8a2e:0370:7334"),
		},
		"invalid string": {
			val:         tftypes.NewValue(tftypes.String, "not ok"),
			expectError: true,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			ctx := t.Context()

			diags := IPAddrType{}.Validate(ctx, test.val, path.Root("test"))

			if !diags.HasError() && test.expectError {
				t.Fatal("expected error, got no error")
			}

			if diags.HasError() && !test.expectError {
				t.Fatalf("got unexpected error: %s", diags)
			}
		})
	}
}
`````

## File: fwprovider/types/ip_addr_value.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure the implementation satisfies the expected interfaces.
var _ basetypes.StringValuable = IPAddrValue{}

// IPAddrValue is a type that represents an IP address value.
type IPAddrValue struct {
	basetypes.StringValue
}

// Equal returns true if the two values are equal.
func (v IPAddrValue) Equal(o attr.Value) bool {
	other, ok := o.(IPAddrValue)

	if !ok {
		return false
	}

	return v.StringValue.Equal(other.StringValue)
}

// Type returns the type of the value.
func (v IPAddrValue) Type(_ context.Context) attr.Type {
	return IPAddrType{}
}

// NewIPAddrPointerValue returns a new IPAddrValue from a string pointer.
func NewIPAddrPointerValue(value *string) IPAddrValue {
	return IPAddrValue{
		StringValue: types.StringPointerValue(value),
	}
}
`````

## File: fwprovider/types/ip_addr.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"context"
	"fmt"
	"net"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

// Ensure the implementation satisfies the expected interfaces.
var _ basetypes.StringTypable = IPAddrType{}

// IPAddrType is a type that represents an IP address.
type IPAddrType struct {
	basetypes.StringType
}

// Equal returns true if the two types are equal.
func (t IPAddrType) Equal(o attr.Type) bool {
	other, ok := o.(IPAddrType)

	if !ok {
		return false
	}

	return t.StringType.Equal(other.StringType)
}

// String returns a string representation of the type.
func (t IPAddrType) String() string {
	return "IPAddrType"
}

// ValueFromString converts a string value to a StringValuable.
func (t IPAddrType) ValueFromString(
	_ context.Context, in basetypes.StringValue,
) (basetypes.StringValuable, diag.Diagnostics) {
	value := IPAddrValue{
		StringValue: in,
	}

	return value, nil
}

// ValueFromTerraform converts a Terraform value to a StringValuable.
func (t IPAddrType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	attrValue, err := t.StringType.ValueFromTerraform(ctx, in)
	if err != nil {
		return nil, fmt.Errorf("unexpected error converting Terraform value to StringValue: %w", err)
	}

	stringValue, ok := attrValue.(basetypes.StringValue)
	if !ok {
		return nil, fmt.Errorf("unexpected value type of %T", attrValue)
	}

	stringValuable, diags := t.ValueFromString(ctx, stringValue)
	if diags.HasError() {
		return nil, fmt.Errorf("unexpected error converting StringValue to StringValuable: %v", diags)
	}

	return stringValuable, nil
}

// ValueType returns the underlying value type.
func (t IPAddrType) ValueType(_ context.Context) attr.Value {
	return IPAddrValue{}
}

// Validate ensures the value is valid IP address.
func (t IPAddrType) Validate(_ context.Context, value tftypes.Value, valuePath path.Path) diag.Diagnostics {
	if value.IsNull() || !value.IsKnown() {
		return nil
	}

	diags := diag.Diagnostics{}

	var valueString string

	if err := value.As(&valueString); err != nil {
		diags.AddAttributeError(
			valuePath,
			"Invalid Terraform Value",
			"An unexpected error occurred while attempting to convert a Terraform value to a string. "+
				"This generally is an issue with the provider schema implementation. "+
				"Please contact the provider developers.\n\n"+
				"Path: "+valuePath.String()+"\n"+
				"Error: "+err.Error(),
		)

		return diags
	}

	if ip := net.ParseIP(valueString); ip == nil {
		diags.AddAttributeError(
			valuePath,
			"Invalid IP String Value",
			"An unexpected error occurred while converting a string value that was expected to be IPv4/IPv6.\n\n"+
				"Path: "+valuePath.String()+"\n"+
				"Given Value: "+valueString,
		)

		return diags
	}

	return diags
}
`````

## File: fwprovider/types/ip_cidr_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

func Test_IPCIDRTypeValueFromTerraform(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		val         tftypes.Value
		expected    func(val IPCIDRValue) bool
		expectError bool
	}{
		"null value": {
			val: tftypes.NewValue(tftypes.String, nil),
			expected: func(val IPCIDRValue) bool {
				return val.IsNull()
			},
		},
		"unknown value": {
			val: tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
			expected: func(val IPCIDRValue) bool {
				return val.IsUnknown()
			},
		},
		"valid IPv4/CIDR": {
			val: tftypes.NewValue(tftypes.String, "1.2.3.4/32"),
			expected: func(val IPCIDRValue) bool {
				return val.ValueString() == "1.2.3.4/32"
			},
		},
		"valid IPv6/CIDR": {
			val: tftypes.NewValue(tftypes.String, "2001:db8::/32"),
			expected: func(val IPCIDRValue) bool {
				return val.ValueString() == "2001:db8::/32"
			},
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			ctx := t.Context()
			val, err := IPCIDRType{}.ValueFromTerraform(ctx, test.val)

			if err == nil && test.expectError {
				t.Fatal("expected error, got no error")
			}

			if err != nil && !test.expectError {
				t.Fatalf("got unexpected error: %s", err)
			}

			if !test.expected(val.(IPCIDRValue)) {
				t.Errorf("unexpected result")
			}
		})
	}
}

func Test_IPCIDRTypeValidate(t *testing.T) {
	t.Parallel()

	type testCase struct {
		val         tftypes.Value
		expectError bool
	}

	tests := map[string]testCase{
		"not a string": {
			val:         tftypes.NewValue(tftypes.Bool, true),
			expectError: true,
		},
		"unknown string": {
			val: tftypes.NewValue(tftypes.String, tftypes.UnknownValue),
		},
		"null string": {
			val: tftypes.NewValue(tftypes.String, nil),
		},
		"valid IPv4 string": {
			val: tftypes.NewValue(tftypes.String, "1.2.3.4/32"),
		},
		"valid IPv6 string": {
			val: tftypes.NewValue(tftypes.String, "2001:db8::/32"),
		},
		"invalid string": {
			val:         tftypes.NewValue(tftypes.String, "not ok"),
			expectError: true,
		},
		"invalid IPv4 string no CIDR": {
			val:         tftypes.NewValue(tftypes.String, "1.2.3.4"),
			expectError: true,
		},
		"invalid IPv6 string no CIDR": {
			val:         tftypes.NewValue(tftypes.String, "2001:db8::"),
			expectError: true,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			ctx := t.Context()

			diags := IPCIDRType{}.Validate(ctx, test.val, path.Root("test"))

			if !diags.HasError() && test.expectError {
				t.Fatal("expected error, got no error")
			}

			if diags.HasError() && !test.expectError {
				t.Fatalf("got unexpected error: %s", diags)
			}
		})
	}
}
`````

## File: fwprovider/types/ip_cidr_value.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure the implementation satisfies the expected interfaces.
var _ basetypes.StringValuable = IPCIDRValue{}

// IPCIDRValue is a type that represents an IP address in CIDR notation.
type IPCIDRValue struct {
	basetypes.StringValue
}

// Equal returns true if the two values are equal.
func (v IPCIDRValue) Equal(o attr.Value) bool {
	other, ok := o.(IPCIDRValue)

	if !ok {
		return false
	}

	return v.StringValue.Equal(other.StringValue)
}

// Type returns the type of the value.
func (v IPCIDRValue) Type(_ context.Context) attr.Type {
	return IPCIDRType{}
}

// NewIPCIDRPointerValue returns a new IPCIDRValue from a string pointer.
func NewIPCIDRPointerValue(value *string) IPCIDRValue {
	return IPCIDRValue{
		StringValue: types.StringPointerValue(value),
	}
}
`````

## File: fwprovider/types/ip_cidr.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"context"
	"fmt"
	"net"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
)

// Ensure the implementation satisfies the expected interfaces.
var _ basetypes.StringTypable = IPCIDRType{}

// IPCIDRType is a type that represents an IP address in CIDR notation.
type IPCIDRType struct {
	basetypes.StringType
}

// Equal returns true if the two types are equal.
func (t IPCIDRType) Equal(o attr.Type) bool {
	other, ok := o.(IPCIDRType)

	if !ok {
		return false
	}

	return t.StringType.Equal(other.StringType)
}

// String returns a string representation of the type.
func (t IPCIDRType) String() string {
	return "IPCIDRType"
}

// ValueFromString converts a string value to a StringValuable.
func (t IPCIDRType) ValueFromString(
	_ context.Context, in basetypes.StringValue,
) (basetypes.StringValuable, diag.Diagnostics) {
	value := IPCIDRValue{
		StringValue: in,
	}

	return value, nil
}

// ValueFromTerraform converts a Terraform value to a StringValuable.
func (t IPCIDRType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	attrValue, err := t.StringType.ValueFromTerraform(ctx, in)
	if err != nil {
		return nil, fmt.Errorf("unexpected error converting Terraform value to StringValue: %w", err)
	}

	stringValue, ok := attrValue.(basetypes.StringValue)
	if !ok {
		return nil, fmt.Errorf("unexpected value type of %T", attrValue)
	}

	stringValuable, diags := t.ValueFromString(ctx, stringValue)
	if diags.HasError() {
		return nil, fmt.Errorf("unexpected error converting StringValue to StringValuable: %v", diags)
	}

	return stringValuable, nil
}

// ValueType returns the underlying value type.
func (t IPCIDRType) ValueType(_ context.Context) attr.Value {
	return IPCIDRValue{}
}

// Validate ensures the value is valid IP address in CIDR notation.
func (t IPCIDRType) Validate(_ context.Context, value tftypes.Value, valuePath path.Path) diag.Diagnostics {
	if value.IsNull() || !value.IsKnown() {
		return nil
	}

	diags := diag.Diagnostics{}

	var valueString string

	if err := value.As(&valueString); err != nil {
		diags.AddAttributeError(
			valuePath,
			"Invalid Terraform Value",
			"An unexpected error occurred while attempting to convert a Terraform value to a string. "+
				"This generally is an issue with the provider schema implementation. "+
				"Please contact the provider developers.\n\n"+
				"Path: "+valuePath.String()+"\n"+
				"Error: "+err.Error(),
		)

		return diags
	}

	if _, _, err := net.ParseCIDR(valueString); err != nil {
		diags.AddAttributeError(
			valuePath,
			"Invalid IP/CIDR String Value",
			"An unexpected error occurred while converting a string value that was expected to be IP/CIDR.\n\n"+
				"Path: "+valuePath.String()+"\n"+
				"Given Value: "+valueString+"\n"+
				"Error: "+err.Error(),
		)

		return diags
	}

	return diags
}
`````

## File: fwprovider/validators/file.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// FileID returns a validator that checks if a string is a valid file ID.
func FileID() validator.String {
	return stringvalidator.RegexMatches(
		regexp.MustCompile(`^(?i)[a-z\d\-_.]+:([a-z\d\-_]+/)?.+$`),
		"must be in the format `<datastore name>:<content type>/<file name>`",
	)
}
`````

## File: fwprovider/validators/hardware_mapping.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

const (
	// HardwareMappingDeviceIDValidatorErrMessage is the error message when the validation fails.
	HardwareMappingDeviceIDValidatorErrMessage = `value must be a valid hardware mapping device ID, e.g. "8086:5916"`
)

// HardwareMappingDeviceIDValidator validates a hardware mapping device ID.
func HardwareMappingDeviceIDValidator() validator.String {
	return NewParseValidator(proxmoxtypes.ParseDeviceID, HardwareMappingDeviceIDValidatorErrMessage)
}
`````

## File: fwprovider/validators/i18n.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// LanguageValidator returns a new validator for language codes.
func LanguageValidator() validator.String {
	return stringvalidator.OneOf([]string{
		`ca`, `da`, `de`, `en`, `es`, `eu`, `fa`, `fr`, `he`, `it`, `ja`, `nb`,
		`nn`, `pl`, `pt_BR`, `ru`, `sl`, `sv`, `tr`, `zh_CN`, `zh_TW`,
	}...)
}

// KeyboardLayoutValidator returns a new validator for keyboard layouts.
func KeyboardLayoutValidator() validator.String {
	return stringvalidator.OneOf([]string{
		`de`, `de-ch`, `da`, `en-gb`, `en-us`, `es`, `fi`, `fr`, `fr-be`, `fr-ca`, `fr-ch`,
		`hu`, `is`, `it`, `ja`, `lt`, `mk`, `nl`, `no`, `pl`, `pt`, `pt-br`, `sv`, `sl`, `tr`,
	}...)
}
`````

## File: fwprovider/validators/parse_validator.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/helpers/validatordiag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// NewParseValidator creates a validator which uses a parsing function to validate a string. The function is expected
// to return a value of type `T` and an error. If the error is non-nil, the validator will fail. The `description`
// argument should contain a description of the validator's effect.
func NewParseValidator[T any](parseFunction func(string) (T, error), description string) validator.String {
	return &parseValidator[T]{
		parseFunction: parseFunction,
		description:   description,
	}
}

// parseValidator is a validator which uses a parsing function to validate a string.
type parseValidator[T any] struct {
	parseFunction func(string) (T, error)
	description   string
}

func (val *parseValidator[T]) Description(_ context.Context) string {
	return val.description
}

func (val *parseValidator[T]) MarkdownDescription(_ context.Context) string {
	return val.description
}

func (val *parseValidator[T]) ValidateString(
	ctx context.Context,
	request validator.StringRequest,
	response *validator.StringResponse,
) {
	if request.ConfigValue.IsNull() || request.ConfigValue.IsUnknown() {
		return
	}

	value := request.ConfigValue

	_, err := val.parseFunction(value.ValueString())
	if err != nil {
		response.Diagnostics.Append(validatordiag.InvalidAttributeValueMatchDiagnostic(
			request.Path,
			val.Description(ctx),
			value.String(),
		))
	}
}
`````

## File: fwprovider/validators/strings.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// AbsoluteFilePathValidator validates that a string is an absolute file path.
func AbsoluteFilePathValidator() validator.String {
	return NewParseValidator(
		func(s string) (string, error) {
			if strings.HasPrefix(s, "/") {
				return s, nil
			}

			return s, fmt.Errorf("%q is not an absolute path", s)
		},
		"must be an absolute file path",
	)
}

// NonEmptyString returns a new validator to ensure a non-empty string.
func NonEmptyString() validator.String {
	return stringvalidator.All(
		stringvalidator.UTF8LengthAtLeast(1),
		stringvalidator.RegexMatches(regexp.MustCompile(`^\S|^$`), "must not start with whitespace"),
		stringvalidator.RegexMatches(regexp.MustCompile(`\S$|^$`), "must not end with whitespace"),
	)
}
`````

## File: fwprovider/datasource_version.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package fwprovider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &versionDatasource{}
	_ datasource.DataSourceWithConfigure = &versionDatasource{}
)

// NewVersionDataSource is a helper function to simplify the provider implementation.
func NewVersionDataSource() datasource.DataSource {
	return &versionDatasource{}
}

// versionDatasource is the data source implementation.
type versionDatasource struct {
	client proxmox.Client
}

// versionDataSourceModel maps the data source schema data.
type versionDataSourceModel struct {
	Release      types.String `tfsdk:"release"`
	RepositoryID types.String `tfsdk:"repository_id"`
	Version      types.String `tfsdk:"version"`
	ID           types.String `tfsdk:"id"`
}

// Metadata returns the data source type name.
func (d *versionDatasource) Metadata(
	_ context.Context,
	req datasource.MetadataRequest,
	resp *datasource.MetadataResponse,
) {
	resp.TypeName = req.ProviderTypeName + "_version"
}

// Schema defines the schema for the data source.
func (d *versionDatasource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Retrieves API version details.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "Placeholder identifier attribute.",
				Computed:    true,
			},
			"release": schema.StringAttribute{
				Description: "The current Proxmox VE point release in `x.y` format.",
				Computed:    true,
			},
			"repository_id": schema.StringAttribute{
				Description: "The short git revision from which this version was build.",
				Computed:    true,
			},
			"version": schema.StringAttribute{
				Description: "The full pve-manager package version of this node.",
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider configured client to the data source.
func (d *versionDatasource) Configure(
	_ context.Context,
	req datasource.ConfigureRequest,
	resp *datasource.ConfigureResponse,
) {
	if req.ProviderData == nil {
		return
	}

	cfg, ok := req.ProviderData.(config.DataSource)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected config.DataSource, got: %T", req.ProviderData),
		)

		return
	}

	d.client = cfg.Client
}

// Read refreshes the Terraform state with the latest data.
func (d *versionDatasource) Read(ctx context.Context, _ datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state versionDataSourceModel

	version, err := d.client.Version().Version(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Read Version",
			err.Error(),
		)

		return
	}

	state.Release = types.StringValue(version.Release)
	state.RepositoryID = types.StringValue(version.RepositoryID)
	state.Version = types.StringValue(version.Version)

	state.ID = types.StringValue("version")

	// Set state
	diags := resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
}
`````

## File: fwprovider/provider_test.go
`````go
//go:build acceptance || all

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package fwprovider_test

import (
	"context"
	"regexp"
	"sync"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/test"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

func TestIDGenerator_Sequence(t *testing.T) {
	t.Parallel()

	const (
		numIDs     = 10
		numBusyIDs = 30
	)

	if utils.GetAnyStringEnv("TF_ACC") == "" {
		t.Skip("Acceptance tests are disabled")
	}

	te := test.InitEnvironment(t)

	ctx := context.Background()

	gen := cluster.NewIDGenerator(te.ClusterClient(), cluster.IDGeneratorConfig{RandomIDs: false})
	firstID, err := gen.NextID(ctx)
	require.NoError(t, err)

	firstBusyID := firstID + 5

	_, err = te.ClusterClient().GetNextID(ctx, ptr.Ptr(firstBusyID))
	require.NoError(t, err, "the VM ID %d should be available", firstBusyID)

	for i := range numBusyIDs {
		busyID := firstBusyID + i
		err = te.NodeClient().VM(0).CreateVM(ctx, &vms.CreateRequestBody{VMID: busyID})
		require.NoError(t, err, "failed to create VM %d", busyID)
	}

	t.Cleanup(func() {
		var wg sync.WaitGroup

		for i := range numBusyIDs {
			wg.Add(1)

			go func() {
				defer wg.Done()

				busyID := firstBusyID + i
				err = te.NodeClient().VM(busyID).DeleteVM(ctx)
				assert.NoError(t, err, "failed to delete VM %d", busyID)
			}()
		}

		wg.Wait()
	})

	ids := make([]int, numIDs)

	t.Cleanup(func() {
		var wg sync.WaitGroup
		for _, id := range ids {
			wg.Add(1)

			go func() {
				defer wg.Done()

				if id > 100 {
					_ = te.NodeClient().VM(id).DeleteVM(ctx) //nolint:errcheck
				}
			}()
		}

		wg.Wait()
	})

	var wg sync.WaitGroup

	for i := range numIDs {
		wg.Add(1)

		go func() {
			defer wg.Done()

			id, err := gen.NextID(ctx)
			if err == nil {
				err = te.NodeClient().VM(0).CreateVM(ctx, &vms.CreateRequestBody{VMID: id})
				ids[i] = id
			}

			assert.NoError(t, err)
		}()
	}

	wg.Wait()
}

func TestIDGenerator_Random(t *testing.T) {
	t.Parallel()

	const (
		numIDs       = 7
		randomIDStat = 1000
		randomIDEnd  = 1010
	)

	if utils.GetAnyStringEnv("TF_ACC") == "" {
		t.Skip("Acceptance tests are disabled")
	}

	te := test.InitEnvironment(t)

	ctx := context.Background()

	gen := cluster.NewIDGenerator(te.ClusterClient(), cluster.IDGeneratorConfig{RandomIDs: true, RandomIDStat: randomIDStat, RandomIDEnd: randomIDEnd})

	ids := make([]int, numIDs)

	t.Cleanup(func() {
		for _, id := range ids {
			if id > 100 {
				_ = te.NodeClient().VM(id).DeleteVM(ctx) //nolint:errcheck
			}
		}
	})

	for i := range numIDs {
		id, err := gen.NextID(ctx)
		require.NoError(t, err)
		err = te.NodeClient().VM(0).CreateVM(ctx, &vms.CreateRequestBody{VMID: id})
		ids[i] = id

		require.NoError(t, err)
	}
}

func TestProviderAuth(t *testing.T) {
	if utils.GetAnyStringEnv("TF_ACC") == "" {
		t.Skip("Acceptance tests are disabled")
	}

	te := test.InitEnvironment(t)

	tests := []struct {
		name  string
		steps []resource.TestStep
	}{
		{"no credentials", []resource.TestStep{{
			Config: `
					provider "proxmox" {
						api_token              = ""
						username               = ""
					}
					data "proxmox_virtual_environment_version" "test" {}
					`,
			ExpectError: regexp.MustCompile(`must provide either username and password, an API token, or a ticket`),
		}}},
		{"invalid api token", []resource.TestStep{{
			Config: `
					provider "proxmox" {
						api_token = "invalid-token"
					}
					data "proxmox_virtual_environment_version" "test" {}
					`,
			ExpectError: regexp.MustCompile(`the API token must be in the format 'USER@REALM!TOKENID=UUID'`),
		}}},
		{"invalid username", []resource.TestStep{{
			Config: `
					provider "proxmox" {
						api_token              = ""
						username               = "root"
					}
					data "proxmox_virtual_environment_version" "test" {}
					`,
			ExpectError: regexp.MustCompile(`username must end with '@pve' or '@pam'`),
		}}},
		{"missing password", []resource.TestStep{{
			Config: `
					provider "proxmox" {
						api_token              = ""
						username               = "root@pam"
						password			   = ""
					}
					data "proxmox_virtual_environment_version" "test" {}
					`,
			ExpectError: regexp.MustCompile(`must provide either username and password, an API token, or a ticket`),
		}}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resource.ParallelTest(t, resource.TestCase{
				ProtoV6ProviderFactories: te.AccProviders,
				Steps:                    tt.steps,
			})
		})
	}
}
`````

## File: fwprovider/provider.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package fwprovider

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/provider"
	"github.com/hashicorp/terraform-plugin-framework/provider/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/fwprovider/access"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/cluster/acme"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/cluster/ha"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/cluster/hardwaremapping"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/cluster/metrics"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/cluster/options"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/config"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/apt"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/datastores"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/network"
	"github.com/bpg/terraform-provider-proxmox/fwprovider/nodes/vm"
	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	proxmoxnodes "github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

// Ensure the implementation satisfies the expected interfaces.
var _ provider.Provider = &proxmoxProvider{}

// New is a helper function to simplify provider server and testing implementation.
func New(version string) func() provider.Provider {
	return func() provider.Provider {
		return &proxmoxProvider{
			version: version,
		}
	}
}

type proxmoxProvider struct {
	// version is set to the provider version on release, "dev" when the
	// provider is built and ran locally, and "test" when running acceptance
	// testing.
	version string
}

// proxmoxProviderModel maps provider schema data.
type proxmoxProviderModel struct {
	Endpoint            types.String `tfsdk:"endpoint"`
	Insecure            types.Bool   `tfsdk:"insecure"`
	MinTLS              types.String `tfsdk:"min_tls"`
	AuthTicket          types.String `tfsdk:"auth_ticket"`
	CSRFPreventionToken types.String `tfsdk:"csrf_prevention_token"`
	APIToken            types.String `tfsdk:"api_token"`
	OTP                 types.String `tfsdk:"otp"`
	Username            types.String `tfsdk:"username"`
	Password            types.String `tfsdk:"password"`

	SSH []struct {
		Agent          types.Bool   `tfsdk:"agent"`
		AgentSocket    types.String `tfsdk:"agent_socket"`
		PrivateKey     types.String `tfsdk:"private_key"`
		Password       types.String `tfsdk:"password"`
		Username       types.String `tfsdk:"username"`
		Socks5Server   types.String `tfsdk:"socks5_server"`
		Socks5Username types.String `tfsdk:"socks5_username"`
		Socks5Password types.String `tfsdk:"socks5_password"`

		Nodes []struct {
			Name    types.String `tfsdk:"name"`
			Address types.String `tfsdk:"address"`
			Port    types.Int64  `tfsdk:"port"`
		} `tfsdk:"node"`
	} `tfsdk:"ssh"`
	TmpDir         types.String `tfsdk:"tmp_dir"`
	RandomVMIDs    types.Bool   `tfsdk:"random_vm_ids"`
	RandomVMIDStat types.Int64  `tfsdk:"random_vm_id_start"`
	RandomVMIDEnd  types.Int64  `tfsdk:"random_vm_id_end"`
}

func (p *proxmoxProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) {
	resp.TypeName = "proxmox_virtual_environment"
	resp.Version = p.version
}

func (p *proxmoxProvider) Schema(_ context.Context, _ provider.SchemaRequest, resp *provider.SchemaResponse) {
	resp.Schema = schema.Schema{
		// Attributes specified in alphabetical order.
		Attributes: map[string]schema.Attribute{
			"api_token": schema.StringAttribute{
				Description: "The API token for the Proxmox VE API.",
				Optional:    true,
				Sensitive:   true,
			},
			"auth_ticket": schema.StringAttribute{
				Description: "The pre-authenticated Ticket for the Proxmox VE API.",
				Optional:    true,
				Sensitive:   true,
			},
			"csrf_prevention_token": schema.StringAttribute{
				Description: "The pre-authenticated CSRF Prevention Token for the Proxmox VE API.",
				Optional:    true,
				Sensitive:   true,
			},
			"endpoint": schema.StringAttribute{
				Description: "The endpoint for the Proxmox VE API.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"insecure": schema.BoolAttribute{
				Description: "Whether to skip the TLS verification step.",
				Optional:    true,
			},
			"min_tls": schema.StringAttribute{
				Description: "The minimum required TLS version for API calls." +
					"Supported values: `1.0|1.1|1.2|1.3`. Defaults to `1.3`.",
				Optional: true,
			},
			"otp": schema.StringAttribute{
				Description: "The one-time password for the Proxmox VE API.",
				Optional:    true,
				DeprecationMessage: "The `otp` attribute is deprecated and will be removed in a future release. " +
					"Please use the `api_token` attribute instead.",
			},
			"password": schema.StringAttribute{
				Description: "The password for the Proxmox VE API.",
				Optional:    true,
				Sensitive:   true,
			},
			"random_vm_ids": schema.BoolAttribute{
				Description: "Whether to generate random VM / Container IDs.",
				Optional:    true,
			},
			"random_vm_id_start": schema.Int64Attribute{
				Description: "The starting number for random VM / Container IDs.",
				Optional:    true,
				Validators:  []validator.Int64{int64validator.Between(100, 999999999)},
			},
			"random_vm_id_end": schema.Int64Attribute{
				Description: "The ending number for random VM / Container IDs.",
				Optional:    true,
				Validators:  []validator.Int64{int64validator.Between(100, 999999999)},
			},
			"tmp_dir": schema.StringAttribute{
				Description: "The alternative temporary directory.",
				Optional:    true,
			},
			"username": schema.StringAttribute{
				Description: "The username for the Proxmox VE API.",
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{
			// have to define it as a list due to backwards compatibility
			"ssh": schema.ListNestedBlock{
				Description: "The SSH configuration for the Proxmox nodes.",
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"agent": schema.BoolAttribute{
							Description: "Whether to use the SSH agent for authentication. Takes precedence over " +
								"the `private_key` and `password` fields. Defaults to the value of the " +
								"`PROXMOX_VE_SSH_AGENT` environment variable, or `false` if not set.",
							Optional: true,
						},
						"agent_socket": schema.StringAttribute{
							Description: "The path to the SSH agent socket. " +
								"Defaults to the value of the `SSH_AUTH_SOCK` " +
								"environment variable.",
							Optional: true,
						},
						"password": schema.StringAttribute{
							Description: "The password used for the SSH connection. " +
								"Defaults to the value of the `password` field of the " +
								"`provider` block.",
							Optional:  true,
							Sensitive: true,
						},
						"private_key": schema.StringAttribute{
							Description: "The unencrypted private key (in PEM format) used for the SSH connection. " +
								"Defaults to the value of the `PROXMOX_VE_SSH_PRIVATE_KEY` environment variable.",
							Optional:  true,
							Sensitive: true,
						},
						"socks5_password": schema.StringAttribute{
							Description: "The password for the SOCKS5 proxy server. " +
								"Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_PASSWORD` environment variable.",
							Optional:  true,
							Sensitive: true,
						},
						"socks5_server": schema.StringAttribute{
							Description: "The address:port of the SOCKS5 proxy server. " +
								"Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_SERVER` environment variable.",
							Optional: true,
						},
						"socks5_username": schema.StringAttribute{
							Description: "The username for the SOCKS5 proxy server. " +
								"Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_USERNAME` environment variable.",
							Optional: true,
						},
						"username": schema.StringAttribute{
							Description: "The username used for the SSH connection. " +
								"Defaults to the value of the `username` field of the " +
								"`provider` block.",
							Optional: true,
						},
					},
					Blocks: map[string]schema.Block{
						"node": schema.ListNestedBlock{
							Description: "Overrides for SSH connection configuration for a Proxmox VE node.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"address": schema.StringAttribute{
										Description: "The address of the Proxmox VE node.",
										Required:    true,
									},
									"name": schema.StringAttribute{
										Description: "The name of the Proxmox VE node.",
										Required:    true,
									},
									"port": schema.Int64Attribute{
										Description: "The port of the Proxmox VE node.",
										Optional:    true,
										Validators:  []validator.Int64{int64validator.Between(1, 65535)},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (p *proxmoxProvider) Configure(
	ctx context.Context,
	req provider.ConfigureRequest,
	resp *provider.ConfigureResponse,
) {
	tflog.Info(ctx, "Configuring the Framework Proxmox provider...")

	// Retrieve provider data from configuration
	var cfg proxmoxProviderModel
	diags := req.Config.Get(ctx, &cfg)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If practitioner provided a configuration value for any of the
	// attributes, it must be a known value.

	if cfg.Endpoint.IsUnknown() {
		resp.Diagnostics.AddAttributeError(
			path.Root("endpoint"),
			"Unknown Proxmox VE API Endpoint",
			"The provider cannot create the Proxmox VE API client as there is an unknown configuration value "+
				"for the API endpoint. Either target apply the source of the value first, set the value statically in "+
				"the configuration, or use the PROXMOX_VE_ENDPOINT environment variable.",
		)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// Default values to environment variables, but override
	// with Terraform configuration value if set.

	// Check environment variables
	endpoint := utils.GetAnyStringEnv("PROXMOX_VE_ENDPOINT")
	insecure := utils.GetAnyBoolEnv("PROXMOX_VE_INSECURE")
	minTLS := utils.GetAnyStringEnv("PROXMOX_VE_MIN_TLS")
	authTicket := utils.GetAnyStringEnv("PROXMOX_VE_AUTH_TICKET")
	csrfPreventionToken := utils.GetAnyStringEnv("PROXMOX_VE_CSRF_PREVENTION_TOKEN")
	apiToken := utils.GetAnyStringEnv("PROXMOX_VE_API_TOKEN")
	username := utils.GetAnyStringEnv("PROXMOX_VE_USERNAME")
	password := utils.GetAnyStringEnv("PROXMOX_VE_PASSWORD")

	if !cfg.APIToken.IsNull() {
		apiToken = cfg.APIToken.ValueString()
	}

	if !cfg.Endpoint.IsNull() {
		endpoint = cfg.Endpoint.ValueString()
	}

	if !cfg.Insecure.IsNull() {
		insecure = cfg.Insecure.ValueBool()
	}

	if !cfg.MinTLS.IsNull() {
		minTLS = cfg.MinTLS.ValueString()
	}

	if !cfg.AuthTicket.IsNull() {
		authTicket = cfg.AuthTicket.ValueString()
	}

	if !cfg.CSRFPreventionToken.IsNull() {
		csrfPreventionToken = cfg.CSRFPreventionToken.ValueString()
	}

	if !cfg.APIToken.IsNull() {
		apiToken = cfg.APIToken.ValueString()
	}

	if !cfg.Username.IsNull() {
		username = cfg.Username.ValueString()
	}

	if !cfg.Password.IsNull() {
		password = cfg.Password.ValueString()
	}

	if endpoint == "" {
		resp.Diagnostics.AddAttributeError(
			path.Root("endpoint"),
			"Missing Proxmox VE API Endpoint",
			"The provider cannot create the Proxmox VE API client as there is a missing or empty value for the API endpoint. "+
				"Set the host value in the configuration or use the PROXMOX_VE_ENDPOINT environment variable. "+
				"If either is already set, ensure the value is not empty.",
		)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// Create the Proxmox VE API client

	creds, err := api.NewCredentials(username, password, "", apiToken, authTicket, csrfPreventionToken)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to create Proxmox VE API credentials",
			err.Error(),
		)
	}

	conn, err := api.NewConnection(
		endpoint,
		insecure,
		minTLS,
	)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to create Proxmox VE API connection",
			err.Error(),
		)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	apiClient, err := api.NewClient(creds, conn)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to create Proxmox VE API client",
			err.Error(),
		)
	}

	sshUsername := utils.GetAnyStringEnv("PROXMOX_VE_SSH_USERNAME")
	sshPassword := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PASSWORD")
	sshAgent := utils.GetAnyBoolEnv("PROXMOX_VE_SSH_AGENT")
	sshPrivateKey := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PRIVATE_KEY")
	sshAgentSocket := utils.GetAnyStringEnv("SSH_AUTH_SOCK", "PROXMOX_VE_SSH_AUTH_SOCK")
	sshSocks5Server := utils.GetAnyStringEnv("PROXMOX_VE_SSH_SOCKS5_SERVER")
	sshSocks5Username := utils.GetAnyStringEnv("PROXMOX_VE_SSH_SOCKS5_USERNAME")
	sshSocks5Password := utils.GetAnyStringEnv("PROXMOX_VE_SSH_SOCKS5_PASSWORD")
	nodeOverrides := map[string]ssh.ProxmoxNode{}

	//nolint: nestif
	if len(cfg.SSH) > 0 {
		if !cfg.SSH[0].Username.IsNull() {
			sshUsername = cfg.SSH[0].Username.ValueString()
		}

		if !cfg.SSH[0].Password.IsNull() {
			sshPassword = cfg.SSH[0].Password.ValueString()
		}

		if !cfg.SSH[0].Agent.IsNull() {
			sshAgent = cfg.SSH[0].Agent.ValueBool()
		}

		if !cfg.SSH[0].AgentSocket.IsNull() {
			sshAgentSocket = cfg.SSH[0].AgentSocket.ValueString()
		}

		if !cfg.SSH[0].PrivateKey.IsNull() {
			sshPrivateKey = cfg.SSH[0].PrivateKey.ValueString()
		}

		if !cfg.SSH[0].Socks5Server.IsNull() {
			sshSocks5Server = cfg.SSH[0].Socks5Server.ValueString()
		}

		if !cfg.SSH[0].Socks5Username.IsNull() {
			sshSocks5Username = cfg.SSH[0].Socks5Username.ValueString()
		}

		if !cfg.SSH[0].Socks5Password.IsNull() {
			sshSocks5Password = cfg.SSH[0].Socks5Password.ValueString()
		}

		for _, n := range cfg.SSH[0].Nodes {
			nodePort := int32(n.Port.ValueInt64())
			if nodePort == 0 {
				nodePort = 22
			}

			nodeOverrides[n.Name.ValueString()] = ssh.ProxmoxNode{
				Address: n.Address.ValueString(),
				Port:    nodePort,
			}
		}
	}

	if sshUsername == "" && creds.UserCredentials != nil {
		sshUsername = strings.Split(creds.UserCredentials.Username, "@")[0]
	}

	if sshPassword == "" && creds.UserCredentials != nil {
		sshPassword = creds.UserCredentials.Password
	}

	sshClient, err := ssh.NewClient(
		sshUsername, sshPassword, sshAgent, sshAgentSocket, sshPrivateKey,
		sshSocks5Server, sshSocks5Username, sshSocks5Password,
		&apiResolverWithOverrides{
			ar:        apiResolver{c: apiClient},
			overrides: nodeOverrides,
		},
	)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to create Proxmox VE SSH client",
			err.Error(),
		)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// Intentionally use 'PROXMOX_VE_TMPDIR' with 'TMP' instead of 'TEMP', to match os.TempDir's use of $TMPDIR
	tmpDirOverride := utils.GetAnyStringEnv("PROXMOX_VE_TMPDIR", "PM_VE_TMPDIR")

	if !cfg.TmpDir.IsNull() {
		tmpDirOverride = cfg.TmpDir.ValueString()
	}

	client := proxmox.NewClient(apiClient, sshClient, tmpDirOverride)

	resp.ResourceData = config.Resource{
		Client: client,
		IDGenerator: cluster.NewIDGenerator(
			client.Cluster(),
			cluster.IDGeneratorConfig{
				RandomIDs:    cfg.RandomVMIDs.ValueBool(),
				RandomIDStat: int(cfg.RandomVMIDStat.ValueInt64()),
				RandomIDEnd:  int(cfg.RandomVMIDEnd.ValueInt64()),
			},
		),
	}

	resp.DataSourceData = config.DataSource{
		Client: client,
	}
}

func (p *proxmoxProvider) Resources(_ context.Context) []func() resource.Resource {
	return []func() resource.Resource{
		access.NewACLResource,
		access.NewUserTokenResource,
		acme.NewACMEAccountResource,
		acme.NewACMEPluginResource,
		apt.NewRepositoryResource,
		apt.NewStandardRepositoryResource,
		ha.NewHAGroupResource,
		ha.NewHAResourceResource,
		hardwaremapping.NewDirResource,
		hardwaremapping.NewPCIResource,
		hardwaremapping.NewUSBResource,
		metrics.NewMetricsServerResource,
		network.NewLinuxBridgeResource,
		network.NewLinuxVLANResource,
		nodes.NewDownloadFileResource,
		options.NewClusterOptionsResource,
		vm.NewResource,
	}
}

func (p *proxmoxProvider) DataSources(_ context.Context) []func() datasource.DataSource {
	return []func() datasource.DataSource{
		NewVersionDataSource,
		acme.NewACMEAccountDataSource,
		acme.NewACMEAccountsDataSource,
		acme.NewACMEPluginDataSource,
		acme.NewACMEPluginsDataSource,
		apt.NewRepositoryDataSource,
		apt.NewStandardRepositoryDataSource,
		datastores.NewDataSource,
		ha.NewHAGroupDataSource,
		ha.NewHAGroupsDataSource,
		ha.NewHAResourceDataSource,
		ha.NewHAResourcesDataSource,
		hardwaremapping.NewDataSource,
		hardwaremapping.NewDirDataSource,
		hardwaremapping.NewPCIDataSource,
		hardwaremapping.NewUSBDataSource,
		metrics.NewMetricsServerDatasource,
		vm.NewDataSource,
	}
}

type apiResolver struct {
	c api.Client
}

func (r *apiResolver) Resolve(ctx context.Context, nodeName string) (ssh.ProxmoxNode, error) {
	nc := &proxmoxnodes.Client{Client: r.c, NodeName: nodeName}

	networkDevices, err := nc.ListNetworkInterfaces(ctx)
	if err != nil {
		return ssh.ProxmoxNode{}, fmt.Errorf("failed to list network devices of node %q: %w", nc.NodeName, err)
	}

	nodeAddress := ""

	// try IPv4 address on the interface with IPv4 gateway
	tflog.Debug(ctx, "Attempting to find interfaces with both a static IPV4 address and gateway.")

	for _, d := range networkDevices {
		if d.Gateway != nil && d.Address != nil {
			nodeAddress = *d.Address
			break
		}
	}

	if nodeAddress == "" {
		// fallback 1: try IPv6 address on the interface with IPv6 gateway
		tflog.Debug(ctx, "Attempting to find interfaces with both a static IPV6 address and gateway.")

		for _, d := range networkDevices {
			if d.Gateway6 != nil && d.Address6 != nil {
				nodeAddress = *d.Address6
				break
			}
		}
	}

	if nodeAddress == "" {
		// fallback 2: use first interface with any IPv4 address
		tflog.Debug(ctx, "Attempting to find interfaces with at least a static IPV4 address.")

		for _, d := range networkDevices {
			if d.Address != nil {
				nodeAddress = *d.Address
				break
			}
		}
	}

	if nodeAddress == "" {
		// fallback 3: do a good old DNS lookup
		tflog.Debug(ctx, fmt.Sprintf("Attempting a DNS lookup of node %q.", nc.NodeName))

		ips, err := net.LookupIP(nodeName)
		if err == nil {
			for _, ip := range ips {
				if ipv4 := ip.To4(); ipv4 != nil {
					nodeAddress = ipv4.String()
					break
				}
			}
		} else {
			tflog.Debug(ctx, fmt.Sprintf("Failed to do a DNS lookup of the node: %s", err.Error()))
		}
	}

	if nodeAddress == "" {
		return ssh.ProxmoxNode{}, fmt.Errorf("failed to determine the IP address of node \"%s\"", nc.NodeName)
	}

	nodeAddressParts := strings.Split(nodeAddress, "/")
	node := ssh.ProxmoxNode{Address: nodeAddressParts[0], Port: 22}

	return node, nil
}

type apiResolverWithOverrides struct {
	ar        apiResolver
	overrides map[string]ssh.ProxmoxNode
}

func (r *apiResolverWithOverrides) Resolve(ctx context.Context, nodeName string) (ssh.ProxmoxNode, error) {
	if node, ok := r.overrides[nodeName]; ok {
		return node, nil
	}

	return r.ar.Resolve(ctx, nodeName)
}
`````

## File: proxmox/access/acl_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// ACLGetResponseBody contains the body from an access control list response.
type ACLGetResponseBody struct {
	Data []ACLGetResponseData `json:"data,omitempty"`
}

// ACLGetResponseData contains the data from an access control list response.
type ACLGetResponseData struct {
	Path          string            `json:"path"`
	Propagate     *types.CustomBool `json:"propagate,omitempty"`
	RoleID        string            `json:"roleid"`
	Type          string            `json:"type"`
	UserOrGroupID string            `json:"ugid"`
}

// ACLUpdateRequestBody contains the data for an access control list update request.
type ACLUpdateRequestBody struct {
	Delete    *types.CustomBool `json:"delete,omitempty"    url:"delete,omitempty,int"`
	Groups    []string          `json:"groups,omitempty"    url:"groups,omitempty,comma"`
	Path      string            `json:"path"                url:"path"`
	Propagate *types.CustomBool `json:"propagate,omitempty" url:"propagate,omitempty,int"`
	Roles     []string          `json:"roles"               url:"roles,comma"`
	Tokens    []string          `json:"tokens,omitempty"    url:"tokens,omitempty,comma"`
	Users     []string          `json:"users,omitempty"     url:"users,omitempty,comma"`
}
`````

## File: proxmox/access/acl.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"
	"net/http"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

func (c *Client) aclPath() string {
	return c.ExpandPath("acl")
}

// GetACL retrieves the access control list.
func (c *Client) GetACL(ctx context.Context) ([]ACLGetResponseData, error) {
	resBody := &ACLGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.aclPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get access control list: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Path < resBody.Data[j].Path
	})

	return resBody.Data, nil
}

// UpdateACL updates the access control list.
func (c *Client) UpdateACL(ctx context.Context, d *ACLUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.aclPath(), d, nil)
	if err != nil {
		return fmt.Errorf("failed to update access control list: %w", err)
	}

	return nil
}
`````

## File: proxmox/access/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for performing requests against the Proxmox 'access' API.
type Client struct {
	api.Client
}

// ExpandPath expands a path relative to the client's base path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("access/%s", path)
}
`````

## File: proxmox/access/groups_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

// GroupCreateRequestBody contains the data for an access group create request.
type GroupCreateRequestBody struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	ID      string  `json:"groupid"           url:"groupid"`
}

// GroupGetResponseBody contains the body from an access group get response.
type GroupGetResponseBody struct {
	Data *GroupGetResponseData `json:"data,omitempty"`
}

// GroupGetResponseData contains the data from an access group get response.
type GroupGetResponseData struct {
	Comment *string  `json:"comment,omitempty"`
	Members []string `json:"members"`
}

// GroupListResponseBody contains the body from an access group list response.
type GroupListResponseBody struct {
	Data []*GroupListResponseData `json:"data,omitempty"`
}

// GroupListResponseData contains the data from an access group list response.
type GroupListResponseData struct {
	Comment *string `json:"comment,omitempty"`
	ID      string  `json:"groupid"`
}

// GroupUpdateRequestBody contains the data for an access group update request.
type GroupUpdateRequestBody struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
}
`````

## File: proxmox/access/groups.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

func (c *Client) groupsPath() string {
	return c.ExpandPath("groups")
}

func (c *Client) groupPath(id string) string {
	return fmt.Sprintf("%s/%s", c.groupsPath(), url.PathEscape(id))
}

// CreateGroup creates an access group.
func (c *Client) CreateGroup(ctx context.Context, d *GroupCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.groupsPath(), d, nil)
	if err != nil {
		return fmt.Errorf("failed to create access group: %w", err)
	}

	return nil
}

// DeleteGroup deletes an access group.
func (c *Client) DeleteGroup(ctx context.Context, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.groupPath(id), nil, nil)
	if err != nil {
		return fmt.Errorf("failed to delete access group: %w", err)
	}

	return nil
}

// GetGroup retrieves an access group.
func (c *Client) GetGroup(ctx context.Context, id string) (*GroupGetResponseData, error) {
	resBody := &GroupGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.groupPath(id), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get access group: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Strings(resBody.Data.Members)

	return resBody.Data, nil
}

// ListGroups retrieves a list of access groups.
func (c *Client) ListGroups(ctx context.Context) ([]*GroupListResponseData, error) {
	resBody := &GroupListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.groupsPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to list access groups: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID < resBody.Data[j].ID
	})

	return resBody.Data, nil
}

// UpdateGroup updates an access group.
func (c *Client) UpdateGroup(ctx context.Context, id string, d *GroupUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.groupPath(id), d, nil)
	if err != nil {
		return fmt.Errorf("failed to update access group: %w", err)
	}

	return nil
}
`````

## File: proxmox/access/roles_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// RoleCreateRequestBody contains the data for an access group create request.
type RoleCreateRequestBody struct {
	ID         string                 `json:"roleid" url:"roleid"`
	Privileges types.CustomPrivileges `json:"privs"  url:"privs,comma"`
}

// RoleGetResponseBody contains the body from an access group get response.
type RoleGetResponseBody struct {
	Data *types.CustomPrivileges `json:"data,omitempty"`
}

// RoleListResponseBody contains the body from an access group list response.
type RoleListResponseBody struct {
	Data []*RoleListResponseData `json:"data,omitempty"`
}

// RoleListResponseData contains the data from an access group list response.
type RoleListResponseData struct {
	ID         string                  `json:"roleid"`
	Privileges *types.CustomPrivileges `json:"privs,omitempty"`
	Special    *types.CustomBool       `json:"special,omitempty"`
}

// RoleUpdateRequestBody contains the data for an access group update request.
type RoleUpdateRequestBody struct {
	Privileges types.CustomPrivileges `json:"privs" url:"privs,comma"`
}
`````

## File: proxmox/access/roles.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

func (c *Client) rolesPath() string {
	return c.ExpandPath("roles")
}

func (c *Client) rolePath(id string) string {
	return fmt.Sprintf("%s/%s", c.rolesPath(), url.PathEscape(id))
}

// CreateRole creates an access role.
func (c *Client) CreateRole(ctx context.Context, d *RoleCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.rolesPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error creating role: %w", err)
	}

	return nil
}

// DeleteRole deletes an access role.
func (c *Client) DeleteRole(ctx context.Context, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.rolePath(id), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting role: %w", err)
	}

	return nil
}

// GetRole retrieves an access role.
func (c *Client) GetRole(ctx context.Context, id string) (*types.CustomPrivileges, error) {
	resBody := &RoleGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.rolePath(id), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error getting role: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Strings(*resBody.Data)

	return resBody.Data, nil
}

// ListRoles retrieves a list of access roles.
func (c *Client) ListRoles(ctx context.Context) ([]*RoleListResponseData, error) {
	resBody := &RoleListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.rolesPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing roles: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID < resBody.Data[j].ID
	})

	for i := range resBody.Data {
		if resBody.Data[i].Privileges != nil {
			sort.Strings(*resBody.Data[i].Privileges)
		}
	}

	return resBody.Data, nil
}

// UpdateRole updates an access role.
func (c *Client) UpdateRole(ctx context.Context, id string, d *RoleUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.rolePath(id), d, nil)
	if err != nil {
		return fmt.Errorf("error updating role: %w", err)
	}

	return nil
}
`````

## File: proxmox/access/user_token_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// UserTokenCreateRequestBody contains the data for a user token create request.
type UserTokenCreateRequestBody struct {
	Comment        *string           `json:"comment,omitempty" url:"comment,omitempty"`
	ExpirationDate *int64            `json:"expire,omitempty"  url:"expire,omitempty"`
	PrivSeparate   *types.CustomBool `json:"privsep,omitempty" url:"privsep,omitempty,int"`
}

// UserTokenUpdateRequestBody contains the data for a user token update request.
type UserTokenUpdateRequestBody UserTokenCreateRequestBody

// UserTokenCreateResponseBody contains the body from a user token create response.
type UserTokenCreateResponseBody struct {
	Data *UserTokenCreateResponseData `json:"data,omitempty"`
}

// UserTokenCreateResponseData contains the data from a user token create response.
type UserTokenCreateResponseData struct {
	// The full token id, format "<userid>!<tokenid>"
	FullTokenID string                   `json:"full-tokenid"`
	Info        UserTokenGetResponseData `json:"info"`
	Value       string                   `json:"value"`
}

// UserTokenGetResponseBody contains the body from a user token get response.
type UserTokenGetResponseBody struct {
	Data *UserTokenGetResponseData `json:"data,omitempty"`
}

// UserTokenGetResponseData contains the data from a user token get response.
type UserTokenGetResponseData struct {
	Comment        *string            `json:"comment,omitempty" url:"comment,omitempty"`
	PrivSeparate   *types.CustomBool  `json:"privsep,omitempty" url:"privsep,omitempty,int"`
	ExpirationDate *types.CustomInt64 `json:"expire,omitempty"  url:"expire,omitempty"`
}

// UserTokenListResponseBody contains the body from a user token list response.
type UserTokenListResponseBody struct {
	Data []*UserTokenListResponseData `json:"data,omitempty"`
}

// UserTokenListResponseData contains the data from a user token list response.
type UserTokenListResponseData struct {
	UserTokenGetResponseData

	TokenID string `json:"tokenid"`
}
`````

## File: proxmox/access/user_token.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"
	"net/http"
	"net/url"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

func (c *Client) userTokensPath(id string) string {
	return fmt.Sprintf("%s/%s/token", c.usersPath(), url.PathEscape(id))
}

func (c *Client) userTokenPath(userid, id string) string {
	return fmt.Sprintf("%s/%s", c.userTokensPath(userid), url.PathEscape(id))
}

// CreateUserToken creates a user token.
func (c *Client) CreateUserToken(
	ctx context.Context,
	userid string,
	id string,
	d *UserTokenCreateRequestBody,
) (string, error) {
	resBody := &UserTokenCreateResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.userTokenPath(userid, id), d, resBody)
	if err != nil {
		return "", fmt.Errorf("error creating user token: %w", err)
	}

	return resBody.Data.FullTokenID + "=" + resBody.Data.Value, nil
}

// DeleteUserToken deletes an user token.
func (c *Client) DeleteUserToken(ctx context.Context, userid string, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.userTokenPath(userid, id), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting user token: %w", err)
	}

	return nil
}

// GetUserToken retrieves a user token.
func (c *Client) GetUserToken(ctx context.Context, userid string, id string) (*UserTokenGetResponseData, error) {
	resBody := &UserTokenGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.userTokenPath(userid, id), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving user token: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ListUserTokens retrieves a list of user tokens.
func (c *Client) ListUserTokens(ctx context.Context, userid string) ([]*UserTokenListResponseData, error) {
	resBody := &UserTokenListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.userTokensPath(userid), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing user tokens: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateUserToken updates the user token.
func (c *Client) UpdateUserToken(ctx context.Context, userid string, id string, d *UserTokenUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.userTokenPath(userid, id), d, nil)
	if err != nil {
		return fmt.Errorf("error updating user token: %w", err)
	}

	return nil
}
`````

## File: proxmox/access/users_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// UserChangePasswordRequestBody contains the data for a user password change request.
type UserChangePasswordRequestBody struct {
	ID       string `json:"userid"   url:"userid"`
	Password string `json:"password" url:"password"`
}

// UserCreateRequestBody contains the data for a user create request.
type UserCreateRequestBody struct {
	Comment        *string           `json:"comment,omitempty"   url:"comment,omitempty"`
	Email          *string           `json:"email,omitempty"     url:"email,omitempty"`
	Enabled        *types.CustomBool `json:"enable,omitempty"    url:"enable,omitempty,int"`
	ExpirationDate *int64            `json:"expire,omitempty"    url:"expire,omitempty"`
	FirstName      *string           `json:"firstname,omitempty" url:"firstname,omitempty"`
	Groups         []string          `json:"groups,omitempty"    url:"groups,omitempty,comma"`
	ID             string            `json:"userid"              url:"userid"`
	Keys           *string           `json:"keys,omitempty"      url:"keys,omitempty"`
	LastName       *string           `json:"lastname,omitempty"  url:"lastname,omitempty"`
	Password       string            `json:"password"            url:"password,omitempty"`
}

// UserGetResponseBody contains the body from a user get response.
type UserGetResponseBody struct {
	Data *UserGetResponseData `json:"data,omitempty"`
}

// UserGetResponseData contains the data from an user get response.
type UserGetResponseData struct {
	Comment        *string           `json:"comment,omitempty"`
	Email          *string           `json:"email,omitempty"`
	Enabled        *types.CustomBool `json:"enable,omitempty"`
	ExpirationDate *int64            `json:"expire,omitempty"`
	FirstName      *string           `json:"firstname,omitempty"`
	Groups         *[]string         `json:"groups,omitempty"`
	Keys           *string           `json:"keys,omitempty"`
	LastName       *string           `json:"lastname,omitempty"`
}

// UserListResponseBody contains the body from a user list response.
type UserListResponseBody struct {
	Data []*UserListResponseData `json:"data,omitempty"`
}

// UserListResponseData contains the data from an user list response.
type UserListResponseData struct {
	Comment        *string           `json:"comment,omitempty"`
	Email          *string           `json:"email,omitempty"`
	Enabled        *types.CustomBool `json:"enable,omitempty"`
	ExpirationDate *int64            `json:"expire,omitempty"`
	FirstName      *string           `json:"firstname,omitempty"`
	Groups         *[]string         `json:"groups,omitempty"`
	ID             string            `json:"userid"`
	Keys           *string           `json:"keys,omitempty"`
	LastName       *string           `json:"lastname,omitempty"`
}

// UserUpdateRequestBody contains the data for an user update request.
type UserUpdateRequestBody struct {
	Append         *types.CustomBool `json:"append,omitempty"    url:"append,omitempty"`
	Comment        *string           `json:"comment,omitempty"   url:"comment,omitempty"`
	Email          *string           `json:"email,omitempty"     url:"email,omitempty"`
	Enabled        *types.CustomBool `json:"enable,omitempty"    url:"enable,omitempty,int"`
	ExpirationDate *int64            `json:"expire,omitempty"    url:"expire,omitempty,int"`
	FirstName      *string           `json:"firstname,omitempty" url:"firstname,omitempty"`
	Groups         []string          `json:"groups,omitempty"    url:"groups,omitempty,comma"`
	Keys           *string           `json:"keys,omitempty"      url:"keys,omitempty"`
	LastName       *string           `json:"lastname,omitempty"  url:"lastname,omitempty"`
}
`````

## File: proxmox/access/users.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package access

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

func (c *Client) usersPath() string {
	return c.ExpandPath("users")
}

func (c *Client) userPath(id string) string {
	return fmt.Sprintf("%s/%s", c.usersPath(), url.PathEscape(id))
}

// ChangeUserPassword changes a user's password.
func (c *Client) ChangeUserPassword(ctx context.Context, id, password string) error {
	d := UserChangePasswordRequestBody{
		ID:       id,
		Password: password,
	}

	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("password"), d, nil)
	if err != nil {
		return fmt.Errorf("error changing user password: %w", err)
	}

	return nil
}

// CreateUser creates a user.
func (c *Client) CreateUser(ctx context.Context, d *UserCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.usersPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error creating user: %w", err)
	}

	return nil
}

// DeleteUser deletes an  user.
func (c *Client) DeleteUser(ctx context.Context, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.userPath(id), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting user: %w", err)
	}

	return nil
}

// GetUser retrieves a user.
func (c *Client) GetUser(ctx context.Context, id string) (*UserGetResponseData, error) {
	resBody := &UserGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.userPath(id), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving user: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	if resBody.Data.Groups != nil {
		sort.Strings(*resBody.Data.Groups)
	}

	return resBody.Data, nil
}

// ListUsers retrieves a list of users.
func (c *Client) ListUsers(ctx context.Context) ([]*UserListResponseData, error) {
	resBody := &UserListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.usersPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing users: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID < resBody.Data[j].ID
	})

	for i := range resBody.Data {
		if resBody.Data[i].Groups != nil {
			sort.Strings(*resBody.Data[i].Groups)
		}
	}

	return resBody.Data, nil
}

// UpdateUser updates a user.
func (c *Client) UpdateUser(ctx context.Context, id string, d *UserUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.userPath(id), d, nil)
	if err != nil {
		return fmt.Errorf("error updating user: %w", err)
	}

	return nil
}
`````

## File: proxmox/api/authenticator.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"context"
	"net/http"
)

// Authenticator is an interface for adding authentication data to a request.
// The authenticator is also aware of the authentication context, e.g. if it
// is configured to use the root user.
type Authenticator interface {
	// IsRoot returns true if the authenticator is configured to use the root
	IsRoot(ctx context.Context) bool

	// IsRootTicket returns true if the authenticator is configured to use the root directly using a login ticket.
	// (root using token is weaker, cannot change VM arch)
	IsRootTicket(ctx context.Context) bool

	// AuthenticateRequest adds authentication data to a new request.
	AuthenticateRequest(ctx context.Context, req *http.Request) error
}
`````

## File: proxmox/api/client_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"context"
	"errors"
	"net/http"
	"reflect"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

// RoundTripFunc .
type RoundTripFunc func(req *http.Request) *http.Response

// RoundTrip .
func (f RoundTripFunc) RoundTrip(req *http.Request) (*http.Response, error) {
	return f(req), nil
}

// NewTestClient returns *http.Client with Transport replaced to avoid making real calls.
func newTestClient(fn RoundTripFunc) *http.Client {
	return &http.Client{
		Transport: fn,
	}
}

type dummyAuthenticator struct{}

func (dummyAuthenticator) IsRoot(_ context.Context) bool {
	return false
}

func (dummyAuthenticator) IsRootTicket(context.Context) bool {
	return false
}

func (dummyAuthenticator) AuthenticateRequest(_ context.Context, _ *http.Request) error {
	return nil
}

func TestClientDoRequest(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		status  string
		wantErr error
	}{
		{name: "no error", status: "200 OK", wantErr: nil},
		{name: "not exists - 404 status", status: "404 missing", wantErr: ErrResourceDoesNotExist},
		{name: "not exists - 500 status", status: "500 This thing does not exist", wantErr: ErrResourceDoesNotExist},
		{name: "500 status", status: "500 Internal Server Error", wantErr: &HTTPError{
			Code:    500,
			Message: "Internal Server Error",
		}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			c := client{
				conn: &Connection{
					endpoint: "http://localhost",
					httpClient: newTestClient(func(_ *http.Request) *http.Response {
						sc, err := strconv.Atoi(strings.Fields(tt.status)[0])
						require.NoError(t, err)
						return &http.Response{
							Status:     tt.status,
							StatusCode: sc,
							Body:       nil,
						}
					}),
				},
				auth: dummyAuthenticator{},
			}

			err := c.DoRequest(t.Context(), "POST", "any", nil, nil)
			fail := false

			switch {
			case err == nil && tt.wantErr == nil:
				return
			case err != nil && tt.wantErr == nil:
				fallthrough
			case err == nil && tt.wantErr != nil:
				fail = true
			default:
				var he, we *HTTPError
				if errors.As(err, &he) && errors.As(tt.wantErr, &we) {
					fail = !reflect.DeepEqual(he, we)
				} else {
					fail = !errors.Is(err, tt.wantErr)
				}
			}

			if fail {
				t.Errorf("DoRequest() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
`````

## File: proxmox/api/client_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"io"
	"os"
)

// MultiPartData enables multipart uploads in DoRequest.
type MultiPartData struct {
	Boundary string
	Reader   io.Reader
	Size     *int64
}

// ErrorResponseBody contains the body of an error response.
type ErrorResponseBody struct {
	Data   *string            `json:"data"`
	Errors *map[string]string `json:"errors"`
}

// FileUploadRequest is a request for uploading a file.
type FileUploadRequest struct {
	ContentType string
	FileName    string
	File        *os.File
	// Will be handled as unsigned 32-bit integer since the underlying type of os.FileMode is the same, but must be parsed
	// as string due to the conversion of the octal format.
	// References:
	//   1. https://en.wikipedia.org/wiki/Chmod#Special_modes
	Mode string
}
`````

## File: proxmox/api/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"maps"
	"net/http"
	"net/url"
	"slices"
	"sort"
	"strings"

	"github.com/avast/retry-go/v4"
	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"

	"github.com/bpg/terraform-provider-proxmox/utils"
)

const (
	basePathJSONAPI = "api2/json"
)

// Client is an interface for performing requests against the Proxmox API.
type Client interface {
	// DoRequest performs a request against the Proxmox API.
	DoRequest(
		ctx context.Context,
		method, path string,
		requestBody, responseBody interface{},
	) error

	// ExpandPath expands a path relative to the client's base path.
	// For example, if the client is configured for a VM and the
	// path is "firewall/options", the returned path will be
	// "/nodes/<node>/qemu/<vmid>/firewall/options".
	ExpandPath(path string) string

	// IsRoot returns true if the client is configured with the root user.
	IsRoot(ctx context.Context) bool

	// IsRootTicket returns true if the authenticator is configured to use the root directly using a login ticket.
	// (root using token is weaker, cannot change VM arch)
	IsRootTicket(ctx context.Context) bool

	// HTTP returns a lower-level HTTP client.
	HTTP() *http.Client
}

// Connection represents a connection to the Proxmox Virtual Environment API.
type Connection struct {
	endpoint   string
	httpClient *http.Client
}

// NewConnection creates and initializes a Connection instance.
func NewConnection(endpoint string, insecure bool, minTLS string) (*Connection, error) {
	u, err := url.ParseRequestURI(endpoint)
	if err != nil {
		return nil, errors.New(
			"you must specify a valid endpoint for the Proxmox Virtual Environment API (valid: https://host:port/)",
		)
	}

	if u.Scheme != "https" {
		return nil, errors.New(
			"you must specify a secure endpoint for the Proxmox Virtual Environment API (valid: https://host:port/)",
		)
	}

	version, err := GetMinTLSVersion(minTLS)
	if err != nil {
		return nil, err
	}

	var transport http.RoundTripper = &http.Transport{
		Proxy: http.ProxyFromEnvironment,
		TLSClientConfig: &tls.Config{
			// deepcode ignore InsecureTLSConfig: the min TLS version is configurable
			MinVersion:         version,
			InsecureSkipVerify: insecure, //nolint:gosec
		},
	}

	if logging.IsDebugOrHigher() {
		transport = logging.NewLoggingHTTPTransport(transport)
	}

	// make sure the path does not contain "/api2/json"
	u.Path = ""

	return &Connection{
		endpoint: strings.TrimRight(u.String(), "/"),
		httpClient: &http.Client{
			Transport: transport,
		},
	}, nil
}

// VirtualEnvironmentClient implements an API client for the Proxmox Virtual Environment API.
type client struct {
	conn *Connection
	auth Authenticator
}

// NewClient creates and initializes a VirtualEnvironmentClient instance.
func NewClient(creds Credentials, conn *Connection) (Client, error) {
	if conn == nil {
		return nil, errors.New("connection must not be nil")
	}

	var auth Authenticator

	var err error

	switch {
	case creds.TokenCredentials != nil:
		auth, err = NewTokenAuthenticator(*creds.TokenCredentials)
	case creds.TicketCredentials != nil:
		auth, err = NewTicketAuthenticator(*creds.TicketCredentials)
	case creds.UserCredentials != nil:
		auth = NewUserAuthenticator(*creds.UserCredentials, conn)
	default:
		return nil, errors.New("must provide either user credentials, an API token, or a ticket")
	}

	if err != nil {
		return nil, fmt.Errorf("failed to create API client: %w", err)
	}

	return &client{
		conn: conn,
		auth: auth,
	}, nil
}

// DoRequest performs a HTTP request against a JSON API endpoint.
func (c *client) DoRequest(
	ctx context.Context,
	method, path string,
	requestBody, responseBody interface{},
) error {
	var reqBodyReader io.Reader

	var reqContentLength *int64

	modifiedPath := path
	reqBodyType := ""

	//nolint:nestif
	if requestBody != nil {
		multipartData, multipart := requestBody.(*MultiPartData)
		pipedBodyReader, pipedBody := requestBody.(*io.PipeReader)

		switch {
		case multipart:
			reqBodyReader = multipartData.Reader
			reqBodyType = fmt.Sprintf("multipart/form-data; boundary=%s", multipartData.Boundary)
			reqContentLength = multipartData.Size
		case pipedBody:
			reqBodyReader = pipedBodyReader
		default:
			v, err := query.Values(requestBody)
			if err != nil {
				return fmt.Errorf("failed to encode HTTP %s request (path: %s) - Reason: %w",
					method,
					modifiedPath,
					err,
				)
			}

			encodedValues := v.Encode()
			if encodedValues != "" {
				if method == http.MethodDelete || method == http.MethodGet || method == http.MethodHead {
					if !strings.Contains(modifiedPath, "?") {
						modifiedPath = fmt.Sprintf("%s?%s", modifiedPath, encodedValues)
					} else {
						modifiedPath = fmt.Sprintf("%s&%s", modifiedPath, encodedValues)
					}
				} else {
					reqBodyReader = bytes.NewBufferString(encodedValues)
					reqBodyType = "application/x-www-form-urlencoded"
				}
			}
		}
	} else {
		reqBodyReader = new(bytes.Buffer)
	}

	req, err := http.NewRequestWithContext(
		ctx,
		method,
		fmt.Sprintf("%s/%s/%s", c.conn.endpoint, basePathJSONAPI, modifiedPath),
		reqBodyReader,
	)
	if err != nil {
		return fmt.Errorf(
			"failed to create HTTP %s request (path: %s) - Reason: %w",
			method,
			modifiedPath,
			err,
		)
	}

	req.Header.Add("Accept", "application/json")

	if reqContentLength != nil {
		req.ContentLength = *reqContentLength
	}

	if reqBodyType != "" {
		req.Header.Add("Content-Type", reqBodyType)
	}

	err = c.auth.AuthenticateRequest(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to authenticate HTTP %s request (path: %s) - Reason: %w",
			method,
			modifiedPath,
			err,
		)
	}

	//nolint:bodyclose
	res, err := retry.DoWithData(
		func() (*http.Response, error) {
			return c.conn.httpClient.Do(req)
		},
		retry.Context(ctx),
		retry.RetryIf(func(err error) bool {
			var urlErr *url.Error
			if errors.As(err, &urlErr) {
				return strings.ToUpper(urlErr.Op) == http.MethodGet
			}

			return false
		}),
		retry.LastErrorOnly(true),
		retry.Attempts(3),
	)
	if err != nil {
		return fmt.Errorf("failed to perform HTTP %s request (path: %s) - Reason: %w",
			method,
			modifiedPath,
			err,
		)
	}

	defer utils.CloseOrLogError(ctx)(res.Body)

	err = validateResponseCode(res)
	if err != nil {
		return err
	}

	//nolint:nestif
	if responseBody != nil {
		err = json.NewDecoder(res.Body).Decode(responseBody)
		if err != nil {
			return fmt.Errorf(
				"failed to decode HTTP %s response (path: %s) - Reason: %w",
				method,
				modifiedPath,
				err,
			)
		}
	} else {
		data, err := io.ReadAll(res.Body)
		if err != nil {
			return fmt.Errorf(
				"failed to read HTTP %s response body (path: %s) - Reason: %w",
				method,
				modifiedPath,
				err,
			)
		}

		if len(data) > 0 {
			dr := dataResponse{}

			if err2 := json.NewDecoder(bytes.NewReader(data)).Decode(&dr); err2 == nil {
				if dr.Data == nil {
					return nil
				}
			}

			tflog.Warn(ctx, "unhandled HTTP response body", map[string]interface{}{
				"data": dr.Data,
			})
		}
	}

	return nil
}

type dataResponse struct {
	Data interface{} `json:"data"`
}

// ExpandPath expands the given path to an absolute path.
func (c *client) ExpandPath(path string) string {
	return path
}

func (c *client) IsRoot(ctx context.Context) bool {
	return c.auth.IsRoot(ctx)
}

func (c *client) IsRootTicket(ctx context.Context) bool {
	return c.auth.IsRootTicket(ctx)
}

func (c *client) HTTP() *http.Client {
	return c.conn.httpClient
}

// validateResponseCode ensures that a response is valid.
func validateResponseCode(res *http.Response) error {
	if res.StatusCode < 200 || res.StatusCode >= 300 {
		msg := strings.TrimPrefix(res.Status, fmt.Sprintf("%d ", res.StatusCode))

		errRes := &ErrorResponseBody{}
		err := json.NewDecoder(res.Body).Decode(errRes)

		if err == nil && errRes.Errors != nil {
			var errList []string

			for k, v := range *errRes.Errors {
				errList = append(errList, fmt.Sprintf("%s: %s", k, strings.TrimRight(v, "\n\r")))
			}

			msg = fmt.Sprintf("%s (%s)", msg, strings.Join(errList, " - "))
		}

		httpError := &HTTPError{
			Code:    res.StatusCode,
			Message: msg,
		}

		if res.StatusCode == http.StatusNotFound ||
			(res.StatusCode == http.StatusInternalServerError && strings.Contains(res.Status, "does not exist")) {
			return errors.Join(ErrResourceDoesNotExist, httpError)
		}

		return httpError
	}

	return nil
}

// GetMinTLSVersion returns the minimum TLS version constant for the given string. If the string is empty,
// the default TLS version is returned. For unsupported TLS versions, an error is returned.
func GetMinTLSVersion(version string) (uint16, error) {
	validVersions := map[string]uint16{
		"":    tls.VersionTLS13,
		"1.3": tls.VersionTLS13,
		"1.2": tls.VersionTLS12,
		"1.1": tls.VersionTLS11,
		"1.0": tls.VersionTLS10,
	}

	if val, ok := validVersions[strings.TrimSpace(version)]; ok {
		return val, nil
	}

	valid := slices.Collect(maps.Keys(validVersions))
	sort.Strings(valid)

	return 0, fmt.Errorf("unsupported minimal TLS version %s, must be one of: %s", version, strings.Join(valid, ", "))
}
`````

## File: proxmox/api/credentials.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"errors"
	"regexp"
	"strings"
)

const rootUsername = "root@pam"

// Package level error declarations.
var (
	ErrMissingAPIToken          = errors.New("no API token provided")
	ErrMissingTicketCredentials = errors.New("no authTicket and csrfPreventionToken pair provided")
	ErrMissingUserCredentials   = errors.New("no username and password provided")
	ErrInvalidAPIToken          = errors.New("the API token must be in the format 'USER@REALM!TOKENID=UUID'")
	ErrInvalidUsernameFormat    = errors.New("the username must end with '@pve' or '@pam'")
)

// Credentials contains the credentials for authenticating with the Proxmox VE API.
type Credentials struct {
	UserCredentials   *UserCredentials
	TokenCredentials  *TokenCredentials
	TicketCredentials *TicketCredentials
}

// UserCredentials contains the username, password, and OTP for authenticating with the Proxmox VE API.
type UserCredentials struct {
	Username string
	Password string
	OTP      string
}

// TokenCredentials contains the API token for authenticating with the Proxmox VE API.
type TokenCredentials struct {
	APIToken string
}

// TicketCredentials contains the auth ticket and CSRF prevention token for authenticating with the Proxmox VE API.
type TicketCredentials struct {
	AuthTicket          string
	CSRFPreventionToken string
}

// NewCredentials creates a new set of credentials for authenticating with the Proxmox VE API.
// The order of precedence is:
// 1. API token
// 2. Ticket
// 3. User credentials.
func NewCredentials(username, password, otp, apiToken, authTicket, csrfPreventionToken string) (Credentials, error) {
	if tok, err := newTokenCredentials(apiToken); err == nil {
		return Credentials{TokenCredentials: &tok}, nil
	} else if errors.Is(err, ErrInvalidAPIToken) {
		return Credentials{}, err
	}

	if tic, err := newTicketCredentials(authTicket, csrfPreventionToken); err == nil {
		return Credentials{TicketCredentials: &tic}, nil
	}

	if usr, err := newUserCredentials(username, password, otp); err == nil {
		return Credentials{UserCredentials: &usr}, nil
	} else if errors.Is(err, ErrInvalidUsernameFormat) {
		return Credentials{}, err
	}

	return Credentials{}, errors.New("must provide either username and password, an API token, or a ticket")
}

func newUserCredentials(username, password, otp string) (UserCredentials, error) {
	if username == "" || password == "" {
		return UserCredentials{}, ErrMissingUserCredentials
	}

	if !strings.Contains(username, "@") {
		return UserCredentials{}, ErrInvalidUsernameFormat
	}

	return UserCredentials{
		Username: username,
		Password: password,
		OTP:      otp,
	}, nil
}

func newTokenCredentials(apiToken string) (TokenCredentials, error) {
	if apiToken == "" {
		return TokenCredentials{}, ErrMissingAPIToken
	}

	re := regexp.MustCompile(`^\S+@\S+!\S+=([a-zA-Z0-9-]+)$`)
	if !re.MatchString(apiToken) {
		return TokenCredentials{}, ErrInvalidAPIToken
	}

	return TokenCredentials{
		APIToken: apiToken,
	}, nil
}

func newTicketCredentials(authTicket, csrfPreventionToken string) (TicketCredentials, error) {
	if authTicket == "" || csrfPreventionToken == "" {
		return TicketCredentials{}, ErrMissingTicketCredentials
	}

	return TicketCredentials{
		AuthTicket:          authTicket,
		CSRFPreventionToken: csrfPreventionToken,
	}, nil
}
`````

## File: proxmox/api/errors.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"fmt"
)

// Error is a sentinel error type for API errors.
type Error string

func (err Error) Error() string {
	return string(err)
}

// ErrNoDataObjectInResponse is returned when the server does not include a data object in the response.
const ErrNoDataObjectInResponse Error = "the server did not include a data object in the response"

// ErrResourceDoesNotExist is returned when the requested resource does not exist.
const ErrResourceDoesNotExist Error = "the requested resource does not exist"

// HTTPError is a generic error type for HTTP errors.
type HTTPError struct {
	Code    int
	Message string
}

func (err HTTPError) Error() string {
	return fmt.Sprintf("received an HTTP %d response - Reason: %s", err.Code, err.Message)
}
`````

## File: proxmox/api/ticket_auth_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// AuthenticationResponseBody contains the body from an authentication response.
type AuthenticationResponseBody struct {
	Data *AuthenticationResponseData `json:"data,omitempty"`
}

// AuthenticationResponseCapabilities contains the supported capabilities for a session.
type AuthenticationResponseCapabilities struct {
	Access     *types.CustomPrivileges `json:"access,omitempty"`
	Datacenter *types.CustomPrivileges `json:"dc,omitempty"`
	Mapping    *types.CustomPrivileges `json:"mapping,omitempty"`
	Nodes      *types.CustomPrivileges `json:"nodes,omitempty"`
	SDN        *types.CustomPrivileges `json:"sdn,omitempty"`
	Storage    *types.CustomPrivileges `json:"storage,omitempty"`
	VMs        *types.CustomPrivileges `json:"vms,omitempty"`
}

// AuthenticationResponseData contains the data from an authentication response.
type AuthenticationResponseData struct {
	ClusterName         *string                             `json:"clustername,omitempty"`
	CSRFPreventionToken *string                             `json:"CSRFPreventionToken,omitempty"`
	Capabilities        *AuthenticationResponseCapabilities `json:"cap,omitempty"`
	Ticket              *string                             `json:"ticket,omitempty"`
	Username            string                              `json:"username"`
}
`````

## File: proxmox/api/ticket_auth.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"context"
	"errors"
	"net/http"
	"strings"
)

type ticketAuthenticator struct {
	authData *AuthenticationResponseData
}

// NewTicketAuthenticator returns a new ticket authenticator.
func NewTicketAuthenticator(creds TicketCredentials) (Authenticator, error) {
	ard := &AuthenticationResponseData{}
	ard.Ticket = &(creds.AuthTicket)
	ard.CSRFPreventionToken = &(creds.CSRFPreventionToken)

	authTicketSplits := strings.Split(creds.AuthTicket, ":")

	if len(authTicketSplits) > 3 {
		ard.Username = strings.Split(creds.AuthTicket, ":")[1]
	} else {
		return nil, errors.New("AuthTicket must include a valid username")
	}

	if !strings.Contains(ard.Username, "@") {
		return nil, errors.New("username must end with '@pve' or '@pam'")
	}

	return &ticketAuthenticator{
		authData: ard,
	}, nil
}

func (t *ticketAuthenticator) IsRoot(_ context.Context) bool {
	return t.authData != nil && t.authData.Username == rootUsername
}

func (t *ticketAuthenticator) IsRootTicket(ctx context.Context) bool {
	return t.IsRoot(ctx)
}

// AuthenticateRequest adds authentication data to a new request.
func (t *ticketAuthenticator) AuthenticateRequest(_ context.Context, req *http.Request) error {
	req.AddCookie(&http.Cookie{
		HttpOnly: true,
		Name:     "PVEAuthCookie",
		Secure:   true,
		Value:    *t.authData.Ticket,
	})

	if req.Method != http.MethodGet {
		req.Header.Add("CSRFPreventionToken", *t.authData.CSRFPreventionToken)
	}

	return nil
}
`````

## File: proxmox/api/token_auth.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"context"
	"net/http"
	"strings"
)

type tokenAuthenticator struct {
	username string
	token    string
}

// NewTokenAuthenticator creates a new authenticator that uses a PVE API Token
// for authentication.
func NewTokenAuthenticator(toc TokenCredentials) (Authenticator, error) {
	return &tokenAuthenticator{
		username: strings.Split(toc.APIToken, "!")[0],
		token:    toc.APIToken,
	}, nil
}

func (t *tokenAuthenticator) IsRoot(_ context.Context) bool {
	return t.username == rootUsername
}

func (t *tokenAuthenticator) IsRootTicket(_ context.Context) bool {
	// Logged using a token, therefore not a ticket login
	return false
}

func (t *tokenAuthenticator) AuthenticateRequest(_ context.Context, req *http.Request) error {
	req.Header.Set("Authorization", "PVEAPIToken="+t.token)
	return nil
}
`````

## File: proxmox/api/user_auth.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"sync"

	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/utils"
)

type userAuthenticator struct {
	conn        *Connection
	authRequest string
	authData    *AuthenticationResponseData

	mu sync.Mutex
}

// NewUserAuthenticator creates a new authenticator that uses a username and password for authentication.
func NewUserAuthenticator(creds UserCredentials, conn *Connection) Authenticator {
	authRequest := fmt.Sprintf(
		"username=%s&password=%s",
		url.QueryEscape(creds.Username),
		url.QueryEscape(creds.Password),
	)

	// OTP is optional, and probably doesn't make much sense for most provider users.
	//   TOTP uses 2x requests; one with payloads `username=` and `password=`,
	//     (this returns a payload including: 'NeedTFA=1')
	//   followed by a 2nd request with payloads:
	//     `username=`, `tfa-challenge=<firsts response ticket>`, `password=totp:######`,
	//   and header: `CSRFPreventionToken: <first response CSRF>`
	//   Ticket generated lasts for ~2hours (to verify)
	if creds.OTP != "" {
		authRequest = fmt.Sprintf("%s&otp=%s", authRequest, url.QueryEscape(creds.OTP))
	}

	return &userAuthenticator{
		conn:        conn,
		authRequest: authRequest,
	}
}

func (t *userAuthenticator) authenticate(ctx context.Context) (*AuthenticationResponseData, error) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.authData != nil {
		return t.authData, nil
	}

	req, err := http.NewRequestWithContext(
		ctx,
		http.MethodPost,
		fmt.Sprintf("%s/%s/access/ticket", t.conn.endpoint, basePathJSONAPI),
		bytes.NewBufferString(t.authRequest),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create authentication request: %w", err)
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	tflog.Debug(ctx, "Sending authentication request", map[string]interface{}{
		"path": req.URL.Path,
	})

	//nolint:bodyclose
	res, err := t.conn.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve authentication response: %w", err)
	}

	defer utils.CloseOrLogError(ctx)(res.Body)

	err = validateResponseCode(res)
	if err != nil {
		return nil, fmt.Errorf("failed to authenticate: %w", err)
	}

	resBody := AuthenticationResponseBody{}

	err = json.NewDecoder(res.Body).Decode(&resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to decode authentication response, %w", err)
	}

	if resBody.Data == nil {
		return nil, errors.New("the server did not include a data object in the authentication response")
	}

	if resBody.Data.CSRFPreventionToken == nil {
		return nil, errors.New(
			"the server did not include a CSRF prevention token in the authentication response",
		)
	}

	if resBody.Data.Ticket == nil {
		return nil, errors.New("the server did not include a ticket in the authentication response")
	}

	if resBody.Data.Username == "" {
		return nil, errors.New("the server did not include the username in the authentication response")
	}

	t.authData = resBody.Data

	return resBody.Data, nil
}

func (t *userAuthenticator) IsRoot(ctx context.Context) bool {
	if t.authData == nil {
		if _, err := t.authenticate(ctx); err != nil {
			tflog.Warn(ctx, "Failed to authenticate while checking root status", map[string]interface{}{
				"error": err.Error(),
			})

			return false
		}
	}

	return t.authData != nil && t.authData.Username == rootUsername
}

func (t *userAuthenticator) IsRootTicket(ctx context.Context) bool {
	return t.IsRoot(ctx)
}

// AuthenticateRequest adds authentication data to a new request.
func (t *userAuthenticator) AuthenticateRequest(ctx context.Context, req *http.Request) error {
	a, err := t.authenticate(ctx)
	if err != nil {
		return fmt.Errorf("failed to authenticate: %w", err)
	}

	req.AddCookie(&http.Cookie{
		HttpOnly: true,
		Name:     "PVEAuthCookie",
		Secure:   true,
		Value:    *a.Ticket,
	})

	if req.Method != http.MethodGet {
		req.Header.Add("CSRFPreventionToken", *a.CSRFPreventionToken)
	}

	return nil
}
`````

## File: proxmox/cluster/acme/account/acme_account_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package account

// ACMEAccountListResponseBody contains the body from a ACME account list response.
type ACMEAccountListResponseBody struct {
	Data []*ACMEAccountListResponseData `json:"data,omitempty"`
}

// ACMEAccountListResponseData contains the data from a ACME account list response.
type ACMEAccountListResponseData struct {
	Name string `json:"name"`
}

// ACMEAccountGetResponseBody contains the body from a ACME account get response.
type ACMEAccountGetResponseBody struct {
	Data *ACMEAccountGetResponseData `json:"data,omitempty"`
}

// ACMEAccountData contains the data from a ACME account.
type ACMEAccountData struct {
	// An array of contact email addresses.
	Contact []string `json:"contact"`
	// Timestamp of the account creation.
	CreatedAt string `json:"createdAt"`
	// Status of the account. Can be one of "valid", "deactivated" or "revoked".
	Status string `json:"status"`
}

// ACMEAccountGetResponseData contains the data from a ACME account get response.
type ACMEAccountGetResponseData struct {
	// Account is the ACME account data.
	Account ACMEAccountData `json:"account"`
	// Directory is the URL of the ACME CA directory endpoint.
	Directory string `json:"directory"`
	// Location is the location of the ACME account.
	Location string `json:"location"`
	// TOS is the terms of service URL.
	TOS string `json:"tos"`
}

// ACMEAccountCreateRequestBody contains the body for creating a new ACME account.
type ACMEAccountCreateRequestBody struct {
	// Contact is the contact email addresses.
	Contact string `url:"contact"`
	// Directory is the URL of the ACME CA directory endpoint.
	Directory string `url:"directory,omitempty"`
	// EABHMACKey is the HMAC key for External Account Binding.
	EABHMACKey string `url:"eab-hmac-key,omitempty"`
	// EABKID is the Key Identifier for External Account Binding.
	EABKID string `url:"eab-kid,omitempty"`
	// Name is the ACME account config file name.
	Name string `url:"name,omitempty"`
	// TOS is the URL of CA TermsOfService - setting this indicates agreement.
	TOS string `url:"tos_url,omitempty"`
}

// ACMEAccountCreateResponseBody contains the body from an ACME account create request.
type ACMEAccountCreateResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// ACMEAccountUpdateRequestBody contains the body for updating an existing ACME account.
type ACMEAccountUpdateRequestBody struct {
	// Contact is the contact email addresses.
	Contact string `url:"contact,omitempty"`
	// Name is the ACME account config file name.
	Name string `url:"name,omitempty"`
}

// ACMEAccountUpdateResponseBody contains the body from an ACME account update request.
type ACMEAccountUpdateResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// ACMEAccountDeleteResponseBody contains the body from an ACME account delete request.
type ACMEAccountDeleteResponseBody struct {
	Data *string `json:"data,omitempty"`
}
`````

## File: proxmox/cluster/acme/account/acme_account.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package account

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// List returns a list of ACME accounts.
func (c *Client) List(ctx context.Context) ([]*ACMEAccountListResponseData, error) {
	resBody := &ACMEAccountListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(""), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing ACME accounts: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Name < resBody.Data[j].Name
	})

	return resBody.Data, nil
}

// Get retrieves a single ACME account based on its identifier.
func (c *Client) Get(ctx context.Context, name string) (*ACMEAccountGetResponseData, error) {
	resBody := &ACMEAccountGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(url.PathEscape(name)), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error reading ACME account: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// Create creates a new ACME account.
func (c *Client) Create(ctx context.Context, data *ACMEAccountCreateRequestBody) error {
	resBody := &ACMEAccountCreateResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(""), data, resBody)
	if err != nil {
		return fmt.Errorf("error creating ACME account: %w", err)
	}

	if resBody.Data == nil {
		return api.ErrNoDataObjectInResponse
	}

	err = c.Tasks().WaitForTask(ctx, *resBody.Data)
	if err != nil {
		return fmt.Errorf(
			"error updating ACME account: failed waiting for task: %w",
			err,
		)
	}

	return nil
}

// Update updates an existing ACME account.
func (c *Client) Update(ctx context.Context, accountName string, data *ACMEAccountUpdateRequestBody) error {
	resBody := &ACMEAccountUpdateResponseBody{}

	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(url.PathEscape(accountName)), data, resBody)
	if err != nil {
		return fmt.Errorf("error updating ACME account: %w", err)
	}

	if resBody.Data == nil {
		return api.ErrNoDataObjectInResponse
	}

	err = c.Tasks().WaitForTask(ctx, *resBody.Data)
	if err != nil {
		return fmt.Errorf(
			"error updating ACME account: failed waiting for task: %w",
			err,
		)
	}

	return nil
}

// Delete removes an ACME account.
func (c *Client) Delete(ctx context.Context, accountName string) error {
	resBody := &ACMEAccountDeleteResponseBody{}

	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(url.PathEscape(accountName)), nil, resBody)
	if err != nil {
		return fmt.Errorf("error deleting ACME account: %w", err)
	}

	if resBody.Data == nil {
		return api.ErrNoDataObjectInResponse
	}

	err = c.Tasks().WaitForTask(ctx, *resBody.Data)
	if err != nil {
		return fmt.Errorf(
			"error deleting ACME account: failed waiting for task: %w",
			err,
		)
	}

	return nil
}
`````

## File: proxmox/cluster/acme/account/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package account

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/tasks"
)

// Client is an interface for accessing the Proxmox ACME management API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to the Proxmox ACME management API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/acme/account/%s", path)
}

// Tasks returns a client for managing ACME account tasks.
func (c *Client) Tasks() *tasks.Client {
	return &tasks.Client{
		Client: c.Client,
	}
}
`````

## File: proxmox/cluster/acme/plugins/acme_plugins_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package plugins

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// BaseACMEPluginData contains common fields for ACME plugin data.
type BaseACMEPluginData struct {
	// ACME challenge type (dns, standalone).
	Type string `json:"type,omitempty" url:"type,omitempty"`
	// Prevent changes if current configuration file has a different digest. This can be used to prevent concurrent modifications.
	Digest string `json:"digest,omitempty" url:"digest,omitempty"`
	// API plugin name
	API string `json:"api,omitempty" url:"api,omitempty"`
	// Extra delay in seconds to wait before requesting validation. Allows to cope with a long TTL of DNS records (0 - 172800).
	ValidationDelay int64 `json:"validation-delay,omitempty" url:"validation-delay,omitempty"`
}

// ACMEPluginsListResponseBody contains the body from an ACME plugins list response.
type ACMEPluginsListResponseBody struct {
	// Unique identifier for ACME plugin instance.
	Data []*ACMEPluginsListResponseData `json:"data,omitempty"`
}

// ACMEPluginsListResponseData contains the data from an ACME plugins list response.
type ACMEPluginsListResponseData struct {
	BaseACMEPluginData
	// ACME Plugin ID name
	Plugin string `json:"plugin" url:"plugin"`
	// DNS plugin data.
	Data *DNSPluginData `json:"data,omitempty"`
}

// ACMEPluginsGetResponseBody contains the body from an ACME plugins get response.
type ACMEPluginsGetResponseBody struct {
	Data *ACMEPluginsGetResponseData `json:"data,omitempty"`
}

// ACMEPluginsGetResponseData contains the data from an ACME plugins get response.
type ACMEPluginsGetResponseData struct {
	BaseACMEPluginData
	// ACME Plugin ID name
	Plugin string `json:"plugin" url:"plugin"`
	// DNS plugin data.
	Data *DNSPluginData `json:"data"`
}

// ACMEPluginsCreateRequestBody contains the body for creating a new ACME plugin.
type ACMEPluginsCreateRequestBody struct {
	BaseACMEPluginData
	// ACME Plugin ID name
	Plugin string `json:"id" url:"id"`
	// DNS plugin data. (base64 encoded)
	Data *DNSPluginData `url:"data,omitempty"`
	// Flag to disable the config.
	Disable bool `url:"disable,omitempty,int"`
}

// ACMEPluginsUpdateRequestBody contains the body for updating an existing ACME plugin.
type ACMEPluginsUpdateRequestBody struct {
	BaseACMEPluginData
	// DNS plugin data. (base64 encoded)
	Data *DNSPluginData `url:"data,omitempty"`
	// A list of settings you want to delete.
	Delete string `url:"delete,omitempty"`
	// Flag to disable the config.
	Disable bool `url:"disable,omitempty,int"`
}

// DNSPluginData is a map of DNS plugin data.
type DNSPluginData map[string]string

// EncodeValues encodes the DNSPluginData into the URL values.
func (d DNSPluginData) EncodeValues(key string, v *url.Values) error {
	values := make([]string, 0, len(d))

	for key, value := range d {
		values = append(values, fmt.Sprintf("%s=%s", key, value))
	}

	v.Add(key, base64.StdEncoding.EncodeToString([]byte(strings.Join(values, "\n"))))

	return nil
}

// UnmarshalJSON unmarshals a DNSPluginData struct from JSON.
func (d *DNSPluginData) UnmarshalJSON(b []byte) error {
	mapData := make(map[string]string)

	s := ""
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling json: %w", err)
	}

	for _, line := range strings.Split(s, "\n") {
		if line == "" {
			continue
		}

		before, after, _ := strings.Cut(line, "=")
		mapData[before] = after
	}

	*d = mapData

	return nil
}
`````

## File: proxmox/cluster/acme/plugins/acme_plugins.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package plugins

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// List returns a list of ACME plugins.
func (c *Client) List(ctx context.Context) ([]*ACMEPluginsListResponseData, error) {
	resBody := &ACMEPluginsListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(""), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing ACME plugins: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Plugin < resBody.Data[j].Plugin
	})

	return resBody.Data, nil
}

// Get retrieves a single ACME plugin based on its identifier.
func (c *Client) Get(ctx context.Context, id string) (*ACMEPluginsGetResponseData, error) {
	resBody := &ACMEPluginsGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(url.PathEscape(id)), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error reading ACME plugin: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// Create creates a new ACME plugin.
func (c *Client) Create(ctx context.Context, data *ACMEPluginsCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(""), data, nil)
	if err != nil {
		return fmt.Errorf("error creating ACME plugin: %w", err)
	}

	return nil
}

// Update updates an existing ACME plugin.
func (c *Client) Update(ctx context.Context, id string, data *ACMEPluginsUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(url.PathEscape(id)), data, nil)
	if err != nil {
		return fmt.Errorf("error updating ACME plugin: %w", err)
	}

	return nil
}

// Delete removes an ACME plugin.
func (c *Client) Delete(ctx context.Context, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(url.PathEscape(id)), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting ACME plugin: %w", err)
	}

	return nil
}
`````

## File: proxmox/cluster/acme/plugins/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package plugins

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox ACME plugins API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to the Proxmox ACME plugins API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/acme/plugins/%s", path)
}
`````

## File: proxmox/cluster/acme/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package acme

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/account"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme/plugins"
)

// Client is an interface for accessing the Proxmox ACME API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to a full cluster ACME API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/acme/%s", path)
}

// Account returns a client for managing the cluster's ACME account.
func (c *Client) Account() *account.Client {
	return &account.Client{Client: c.Client}
}

// Plugins returns a client for managing the cluster's ACME plugins.
func (c *Client) Plugins() *plugins.Client {
	return &plugins.Client{Client: c.Client}
}
`````

## File: proxmox/cluster/firewall/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
)

// API is an interface for managing cluster firewall.
type API interface {
	firewall.API
	SecurityGroup
	Options
	SecurityGroup(group string) firewall.Rule
}

// Client is an interface for accessing the Proxmox cluster firewall API.
type Client struct {
	firewall.Client
}

type groupClient struct {
	firewall.Client
	Group string
}

// SecurityGroup returns a client for managing a specific security group.
func (c *Client) SecurityGroup(group string) firewall.Rule {
	// My head really hurts when I'm looking at this code
	// I'm not sure if this is the best way to do the required
	// interface composition and method "overrides", but it works.
	return &Client{
		Client: firewall.Client{
			Client: &groupClient{
				Client: c.Client,
				Group:  group,
			},
		},
	}
}

func (c *groupClient) ExpandPath(_ string) string {
	return fmt.Sprintf("cluster/firewall/groups/%s", c.Group)
}
`````

## File: proxmox/cluster/firewall/options_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// OptionsPutRequestBody is the request body for the PUT /cluster/firewall/options API call.
type OptionsPutRequestBody struct {
	EBTables     *types.CustomBool   `json:"ebtables,omitempty"      url:"ebtables,omitempty,int"`
	Enable       *types.CustomBool   `json:"enable,omitempty"        url:"enable,omitempty,int"`
	LogRateLimit *CustomLogRateLimit `json:"log_ratelimit,omitempty" url:"log_ratelimit,omitempty"`
	PolicyIn     *string             `json:"policy_in,omitempty"     url:"policy_in,omitempty"`
	PolicyOut    *string             `json:"policy_out,omitempty"    url:"policy_out,omitempty"`
}

// CustomLogRateLimit is a custom type for the log_ratelimit field of the firewall optionss.
type CustomLogRateLimit struct {
	Enable types.CustomBool `json:"enable,omitempty" url:"enable,omitempty,int"`
	Burst  *int             `json:"burst,omitempty"  url:"burst,omitempty,int"`
	Rate   *string          `json:"rate,omitempty"   url:"rate,omitempty"`
}

// OptionsGetResponseBody is the response body for the GET /cluster/firewall/options API call.
type OptionsGetResponseBody struct {
	Data *OptionsGetResponseData `json:"data,omitempty"`
}

// OptionsGetResponseData is the data field of the response body for the GET /cluster/firewall/options API call.
type OptionsGetResponseData struct {
	EBTables     *types.CustomBool   `json:"ebtables"      url:"ebtables, int"`
	Enable       *types.CustomBool   `json:"enable"        url:"enable,int"`
	LogRateLimit *CustomLogRateLimit `json:"log_ratelimit" url:"log_ratelimit"`
	PolicyIn     *string             `json:"policy_in"     url:"policy_in"`
	PolicyOut    *string             `json:"policy_out"    url:"policy_out"`
}

// EncodeValues converts a CustomWatchdogDevice struct to a URL vlaue.
func (r *CustomLogRateLimit) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.Enable {
		values = append(values, "enable=1")
	} else {
		values = append(values, "enable=0")
	}

	if r.Burst != nil {
		values = append(values, fmt.Sprintf("burst=%d", *r.Burst))
	}

	if r.Rate != nil {
		values = append(values, fmt.Sprintf("rate=%s", *r.Rate))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON unmarshals a CustomLogRateLimit struct from JSON.
func (r *CustomLogRateLimit) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("error unmarshaling json: %w", err)
	}

	if s == "" {
		return nil
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.Enable = v[0] == "1"
		} else if len(v) == 2 {
			switch v[0] {
			case "enable":
				r.Enable = v[1] == "1"
			case "burst":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("error converting burst to int: %w", err)
				}

				r.Burst = &iv
			case "rate":
				r.Rate = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/cluster/firewall/options.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Options is an interface for managing global firewall options.
type Options interface {
	SetGlobalOptions(ctx context.Context, d *OptionsPutRequestBody) error
	GetGlobalOptions(ctx context.Context) (*OptionsGetResponseData, error)
}

// SetGlobalOptions sets the global firewall options.
func (c *Client) SetGlobalOptions(ctx context.Context, d *OptionsPutRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, "cluster/firewall/options", d, nil)
	if err != nil {
		return fmt.Errorf("error setting optionss: %w", err)
	}

	return nil
}

// GetGlobalOptions retrieves the global firewall options.
func (c *Client) GetGlobalOptions(ctx context.Context) (*OptionsGetResponseData, error) {
	resBody := &OptionsGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, "cluster/firewall/options", nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving options: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/cluster/firewall/security_groups_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

// GroupCreateRequestBody contains the data for a security group create request.
type GroupCreateRequestBody struct {
	Group   string  `json:"group"             url:"group"`
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	Digest  *string `json:"digest,omitempty"  url:"digest,omitempty"`
}

// GroupListResponseData contains the data from a group list response.
type GroupListResponseData struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	Group   string  `json:"group"             url:"group"`
	Digest  string  `json:"digest"            url:"digest"`
}

// GroupListResponseBody contains the data from a group get response.
type GroupListResponseBody struct {
	Data []*GroupListResponseData `json:"data,omitempty"`
}

// GroupUpdateRequestBody contains the data for a group update request.
type GroupUpdateRequestBody struct {
	Group string `json:"group" url:"group"`

	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	ReName  *string `json:"rename,omitempty"  url:"rename,omitempty"`
	Digest  *string `json:"digest,omitempty"  url:"digest,omitempty"`
}
`````

## File: proxmox/cluster/firewall/security_groups.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// SecurityGroup is an interface for the Proxmox security group API.
type SecurityGroup interface {
	CreateGroup(ctx context.Context, d *GroupCreateRequestBody) error
	ListGroups(ctx context.Context) ([]*GroupListResponseData, error)
	UpdateGroup(ctx context.Context, d *GroupUpdateRequestBody) error
	DeleteGroup(ctx context.Context, group string) error
}

func (c *Client) securityGroupsPath() string {
	return "cluster/firewall/groups"
}

// CreateGroup create new security group.
func (c *Client) CreateGroup(ctx context.Context, d *GroupCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.securityGroupsPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error creating security group: %w", err)
	}

	return nil
}

// ListGroups retrieve list of security groups.
func (c *Client) ListGroups(ctx context.Context) ([]*GroupListResponseData, error) {
	resBody := &GroupListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.securityGroupsPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving security groups: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Group < resBody.Data[j].Group
	})

	return resBody.Data, nil
}

// UpdateGroup update security group.
func (c *Client) UpdateGroup(ctx context.Context, d *GroupUpdateRequestBody) error {
	err := c.DoRequest(
		ctx,
		http.MethodPost,
		c.securityGroupsPath(),
		d,
		nil,
	)
	if err != nil {
		return fmt.Errorf("error updating security group: %w", err)
	}

	return nil
}

// DeleteGroup delete security group.
func (c *Client) DeleteGroup(ctx context.Context, group string) error {
	err := c.DoRequest(
		ctx,
		http.MethodDelete,
		fmt.Sprintf("%s/%s", c.securityGroupsPath(), url.PathEscape(group)),
		nil,
		nil,
	)
	if err != nil {
		return fmt.Errorf("error deleting security group '%s': %w", group, err)
	}

	return nil
}
`````

## File: proxmox/cluster/ha/groups/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package groups

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox High Availability groups API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to the HA groups management API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/ha/groups/%s", path)
}
`````

## File: proxmox/cluster/ha/groups/hagroups_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package groups

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// HAGroupListResponseBody contains the body from a HA group list response.
type HAGroupListResponseBody struct {
	Data []*HAGroupListResponseData `json:"data,omitempty"`
}

// HAGroupListResponseData contains the data from a HA group list response.
type HAGroupListResponseData struct {
	ID string `json:"group"`
}

// HAGroupGetResponseBody contains the body from a HA group get response.
type HAGroupGetResponseBody struct {
	Data *HAGroupGetResponseData `json:"data,omitempty"`
}

// HAGroupDataBase contains fields which are both received from and send to the HA group API.
type HAGroupDataBase struct {
	// A SHA1 digest of the group's configuration.
	Digest *string `json:"digest,omitempty" url:"digest,omitempty"`
	// The group's comment, if defined
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	// A comma-separated list of node fields. Each node field contains a node name, and may
	// include a priority, with a semicolon acting as a separator.
	Nodes string `json:"nodes" url:"nodes"`
	// A boolean (0/1) indicating that failing back to the highest priority node is disabled.
	NoFailback types.CustomBool `json:"nofailback" url:"nofailback,int"`
	// A boolean (0/1) indicating that associated resources cannot run on other nodes.
	Restricted types.CustomBool `json:"restricted" url:"restricted,int"`
}

// HAGroupGetResponseData contains the data from a HA group get response.
type HAGroupGetResponseData struct {
	// The group's data
	HAGroupDataBase
	// The group's identifier
	ID string `json:"group"`
	// The type. Always set to `group`.
	Type string `json:"type"`
}

// HAGroupCreateRequestBody contains the data which must be sent when creating a HA group.
type HAGroupCreateRequestBody struct {
	// The group's data
	HAGroupDataBase
	// The group's identifier
	ID string `url:"group"`
	// The type. Always set to `group`.
	Type string `url:"type"`
}

// HAGroupUpdateRequestBody contains the data which must be sent when updating a HA group.
type HAGroupUpdateRequestBody struct {
	// The group's data
	HAGroupDataBase
	// A list of settings to delete
	Delete string `url:"delete"`
}
`````

## File: proxmox/cluster/ha/groups/hagroups.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package groups

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// List retrieves the list of HA groups.
func (c *Client) List(ctx context.Context) ([]*HAGroupListResponseData, error) {
	resBody := &HAGroupListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(""), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing HA groups: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID < resBody.Data[j].ID
	})

	return resBody.Data, nil
}

// Get retrieves a single HA group based on its identifier.
func (c *Client) Get(ctx context.Context, groupID string) (*HAGroupGetResponseData, error) {
	resBody := &HAGroupGetResponseBody{}

	err := c.DoRequest(
		ctx, http.MethodGet,
		c.ExpandPath(url.PathEscape(groupID)), nil, resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error reading HA group: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// Create creates a new HA group.
func (c *Client) Create(ctx context.Context, data *HAGroupCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(""), data, nil)
	if err != nil {
		return fmt.Errorf("error creating HA group: %w", err)
	}

	return nil
}

// Update updates a HA group's configuration.
func (c *Client) Update(ctx context.Context, groupID string, data *HAGroupUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(url.PathEscape(groupID)), data, nil)
	if err != nil {
		return fmt.Errorf("error updating HA group: %w", err)
	}

	return nil
}

// Delete deletes a HA group.
func (c *Client) Delete(ctx context.Context, groupID string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(url.PathEscape(groupID)), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting HA group: %w", err)
	}

	return nil
}
`````

## File: proxmox/cluster/ha/resources/api.http
`````
### Create Proxmox VE API acsess ticket
POST {{host}}:{{port}}/{{api-path-base}}/access/ticket
Accept: application/json
Content-Type: application/x-www-form-urlencoded

username = {{api-user}} &
password = {{api-user-password}}

// Save the ticket into a global variable to use in other calls.
> {%
  client.global.set("pve_api_access_ticket", response.body.data.ticket);
  client.global.set("pve_api_access_ticket_csrf_prevention_token", response.body.data.CSRFPreventionToken);
  client.log(`Received Proxmox VE API access ticket "${client.global.get("pve_api_access_ticket")}"`)
%}

### List HA resources
GET {{host}}:{{port}}/{{api-path-base}}/cluster/ha/resources
Accept: application/json
Cookie: PVEAuthCookie={{pve_api_access_ticket}}
`````

## File: proxmox/cluster/ha/resources/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resources

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox High Availability resources management API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to the HA resources management API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/ha/resources/%s", path)
}
`````

## File: proxmox/cluster/ha/resources/http-client.env.json
`````json
{
  "utm-8.1-1": {
    "api-path-base": "api2/json",
    "host": "https://172.16.1.10",
    "port": "8006"
  },
  "adelie": {
    "api-path-base": "api2/json",
    "host": "https://192.168.178.30",
    "port": "8006"
  }
}
`````

## File: proxmox/cluster/ha/resources/http-client.private.env.json
`````json
{
  "utm-8.1-1": {
    "api-user": "root@pam",
    "api-user-password": "root123"
  },
  "adelie": {
    "api-user": "root@pam",
    "api-user-password": "root123"
  }
}
`````

## File: proxmox/cluster/ha/resources/resources_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resources

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// HAResourceListResponseBody contains the body from a HA resource list response.
type HAResourceListResponseBody struct {
	Data []*HAResourceListResponseData `json:"data,omitempty"`
}

// HAResourceListResponseData contains the data from a HA resource list response.
type HAResourceListResponseData struct {
	ID types.HAResourceID `json:"sid"`
}

// HAResourceGetResponseBody contains the body from a HA resource get response.
type HAResourceGetResponseBody struct {
	Data *HAResourceGetResponseData `json:"data,omitempty"`
}

// HAResourceDataBase contains data common to all HA resource API calls.
type HAResourceDataBase struct {
	// Resource comment, if defined
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	// HA group identifier, if the resource is part of one.
	Group *string `json:"group,omitempty" url:"group,omitempty"`
	// Maximal number of service relocation attempts.
	MaxRelocate *int64 `json:"max_relocate,omitempty" url:"max_relocate,omitempty"`
	// Maximal number of service restart attempts.
	MaxRestart *int64 `json:"max_restart" url:"max_restart,omitempty"`
	// Requested resource state.
	State types.HAResourceState `json:"state" url:"state"`
}

// HAResourceGetResponseData contains data received from the HA resource API when requesting information about a single
// HA resource.
type HAResourceGetResponseData struct {
	HAResourceDataBase
	// Identifier of this resource
	ID types.HAResourceID `json:"sid"`
	// Type of this resource
	Type types.HAResourceType `json:"type"`
	// SHA-1 digest of the resources' configuration.
	Digest *string `json:"digest,omitempty"`
}

// HAResourceCreateRequestBody contains data received from the HA resource API when creating a new HA resource.
type HAResourceCreateRequestBody struct {
	HAResourceDataBase
	// Identifier of this resource
	ID types.HAResourceID `url:"sid"`
	// Type of this resource
	Type *types.HAResourceType `url:"type,omitempty"`
	// SHA-1 digest of the resources' configuration.
	Digest *string `url:"comment,omitempty"`
}

// HAResourceUpdateRequestBody contains data received from the HA resource API when updating an existing HA resource.
type HAResourceUpdateRequestBody struct {
	HAResourceDataBase
	// Settings that must be deleted from the resource's configuration
	Delete []string `url:"delete,omitempty,comma"`
}
`````

## File: proxmox/cluster/ha/resources/resources.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resources

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

type haResourceTypeListQuery struct {
	ResType *types.HAResourceType `url:"type"`
}

// List retrieves the list of HA resources. If the `resType` argument is `nil`, all resources will be returned;
// otherwise resources will be filtered by the specified type (either `ct` or `vm`).
func (c *Client) List(ctx context.Context, resType *types.HAResourceType) ([]*HAResourceListResponseData, error) {
	options := &haResourceTypeListQuery{resType}
	resBody := &HAResourceListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(""), options, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing HA resources: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID.Type < resBody.Data[j].ID.Type ||
			(resBody.Data[i].ID.Type == resBody.Data[j].ID.Type &&
				resBody.Data[i].ID.Name < resBody.Data[j].ID.Name)
	})

	return resBody.Data, nil
}

// Get retrieves the configuration of a single HA resource.
func (c *Client) Get(ctx context.Context, id types.HAResourceID) (*HAResourceGetResponseData, error) {
	resBody := &HAResourceGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(url.PathEscape(id.String())), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error reading HA resource: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// Create creates a new HA resource.
func (c *Client) Create(ctx context.Context, data *HAResourceCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(""), data, nil)
	if err != nil {
		return fmt.Errorf("error creating HA resource: %w", err)
	}

	return nil
}

// Update updates an existing HA resource.
func (c *Client) Update(ctx context.Context, id types.HAResourceID, data *HAResourceUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(url.PathEscape(id.String())), data, nil)
	if err != nil {
		return fmt.Errorf("error updating HA resource %v: %w", id, err)
	}

	return nil
}

// Delete deletes a HA resource.
func (c *Client) Delete(ctx context.Context, id types.HAResourceID) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(url.PathEscape(id.String())), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting HA resource %v: %w", id, err)
	}

	return nil
}
`````

## File: proxmox/cluster/ha/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ha

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	hagroups "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/groups"
	haresources "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha/resources"
)

// Client is an interface for accessing the Proxmox High Availability API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to a full cluster API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/ha/%s", path)
}

// Groups returns a client for managing the cluster's High Availability groups.
func (c *Client) Groups() *hagroups.Client {
	return &hagroups.Client{Client: c.Client}
}

// Resources returns a client for managing the cluster's High Availability resources.
func (c *Client) Resources() *haresources.Client {
	return &haresources.Client{Client: c.Client}
}
`````

## File: proxmox/cluster/mapping/client.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package mapping

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Client is an interface for accessing the Proxmox cluster mapping API.
type Client struct {
	api.Client
}

func (c *Client) basePath() string {
	return c.Client.ExpandPath("mapping")
}

// ExpandPath expands a relative path to a full hardware mapping API path.
func (c *Client) ExpandPath(hmType proxmoxtypes.Type, path string) string {
	ep := c.basePath()
	if hmType.String() != "" {
		ep = fmt.Sprintf("%s/%s", ep, hmType.String())
	}

	if path != "" {
		ep = fmt.Sprintf("%s/%s", ep, path)
	}

	return ep
}
`````

## File: proxmox/cluster/mapping/mapping.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package mapping

import (
	"context"
	"fmt"
	"net/http"
	"net/url"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

// Create creates a new hardware mapping.
func (c *Client) Create(ctx context.Context, hmType proxmoxtypes.Type, data *CreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(hmType, ""), data, nil)
	if err != nil {
		return fmt.Errorf("creating hardware mapping %q: %w", data.ID, err)
	}

	return nil
}

// Delete deletes a hardware mapping.
func (c *Client) Delete(ctx context.Context, hmType proxmoxtypes.Type, name string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(hmType, url.PathEscape(name)), nil, nil)
	if err != nil {
		return fmt.Errorf("deleting hardware mapping %q: %w", name, err)
	}

	return nil
}

// Get retrieves the configuration of a single hardware mapping.
func (c *Client) Get(ctx context.Context, hmType proxmoxtypes.Type, name string) (*GetResponseData, error) {
	resBody := &GetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(hmType, url.PathEscape(name)), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("reading hardware mapping %q: %w", name, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// List retrieves the list of hardware mappings.
// If "checkNode" is not empty, the "checks" list will be included in the response that might include configuration
// correctness diagnostics for the given node.
func (c *Client) List(ctx context.Context, hmType proxmoxtypes.Type, checkNode string) ([]*ListResponseData, error) {
	options := &listQuery{
		CheckNode: checkNode,
	}

	resBody := &ListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(hmType, ""), options, resBody)
	if err != nil {
		return nil, fmt.Errorf("listing hardware mapping: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// Update updates an existing hardware mapping.
func (c *Client) Update(ctx context.Context, hmType proxmoxtypes.Type, name string, data *UpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(hmType, url.PathEscape(name)), data, nil)
	if err != nil {
		return fmt.Errorf("udating hardware mapping %q: %w", name, err)
	}

	return nil
}
`````

## File: proxmox/cluster/mapping/types.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package mapping

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	proxmoxtypes "github.com/bpg/terraform-provider-proxmox/proxmox/types/hardwaremapping"
)

const (
	// APIParamNamePCIMediatedDevices is the API attribute name of the Proxmox VE API "mediated devices" parameter for a
	// PCI hardware mapping.
	APIParamNamePCIMediatedDevices = "mdev"
)

type listQuery struct {
	// CheckNode is the name of the node those configuration should be checked for correctness.
	CheckNode string `url:"check-node,omitempty"`
}

// DataBase contains common data for hardware mapping API calls.
type DataBase struct {
	// Description is the optional key for the description for a hardware mapping that is omitted by the Proxmox VE API
	// when not set.
	// Note that even though the Proxmox VE API attribute is named "description" it is generally labeled as "comment"
	// cross the Proxmox VE web UI while only being named "description" in the Proxmox VE API and its documentation.
	Description *string `url:"description,omitempty"`

	// Map is the list of device mappings.
	Map []proxmoxtypes.Map `json:"map" url:"map"`

	// MediatedDevices is the indicator for the optional APIParamNamePCIMediatedDevices parameter.
	MediatedDevices types.CustomBool `json:"mdev" url:"mdev,omitempty,int"`
}

// CreateRequestBody contains the data which must be sent when creating a hardware mapping.
type CreateRequestBody struct {
	DataBase

	// ID is the hardware mappings identifier.
	ID string `url:"id"`
}

// GetResponseBody contains the body from a hardware mapping get response.
type GetResponseBody struct {
	// Data is the hardware mapping get response data.
	Data *GetResponseData `json:"data,omitempty"`
}

// ListResponseBody contains the body from a hardware mapping list response.
type ListResponseBody struct {
	// Data is the hardware mapping list response data.
	Data []*ListResponseData `json:"data,omitempty"`
}

// GetResponseData contains data received from the hardware mapping API when requesting information about a single
// mapping.
type GetResponseData struct {
	DataBase

	// Type is the required types of the hardware mapping.
	Type proxmoxtypes.Type `json:"type"`
}

// ListResponseData contains the data from a hardware mapping list response.
type ListResponseData struct {
	DataBase

	// Checks might contain relevant diagnostics about incorrect [typesHWM.TypePCI] configurations.
	// The name of the node must be passed to the Proxmox VE API call which maps to the "check-node" URL parameter.
	// Note that the Proxmox VE API, for whatever reason, only returns one error at a time, even though the field is an
	// array.
	Checks []NodeCheckDiag `json:"checks,omitempty"`

	// ChecksUSB might contain relevant diagnostics about incorrect [typesHWM.TypeUSB] configurations.
	// The name of the node must be passed to the Proxmox VE API call which maps to the "check-node" URL parameter.
	// Note that the actual JSON field name matches the Proxmox VE API, but the name of this variable has been adjusted
	// for clarity.
	// Also note that the Proxmox VE API, for whatever reason, only returns one error at a time, even though the field is
	// an array.
	ChecksUSB []NodeCheckDiag `json:"errors,omitempty"`

	// ID is the hardware mappings identifier.
	ID string `json:"id"`

	// Type is the required types of the hardware mapping.
	Type proxmoxtypes.Type `json:"type"`
}

// NodeCheckDiag is a hardware mapping configuration correctness diagnostic entry.
type NodeCheckDiag struct {
	// Message is the message of the node check diagnostic entry.
	Message *string `json:"message"`

	// Severity is the severity of the node check diagnostic entry.
	Severity *string `json:"severity"`
}

// UpdateRequestBody contains data received from the hardware mapping resource API when updating an existing hardware
// mapping resource.
type UpdateRequestBody struct {
	DataBase

	// Delete are settings that must be deleted from the resource's configuration.
	Delete []string `url:"delete,omitempty,comma"`
}
`````

## File: proxmox/cluster/metrics/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox metrics management API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to the Proxmox metrics server management API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/metrics/server/%s", path)
}
`````

## File: proxmox/cluster/metrics/server_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics

// ServerData contains the data from a metrics server response.
type ServerData struct {
	Disable *int64  `json:"disable,omitempty" url:"disable,omitempty"`
	ID      string  `json:"id,omitempty"      url:"id,omitempty"`
	MTU     *int64  `json:"mtu"               url:"mtu,omitempty"`
	Port    int64   `json:"port"              url:"port"`
	Server  string  `json:"server"            url:"server"`
	Timeout *int64  `json:"timeout,omitempty" url:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"    url:"type,omitempty"`

	// influxdb only options
	APIPathPrefix *string `json:"api-path-prefix,omitempty"    url:"api-path-prefix,omitempty"`
	Bucket        *string `json:"bucket,omitempty"             url:"bucket,omitempty"`
	InfluxDBProto *string `json:"influxdbproto,omitempty"      url:"influxdbproto,omitempty"`
	MaxBodySize   *int64  `json:"max-body-size,omitempty"      url:"max-body-size,omitempty"`
	Organization  *string `json:"organization,omitempty"       url:"organization,omitempty"`
	Token         *string `json:"token,omitempty"              url:"token,omitempty"`
	Verify        *int64  `json:"verify-certificate,omitempty" url:"verify-certificate,omitempty"`

	// graphite only options
	Path  *string `json:"path,omitempty"  url:"path,omitempty"`
	Proto *string `json:"proto,omitempty" url:"proto,omitempty"`
}

// ServerResponseBody contains the body from a metrics server response.
type ServerResponseBody struct {
	Data *ServerData `json:"data,omitempty"`
}

// ServersResponseBody contains the body from a metrics server list response.
type ServersResponseBody struct {
	Data *[]ServerData `json:"data,omitempty"`
}

// ServerRequestData contains the data for a metric server post/put request.
type ServerRequestData struct {
	ServerData
	Delete *[]string `url:"delete,omitempty"`
}
`````

## File: proxmox/cluster/metrics/server.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package metrics

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetServer retrieves the metrics server data.
func (c *Client) GetServer(ctx context.Context, id string) (*ServerData, error) {
	resBody := &ServerResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(id), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error reading metrics server: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// GetServers lists the metrics servers.
func (c *Client) GetServers(ctx context.Context) (*[]ServerData, error) {
	resBody := &ServersResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(""), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error reading list of metrics servers: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateServer updates the metrics server.
func (c *Client) UpdateServer(ctx context.Context, data *ServerRequestData) error {
	// PVE API does not allow to pass "type" in PUT requests, this doesn't makes any sense
	// since other required params like port, server must still be there
	// while we could spawn another struct, let's just fix it silently
	data.Type = nil

	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(data.ID), data, nil)
	if err != nil {
		return fmt.Errorf("error updating metrics server: %w", err)
	}

	return nil
}

// CreateServer creates the metrics server.
func (c *Client) CreateServer(ctx context.Context, data *ServerRequestData) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(data.ID), data, nil)
	if err != nil {
		return fmt.Errorf("error creating metrics server: %w", err)
	}

	return nil
}

// DeleteServer deletes the metrics server.
func (c *Client) DeleteServer(ctx context.Context, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(id), nil, nil)
	if err != nil {
		return fmt.Errorf("error updating metrics server: %w", err)
	}

	return nil
}
`````

## File: proxmox/cluster/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cluster

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/acme"
	clusterfirewall "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/ha"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/mapping"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/metrics"
	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
)

// Client is an interface for accessing the Proxmox cluster API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to a full cluster API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("cluster/%s", path)
}

// Firewall returns a client for managing the cluster firewall.
func (c *Client) Firewall() clusterfirewall.API {
	return &clusterfirewall.Client{
		Client: firewall.Client{Client: c},
	}
}

// HA returns a client for managing the cluster's High Availability features.
func (c *Client) HA() *ha.Client {
	return &ha.Client{Client: c}
}

// HardwareMapping returns a client for managing the cluster's hardware mapping features.
func (c *Client) HardwareMapping() *mapping.Client {
	return &mapping.Client{Client: c}
}

// ACME returns a client for managing the cluster's ACME features.
func (c *Client) ACME() *acme.Client {
	return &acme.Client{Client: c}
}

// Metrics returns a client for managing the cluster's metrics features.
func (c *Client) Metrics() *metrics.Client {
	return &metrics.Client{Client: c}
}
`````

## File: proxmox/cluster/cluster_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cluster

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// NextIDRequestBody contains the data for a cluster next id request.
type NextIDRequestBody struct {
	VMID *int `json:"vmid,omitempty" url:"vmid,omitempty"`
}

// NextIDResponseBody contains the body from a cluster next id response.
type NextIDResponseBody struct {
	Data *types.CustomInt `json:"data,omitempty"`
}

// ResourcesListBody contains the body from a cluste resource list response.
type ResourcesListBody struct {
	Data []*ResourcesListResponseData `json:"data,omitempty"`
}

// ResourcesListRequestBody contains the body params to cluster resource list request.
type ResourcesListRequestBody struct {
	Type string `json:"type" url:"type"`
}

// ResourcesListResponseData contains the data from a cluster resource list body response.
type ResourcesListResponseData struct {
	Type       string  `json:"type"`
	ID         string  `json:"id"`
	CgroupMode int     `json:"cgroup-mode,omitempty"`
	Content    int     `json:"content,omitempty"`
	CPU        float64 `json:"cpu,omitempty"`
	Disk       int64   `json:"disk,omitempty"`
	HaState    string  `json:"hastate,omitempty"`
	Level      string  `json:"level,omitempty"`
	MaxCPU     float64 `json:"maxcpu,omitempty"`
	MaxDisk    int64   `json:"maxdisk,omitempty"`
	MaxMem     int64   `json:"maxmem,omitempty"`
	Mem        int64   `json:"mem,omitempty"`
	Name       string  `json:"name,omitempty"`
	NodeName   string  `json:"node,omitempty"`
	PluginType string  `json:"plugintype,omitempty"`
	PoolName   string  `json:"poolname,omitempty"`
	Status     string  `json:"status,omitempty"`
	Storage    string  `json:"storage,omitempty"`
	Uptime     int     `json:"uptime,omitempty"`
	VMID       int     `json:"vmid,omitempty"`
}
`````

## File: proxmox/cluster/cluster.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cluster

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// ErrVMDoesNotExist is returned when the VM identifier cannot be found on any cluster node.
var ErrVMDoesNotExist = errors.New("unable to find VM identifier on any cluster node")

// GetNextID retrieves the next free VM identifier for the cluster.
func (c *Client) GetNextID(ctx context.Context, vmID *int) (*int, error) {
	reqBody := &NextIDRequestBody{
		VMID: vmID,
	}

	resBody := &NextIDResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, "cluster/nextid", reqBody, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving next VM ID: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return (*int)(resBody.Data), nil
}

// GetClusterResources retrieves current resources for cluster.
func (c *Client) GetClusterResources(ctx context.Context, resourceType string) ([]*ResourcesListResponseData, error) {
	reqBody := &ResourcesListRequestBody{
		Type: resourceType,
	}
	resBody := &ResourcesListBody{}

	err := c.DoRequest(ctx, http.MethodGet, "cluster/resources", reqBody, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get resources list of type (\"%s\") for cluster: %w", resourceType, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// GetClusterResourcesVM retrieves current VM resources for cluster.
func (c *Client) GetClusterResourcesVM(ctx context.Context) ([]*ResourcesListResponseData, error) {
	return c.GetClusterResources(ctx, "vm")
}

// GetVMNodeName gets node for specified vmID.
func (c *Client) GetVMNodeName(ctx context.Context, vmID int) (*string, error) {
	allClusterVM, err := c.GetClusterResourcesVM(ctx)
	if err != nil {
		return nil, err
	}

	if allClusterVM == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	for _, v := range allClusterVM {
		if v.VMID == vmID {
			return &v.NodeName, nil
		}
	}

	return nil, ErrVMDoesNotExist
}
`````

## File: proxmox/cluster/id_generator.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cluster

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/avast/retry-go/v4"
	"github.com/rogpeppe/go-internal/lockedfile"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
)

const (
	idGeneratorLockFile         = "terraform-provider-proxmox-id-gen.lock"
	idGeneratorSequenceFile     = "terraform-provider-proxmox-id-gen.seq"
	idGeneratorContentionWindow = 5 * time.Second
)

// IDGenerator is responsible for generating unique identifiers for VMs and Containers.
type IDGenerator struct {
	client *Client
	config IDGeneratorConfig
}

// IDGeneratorConfig is the configuration for the IDGenerator.
type IDGeneratorConfig struct {
	RandomIDs    bool
	RandomIDStat int
	RandomIDEnd  int

	lockFName string
	seqFName  string
}

// NewIDGenerator creates a new IDGenerator with the given parameters.
func NewIDGenerator(client *Client, config IDGeneratorConfig) IDGenerator {
	if config.RandomIDStat == 0 {
		config.RandomIDStat = 10000
	}

	if config.RandomIDEnd == 0 {
		config.RandomIDEnd = 99999
	}

	config.lockFName = filepath.Join(os.TempDir(), idGeneratorLockFile)
	config.seqFName = filepath.Join(os.TempDir(), idGeneratorSequenceFile)

	unlock, err := lockedfile.MutexAt(config.lockFName).Lock()
	if err == nil {
		defer unlock()

		// delete the sequence file if it is older than 10 seconds
		// this is to prevent the sequence file from growing indefinitely,
		// while giving some protection against parallel runs of the provider
		// that might interfere with each other and reset the sequence at the same time
		stat, err := os.Stat(config.seqFName)
		if err == nil && time.Since(stat.ModTime()) > idGeneratorContentionWindow {
			_ = os.Remove(config.seqFName)
		}
	}

	return IDGenerator{client, config}
}

// NextID returns the next available VM identifier.
func (g IDGenerator) NextID(ctx context.Context) (int, error) {
	// lock the ID generator to prevent concurrent access
	// it should be unlocked only when the new ID is successfully
	// retrieved (and optionally written to the sequence file)
	unlock, err := lockedfile.MutexAt(g.config.lockFName).Lock()
	if err != nil {
		return -1, fmt.Errorf("unable to lock the ID generator: %w", err)
	}

	defer unlock()

	ctx, cancel := context.WithTimeout(ctx, idGeneratorContentionWindow+time.Second)
	defer cancel()

	var newID *int

	var errs []error

	id, err := retry.DoWithData(func() (*int, error) {
		if g.config.RandomIDs {
			//nolint:gosec
			newID = ptr.Ptr(rand.Intn(g.config.RandomIDEnd-g.config.RandomIDStat) + g.config.RandomIDStat)
		} else if newID == nil {
			newID, err = nextSequentialID(g.config.seqFName)
			if err != nil {
				return nil, err
			}
		}

		return g.client.GetNextID(ctx, newID)
	},
		retry.OnRetry(func(_ uint, err error) {
			if strings.Contains(err.Error(), "already exists") && newID != nil {
				newID, err = g.client.GetNextID(ctx, nil)
			}

			errs = append(errs, err)
		}),
		retry.Context(ctx),
		retry.UntilSucceeded(),
		retry.DelayType(retry.FixedDelay),
		retry.Delay(200*time.Millisecond),
	)
	if err != nil {
		errs = append(errs, err)
		return -1, fmt.Errorf("unable to retrieve the next available VM identifier: %w", errors.Join(errs...))
	}

	if !g.config.RandomIDs {
		var b bytes.Buffer
		_, _ = fmt.Fprintf(&b, "%d", *id)

		if err := lockedfile.Write(g.config.seqFName, &b, 0o666); err != nil {
			return -1, fmt.Errorf("unable to write the ID generator file: %w", err)
		}
	}

	return *id, nil
}

func nextSequentialID(seqFName string) (*int, error) {
	buf, err := lockedfile.Read(seqFName)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil, nil //nolint:nilnil
		}

		return nil, fmt.Errorf("unable to read the ID generator sequence file: %w", err)
	}

	id, err := strconv.Atoi(string(buf))
	if err != nil {
		return nil, fmt.Errorf("unable to parse the ID generator file: %w", err)
	}

	return ptr.Ptr(id + 1), nil
}
`````

## File: proxmox/cluster/options_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cluster

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

type userTagAccess struct {
	UserAllowList *[]string `json:"user-allow-list,omitempty"`
	UserAllow     *string   `json:"user-allow,omitempty"`
}
type tagStyle struct {
	Shape         *string           `json:"shape,omitempty"`
	CaseSensitive *types.CustomBool `json:"case-sensitive,omitempty"`
	Ordering      *string           `json:"ordering,omitempty"`
	ColorMap      *string           `json:"color-map,omitempty"`
}
type crs struct {
	HaRebalanceOnStart *types.CustomBool `json:"ha-rebalance-on-start,omitempty"`
	HA                 *string           `json:"ha,omitempty"`
}
type notify struct {
	HAFencingMode        *string `json:"fencing,omitempty"`
	HAFencingTarget      *string `json:"target-fencing,omitempty"`
	PackageUpdates       *string `json:"package-updates,omitempty"`
	PackageUpdatesTarget *string `json:"target-package-updates,omitempty"`
	Replication          *string `json:"replication,omitempty"`
	ReplicationTarget    *string `json:"target-replication,omitempty"`
}
type migration struct {
	Network *string `json:"network,omitempty"`
	Type    *string `json:"type,omitempty"`
}

type haSettings struct {
	ShutdownPolicy *string `json:"shutdown_policy,omitempty"`
}
type nextID struct {
	Upper *types.CustomInt64 `json:"upper,omitempty"`
	Lower *types.CustomInt64 `json:"lower,omitempty"`
}
type webauthn struct {
	ID     *string `json:"id,omitempty"`
	Origin *string `json:"origin,omitempty"`
	RP     *string `json:"rp,omitempty"`
}
type optionsBaseData struct {
	BandwidthLimit *string `json:"bwlimit,omitempty"     url:"bwlimit,omitempty"`
	EmailFrom      *string `json:"email_from,omitempty"  url:"email_from,omitempty"`
	Description    *string `json:"description,omitempty" url:"description,omitempty"`
	Console        *string `json:"console,omitempty"     url:"console,omitempty"`
	HTTPProxy      *string `json:"http_proxy,omitempty"  url:"http_proxy,omitempty"`
	MacPrefix      *string `json:"mac_prefix,omitempty"  url:"mac_prefix,omitempty"`
	Keyboard       *string `json:"keyboard,omitempty"    url:"keyboard,omitempty"`
	Language       *string `json:"language,omitempty"    url:"language,omitempty"`
}

// OptionsResponseBody contains the body from a cluster options response.
type OptionsResponseBody struct {
	Data *OptionsResponseData `json:"data,omitempty"`
}

// OptionsResponseData contains the data from a cluster options response.
type OptionsResponseData struct {
	optionsBaseData
	MaxWorkers                *types.CustomInt64 `json:"max_workers,omitempty"`
	ClusterResourceScheduling *crs               `json:"crs,omitempty"`
	HASettings                *haSettings        `json:"ha,omitempty"`
	TagStyle                  *tagStyle          `json:"tag-style,omitempty"`
	Migration                 *migration         `json:"migration,omitempty"`
	Webauthn                  *webauthn          `json:"webauthn,omitempty"`
	NextID                    *nextID            `json:"next-id,omitempty"`
	Notify                    *notify            `json:"notify,omitempty"`
	UserTagAccess             *userTagAccess     `json:"user-tag-access,omitempty"`
	RegisteredTags            *[]string          `json:"registered-tags,omitempty"`
}

// OptionsRequestData contains the body for cluster options request.
type OptionsRequestData struct {
	optionsBaseData
	MaxWorkers                *int64  `json:"max_workers,omitempty"     url:"max_workers,omitempty"`
	Delete                    *string `json:"delete,omitempty"          url:"delete,omitempty"`
	ClusterResourceScheduling *string `json:"crs,omitempty"             url:"crs,omitempty"`
	HASettings                *string `json:"ha,omitempty"              url:"ha,omitempty"`
	TagStyle                  *string `json:"tag-style,omitempty"       url:"tag-style,omitempty"`
	Migration                 *string `json:"migration,omitempty"       url:"migration,omitempty"`
	Webauthn                  *string `json:"webauthn,omitempty"        url:"webauthn,omitempty"`
	NextID                    *string `json:"next-id,omitempty"         url:"next-id,omitempty"`
	Notify                    *string `json:"notify,omitempty"          url:"notify,omitempty"`
	UserTagAccess             *string `json:"user-tag-access,omitempty" url:"user-tag-access,omitempty"`
	RegisteredTags            *string `json:"registered-tags,omitempty" url:"registered-tags,omitempty"`
}
`````

## File: proxmox/cluster/options.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package cluster

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetOptions retrieves the cluster options.
func (c *Client) GetOptions(ctx context.Context) (*OptionsResponseData, error) {
	resBody := &OptionsResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("options"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error reading Cluster options: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// CreateUpdateOptions updates the cluster options.
func (c *Client) CreateUpdateOptions(ctx context.Context, data *OptionsRequestData) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("options"), data, nil)
	if err != nil {
		return fmt.Errorf("error updating Cluster resource: %w", err)
	}

	return nil
}
`````

## File: proxmox/firewall/aliases_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

// AliasCreateRequestBody contains the data for an alias create request.
type AliasCreateRequestBody struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	Name    string  `json:"name"              url:"name"`
	CIDR    string  `json:"cidr"              url:"cidr"`
}

// AliasGetResponseBody contains the body from an alias get response.
type AliasGetResponseBody struct {
	Data *AliasGetResponseData `json:"data,omitempty"`
}

// AliasGetResponseData contains the data from an alias get response.
type AliasGetResponseData struct {
	Comment   *string `json:"comment,omitempty" url:"comment,omitempty"`
	Name      string  `json:"name"              url:"name"`
	CIDR      string  `json:"cidr"              url:"cidr"`
	Digest    *string `json:"digest"            url:"digest"`
	IPVersion int     `json:"ipversion"         url:"ipversion"`
}

// AliasListResponseBody contains the data from an alias get response.
type AliasListResponseBody struct {
	Data []*AliasGetResponseData `json:"data,omitempty"`
}

// AliasUpdateRequestBody contains the data for an alias update request.
type AliasUpdateRequestBody struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	ReName  string  `json:"rename"            url:"rename"`
	CIDR    string  `json:"cidr"              url:"cidr"`
}
`````

## File: proxmox/firewall/aliases.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Alias is an interface for managing firewall aliases.
type Alias interface {
	CreateAlias(ctx context.Context, d *AliasCreateRequestBody) error
	DeleteAlias(ctx context.Context, name string) error
	GetAlias(ctx context.Context, name string) (*AliasGetResponseData, error)
	ListAliases(ctx context.Context) ([]*AliasGetResponseData, error)
	UpdateAlias(ctx context.Context, name string, d *AliasUpdateRequestBody) error
}

func (c *Client) aliasesPath() string {
	return c.ExpandPath("firewall/aliases")
}

func (c *Client) aliasPath(name string) string {
	return fmt.Sprintf("%s/%s", c.aliasesPath(), url.PathEscape(name))
}

// CreateAlias create an alias.
func (c *Client) CreateAlias(ctx context.Context, d *AliasCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.aliasesPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error creating alias: %w", err)
	}

	return nil
}

// DeleteAlias delete an alias.
func (c *Client) DeleteAlias(ctx context.Context, name string) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.aliasPath(name), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting alias '%s': %w", name, err)
	}

	return nil
}

// GetAlias retrieves an alias.
func (c *Client) GetAlias(ctx context.Context, name string) (*AliasGetResponseData, error) {
	resBody := &AliasGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.aliasPath(name), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving alias '%s': %w", name, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ListAliases retrieves a list of aliases.
func (c *Client) ListAliases(ctx context.Context) ([]*AliasGetResponseData, error) {
	resBody := &AliasListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.aliasesPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving aliases: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Name < resBody.Data[j].Name
	})

	return resBody.Data, nil
}

// UpdateAlias updates an alias.
func (c *Client) UpdateAlias(ctx context.Context, name string, d *AliasUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.aliasPath(name), d, nil)
	if err != nil {
		return fmt.Errorf("error updating alias '%s': %w", name, err)
	}

	return nil
}
`````

## File: proxmox/firewall/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// API is an interface for the Proxmox firewall API.
type API interface {
	Alias
	IPSet
	Rule
	Options
}

// Client is an interface for accessing the Proxmox firewall API.
type Client struct {
	api.Client
}
`````

## File: proxmox/firewall/ipset_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// IPSetListResponseBody contains the data from an IPSet get response.
type IPSetListResponseBody struct {
	Data []*IPSetListResponseData `json:"data,omitempty"`
}

// IPSetCreateRequestBody contains the data for an IPSet create request.
type IPSetCreateRequestBody struct {
	Comment string `json:"comment,omitempty" url:"comment,omitempty"`
	Name    string `json:"name"              url:"name"`
}

// IPSetGetResponseBody contains the body from an IPSet get response.
type IPSetGetResponseBody struct {
	Data []*IPSetGetResponseData `json:"data,omitempty"`
}

// IPSetGetResponseData contains the data from an IPSet get response.
type IPSetGetResponseData struct {
	CIDR    string            `json:"cidr"              url:"cidr"`
	NoMatch *types.CustomBool `json:"nomatch,omitempty" url:"nomatch,omitempty,int"`
	Comment *string           `json:"comment,omitempty" url:"comment,omitempty"`
}

// IPSetUpdateRequestBody contains the data for an IPSet update request.
type IPSetUpdateRequestBody struct {
	ReName  string  `json:"rename,omitempty"  url:"rename,omitempty"`
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	Name    string  `json:"name"              url:"name"`
}

// IPSetListResponseData contains list of IPSets from.
type IPSetListResponseData struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	Name    string  `json:"name"              url:"name"`
}

// IPSetContent is an array of IPSetGetResponseData.
type IPSetContent []IPSetGetResponseData
`````

## File: proxmox/firewall/ipset.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

/**
* Reference: https://pve.proxmox.com/pve-docs/api-viewer/#/cluster/firewall/ipset
 */

package firewall

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// IPSet is an interface for managing IP sets.
type IPSet interface {
	CreateIPSet(ctx context.Context, d *IPSetCreateRequestBody) error
	AddCIDRToIPSet(ctx context.Context, id string, d IPSetGetResponseData) error
	UpdateIPSet(ctx context.Context, d *IPSetUpdateRequestBody) error
	DeleteIPSet(ctx context.Context, id string) error
	DeleteIPSetContent(ctx context.Context, id string, cidr string) error
	GetIPSetContent(ctx context.Context, id string) ([]*IPSetGetResponseData, error)
	ListIPSets(ctx context.Context) ([]*IPSetListResponseData, error)
}

func (c *Client) ipsetPath() string {
	return c.ExpandPath("firewall/ipset")
}

// CreateIPSet create an IPSet.
func (c *Client) CreateIPSet(ctx context.Context, d *IPSetCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ipsetPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error creating IPSet: %w", err)
	}

	return nil
}

// AddCIDRToIPSet adds IP or Network to IPSet.
func (c *Client) AddCIDRToIPSet(ctx context.Context, id string, d IPSetGetResponseData) error {
	err := c.DoRequest(
		ctx,
		http.MethodPost,
		fmt.Sprintf("%s/%s", c.ipsetPath(), url.PathEscape(id)),
		&d,
		nil,
	)
	if err != nil {
		return fmt.Errorf("error adding CIDR to IPSet: %w", err)
	}

	return nil
}

// UpdateIPSet updates an IPSet.
func (c *Client) UpdateIPSet(ctx context.Context, d *IPSetUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ipsetPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error updating IPSet: %w", err)
	}

	return nil
}

// DeleteIPSet delete an IPSet.
func (c *Client) DeleteIPSet(ctx context.Context, id string) error {
	err := c.DoRequest(
		ctx,
		http.MethodDelete,
		fmt.Sprintf("%s/%s", c.ipsetPath(), url.PathEscape(id)),
		nil,
		nil,
	)
	if err != nil {
		return fmt.Errorf("error deleting IPSet %s: %w", id, err)
	}

	return nil
}

// DeleteIPSetContent remove IP or Network from IPSet.
func (c *Client) DeleteIPSetContent(ctx context.Context, id string, cidr string) error {
	err := c.DoRequest(
		ctx,
		http.MethodDelete,
		fmt.Sprintf("%s/%s/%s", c.ipsetPath(), url.PathEscape(id), url.PathEscape(cidr)),
		nil,
		nil,
	)
	if err != nil {
		return fmt.Errorf("error deleting IPSet content %s: %w", id, err)
	}

	return nil
}

// GetIPSetContent retrieve a list of IPSet content.
func (c *Client) GetIPSetContent(ctx context.Context, id string) ([]*IPSetGetResponseData, error) {
	resBody := &IPSetGetResponseBody{}

	err := c.DoRequest(
		ctx,
		http.MethodGet,
		fmt.Sprintf("%s/%s", c.ipsetPath(), url.PathEscape(id)),
		nil,
		resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error getting IPSet content: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ListIPSets retrieves list of IPSets.
func (c *Client) ListIPSets(ctx context.Context) ([]*IPSetListResponseData, error) {
	resBody := &IPSetListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ipsetPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error getting IPSet list: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Name < resBody.Data[j].Name
	})

	return resBody.Data, nil
}
`````

## File: proxmox/firewall/options_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// OptionsPutRequestBody is the request body for the PUT /cluster/firewall/options API call.
type OptionsPutRequestBody struct {
	DHCP        *types.CustomBool `json:"dhcp,omitempty"          url:"dhcp,omitempty,int"`
	Enable      *types.CustomBool `json:"enable,omitempty"        url:"enable,omitempty,int"`
	IPFilter    *types.CustomBool `json:"ipfilter,omitempty"      url:"ipfilter,omitempty,int"`
	LogLevelIN  *string           `json:"log_level_in,omitempty"  url:"log_level_in,omitempty"`
	LogLevelOUT *string           `json:"log_level_out,omitempty" url:"log_level_out,omitempty"`
	MACFilter   *types.CustomBool `json:"macfilter,omitempty"     url:"macfilter,omitempty,int"`
	NDP         *types.CustomBool `json:"ndp,omitempty"           url:"ndp,omitempty,int"`
	PolicyIn    *string           `json:"policy_in,omitempty"     url:"policy_in,omitempty"`
	PolicyOut   *string           `json:"policy_out,omitempty"    url:"policy_out,omitempty"`
	RAdv        *types.CustomBool `json:"radv,omitempty"          url:"radv,omitempty,int"`
}

// OptionsGetResponseBody is the response body for the GET /cluster/firewall/options API call.
type OptionsGetResponseBody struct {
	Data *OptionsGetResponseData `json:"data,omitempty"`
}

// OptionsGetResponseData is the data field of the response body for the GET /cluster/firewall/options API call.
type OptionsGetResponseData struct {
	DHCP        *types.CustomBool `json:"dhcp"          url:"dhcp,int"`
	Enable      *types.CustomBool `json:"enable"        url:"enable,int"`
	IPFilter    *types.CustomBool `json:"ipfilter"      url:"ipfilter,int"`
	LogLevelIN  *string           `json:"log_level_in"  url:"log_level_in"`
	LogLevelOUT *string           `json:"log_level_out" url:"log_level_out"`
	MACFilter   *types.CustomBool `json:"macfilter"     url:"macfilter,int"`
	NDP         *types.CustomBool `json:"ndp"           url:"ndp,int"`
	PolicyIn    *string           `json:"policy_in"     url:"policy_in"`
	PolicyOut   *string           `json:"policy_out"    url:"policy_out"`
	RAdv        *types.CustomBool `json:"radv"          url:"radv,int"`
}
`````

## File: proxmox/firewall/options.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"fmt"
	"net/http"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Options is an interface for the Proxmox firewall options API.
type Options interface {
	GetOptionsID() string
	SetOptions(ctx context.Context, d *OptionsPutRequestBody) error
	GetOptions(ctx context.Context) (*OptionsGetResponseData, error)
}

func (c *Client) optionsPath() string {
	return c.ExpandPath("firewall/options")
}

// GetOptionsID returns the ID of the options object.
func (c *Client) GetOptionsID() string {
	return "options-" + strconv.Itoa(schema.HashString(c.optionsPath()))
}

// SetOptions sets the options object.
func (c *Client) SetOptions(ctx context.Context, d *OptionsPutRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.optionsPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error setting optionss: %w", err)
	}

	return nil
}

// GetOptions retrieves the options object.
func (c *Client) GetOptions(ctx context.Context) (*OptionsGetResponseData, error) {
	resBody := &OptionsGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.optionsPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving options: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/firewall/rules_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

// RuleCreateRequestBody contains the data for a firewall rule create request.
type RuleCreateRequestBody struct {
	BaseRule

	Action string `json:"action" url:"action"`
	Type   string `json:"type"   url:"type"`

	Group *string `json:"group,omitempty" url:"group,omitempty"`
}

// RuleGetResponseBody contains the body from a firewall rule get response.
type RuleGetResponseBody struct {
	Data *RuleGetResponseData `json:"data,omitempty"`
}

// RuleGetResponseData contains the data from a firewall rule get response.
type RuleGetResponseData struct {
	BaseRule

	// NOTE: This is `int` in the PVE API docs, but it's actually a string in the response.
	Pos    string `json:"pos"    url:"pos"`
	Action string `json:"action" url:"action"`
	Type   string `json:"type"   url:"type"`
}

// RuleListResponseBody contains the data from a firewall rule get response.
type RuleListResponseBody struct {
	Data []*RuleListResponseData `json:"data,omitempty"`
}

// RuleListResponseData contains the data from a firewall rule get response.
type RuleListResponseData struct {
	Pos int `json:"pos" url:"pos"`
}

// RuleUpdateRequestBody contains the data for a firewall rule update request.
type RuleUpdateRequestBody struct {
	BaseRule

	Pos    *int    `json:"pos,omitempty"    url:"pos,omitempty"`
	Action *string `json:"action,omitempty" url:"action,omitempty"`
	Type   *string `json:"type,omitempty"   url:"type,omitempty"`

	Group *string `json:"group,omitempty" url:"group,omitempty"`
}
`````

## File: proxmox/firewall/rules.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"fmt"
	"net/http"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// Rule is an interface for the Proxmox firewall rule API.
type Rule interface {
	GetRulesID() string
	CreateRule(ctx context.Context, d *RuleCreateRequestBody) error
	GetRule(ctx context.Context, pos int) (*RuleGetResponseData, error)
	ListRules(ctx context.Context) ([]*RuleListResponseData, error)
	UpdateRule(ctx context.Context, pos int, d *RuleUpdateRequestBody) error
	DeleteRule(ctx context.Context, pos int) error
}

// BaseRule is the base struct for firewall rules.
type BaseRule struct {
	Comment  *string           `json:"comment,omitempty"   url:"comment,omitempty"`
	Dest     *string           `json:"dest,omitempty"      url:"dest,omitempty"`
	Digest   *string           `json:"digest,omitempty"    url:"digest,omitempty"`
	DPort    *string           `json:"dport,omitempty"     url:"dport,omitempty"`
	Enable   *types.CustomBool `json:"enable,omitempty"    url:"enable,omitempty,int"`
	ICMPType *string           `json:"icmp-type,omitempty" url:"icmp-type,omitempty"`
	IFace    *string           `json:"iface,omitempty"     url:"iface,omitempty"`
	Log      *string           `json:"log,omitempty"       url:"log,omitempty"`
	Macro    *string           `json:"macro,omitempty"     url:"macro,omitempty"`
	Proto    *string           `json:"proto,omitempty"     url:"proto,omitempty"`
	Source   *string           `json:"source,omitempty"    url:"source,omitempty"`
	SPort    *string           `json:"sport,omitempty"     url:"sport,omitempty"`
}

func (c *Client) rulesPath() string {
	return c.ExpandPath("firewall/rules")
}

func (c *Client) rulePath(pos int) string {
	return fmt.Sprintf("%s/%d", c.rulesPath(), pos)
}

// GetRulesID returns the ID of the rules object.
func (c *Client) GetRulesID() string {
	return "rule-" + strconv.Itoa(schema.HashString(c.rulesPath()))
}

// CreateRule creates a firewall rule.
func (c *Client) CreateRule(ctx context.Context, d *RuleCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.rulesPath(), d, nil)
	if err != nil {
		return fmt.Errorf("error creating firewall rule: %w", err)
	}

	return nil
}

// GetRule retrieves a firewall rule.
func (c *Client) GetRule(ctx context.Context, pos int) (*RuleGetResponseData, error) {
	resBody := &RuleGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.rulePath(pos), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving firewall rule %d: %w", pos, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ListRules retrieves a list of firewall rules.
func (c *Client) ListRules(ctx context.Context) ([]*RuleListResponseData, error) {
	resBody := &RuleListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.rulesPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving firewall rules: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateRule updates a firewall rule.
func (c *Client) UpdateRule(ctx context.Context, pos int, d *RuleUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.rulePath(pos), d, nil)
	if err != nil {
		return fmt.Errorf("error updating firewall rule %d: %w", pos, err)
	}

	return nil
}

// DeleteRule deletes a firewall rule.
func (c *Client) DeleteRule(ctx context.Context, pos int) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.rulePath(pos), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting firewall rule %d: %w", pos, err)
	}

	return nil
}
`````

## File: proxmox/helpers/ptr/ptr.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ptr

// Ptr creates a ptr from a value to use it inline.
func Ptr[T any](val T) *T {
	return &val
}

// Or will dereference a pointer and return the given value if it's nil.
func Or[T any](p *T, or T) T {
	if p != nil {
		return *p
	}

	return or
}

// Eq compares two pointers and returns true if they are equal.
func Eq[T comparable](a, b *T) bool {
	if a == nil && b == nil {
		return true
	}

	if a == nil || b == nil {
		return false
	}

	return *a == *b
}

// UpdateIfChanged updates dst with src if src is not nil and different from dst.
// Returns true if an update was made.
func UpdateIfChanged[T comparable](dst **T, src *T) bool {
	if src != nil && !Eq(*dst, src) {
		*dst = src
		return true
	}

	return false
}
`````

## File: proxmox/nodes/apt/repositories/repositories.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package repositories

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox node APT repositories API.
type Client struct {
	api.Client
}

// basePath returns the expanded APT repositories API base path.
func (c *Client) basePath() string {
	return c.Client.ExpandPath("repositories")
}

// Add adds an APT standard repository entry.
func (c *Client) Add(ctx context.Context, data *AddRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath(), data, nil)
	if err != nil {
		return fmt.Errorf("adding APT standard repository: %w", err)
	}

	return nil
}

// ExpandPath expands a relative path to a full APT repositories API path.
func (c *Client) ExpandPath() string {
	return c.basePath()
}

// Get retrieves all APT repositories.
func (c *Client) Get(ctx context.Context) (*GetResponseData, error) {
	resBody := &GetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("reading APT repositories: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// Modify modifies the activation status of an APT repository.
func (c *Client) Modify(ctx context.Context, data *ModifyRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath(), data, nil)
	if err != nil {
		return fmt.Errorf(
			`modifying APT repository in file %s at index %d to activation state %v: %w`,
			data.Path,
			data.Index,
			data.Enabled,
			err,
		)
	}

	return nil
}
`````

## File: proxmox/nodes/apt/repositories/types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package repositories

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// baseData contains common data for APT repository API calls.
type baseData struct {
	Digest *string `json:"digest,omitempty" url:"digest,omitempty"`
}

// file contains the data of a parsed APT repository file.
type file struct {
	// FileType is the format of the file.
	FileType string `json:"file-type"`

	// Path is the path to the repository file.
	Path string `json:"path"`

	// Repositories is the list of parsed repositories.
	Repositories []*repo `json:"repositories"`
}

// repo contains the data of an APT repository from a parsed file.
type repo struct {
	// Comment is the associated comment.
	Comment *string `json:"Comment,omitempty"`

	// Components is the list of repository components.
	Components []string `json:"Components,omitempty"`

	// Enabled indicates whether the repository is enabled.
	Enabled types.CustomBool `json:"Enabled"`

	// FileTpe is the format of the defining file.
	FileType string `json:"FileType"`

	// PackageTypes is the list of package types.
	PackageTypes []string `json:"Types"`

	// Suites is the list of package distributions.
	Suites []string `json:"Suites"`

	// URIs is the list of repository URIs.
	URIs []string `json:"URIs"`
}

// standardRepo contains the data for an APT standard repository.
type standardRepo struct {
	// Description is the description of the APT standard repository.
	Description *string `json:"description,omitempty"`

	// Handle is the pre-defined handle of the APT standard repository.
	Handle string `json:"handle"`

	// Name is the human-readable name of the APT standard repository.
	Name string `json:"Name"`

	// Status is the activation status of the APT standard repository.
	// Can be either 0 (disabled) or 1 (enabled).
	Status *int64 `json:"status,omitempty"`
}

// AddRequestBody contains the body for an APT repository PUT request to add a standard repository.
type AddRequestBody struct {
	baseData

	// Handle is the pre-defined handle of the APT standard repository.
	Handle string `json:"handle" url:"handle"`

	// Node is the name of the target Proxmox VE node.
	Node string `json:"node" url:"node"`
}

// GetResponseBody is the body from an APT repository GET response.
type GetResponseBody struct {
	Data *GetResponseData `json:"data,omitempty"`
}

// GetResponseData contains the data from an APT repository GET response.
type GetResponseData struct {
	baseData

	// Files contains the APT repository files.
	Files []*file `json:"files,omitempty"`

	// StandardRepos contains the APT standard repositories.
	StandardRepos []*standardRepo `json:"standard-repos,omitempty"`
}

// ModifyRequestBody contains the body for an APT repository POST request to modify a repository.
type ModifyRequestBody struct {
	baseData

	// Enabled indicates the activation status of the APT repository.
	// Must either be 0 (disabled) or 1 (enabled).
	Enabled types.CustomBool `json:"enabled" url:"enabled,int"`

	// Index is the index of the APT repository within the defining repository source file.
	Index int64 `json:"handle" url:"index"`

	// Path is the absolute path of the defining source file for the APT repository.
	Path string `json:"path" url:"path"`
}
`````

## File: proxmox/nodes/apt/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package apt

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/apt/repositories"
)

// Client is an interface for accessing the Proxmox cluster API.
type Client struct {
	api.Client
}

// ExpandPath expands a relative path to a full cluster API path.
func (c *Client) ExpandPath(path string) string {
	return c.Client.ExpandPath(fmt.Sprintf("apt/%s", path))
}

// Repositories returns a client for managing APT repositories.
func (c *Client) Repositories() *repositories.Client {
	return &repositories.Client{Client: c}
}
`````

## File: proxmox/nodes/containers/firewall/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
)

// Client is an interface for accessing the Proxmox container firewall API.
type Client struct {
	firewall.Client
}
`````

## File: proxmox/nodes/containers/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package containers

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	containerfirewall "github.com/bpg/terraform-provider-proxmox/proxmox/nodes/containers/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/tasks"
)

// Client is an interface for accessing the Proxmox container API.
type Client struct {
	api.Client
	VMID int
}

func (c *Client) basePath() string {
	return c.Client.ExpandPath("lxc")
}

// ExpandPath expands a relative path to a full container API path.
func (c *Client) ExpandPath(path string) string {
	ep := fmt.Sprintf("%s/%d", c.basePath(), c.VMID)
	if path != "" {
		ep = fmt.Sprintf("%s/%s", ep, path)
	}

	return ep
}

// Tasks returns a client for managing container tasks.
func (c *Client) Tasks() *tasks.Client {
	return &tasks.Client{
		Client: c.Client,
	}
}

// Firewall returns a client for managing the container firewall.
func (c *Client) Firewall() firewall.API {
	return &containerfirewall.Client{
		Client: firewall.Client{Client: c},
	}
}
`````

## File: proxmox/nodes/containers/containers_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package containers

import (
	"encoding/json"
	"fmt"
	"net/url"
	"regexp"
	"strconv"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	// regexDeviceKey matches device keys like dev0, dev1, etc.
	regexDeviceKey = regexp.MustCompile(`^dev\d+$`)
	// regexNetworkKey matches network interface keys like net0, net1, etc.
	regexNetworkKey = regexp.MustCompile(`^net\d+$`)
	// regexMountPointKey matches mount point keys like mp0, mp1, etc.
	regexMountPointKey = regexp.MustCompile(`^mp\d+$`)
)

// CloneRequestBody contains the data for an container clone request.
type CloneRequestBody struct {
	BandwidthLimit *int              `json:"bwlimit,omitempty"     url:"bwlimit,omitempty"`
	Description    *string           `json:"description,omitempty" url:"description,omitempty"`
	FullCopy       *types.CustomBool `json:"full,omitempty"        url:"full,omitempty,int"`
	Hostname       *string           `json:"hostname,omitempty"    url:"hostname,omitempty"`
	PoolID         *string           `json:"pool,omitempty"        url:"pool,omitempty"`
	SnapshotName   *string           `json:"snapname,omitempty"    url:"snapname,omitempty"`
	TargetNodeName *string           `json:"target,omitempty"      url:"target,omitempty"`
	TargetStorage  *string           `json:"storage,omitempty"     url:"storage,omitempty"`
	VMIDNew        int               `json:"newid"                 url:"newid"`
}

// CreateRequestBody contains the data for a user create request.
type CreateRequestBody struct {
	BandwidthLimit       *float64                 `json:"bwlimit,omitempty"              url:"bwlimit,omitempty"`
	ConsoleEnabled       *types.CustomBool        `json:"console,omitempty"              url:"console,omitempty,int"`
	ConsoleMode          *string                  `json:"cmode,omitempty"                url:"cmode,omitempty"`
	CPUArchitecture      *string                  `json:"arch,omitempty"                 url:"arch,omitempty"`
	CPUCores             *int                     `json:"cores,omitempty"                url:"cores,omitempty"`
	CPULimit             *int                     `json:"cpulimit,omitempty"             url:"cpulimit,omitempty"`
	CPUUnits             *int                     `json:"cpuunits,omitempty"             url:"cpuunits,omitempty"`
	DatastoreID          *string                  `json:"storage,omitempty"              url:"storage,omitempty"`
	DedicatedMemory      *int                     `json:"memory,omitempty"               url:"memory,omitempty"`
	Delete               []string                 `json:"delete,omitempty"               url:"delete,omitempty"`
	Description          *string                  `json:"description,omitempty"          url:"description,omitempty"`
	DNSDomain            *string                  `json:"searchdomain,omitempty"         url:"searchdomain,omitempty"`
	DNSServer            *string                  `json:"nameserver,omitempty"           url:"nameserver,omitempty"`
	Features             *CustomFeatures          `json:"features,omitempty"             url:"features,omitempty"`
	Force                *types.CustomBool        `json:"force,omitempty"                url:"force,omitempty,int"`
	HookScript           *string                  `json:"hookscript,omitempty"           url:"hookscript,omitempty"`
	Hostname             *string                  `json:"hostname,omitempty"             url:"hostname,omitempty"`
	IgnoreUnpackErrors   *types.CustomBool        `json:"ignore-unpack-errors,omitempty" url:"force,omitempty,int"`
	Lock                 *string                  `json:"lock,omitempty"                 url:"lock,omitempty,int"`
	MountPoints          CustomMountPoints        `json:"mp,omitempty"                   url:"mp,omitempty,numbered"`
	PassthroughDevices   CustomPassthroughDevices `json:"dev,omitempty"                  url:"dev,omitempty,numbered"`
	NetworkInterfaces    CustomNetworkInterfaces  `json:"net,omitempty"                  url:"net,omitempty,numbered"`
	OSTemplateFileVolume *string                  `json:"ostemplate,omitempty"           url:"ostemplate,omitempty"`
	OSType               *string                  `json:"ostype,omitempty"               url:"ostype,omitempty"`
	Password             *string                  `json:"password,omitempty"             url:"password,omitempty"`
	PoolID               *string                  `json:"pool,omitempty"                 url:"pool,omitempty"`
	Protection           *types.CustomBool        `json:"protection,omitempty"           url:"protection,omitempty,int"`
	Restore              *types.CustomBool        `json:"restore,omitempty"              url:"restore,omitempty,int"`
	RootFS               *CustomRootFS            `json:"rootfs,omitempty"               url:"rootfs,omitempty"`
	SSHKeys              *CustomSSHKeys           `json:"ssh-public-keys,omitempty"      url:"ssh-public-keys,omitempty"`
	Start                *types.CustomBool        `json:"start,omitempty"                url:"start,omitempty,int"`
	StartOnBoot          *types.CustomBool        `json:"onboot,omitempty"               url:"onboot,omitempty,int"`
	StartupBehavior      *CustomStartupBehavior   `json:"startup,omitempty"              url:"startup,omitempty"`
	Swap                 *int                     `json:"swap,omitempty"                 url:"swap,omitempty"`
	Tags                 *string                  `json:"tags,omitempty"                 url:"tags,omitempty"`
	Template             *types.CustomBool        `json:"template,omitempty"             url:"template,omitempty,int"`
	TTY                  *int                     `json:"tty,omitempty"                  url:"tty,omitempty"`
	Unique               *types.CustomBool        `json:"unique,omitempty"               url:"unique,omitempty,int"`
	Unprivileged         *types.CustomBool        `json:"unprivileged,omitempty"         url:"unprivileged,omitempty,int"`
	VMID                 *int                     `json:"vmid,omitempty"                 url:"vmid,omitempty"`
}

// CustomFeatures contains the values for the "features" property.
type CustomFeatures struct {
	FUSE       *types.CustomBool `json:"fuse,omitempty"    url:"fuse,omitempty,int"`
	KeyControl *types.CustomBool `json:"keyctl,omitempty"  url:"keyctl,omitempty,int"`
	MountTypes *[]string         `json:"mount,omitempty"   url:"mount,omitempty"`
	Nesting    *types.CustomBool `json:"nesting,omitempty" url:"nesting,omitempty,int"`
}

// CustomMountPoint contains the values for the "mp[n]" properties.
type CustomMountPoint struct {
	ACL          *types.CustomBool `json:"acl,omitempty"          url:"acl,omitempty,int"`
	Backup       *types.CustomBool `json:"backup,omitempty"       url:"backup,omitempty,int"`
	DiskSize     *string           `json:"size,omitempty"         url:"size,omitempty"` // read-only
	Enabled      bool              `json:"-"                      url:"-"`
	MountOptions *[]string         `json:"mountoptions,omitempty" url:"mountoptions,omitempty"`
	MountPoint   string            `json:"mp"                     url:"mp"`
	Quota        *types.CustomBool `json:"quota,omitempty"        url:"quota,omitempty,int"`
	ReadOnly     *types.CustomBool `json:"ro,omitempty"           url:"ro,omitempty,int"`
	Replicate    *types.CustomBool `json:"replicate,omitempty"    url:"replicate,omitempty,int"`
	Shared       *types.CustomBool `json:"shared,omitempty"       url:"shared,omitempty,int"`
	Volume       string            `json:"volume"                 url:"volume"`
}

// CustomMountPoints is a map of CustomMountPoint per mount point ID (i.e. `mp1`).
type CustomMountPoints map[string]*CustomMountPoint

// CustomNetworkInterface contains the values for the "net[n]" properties.
type CustomNetworkInterface struct {
	Bridge      *string           `json:"bridge,omitempty"   url:"bridge,omitempty"`
	Enabled     bool              `json:"-"                  url:"-"`
	Firewall    *types.CustomBool `json:"firewall,omitempty" url:"firewall,omitempty,int"`
	IPv4Address *string           `json:"ip,omitempty"       url:"ip,omitempty"`
	IPv4Gateway *string           `json:"gw,omitempty"       url:"gw,omitempty"`
	IPv6Address *string           `json:"ip6,omitempty"      url:"ip6,omitempty"`
	IPv6Gateway *string           `json:"gw6,omitempty"      url:"gw6,omitempty"`
	MACAddress  *string           `json:"hwaddr,omitempty"   url:"hwaddr,omitempty"`
	MTU         *int              `json:"mtu,omitempty"      url:"mtu,omitempty"`
	Name        string            `json:"name"               url:"name"`
	RateLimit   *float64          `json:"rate,omitempty"     url:"rate,omitempty"`
	Tag         *int              `json:"tag,omitempty"      url:"tag,omitempty"`
	Trunks      *[]int            `json:"trunks,omitempty"   url:"trunks,omitempty"`
	Type        *string           `json:"type,omitempty"     url:"type,omitempty"`
}

// CustomPassthroughDevices is a map of CustomPassthroughDevice per passthrough device ID (i.e. `dev0`).
type CustomPassthroughDevices map[string]*CustomPassthroughDevice

// CustomPassthroughDevice contains the values for the "dev[n]" properties.
type CustomPassthroughDevice struct {
	DenyWrite *types.CustomBool `json:"deny-write,omitempty" url:"deny-write,omitempty,int"`
	Path      string            `json:"path"                 url:"path"`
	UID       *int              `json:"uid,omitempty"        url:"uid,omitempty"`
	GID       *int              `json:"gid,omitempty"        url:"gid,omitempty"`
	Mode      *string           `json:"mode,omitempty"       url:"mode,omitempty"`
}

// CustomNetworkInterfaces is a map of CustomNetworkInterface per network interface ID (i.e. `net0`).
type CustomNetworkInterfaces map[string]*CustomNetworkInterface

// CustomRootFS contains the values for the "rootfs" property.
type CustomRootFS struct {
	ACL          *types.CustomBool `json:"acl,omitempty"          url:"acl,omitempty,int"`
	Size         *types.DiskSize   `json:"size,omitempty"         url:"size,omitempty"`
	MountOptions *[]string         `json:"mountoptions,omitempty" url:"mountoptions,omitempty"`
	Quota        *types.CustomBool `json:"quota,omitempty"        url:"quota,omitempty,int"`
	ReadOnly     *types.CustomBool `json:"ro,omitempty"           url:"ro,omitempty,int"`
	Replicate    *types.CustomBool `json:"replicate,omitempty"    url:"replicate,omitempty,int"`
	Shared       *types.CustomBool `json:"shared,omitempty"       url:"shared,omitempty,int"`
	Volume       string            `json:"volume"                 url:"volume"`
}

// CustomSSHKeys contains the values for the "ssh-public-keys" property.
type CustomSSHKeys []string

// CustomStartupBehavior contains the values for the "startup" property.
type CustomStartupBehavior struct {
	Down  *int `json:"down,omitempty"  url:"down,omitempty"`
	Order *int `json:"order,omitempty" url:"order,omitempty"`
	Up    *int `json:"up,omitempty"    url:"up,omitempty"`
}

// CreateResponseBody contains the body from a container create response.
type CreateResponseBody struct {
	Data *string `json:"data,omitempty"`
}

type ShutdownResponseBody = CreateResponseBody

// GetResponseBody contains the body from a user get response.
type GetResponseBody struct {
	Data *GetResponseData `json:"data,omitempty"`
}

// GetResponseData contains the data from a user get response.
type GetResponseData struct {
	ConsoleEnabled     *types.CustomBool        `json:"console,omitempty"`
	ConsoleMode        *string                  `json:"cmode,omitempty"`
	CPUArchitecture    *string                  `json:"arch,omitempty"`
	CPUCores           *int                     `json:"cores,omitempty"`
	CPULimit           *types.CustomInt         `json:"cpulimit,omitempty"`
	CPUUnits           *int                     `json:"cpuunits,omitempty"`
	DedicatedMemory    *int                     `json:"memory,omitempty"`
	Description        *string                  `json:"description,omitempty"`
	Digest             string                   `json:"digest"`
	DNSDomain          *string                  `json:"searchdomain,omitempty"`
	DNSServer          *string                  `json:"nameserver,omitempty"`
	Features           *CustomFeatures          `json:"features,omitempty"`
	HookScript         *string                  `json:"hookscript,omitempty"`
	Hostname           *string                  `json:"hostname,omitempty"`
	Lock               *types.CustomBool        `json:"lock,omitempty"`
	LXCConfiguration   *[][2]string             `json:"lxc,omitempty"`
	MountPoints        CustomMountPoints        `json:"mp,omitempty"`
	PassthroughDevices CustomPassthroughDevices `json:"dev,omitempty"`
	NetworkInterfaces  CustomNetworkInterfaces  `json:"net,omitempty"`
	OSType             *string                  `json:"ostype,omitempty"`
	Protection         *types.CustomBool        `json:"protection,omitempty"`
	RootFS             *CustomRootFS            `json:"rootfs,omitempty"`
	StartOnBoot        *types.CustomBool        `json:"onboot,omitempty"`
	StartupBehavior    *CustomStartupBehavior   `json:"startup,omitempty"`
	Swap               *int                     `json:"swap,omitempty"`
	Tags               *string                  `json:"tags,omitempty"`
	Template           *types.CustomBool        `json:"template,omitempty"`
	TTY                *int                     `json:"tty,omitempty"`
	Unprivileged       *types.CustomBool        `json:"unprivileged,omitempty"`
}

// GetStatusResponseBody contains the body from a container get status response.
type GetStatusResponseBody struct {
	Data *GetStatusResponseData `json:"data,omitempty"`
}

// GetStatusResponseData contains the data from a container get status response.
type GetStatusResponseData struct {
	CPUCount         *float64         `json:"cpus,omitempty"`
	Lock             *string          `json:"lock,omitempty"`
	MemoryAllocation *int             `json:"maxmem,omitempty"`
	Name             *string          `json:"name,omitempty"`
	RootDiskSize     *interface{}     `json:"maxdisk,omitempty"`
	Status           string           `json:"status,omitempty"`
	SwapAllocation   *int             `json:"maxswap,omitempty"`
	Tags             *string          `json:"tags,omitempty"`
	Uptime           *int             `json:"uptime,omitempty"`
	VMID             *types.CustomInt `json:"vmid,omitempty"`
}

// StartResponseBody contains the body from a container start response.
type StartResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// RebootRequestBody contains the body for a container reboot request.
type RebootRequestBody struct {
	Timeout *int `json:"timeout,omitempty" url:"timeout,omitempty"`
}

// ShutdownRequestBody contains the body for a container shutdown request.
type ShutdownRequestBody struct {
	ForceStop *types.CustomBool `json:"forceStop,omitempty" url:"forceStop,omitempty,int"`
	Timeout   *int              `json:"timeout,omitempty"   url:"timeout,omitempty"`
}

// UpdateRequestBody contains the data for an user update request.
type UpdateRequestBody CreateRequestBody

// EncodeValues converts a ContainerCustomFeatures struct to a URL value.
func (r *CustomFeatures) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.FUSE != nil {
		if *r.FUSE {
			values = append(values, "fuse=1")
		} else {
			values = append(values, "fuse=0")
		}
	}

	if r.KeyControl != nil {
		if *r.KeyControl {
			values = append(values, "keyctl=1")
		} else {
			values = append(values, "keyctl=0")
		}
	}

	if r.MountTypes != nil {
		if len(*r.MountTypes) > 0 {
			values = append(values, fmt.Sprintf("mount=%s", strings.Join(*r.MountTypes, ";")))
		}
	}

	if r.Nesting != nil {
		if *r.Nesting {
			values = append(values, "nesting=1")
		} else {
			values = append(values, "nesting=0")
		}
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// EncodeValues converts a CustomPassthroughDevice struct to a URL value.
func (r *CustomPassthroughDevice) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.DenyWrite != nil {
		if *r.DenyWrite {
			values = append(values, "deny-write=1")
		} else {
			values = append(values, "deny-write=0")
		}
	}

	if r.Path != "" {
		values = append(values, fmt.Sprintf("path=%s", r.Path))
	}

	if r.UID != nil {
		values = append(values, fmt.Sprintf("uid=%d", *r.UID))
	}

	if r.GID != nil {
		values = append(values, fmt.Sprintf("gid=%d", *r.GID))
	}

	if r.Mode != nil && *r.Mode != "" {
		values = append(values, fmt.Sprintf("mode=%s", *r.Mode))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// EncodeValues converts a CustomPassthroughDevices array to multiple URL values.
func (r CustomPassthroughDevices) EncodeValues(
	_ string,
	v *url.Values,
) error {
	for key, d := range r {
		if err := d.EncodeValues(key, v); err != nil {
			return fmt.Errorf("failed to encode CustomPassthroughDevices: %w", err)
		}
	}

	return nil
}

// EncodeValues converts a CustomMountPoint struct to a URL value.
func (r *CustomMountPoint) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.ACL != nil {
		if *r.ACL {
			values = append(values, "acl=1")
		} else {
			values = append(values, "acl=0")
		}
	}

	if r.Backup != nil {
		if *r.Backup {
			values = append(values, "backup=1")
		} else {
			values = append(values, "backup=0")
		}
	}

	if r.DiskSize != nil {
		values = append(values, fmt.Sprintf("size=%s", *r.DiskSize))
	}

	if r.MountOptions != nil {
		if len(*r.MountOptions) > 0 {
			values = append(values, fmt.Sprintf("mountoptions=%s", strings.Join(*r.MountOptions, ";")))
		}
	}

	values = append(values, fmt.Sprintf("mp=%s", r.MountPoint))

	if r.Quota != nil {
		if *r.Quota {
			values = append(values, "quota=1")
		} else {
			values = append(values, "quota=0")
		}
	}

	if r.ReadOnly != nil {
		if *r.ReadOnly {
			values = append(values, "ro=1")
		} else {
			values = append(values, "ro=0")
		}
	}

	if r.Replicate != nil {
		if *r.Replicate {
			values = append(values, "replicate=1")
		} else {
			values = append(values, "replicate=0")
		}
	}

	if r.Shared != nil {
		if *r.Shared {
			values = append(values, "shared=1")
		} else {
			values = append(values, "shared=0")
		}
	}

	values = append(values, fmt.Sprintf("volume=%s", r.Volume))

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// EncodeValues converts a CustomMountPoints array to multiple URL values.
func (r CustomMountPoints) EncodeValues(
	_ string,
	v *url.Values,
) error {
	for key, d := range r {
		if err := d.EncodeValues(key, v); err != nil {
			return fmt.Errorf("failed to encode CustomMountPoints: %w", err)
		}
	}

	return nil
}

// EncodeValues converts a CustomNetworkInterface struct to a URL value.
func (r *CustomNetworkInterface) EncodeValues(
	key string,
	v *url.Values,
) error {
	var values []string

	if r.Bridge != nil {
		values = append(values, fmt.Sprintf("bridge=%s", *r.Bridge))
	}

	if r.Firewall != nil {
		if *r.Firewall {
			values = append(values, "firewall=1")
		} else {
			values = append(values, "firewall=0")
		}
	}

	if r.IPv4Address != nil {
		values = append(values, fmt.Sprintf("ip=%s", *r.IPv4Address))
	}

	if r.IPv4Gateway != nil {
		values = append(values, fmt.Sprintf("gw=%s", *r.IPv4Gateway))
	}

	if r.IPv6Address != nil {
		values = append(values, fmt.Sprintf("ip6=%s", *r.IPv6Address))
	}

	if r.IPv6Gateway != nil {
		values = append(values, fmt.Sprintf("gw6=%s", *r.IPv6Gateway))
	}

	if r.MACAddress != nil {
		values = append(values, fmt.Sprintf("hwaddr=%s", *r.MACAddress))
	}

	if r.MTU != nil {
		values = append(values, fmt.Sprintf("mtu=%d", *r.MTU))
	}

	values = append(values, fmt.Sprintf("name=%s", r.Name))

	if r.RateLimit != nil {
		values = append(values, fmt.Sprintf("rate=%.2f", *r.RateLimit))
	}

	if r.Tag != nil {
		values = append(values, fmt.Sprintf("tag=%d", *r.Tag))
	}

	if r.Trunks != nil && len(*r.Trunks) > 0 {
		sTrunks := make([]string, len(*r.Trunks))

		for i, v := range *r.Trunks {
			sTrunks[i] = strconv.Itoa(v)
		}

		values = append(values, fmt.Sprintf("trunks=%s", strings.Join(sTrunks, ";")))
	}

	if r.Type != nil {
		values = append(values, fmt.Sprintf("type=%s", *r.Type))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// EncodeValues converts a CustomNetworkInterfaces array to multiple URL values.
func (r CustomNetworkInterfaces) EncodeValues(
	_ string,
	v *url.Values,
) error {
	for key, d := range r {
		if err := d.EncodeValues(key, v); err != nil {
			return fmt.Errorf("failed to encode CustomNetworkInterfaces: %w", err)
		}
	}

	return nil
}

// EncodeValues converts a CustomRootFS struct to a URL value.
func (r *CustomRootFS) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.ACL != nil {
		if *r.ACL {
			values = append(values, "acl=1")
		} else {
			values = append(values, "acl=0")
		}
	}

	if r.Size != nil {
		values = append(values, fmt.Sprintf("size=%d", *r.Size))
	}

	if r.MountOptions != nil {
		if len(*r.MountOptions) > 0 {
			values = append(values, fmt.Sprintf("mount=%s", strings.Join(*r.MountOptions, ";")))
		}
	}

	if r.Quota != nil {
		if *r.Quota {
			values = append(values, "quota=1")
		} else {
			values = append(values, "quota=0")
		}
	}

	if r.ReadOnly != nil {
		if *r.ReadOnly {
			values = append(values, "ro=1")
		} else {
			values = append(values, "ro=0")
		}
	}

	if r.Replicate != nil {
		if *r.Replicate {
			values = append(values, "replicate=1")
		} else {
			values = append(values, "replicate=0")
		}
	}

	if r.Shared != nil {
		if *r.Shared {
			values = append(values, "shared=1")
		} else {
			values = append(values, "shared=0")
		}
	}

	values = append(values, fmt.Sprintf("volume=%s", r.Volume))

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// EncodeValues converts a CustomSSHKeys array to a URL value.
func (r CustomSSHKeys) EncodeValues(key string, v *url.Values) error {
	v.Add(key, strings.Join(r, "\n"))

	return nil
}

// EncodeValues converts a CustomStartupBehavior struct to a URL value.
func (r *CustomStartupBehavior) EncodeValues(
	key string,
	v *url.Values,
) error {
	var values []string

	if r.Down != nil {
		values = append(values, fmt.Sprintf("down=%d", *r.Down))
	}

	if r.Order != nil {
		values = append(values, fmt.Sprintf("order=%d", *r.Order))
	}

	if r.Up != nil {
		values = append(values, fmt.Sprintf("up=%d", *r.Up))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON converts a ContainerCustomFeatures string to an object.
func (r *CustomFeatures) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unable to unmarshal ContainerCustomFeatures: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "fuse":
				bv := types.CustomBool(v[1] == "1")
				r.FUSE = &bv
			case "keyctl":
				bv := types.CustomBool(v[1] == "1")
				r.KeyControl = &bv
			case "mount":
				if v[1] != "" {
					a := strings.Split(v[1], ";")
					r.MountTypes = &a
				} else {
					var a []string
					r.MountTypes = &a
				}
			case "nesting":
				bv := types.CustomBool(v[1] == "1")
				r.Nesting = &bv
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomPassthroughDevice string to an object.
func (r *CustomPassthroughDevice) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unable to unmarshal CustomPassthroughDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	var path string

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			path = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "deny-write":
				bv := types.CustomBool(v[1] == "1")
				r.DenyWrite = &bv
			case "path":
				path = v[1]
			case "uid":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'uid': %w", err)
				}

				r.UID = &iv
			case "gid":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'gid': %w", err)
				}

				r.GID = &iv
			case "mode":
				r.Mode = &v[1]
			}
		}
	}

	r.Path = path

	return nil
}

// UnmarshalJSON converts a CustomMountPoint string to an object.
func (r *CustomMountPoint) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unable to unmarshal CustomMountPoint: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.Volume = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "acl":
				bv := types.CustomBool(v[1] == "1")
				r.ACL = &bv
			case "backup":
				bv := types.CustomBool(v[1] == "1")
				r.Backup = &bv
			case "mountoptions":
				if v[1] != "" {
					a := strings.Split(v[1], ";")
					r.MountOptions = &a
				} else {
					var a []string
					r.MountOptions = &a
				}
			case "mp":
				r.MountPoint = v[1]
			case "quota":
				bv := types.CustomBool(v[1] == "1")
				r.Quota = &bv
			case "ro":
				bv := types.CustomBool(v[1] == "1")
				r.ReadOnly = &bv
			case "replicate":
				bv := types.CustomBool(v[1] == "1")
				r.Replicate = &bv
			case "shared":
				bv := types.CustomBool(v[1] == "1")
				r.Shared = &bv
			case "size":
				r.DiskSize = &v[1]
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomNetworkInterface string to an object.
func (r *CustomNetworkInterface) UnmarshalJSON(b []byte) error {
	var s string

	er := json.Unmarshal(b, &s)
	if er != nil {
		return fmt.Errorf("unable to unmarshal CustomNetworkInterface: %w", er)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		//nolint:nestif
		if len(v) == 1 {
			r.Name = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "bridge":
				r.Bridge = &v[1]
			case "firewall":
				bv := types.CustomBool(v[1] == "1")
				r.Firewall = &bv
			case "gw":
				r.IPv4Gateway = &v[1]
			case "gw6":
				r.IPv6Gateway = &v[1]
			case "ip":
				r.IPv4Address = &v[1]
			case "ip6":
				r.IPv6Address = &v[1]
			case "hwaddr":
				r.MACAddress = &v[1]
			case "mtu":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'mtu': %w", err)
				}

				r.MTU = &iv
			case "name":
				r.Name = v[1]
			case "rate":
				fv, err := strconv.ParseFloat(v[1], 64)
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'rate': %w", err)
				}

				r.RateLimit = &fv
			case "tag":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'tag': %w", err)
				}

				r.Tag = &iv
			case "trunks":
				var err error

				if v[1] != "" {
					trunks := strings.Split(v[1], ";")
					a := make([]int, len(trunks))

					for ti, tv := range trunks {
						a[ti], err = strconv.Atoi(tv)
						if err != nil {
							return fmt.Errorf("unable to unmarshal 'trunks': %w", err)
						}
					}

					r.Trunks = &a
				} else {
					var a []int
					r.Trunks = &a
				}
			case "type":
				r.Type = &v[1]
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomRootFS string to an object.
func (r *CustomRootFS) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unable to unmarshal CustomRootFS: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.Volume = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "acl":
				bv := types.CustomBool(v[1] == "1")
				r.ACL = &bv
			case "mountoptions":
				if v[1] != "" {
					a := strings.Split(v[1], ";")
					r.MountOptions = &a
				} else {
					var a []string
					r.MountOptions = &a
				}
			case "quota":
				bv := types.CustomBool(v[1] == "1")
				r.Quota = &bv
			case "ro":
				bv := types.CustomBool(v[1] == "1")
				r.ReadOnly = &bv
			case "replicate":
				bv := types.CustomBool(v[1] == "1")
				r.Replicate = &bv
			case "shared":
				bv := types.CustomBool(v[1] == "1")
				r.Shared = &bv
			case "size":
				r.Size = new(types.DiskSize)

				err := r.Size.UnmarshalJSON([]byte(v[1]))
				if err != nil {
					return fmt.Errorf("failed to unmarshal disk size: %w", err)
				}
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomStartupBehavior string to an object.
func (r *CustomStartupBehavior) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return fmt.Errorf("unable to unmarshal CustomStartupBehavior: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "down":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'down': %w", err)
				}

				r.Down = &iv
			case "order":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'order': %w", err)
				}

				r.Order = &iv
			case "up":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("unable to unmarshal 'up': %w", err)
				}

				r.Up = &iv
			}
		}
	}

	return nil
}

// UnmarshalJSON unmarshals the data from the JSON response, populating the CustomStorageDevices field.
func (d *GetResponseData) UnmarshalJSON(b []byte) error {
	type Alias GetResponseData

	var data Alias

	// get original struct
	if err := json.Unmarshal(b, &data); err != nil {
		return fmt.Errorf("failed to unmarshal data: %w", err)
	}

	var byAttr map[string]interface{}

	// now get map by attribute name
	err := json.Unmarshal(b, &byAttr)
	if err != nil {
		return fmt.Errorf("failed to unmarshal data: %w", err)
	}

	data.PassthroughDevices = make(CustomPassthroughDevices)
	data.NetworkInterfaces = make(CustomNetworkInterfaces)
	data.MountPoints = make(CustomMountPoints)

	for key, value := range byAttr {
		valueStr, ok := value.(string)
		if !ok {
			continue // Skip non-string values
		}

		jsonValue := []byte(`"` + valueStr + `"`)

		switch {
		case regexDeviceKey.MatchString(key):
			var device CustomPassthroughDevice
			if e := json.Unmarshal(jsonValue, &device); e != nil {
				return fmt.Errorf("failed to unmarshal %s with value %q: %w", key, valueStr, e)
			}

			data.PassthroughDevices[key] = &device

		case regexNetworkKey.MatchString(key):
			var net CustomNetworkInterface
			if e := json.Unmarshal(jsonValue, &net); e != nil {
				return fmt.Errorf("failed to unmarshal %s with value %q: %w", key, valueStr, e)
			}

			data.NetworkInterfaces[key] = &net

		case regexMountPointKey.MatchString(key):
			var mp CustomMountPoint
			if e := json.Unmarshal(jsonValue, &mp); e != nil {
				return fmt.Errorf("failed to unmarshal %s with value %q: %w", key, valueStr, e)
			}

			data.MountPoints[key] = &mp
		}
	}

	*d = GetResponseData(data)

	return nil
}
`````

## File: proxmox/nodes/containers/containers.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package containers

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/avast/retry-go/v4"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// CloneContainer clones a container.
func (c *Client) CloneContainer(ctx context.Context, d *CloneRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("/clone"), d, nil)
	if err != nil {
		return fmt.Errorf("error cloning container: %w", err)
	}

	return nil
}

// CreateContainer creates a container.
func (c *Client) CreateContainer(ctx context.Context, d *CreateRequestBody) error {
	taskID, err := c.CreateContainerAsync(ctx, d)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for container created: %w", err)
	}

	return nil
}

// CreateContainerAsync creates a container asynchronously.
func (c *Client) CreateContainerAsync(ctx context.Context, d *CreateRequestBody) (*string, error) {
	resBody := &CreateResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.basePath(), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error creating container: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// DeleteContainer deletes a container.
func (c *Client) DeleteContainer(ctx context.Context) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath(""), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting container: %w", err)
	}

	return nil
}

// GetContainer retrieves a container.
func (c *Client) GetContainer(ctx context.Context) (*GetResponseData, error) {
	resBody := &GetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("config"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving container: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// GetContainerStatus retrieves the status for a container.
func (c *Client) GetContainerStatus(ctx context.Context) (*GetStatusResponseData, error) {
	resBody := &GetStatusResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("status/current"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving container status: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// RebootContainer reboots a container.
func (c *Client) RebootContainer(ctx context.Context, d *RebootRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/reboot"), d, nil)
	if err != nil {
		return fmt.Errorf("error rebooting container: %w", err)
	}

	return nil
}

// ShutdownContainer shuts down a container.
func (c *Client) ShutdownContainer(ctx context.Context, d *ShutdownRequestBody) error {
	taskID, err := c.ShutdownContainerAsync(ctx, d)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for container shut down: %w", err)
	}

	return nil
}

// ShutdownContainerAsync shuts down a container asynchronously.
func (c *Client) ShutdownContainerAsync(ctx context.Context, d *ShutdownRequestBody) (*string, error) {
	resBody := &ShutdownResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/shutdown"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error shutting down container: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// StartContainer starts a container if is not already running.
func (c *Client) StartContainer(ctx context.Context) error {
	status, err := c.GetContainerStatus(ctx)
	if err != nil {
		return fmt.Errorf("error retrieving container status: %w", err)
	}

	if status.Status == "running" {
		return nil
	}

	taskID, err := c.StartContainerAsync(ctx)
	if err != nil {
		return fmt.Errorf("error starting container: %w", err)
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for container start: %w", err)
	}

	// the timeout here should probably be configurable
	err = c.WaitForContainerStatus(ctx, "running")
	if err != nil {
		return fmt.Errorf("error waiting for container start: %w", err)
	}

	return nil
}

// StartContainerAsync starts a container asynchronously.
func (c *Client) StartContainerAsync(ctx context.Context) (*string, error) {
	resBody := &StartResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/start"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error starting container: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// StopContainer stops a container immediately.
func (c *Client) StopContainer(ctx context.Context) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/stop"), nil, nil)
	if err != nil {
		return fmt.Errorf("error stopping container: %w", err)
	}

	return nil
}

// UpdateContainer updates a container.
func (c *Client) UpdateContainer(ctx context.Context, d *UpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("config"), d, nil)
	if err != nil {
		return fmt.Errorf("error updating container: %w", err)
	}

	return nil
}

// WaitForContainerStatus waits for a container to reach a specific state.
func (c *Client) WaitForContainerStatus(ctx context.Context, status string) error {
	status = strings.ToLower(status)

	unexpectedStatus := fmt.Errorf("unexpected status %q", status)

	err := retry.Do(
		func() error {
			data, err := c.GetContainerStatus(ctx)
			if err != nil {
				return err
			}

			if data.Status != status {
				return unexpectedStatus
			}

			return nil
		},
		retry.Context(ctx),
		retry.RetryIf(func(err error) bool {
			return errors.Is(err, unexpectedStatus)
		}),
		retry.UntilSucceeded(),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
	)

	if errors.Is(err, context.DeadlineExceeded) {
		return fmt.Errorf("timeout while waiting for container %d to enter the status %q", c.VMID, status)
	}

	if err != nil {
		return fmt.Errorf("error waiting for container %d to enter the status %q: %w", c.VMID, status, err)
	}

	return nil
}

// WaitForContainerConfigUnlock waits for a container lock to be released.
func (c *Client) WaitForContainerConfigUnlock(ctx context.Context, ignoreErrorResponse bool) error {
	stillLocked := errors.New("still locked")

	err := retry.Do(
		func() error {
			data, err := c.GetContainerStatus(ctx)
			if err != nil {
				return err
			}

			if data.Lock != nil && *data.Lock != "" {
				return stillLocked
			}

			return nil
		},
		retry.Context(ctx),
		retry.RetryIf(func(err error) bool {
			return errors.Is(err, stillLocked) || ignoreErrorResponse
		}),
		retry.UntilSucceeded(),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
	)

	if errors.Is(err, context.DeadlineExceeded) {
		return fmt.Errorf("timeout while waiting for container %d configuration to become unlocked", c.VMID)
	}

	if err != nil && !ignoreErrorResponse {
		return fmt.Errorf("error waiting for container %d configuration to become unlocked: %w", c.VMID, err)
	}

	return nil
}
`````

## File: proxmox/nodes/storage/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/tasks"
)

// Client is an interface for accessing the Proxmox node storage API.
type Client struct {
	api.Client
	StorageName string
}

func (c *Client) basePath() string {
	return c.Client.ExpandPath("storage")
}

// ExpandPath expands a relative path to a full node storage API path.
func (c *Client) ExpandPath(path string) string {
	ep := fmt.Sprintf("%s/%s", c.basePath(), c.StorageName)
	if path != "" {
		ep = fmt.Sprintf("%s/%s", ep, path)
	}

	return ep
}

// Tasks returns a client for managing node storage tasks.
func (c *Client) Tasks() *tasks.Client {
	return &tasks.Client{
		Client: c.Client,
	}
}
`````

## File: proxmox/nodes/storage/content_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

// DatastoreFileListResponseBody contains the body from a datastore content list response.
type DatastoreFileListResponseBody struct {
	Data []*DatastoreFileListResponseData `json:"data,omitempty"`
}

// DatastoreFileListResponseData contains the data from a datastore content list response.
type DatastoreFileListResponseData struct {
	ContentType    string  `json:"content"`
	FileFormat     string  `json:"format"`
	FileSize       int64   `json:"size"`
	ParentVolumeID *string `json:"parent,omitempty"`
	SpaceUsed      *int    `json:"used,omitempty"`
	VMID           *int    `json:"vmid,omitempty"`
	VolumeID       string  `json:"volid"`
}

// DatastoreFileGetRequestData contains the body from a datastore content get request.
type DatastoreFileGetRequestData struct {
	Node     string `json:"node,omitempty"   url:"node,omitempty"`
	VolumeID string `json:"volume,omitempty" url:"volume,omitempty"`
}

// DatastoreFileGetResponseBody contains the body from a datastore content get response.
type DatastoreFileGetResponseBody struct {
	Data *DatastoreFileGetResponseData `json:"data,omitempty" url:"data,omitempty"`
}

// DatastoreFileGetResponseData contains the data from a datastore content get response.
type DatastoreFileGetResponseData struct {
	Path       *string `json:"path"           url:"path,omitempty"`
	FileFormat *string `json:"format"         url:"format,omitempty"`
	FileSize   *int64  `json:"size"           url:"size,omitempty"`
	SpaceUsed  *int64  `json:"used,omitempty" url:"used,omitempty"`
}
`````

## File: proxmox/nodes/storage/content.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/avast/retry-go/v4"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// DeleteDatastoreFile deletes a file in a datastore.
func (c *Client) DeleteDatastoreFile(
	ctx context.Context,
	volumeID string,
) error {
	path := c.ExpandPath(fmt.Sprintf("content/%s", url.PathEscape(volumeID)))

	err := retry.Do(
		func() error {
			return c.DoRequest(ctx, http.MethodDelete, path, nil, nil)
		},
		retry.Context(ctx),
		retry.RetryIf(func(err error) bool {
			return !errors.Is(err, api.ErrResourceDoesNotExist)
		}),
		retry.LastErrorOnly(true),
	)
	if err != nil {
		return fmt.Errorf("error deleting file %s from datastore %s: %w", volumeID, c.StorageName, err)
	}

	return nil
}

// ListDatastoreFiles retrieves a list of the files in a datastore.
func (c *Client) ListDatastoreFiles(
	ctx context.Context,
) ([]*DatastoreFileListResponseData, error) {
	resBody := &DatastoreFileListResponseBody{}

	err := retry.Do(
		func() error {
			return c.DoRequest(ctx, http.MethodGet, c.ExpandPath("content"), nil, resBody)
		},
		retry.Context(ctx),
		retry.RetryIf(func(err error) bool {
			return !errors.Is(err, api.ErrResourceDoesNotExist)
		}),
		retry.LastErrorOnly(true),
	)
	if err != nil {
		return nil, fmt.Errorf("error listing files from datastore %s: %w", c.StorageName, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].VolumeID < resBody.Data[j].VolumeID
	})

	return resBody.Data, nil
}

// GetDatastoreFile get a file details in a datastore.
func (c *Client) GetDatastoreFile(
	ctx context.Context,
	volumeID string,
) (*DatastoreFileGetResponseData, error) {
	resBody := &DatastoreFileGetResponseBody{}

	err := c.DoRequest(
		ctx,
		http.MethodGet,
		c.ExpandPath(
			fmt.Sprintf(
				"content/%s",
				url.PathEscape(volumeID),
			),
		),
		nil,
		resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error get file %s from datastore %s: %w", volumeID, c.StorageName, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/nodes/storage/download_url_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import "github.com/bpg/terraform-provider-proxmox/proxmox/types"

// DownloadURLResponseBody contains the body from a DownloadURL post response.
type DownloadURLResponseBody struct {
	TaskID *string `json:"data,omitempty"`
}

// DownloadURLPostRequestBody contains the body for a DownloadURL post request.
type DownloadURLPostRequestBody struct {
	Content           *string           `json:"content,omitempty"             url:"content,omitempty"`
	FileName          *string           `json:"filename,omitempty"            url:"filename,omitempty"`
	Node              *string           `json:"node,omitempty"                url:"node,omitempty"`
	Storage           *string           `json:"storage,omitempty"             url:"storage,omitempty"`
	URL               *string           `json:"url,omitempty"                 url:"url,omitempty"`
	Checksum          *string           `json:"checksum,omitempty"            url:"checksum,omitempty"`
	ChecksumAlgorithm *string           `json:"checksum-algorithm,omitempty"  url:"checksum-algorithm,omitempty"`
	Compression       *string           `json:"compression,omitempty"         url:"compression,omitempty"`
	Verify            *types.CustomBool `json:"verify-certificates,omitempty" url:"verify-certificates,omitempty,int"`
}
`````

## File: proxmox/nodes/storage/download_url.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// DownloadFileByURL downloads the file using URL.
func (c *Client) DownloadFileByURL(
	ctx context.Context,
	d *DownloadURLPostRequestBody,
) error {
	resBody := &DownloadURLResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("download-url"), d, resBody)
	if err != nil {
		return fmt.Errorf("error download file by URL: %w", err)
	}

	if resBody.TaskID == nil {
		return api.ErrNoDataObjectInResponse
	}

	taskErr := c.Tasks().WaitForTask(ctx, *resBody.TaskID)
	if taskErr != nil {
		err = fmt.Errorf(
			"error download file to datastore %s: failed waiting for url download: %w",
			c.StorageName,
			taskErr,
		)

		deleteErr := c.Tasks().DeleteTask(context.WithoutCancel(ctx), *resBody.TaskID)
		if deleteErr != nil {
			return fmt.Errorf("%w \n %w", err, deleteErr)
		}

		return err
	}

	return nil
}
`````

## File: proxmox/nodes/storage/status_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// DatastoreGetStatusResponseBody contains the body from a datastore status get request.
type DatastoreGetStatusResponseBody struct {
	Data *DatastoreGetStatusResponseData `json:"data,omitempty"`
}

// DatastoreGetStatusResponseData contains the data from a datastore status get request.
type DatastoreGetStatusResponseData struct {
	Active         *types.CustomBool               `json:"active,omitempty"`
	AvailableBytes *int64                          `json:"avail,omitempty"`
	Content        *types.CustomCommaSeparatedList `json:"content,omitempty" url:"content,omitempty,comma"`
	Enabled        *types.CustomBool               `json:"enabled,omitempty"`
	Shared         *types.CustomBool               `json:"shared,omitempty"`
	TotalBytes     *int64                          `json:"total,omitempty"`
	Type           *string                         `json:"type,omitempty"`
	UsedBytes      *int64                          `json:"used,omitempty"`
}
`````

## File: proxmox/nodes/storage/status.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetDatastoreStatus gets status information for a given datastore.
func (c *Client) GetDatastoreStatus(
	ctx context.Context,
) (*DatastoreGetStatusResponseData, error) {
	resBody := &DatastoreGetStatusResponseBody{}

	err := c.DoRequest(
		ctx,
		http.MethodGet,
		c.ExpandPath("status"),
		nil,
		resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error retrieving status for datastore %s: %w", c.StorageName, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/nodes/storage/storage_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// DatastoreListRequestBody contains the body for a datastore list request.
type DatastoreListRequestBody struct {
	ContentTypes types.CustomCommaSeparatedList `json:"content,omitempty" url:"content,omitempty,comma"`
	Enabled      *types.CustomBool              `json:"enabled,omitempty" url:"enabled,omitempty,int"`
	Format       *types.CustomBool              `json:"format,omitempty"  url:"format,omitempty,int"`
	ID           *string                        `json:"storage,omitempty" url:"storage,omitempty"`
	Target       *string                        `json:"target,omitempty"  url:"target,omitempty"`
}

// DatastoreListResponseBody contains the body from a datastore list response.
type DatastoreListResponseBody struct {
	Data []*DatastoreListResponseData `json:"data,omitempty"`
}

// DatastoreListResponseData contains the data from a datastore list response.
type DatastoreListResponseData struct {
	Active              *types.CustomBool               `json:"active,omitempty"`
	ContentTypes        *types.CustomCommaSeparatedList `json:"content,omitempty"`
	Enabled             *types.CustomBool               `json:"enabled,omitempty"`
	ID                  string                          `json:"storage,omitempty"`
	Shared              *types.CustomBool               `json:"shared,omitempty"`
	SpaceAvailable      *types.CustomInt64              `json:"avail,omitempty"`
	SpaceTotal          *types.CustomInt64              `json:"total,omitempty"`
	SpaceUsed           *types.CustomInt64              `json:"used,omitempty"`
	SpaceUsedPercentage *types.CustomFloat64            `json:"used_fraction,omitempty"`
	Type                string                          `json:"type,omitempty"`
}
`````

## File: proxmox/nodes/storage/storage.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"context"
	"fmt"
	"net/http"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// ListDatastores retrieves a list of nodes.
func (c *Client) ListDatastores(
	ctx context.Context,
	d *DatastoreListRequestBody,
) ([]*DatastoreListResponseData, error) {
	resBody := &DatastoreListResponseBody{}

	err := c.DoRequest(
		ctx,
		http.MethodGet,
		c.basePath(),
		d,
		resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error retrieving datastores: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID < resBody.Data[j].ID
	})

	return resBody.Data, nil
}
`````

## File: proxmox/nodes/storage/upload_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

// DatastoreUploadResponseBody contains the body from a datastore upload response.
type DatastoreUploadResponseBody struct {
	UploadID *string `json:"data,omitempty"`
}
`````

## File: proxmox/nodes/storage/upload.go
`````go
package storage

import (
	"context"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"

	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// APIUpload uploads a file to a datastore using the Proxmox API.
func (c *Client) APIUpload(
	ctx context.Context,
	d *api.FileUploadRequest,
	tempDir string,
) (*DatastoreUploadResponseBody, error) {
	tflog.Debug(ctx, "uploading file to datastore using PVE API", map[string]interface{}{
		"file_name":    d.FileName,
		"content_type": d.ContentType,
	})

	r, w := io.Pipe()

	defer func(r *io.PipeReader) {
		err := r.Close()
		if err != nil {
			tflog.Error(ctx, "failed to close pipe reader", map[string]interface{}{
				"error": err,
			})
		}
	}(r)

	m := multipart.NewWriter(w)

	go func() {
		defer func(w *io.PipeWriter) {
			err := w.Close()
			if err != nil {
				tflog.Error(ctx, "failed to close pipe writer", map[string]interface{}{
					"error": err,
				})
			}
		}(w)
		defer func(m *multipart.Writer) {
			err := m.Close()
			if err != nil {
				tflog.Error(ctx, "failed to close multipart writer", map[string]interface{}{
					"error": err,
				})
			}
		}(m)

		err := m.WriteField("content", d.ContentType)
		if err != nil {
			tflog.Error(ctx, "failed to write 'content' field", map[string]interface{}{
				"error": err,
			})

			return
		}

		part, err := m.CreateFormFile("filename", d.FileName)
		if err != nil {
			return
		}

		_, err = io.Copy(part, d.File)
		if err != nil {
			return
		}
	}()

	// We need to store the multipart content in a temporary file to avoid using high amounts of memory.
	// This is necessary due to Proxmox VE not supporting chunked transfers in v6.1 and earlier versions.
	tempMultipartFile, err := os.CreateTemp(tempDir, "multipart")
	if err != nil {
		return nil, fmt.Errorf("failed to create temporary file: %w", err)
	}

	tempMultipartFileName := tempMultipartFile.Name()

	_, err = io.Copy(tempMultipartFile, r)
	if err != nil {
		return nil, fmt.Errorf("failed to copy multipart data to temporary file: %w", err)
	}

	err = tempMultipartFile.Close()
	if err != nil {
		return nil, fmt.Errorf("failed to close temporary file: %w", err)
	}

	defer func(name string) {
		e := os.Remove(name)
		if e != nil {
			tflog.Error(ctx, "failed to remove temporary file", map[string]interface{}{
				"error": e,
			})
		}
	}(tempMultipartFileName)

	// Now that the multipart data is stored in a file, we can go ahead and do an HTTP POST request.
	fileReader, err := os.Open(tempMultipartFileName)
	if err != nil {
		return nil, fmt.Errorf("failed to open temporary file: %w", err)
	}

	defer func(fileReader *os.File) {
		e := fileReader.Close()
		if e != nil {
			if errors.Is(e, os.ErrClosed) {
				// We can ignore the error in the case that the file was already closed.
				return
			}

			tflog.Error(ctx, "failed to close file reader", map[string]interface{}{
				"error": e,
			})
		}
	}(fileReader)

	fileInfo, err := fileReader.Stat()
	if err != nil {
		return nil, fmt.Errorf("failed to get file info: %w", err)
	}

	fileSize := fileInfo.Size()

	reqBody := &api.MultiPartData{
		Boundary: m.Boundary(),
		Reader:   fileReader,
		Size:     &fileSize,
	}

	resBody := &DatastoreUploadResponseBody{}

	err = c.DoRequest(
		ctx,
		http.MethodPost,
		c.ExpandPath("upload"),
		reqBody,
		resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error uploading file to datastore %s: %w", c.StorageName, err)
	}

	if resBody.UploadID == nil {
		return nil, fmt.Errorf("error uploading file to datastore %s: no uploadID", c.StorageName)
	}

	err = c.Tasks().WaitForTask(ctx, *resBody.UploadID)
	if err != nil {
		return nil, fmt.Errorf("error uploading file to datastore %s: failed waiting for upload - %w", c.StorageName, err)
	}

	return resBody, nil
}
`````

## File: proxmox/nodes/tasks/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package tasks

import (
	"fmt"
	"net/url"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for performing requests against the Proxmox 'tasks' API.
type Client struct {
	api.Client
}

// ExpandPath expands a path relative to the client's base path.
func (c *Client) ExpandPath(_ string) string {
	panic("ExpandPath of tasks.Client must not be used. Use BuildPath instead.")
}

func (c *Client) baseTaskPath(taskID string) (string, error) {
	tid, err := ParseTaskID(taskID)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("nodes/%s/tasks/%s",
		url.PathEscape(tid.NodeName),
		url.PathEscape(taskID),
	), nil
}

// BuildPath builds a path using information from Task ID.
func (c *Client) BuildPath(taskID string, path string) (string, error) {
	basePath, err := c.baseTaskPath(taskID)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%s/%s",
		basePath, url.PathEscape(path),
	), nil
}
`````

## File: proxmox/nodes/tasks/tasks_types_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

// file deepcode ignore NoHardcodedCredentials/test: test file

package tasks

import (
	"reflect"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestParseTaskID(t *testing.T) {
	t.Parallel()

	parseTime := func(s string) time.Time {
		stime, err := time.Parse(time.RFC3339, s)
		require.NoError(t, err)

		return stime.UTC()
	}

	tests := []struct {
		name    string
		taskID  string
		want    TaskID
		wantErr bool
	}{
		{
			name:   "imgcopy task",
			taskID: "UPID:pve:00061CB3:010BA69C:64EFECB0:imgcopy::root@pam:",
			want: TaskID{
				NodeName:  "pve",
				PID:       400563,
				PStart:    17540764,
				StartTime: parseTime("2023-08-30T21:28:16-04:00"),
				Type:      "imgcopy",
				ID:        "",
				User:      "root@pam",
			},
		},
		{
			name:   "qmcreate task",
			taskID: "UPID:pve:00061CB3:010BA69C:64EFECB0:qmcreate:101:root@pam:",
			want: TaskID{
				NodeName:  "pve",
				PID:       400563,
				PStart:    17540764,
				StartTime: parseTime("2023-08-30T21:28:16-04:00"),
				Type:      "qmcreate",
				ID:        "101",
				User:      "root@pam",
			},
		},
		{
			name:   "large pid",
			taskID: "UPID:pve-srv:0012D68C:8206F38C:65144CB7:qmcreate:501:root@pam:",
			want: TaskID{
				NodeName:  "pve-srv",
				PID:       1234572,
				PStart:    2181493644,
				StartTime: parseTime("2023-09-27T15:39:35Z"),
				Type:      "qmcreate",
				ID:        "501",
				User:      "root@pam",
			},
		},
		{
			name:    "missing node",
			taskID:  "UPID::00061CB3:010BA69C:64EFECB0:qmcreate:101:root@pam:",
			wantErr: true,
		},
		{
			name:    "wrong ID format",
			taskID:  "blah",
			wantErr: true,
		},
		{
			name:    "missing pid",
			taskID:  "UPID:pve::010BA69C:64EFECB0:qmcreate:101:root@pam:",
			wantErr: true,
		},
		{
			name:    "missing parts",
			taskID:  "UPID:pve:00061CB3:010BA69C:64EFECB0::root@pam:",
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := ParseTaskID(tt.taskID)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseTaskID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ParseTaskID() got = %v, want %v", got, tt.want)
			}
		})
	}
}
`````

## File: proxmox/nodes/tasks/tasks_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package tasks

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

// GetTaskStatusResponseBody contains the body from a node get task status response.
type GetTaskStatusResponseBody struct {
	Data *GetTaskStatusResponseData `json:"data,omitempty"`
}

// GetTaskStatusResponseData contains the data from a node get task status response.
type GetTaskStatusResponseData struct {
	PID      int    `json:"pid,omitempty"`
	Status   string `json:"status,omitempty"`
	ExitCode string `json:"exitstatus,omitempty"`
}

// GetTaskLogResponseBody contains the body from a node get task log response.
type GetTaskLogResponseBody struct {
	Data []*GetTaskLogResponseData `json:"data,omitempty"`
}

// GetTaskLogResponseData contains the data from a node get task log response.
type GetTaskLogResponseData struct {
	LineNumber int    `json:"n,omitempty"`
	LineText   string `json:"t,omitempty"`
}

// TaskID contains the components of a PVE task ID.
type TaskID struct {
	NodeName  string
	PID       int64
	PStart    int64
	StartTime time.Time
	Type      string
	ID        string
	User      string
}

// ParseTaskID parses a task ID into its component parts.
// The task ID is expected to be in the format of:
//
//	UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>:
func ParseTaskID(taskID string) (TaskID, error) {
	parts := strings.SplitN(taskID, ":", 9)

	if parts[0] != "UPID" || len(parts) < 8 {
		return TaskID{}, fmt.Errorf("invalid task ID format: %s", taskID)
	}

	if parts[1] == "" {
		return TaskID{}, fmt.Errorf("missing node name in task ID: %s", taskID)
	}

	pid, err := strconv.ParseInt(parts[2], 16, 64)
	if err != nil {
		return TaskID{}, fmt.Errorf("error parsing task ID: %w", err)
	}

	pstart, err := strconv.ParseInt(parts[3], 16, 64)
	if err != nil {
		return TaskID{}, fmt.Errorf("error parsing pstart in task ID: %q: %w", taskID, err)
	}

	stime, err := strconv.ParseInt(parts[4], 16, 64)
	if err != nil {
		return TaskID{}, fmt.Errorf("error parsing start time in task ID: %q: %w", taskID, err)
	}

	if parts[5] == "" {
		return TaskID{}, fmt.Errorf("missing task type in task ID: %q", taskID)
	}

	if parts[7] == "" {
		return TaskID{}, fmt.Errorf("missing user in task ID: %q", taskID)
	}

	return TaskID{
		NodeName:  parts[1],
		PID:       pid,
		PStart:    pstart,
		StartTime: time.Unix(stime, 0).UTC(),
		Type:      parts[5],
		ID:        parts[6],
		User:      parts[7],
	}, nil
}
`````

## File: proxmox/nodes/tasks/tasks.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package tasks

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/avast/retry-go/v4"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetTaskStatus retrieves the status of a task.
func (c *Client) GetTaskStatus(ctx context.Context, upid string) (*GetTaskStatusResponseData, error) {
	resBody := &GetTaskStatusResponseBody{}

	path, err := c.BuildPath(upid, "status")
	if err != nil {
		return nil, fmt.Errorf("error building path for task status: %w", err)
	}

	err = c.DoRequest(ctx, http.MethodGet, path, nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving task status: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// GetTaskLog retrieves the log of a task. The log is returned as an array of
// lines. Each line is an object with a line number and the text of the line.
// Reads first 50 lines by default.
func (c *Client) GetTaskLog(ctx context.Context, upid string) ([]string, error) {
	resBody := &GetTaskLogResponseBody{}

	var lines []string //nolint: prealloc

	path, err := c.BuildPath(upid, "log")
	if err != nil {
		return lines, fmt.Errorf("error building path for task status: %w", err)
	}

	err = c.DoRequest(ctx, http.MethodGet, path, nil, resBody)
	if err != nil {
		return lines, fmt.Errorf("error retrieving task status: %w", err)
	}

	if resBody.Data == nil {
		return lines, api.ErrNoDataObjectInResponse
	}

	for _, line := range resBody.Data {
		lines = append(lines, line.LineText)
	}

	return lines, nil
}

// DeleteTask deletes specific task.
func (c *Client) DeleteTask(ctx context.Context, upid string) error {
	path, err := c.baseTaskPath(upid)
	if err != nil {
		return fmt.Errorf("error creating task path: %w", err)
	}

	err = c.DoRequest(ctx, http.MethodDelete, path, nil, nil)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			return nil
		}

		return fmt.Errorf("error deleting task: %w", err)
	}

	return nil
}

type taskWaitOptions struct {
	ignoreWarnings   bool
	ignoreStatusCode int
}

// TaskWaitOption is an option for waiting for a task to complete.
type TaskWaitOption interface {
	apply(opts *taskWaitOptions)
}

type withIgnoreWarnings struct{}

// WithIgnoreWarnings is an option to ignore warnings when waiting for a task to complete.
func WithIgnoreWarnings() TaskWaitOption {
	return withIgnoreWarnings{}
}

func (w withIgnoreWarnings) apply(opts *taskWaitOptions) {
	opts.ignoreWarnings = true
}

type withIgnoreStatus struct {
	statusCode int
}

// WithIgnoreStatus is an option to ignore particular status code from PVE API when waiting for a task to complete.
func WithIgnoreStatus(statusCode int) TaskWaitOption {
	return withIgnoreStatus{statusCode: statusCode}
}

func (w withIgnoreStatus) apply(opts *taskWaitOptions) {
	opts.ignoreStatusCode = w.statusCode
}

// WaitForTask waits for a specific task to complete.
func (c *Client) WaitForTask(ctx context.Context, upid string, opts ...TaskWaitOption) error {
	errStillRunning := errors.New("still running")

	options := &taskWaitOptions{}

	for _, opt := range opts {
		opt.apply(options)
	}

	status, err := retry.DoWithData(
		func() (*GetTaskStatusResponseData, error) {
			status, err := c.GetTaskStatus(ctx, upid)
			if err != nil {
				return nil, err
			}

			if status.Status == "running" {
				return nil, errStillRunning
			}

			return status, err
		},
		retry.Context(ctx),
		retry.RetryIf(func(err error) bool {
			var target *api.HTTPError
			if errors.As(err, &target) {
				if target.Code == http.StatusBadRequest {
					// this is a special case to account for eventual consistency
					// when creating a task -- the task may not be available via status API
					// immediately after creation
					return true
				}

				if options.ignoreStatusCode != 0 && target.Code == options.ignoreStatusCode {
					return true
				}
			}

			return errors.Is(err, errStillRunning)
		}),
		retry.LastErrorOnly(true),
		retry.UntilSucceeded(),
		retry.DelayType(retry.FixedDelay),
		retry.Delay(time.Second),
	)

	if errors.Is(err, context.DeadlineExceeded) {
		return fmt.Errorf("timeout while waiting for task %q to complete", upid)
	}

	if err != nil {
		return fmt.Errorf("error while waiting for task %q to complete: %w", upid, err)
	}

	if status.ExitCode != "OK" {
		if options.ignoreWarnings &&
			strings.HasPrefix(status.ExitCode, "WARNINGS: ") && !strings.Contains(status.ExitCode, "ERROR") {
			return nil
		}

		return fmt.Errorf("task %q failed to complete with exit code: %s", upid, status.ExitCode)
	}

	return nil
}
`````

## File: proxmox/nodes/vms/firewall/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
)

// Client is an interface for accessing the Proxmox VM firewall API.
type Client struct {
	firewall.Client
}
`````

## File: proxmox/nodes/vms/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"fmt"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/tasks"
	vmfirewall "github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms/firewall"
)

// Client is an interface for accessing the Proxmox VM API.
type Client struct {
	api.Client
	VMID int
}

func (c *Client) basePath() string {
	return c.Client.ExpandPath("qemu")
}

// ExpandPath expands a relative path to a full VM API path.
func (c *Client) ExpandPath(path string) string {
	ep := fmt.Sprintf("%s/%d", c.basePath(), c.VMID)
	if path != "" {
		ep = fmt.Sprintf("%s/%s", ep, path)
	}

	return ep
}

// Tasks returns a client for managing VM tasks.
func (c *Client) Tasks() *tasks.Client {
	return &tasks.Client{
		Client: c.Client,
	}
}

// Firewall returns a client for managing the VM firewall.
func (c *Client) Firewall() firewall.API {
	return &vmfirewall.Client{
		Client: firewall.Client{Client: c},
	}
}
`````

## File: proxmox/nodes/vms/custom_agent.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomAgent handles QEMU agent parameters.
type CustomAgent struct {
	Enabled         *types.CustomBool `json:"enabled,omitempty"   url:"enabled,int"`
	TrimClonedDisks *types.CustomBool `json:"fstrim_cloned_disks" url:"fstrim_cloned_disks,int"`
	Type            *string           `json:"type"                url:"type"`
}

// EncodeValues converts a CustomAgent struct to a URL value.
func (r *CustomAgent) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.Enabled != nil {
		if *r.Enabled {
			values = append(values, "enabled=1")
		} else {
			values = append(values, "enabled=0")
		}
	}

	if r.TrimClonedDisks != nil {
		if *r.TrimClonedDisks {
			values = append(values, "fstrim_cloned_disks=1")
		} else {
			values = append(values, "fstrim_cloned_disks=0")
		}
	}

	if r.Type != nil {
		values = append(values, fmt.Sprintf("type=%s", *r.Type))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON converts a CustomAgent string to an object.
func (r *CustomAgent) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomAgent: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			enabled := types.CustomBool(v[0] == "1")
			r.Enabled = &enabled
		} else if len(v) == 2 {
			switch v[0] {
			case "enabled":
				enabled := types.CustomBool(v[1] == "1")
				r.Enabled = &enabled
			case "fstrim_cloned_disks":
				fstrim := types.CustomBool(v[1] == "1")
				r.TrimClonedDisks = &fstrim
			case "type":
				r.Type = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_amdsev.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomAMDSEV handles AMDSEV parameters.
type CustomAMDSEV struct {
	Type         string            `json:"type"           url:"type"`
	AllowSMT     *types.CustomBool `json:"allow-smt"      url:"allow-smt,int"`
	KernelHashes *types.CustomBool `json:"kernel-hashes"  url:"kernel-hashes,int"`
	NoDebug      *types.CustomBool `json:"no-debug"       url:"no-debug,int"`
	NoKeySharing *types.CustomBool `json:"no-key-sharing" url:"no-key-sharing,int"`
}

// EncodeValues converts a CustomAMDSEV struct to a URL value.
func (r *CustomAMDSEV) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("type=%s", r.Type),
	}

	if r.AllowSMT != nil {
		if *r.AllowSMT {
			values = append(values, "allow-smt=1")
		} else {
			values = append(values, "allow-smt=0")
		}
	}

	if r.KernelHashes != nil {
		if *r.KernelHashes {
			values = append(values, "kernel-hashes=1")
		} else {
			values = append(values, "kernel-hashes=0")
		}
	}

	if r.NoDebug != nil {
		if *r.NoDebug {
			values = append(values, "no-debug=1")
		} else {
			values = append(values, "no-debug=0")
		}
	}

	if r.NoKeySharing != nil {
		if *r.NoKeySharing {
			values = append(values, "no-key-sharing=1")
		} else {
			values = append(values, "no-key-sharing=0")
		}
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON converts a CustomAMDSEV string to an object.
func (r *CustomAMDSEV) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomAMDSEV: %w", err)
	}

	pairs := strings.Split(s, ",")

	for i, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 && i == 0 {
			r.Type = v[0]
		}

		if len(v) == 2 {
			switch v[0] {
			case "type":
				r.Type = v[1]
			case "allow-smt":
				allow_smt := types.CustomBool(v[1] == "1")
				r.AllowSMT = &allow_smt
			case "kernel-hashes":
				kernel_hashes := types.CustomBool(v[1] == "1")
				r.KernelHashes = &kernel_hashes
			case "no-debug":
				no_debug := types.CustomBool(v[1] == "1")
				r.NoDebug = &no_debug
			case "no-key-sharing":
				no_key_sharing := types.CustomBool(v[1] == "1")
				r.NoKeySharing = &no_key_sharing
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_audio_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// CustomAudioDevice handles QEMU audio parameters.
type CustomAudioDevice struct {
	Device  string  `json:"device" url:"device"`
	Driver  *string `json:"driver" url:"driver"`
	Enabled bool    `json:"-"      url:"-"`
}

// CustomAudioDevices handles QEMU audio device parameters.
type CustomAudioDevices []CustomAudioDevice

// EncodeValues converts a CustomAudioDevice struct to a URL value.
func (r *CustomAudioDevice) EncodeValues(key string, v *url.Values) error {
	values := []string{fmt.Sprintf("device=%s", r.Device)}

	if r.Driver != nil {
		values = append(values, fmt.Sprintf("driver=%s", *r.Driver))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomAudioDevice string to an object.
func (r *CustomAudioDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomAudioDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "device":
				r.Device = v[1]
			case "driver":
				r.Driver = &v[1]
			}
		}
	}

	return nil
}

// EncodeValues converts a CustomAudioDevices array to multiple URL values.
func (r CustomAudioDevices) EncodeValues(key string, v *url.Values) error {
	for i, d := range r {
		if d.Enabled {
			if err := d.EncodeValues(fmt.Sprintf("%s%d", key, i), v); err != nil {
				return fmt.Errorf("unable to encode audio device %d: %w", i, err)
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_boot.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// CustomBoot handles QEMU boot parameters.
type CustomBoot struct {
	Order *[]string `json:"order,omitempty" url:"order,omitempty,semicolon"`
}

// EncodeValues converts a CustomBoot struct to multiple URL values.
func (r *CustomBoot) EncodeValues(key string, v *url.Values) error {
	if r.Order != nil && len(*r.Order) > 0 {
		v.Add(key, fmt.Sprintf("order=%s", strings.Join(*r.Order, ";")))
	}

	return nil
}

// UnmarshalJSON converts a CustomBoot string to an object.
func (r *CustomBoot) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomBoot: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			if v[0] == "order" {
				o := strings.Split(strings.TrimSpace(v[1]), ";")
				r.Order = &o
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_cloud_init.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// CustomCloudInitConfig handles QEMU cloud-init parameters.
type CustomCloudInitConfig struct {
	Files        *CustomCloudInitFiles     `json:"cicustom,omitempty"     url:"cicustom,omitempty"`
	IPConfig     []CustomCloudInitIPConfig `json:"ipconfig,omitempty"     url:"ipconfig,omitempty,numbered"`
	Nameserver   *string                   `json:"nameserver,omitempty"   url:"nameserver,omitempty"`
	Password     *string                   `json:"cipassword,omitempty"   url:"cipassword,omitempty"`
	SearchDomain *string                   `json:"searchdomain,omitempty" url:"searchdomain,omitempty"`
	SSHKeys      *CustomCloudInitSSHKeys   `json:"sshkeys,omitempty"      url:"sshkeys,omitempty"`
	Type         *string                   `json:"citype,omitempty"       url:"citype,omitempty"`
	// Can't be reliably set, it is TRUE by default in PVE
	// Upgrade      *types.CustomBool         `json:"ciupgrade,omitempty"    url:"ciupgrade,omitempty,int"`
	Username *string `json:"ciuser,omitempty" url:"ciuser,omitempty"`
}

// CustomCloudInitFiles handles QEMU cloud-init custom files parameters.
type CustomCloudInitFiles struct {
	MetaVolume    *string `json:"meta,omitempty"    url:"meta,omitempty"`
	NetworkVolume *string `json:"network,omitempty" url:"network,omitempty"`
	UserVolume    *string `json:"user,omitempty"    url:"user,omitempty"`
	VendorVolume  *string `json:"vendor,omitempty"  url:"vendor,omitempty"`
}

// CustomCloudInitIPConfig handles QEMU cloud-init IP configuration parameters.
type CustomCloudInitIPConfig struct {
	GatewayIPv4 *string `json:"gw,omitempty"  url:"gw,omitempty"`
	GatewayIPv6 *string `json:"gw6,omitempty" url:"gw6,omitempty"`
	IPv4        *string `json:"ip,omitempty"  url:"ip,omitempty"`
	IPv6        *string `json:"ip6,omitempty" url:"ip6,omitempty"`
}

// CustomCloudInitSSHKeys handles QEMU cloud-init SSH keys parameters.
type CustomCloudInitSSHKeys []string

// EncodeValues converts a CustomCloudInitConfig struct to multiple URL values.
func (r CustomCloudInitConfig) EncodeValues(_ string, v *url.Values) error {
	//nolint:nestif
	if r.Files != nil {
		var volumes []string

		if r.Files.MetaVolume != nil {
			volumes = append(volumes, fmt.Sprintf("meta=%s", *r.Files.MetaVolume))
		}

		if r.Files.NetworkVolume != nil {
			volumes = append(volumes, fmt.Sprintf("network=%s", *r.Files.NetworkVolume))
		}

		if r.Files.UserVolume != nil {
			volumes = append(volumes, fmt.Sprintf("user=%s", *r.Files.UserVolume))
		}

		if r.Files.VendorVolume != nil {
			volumes = append(volumes, fmt.Sprintf("vendor=%s", *r.Files.VendorVolume))
		}

		if len(volumes) > 0 {
			v.Add("cicustom", strings.Join(volumes, ","))
		}
	}

	for i, c := range r.IPConfig {
		var config []string

		if c.GatewayIPv4 != nil {
			config = append(config, fmt.Sprintf("gw=%s", *c.GatewayIPv4))
		}

		if c.GatewayIPv6 != nil {
			config = append(config, fmt.Sprintf("gw6=%s", *c.GatewayIPv6))
		}

		if c.IPv4 != nil {
			config = append(config, fmt.Sprintf("ip=%s", *c.IPv4))
		}

		if c.IPv6 != nil {
			config = append(config, fmt.Sprintf("ip6=%s", *c.IPv6))
		}

		if len(config) > 0 {
			v.Add(fmt.Sprintf("ipconfig%d", i), strings.Join(config, ","))
		}
	}

	if r.Nameserver != nil {
		v.Add("nameserver", *r.Nameserver)
	}

	if r.Password != nil {
		v.Add("cipassword", *r.Password)
	}

	if r.SearchDomain != nil {
		v.Add("searchdomain", *r.SearchDomain)
	}

	if r.SSHKeys != nil {
		v.Add(
			"sshkeys",
			strings.ReplaceAll(url.QueryEscape(strings.Join(*r.SSHKeys, "\n")), "+", "%20"),
		)
	}

	if r.Type != nil {
		v.Add("citype", *r.Type)
	}

	if r.Username != nil {
		v.Add("ciuser", *r.Username)
	}

	return nil
}

// UnmarshalJSON converts a CustomCloudInitFiles string to an object.
func (r *CustomCloudInitFiles) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomCloudInitFiles: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "meta":
				r.MetaVolume = &v[1]
			case "network":
				r.NetworkVolume = &v[1]
			case "user":
				r.UserVolume = &v[1]
			case "vendor":
				r.VendorVolume = &v[1]
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomCloudInitIPConfig string to an object.
func (r *CustomCloudInitIPConfig) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomCloudInitIPConfig: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "gw":
				r.GatewayIPv4 = &v[1]
			case "gw6":
				r.GatewayIPv6 = &v[1]
			case "ip":
				r.IPv4 = &v[1]
			case "ip6":
				r.IPv6 = &v[1]
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomCloudInitFiles string to an object.
func (r *CustomCloudInitSSHKeys) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomCloudInitSSHKeys: %w", err)
	}

	s, err := url.QueryUnescape(s)
	if err != nil {
		return fmt.Errorf("error unescaping CustomCloudInitSSHKeys: %w", err)
	}

	if s != "" {
		*r = strings.Split(strings.TrimSpace(s), "\n")
	} else {
		*r = []string{}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_cpu_emulation.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomCPUEmulation handles QEMU CPU emulation parameters.
type CustomCPUEmulation struct {
	Flags      *[]string         `json:"flags,omitempty"        url:"flags,omitempty,semicolon"`
	Hidden     *types.CustomBool `json:"hidden,omitempty"       url:"hidden,omitempty,int"`
	HVVendorID *string           `json:"hv-vendor-id,omitempty" url:"hv-vendor-id,omitempty"`
	Type       string            `json:"cputype,omitempty"      url:"cputype,omitempty"`
}

// EncodeValues converts a CustomCPUEmulation struct to a URL value.
func (r *CustomCPUEmulation) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("cputype=%s", r.Type),
	}

	if r.Flags != nil && len(*r.Flags) > 0 {
		values = append(values, fmt.Sprintf("flags=%s", strings.Join(*r.Flags, ";")))
	}

	if r.Hidden != nil {
		if *r.Hidden {
			values = append(values, "hidden=1")
		} else {
			values = append(values, "hidden=0")
		}
	}

	if r.HVVendorID != nil {
		values = append(values, fmt.Sprintf("hv-vendor-id=%s", *r.HVVendorID))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomCPUEmulation string to an object.
func (r *CustomCPUEmulation) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshalling CustomCPUEmulation: %w", err)
	}

	if s == "" {
		return errors.New("unexpected empty string")
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.Type = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "cputype":
				r.Type = v[1]
			case "flags":
				if v[1] != "" {
					f := strings.Split(v[1], ";")
					r.Flags = &f
				} else {
					var f []string
					r.Flags = &f
				}
			case "hidden":
				bv := types.CustomBool(v[1] == "1")
				r.Hidden = &bv
			case "hv-vendor-id":
				r.HVVendorID = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_efi_disk.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomEFIDisk handles QEMU EFI disk parameters.
type CustomEFIDisk struct {
	FileVolume      string            `json:"file"                        url:"file"`
	Format          *string           `json:"format,omitempty"            url:"format,omitempty"`
	Type            *string           `json:"efitype,omitempty"           url:"efitype,omitempty"`
	PreEnrolledKeys *types.CustomBool `json:"pre-enrolled-keys,omitempty" url:"pre-enrolled-keys,omitempty,int"`
}

// EncodeValues converts a CustomEFIDisk struct to a URL value.
func (r *CustomEFIDisk) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("file=%s", r.FileVolume),
	}

	if r.Format != nil {
		values = append(values, fmt.Sprintf("format=%s", *r.Format))
	}

	if r.Type != nil {
		values = append(values, fmt.Sprintf("efitype=%s", *r.Type))
	}

	if r.PreEnrolledKeys != nil {
		if *r.PreEnrolledKeys {
			values = append(values, "pre-enrolled-keys=1")
		} else {
			values = append(values, "pre-enrolled-keys=0")
		}
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomEFIDisk string to an object.
func (r *CustomEFIDisk) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomEFIDisk: %w", err)
	}

	pairs := strings.Split(s, ",")

	for i, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 && i == 0 {
			r.FileVolume = v[0]
		}

		if len(v) == 2 {
			switch v[0] {
			case "file":
				r.FileVolume = v[1]
			case "format":
				r.Format = &v[1]
			case "efitype":
				t := strings.ToLower(v[1])
				r.Type = &t
			case "pre-enrolled-keys":
				bv := types.CustomBool(v[1] == "1")
				r.PreEnrolledKeys = &bv
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_network_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomNetworkDevice handles QEMU network device parameters.
type CustomNetworkDevice struct {
	Enabled    bool              `json:"-"                   url:"-"`
	Bridge     *string           `json:"bridge,omitempty"    url:"bridge,omitempty"`
	Firewall   *types.CustomBool `json:"firewall,omitempty"  url:"firewall,omitempty,int"`
	LinkDown   *types.CustomBool `json:"link_down,omitempty" url:"link_down,omitempty,int"`
	MACAddress *string           `json:"macaddr,omitempty"   url:"macaddr,omitempty"`
	MTU        *int              `json:"mtu,omitempty"       url:"mtu,omitempty"`
	Model      string            `json:"model"               url:"model"`
	Queues     *int              `json:"queues,omitempty"    url:"queues,omitempty"`
	RateLimit  *float64          `json:"rate,omitempty"      url:"rate,omitempty"`
	Tag        *int              `json:"tag,omitempty"       url:"tag,omitempty"`
	Trunks     []int             `json:"trunks,omitempty"    url:"trunks,omitempty"`
}

// CustomNetworkDevices handles QEMU network device parameters.
type CustomNetworkDevices []CustomNetworkDevice

// EncodeValues converts a CustomNetworkDevice struct to a URL value.
func (r *CustomNetworkDevice) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("model=%s", r.Model),
	}

	if r.Bridge != nil {
		values = append(values, fmt.Sprintf("bridge=%s", *r.Bridge))
	}

	if r.Firewall != nil {
		if *r.Firewall {
			values = append(values, "firewall=1")
		} else {
			values = append(values, "firewall=0")
		}
	}

	if r.LinkDown != nil {
		if *r.LinkDown {
			values = append(values, "link_down=1")
		} else {
			values = append(values, "link_down=0")
		}
	}

	if r.MACAddress != nil {
		values = append(values, fmt.Sprintf("macaddr=%s", *r.MACAddress))
	}

	if r.Queues != nil {
		values = append(values, fmt.Sprintf("queues=%d", *r.Queues))
	}

	if r.RateLimit != nil {
		values = append(values, fmt.Sprintf("rate=%f", *r.RateLimit))
	}

	if r.Tag != nil {
		values = append(values, fmt.Sprintf("tag=%d", *r.Tag))
	}

	if r.MTU != nil {
		values = append(values, fmt.Sprintf("mtu=%d", *r.MTU))
	}

	if len(r.Trunks) > 0 {
		trunks := make([]string, len(r.Trunks))

		for i, v := range r.Trunks {
			trunks[i] = strconv.Itoa(v)
		}

		values = append(values, fmt.Sprintf("trunks=%s", strings.Join(trunks, ";")))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// EncodeValues converts a CustomNetworkDevices array to multiple URL values.
func (r CustomNetworkDevices) EncodeValues(key string, v *url.Values) error {
	for i, d := range r {
		if d.Enabled {
			if err := d.EncodeValues(fmt.Sprintf("%s%d", key, i), v); err != nil {
				return fmt.Errorf("failed to encode network device %d: %w", i, err)
			}
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomNetworkDevice string to an object.
func (r *CustomNetworkDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomNetworkDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		//nolint:nestif
		if len(v) == 2 {
			switch v[0] {
			case "bridge":
				r.Bridge = &v[1]
			case "firewall":
				bv := types.CustomBool(v[1] == "1")
				r.Firewall = &bv
			case "link_down":
				bv := types.CustomBool(v[1] == "1")
				r.LinkDown = &bv
			case "macaddr":
				r.MACAddress = &v[1]
			case "model":
				r.Model = v[1]
			case "queues":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse queues: %w", err)
				}

				r.Queues = &iv
			case "rate":
				fv, err := strconv.ParseFloat(v[1], 64)
				if err != nil {
					return fmt.Errorf("failed to parse rate: %w", err)
				}

				r.RateLimit = &fv

			case "mtu":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse mtu: %w", err)
				}

				r.MTU = &iv

			case "tag":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse tag: %w", err)
				}

				r.Tag = &iv
			case "trunks":
				trunks := strings.Split(v[1], ";")
				r.Trunks = make([]int, len(trunks))

				for i, trunk := range trunks {
					iv, err := strconv.Atoi(trunk)
					if err != nil {
						return fmt.Errorf("failed to parse trunk %d: %w", i, err)
					}

					r.Trunks[i] = iv
				}
			default:
				r.MACAddress = &v[1]
				r.Model = v[0]
			}
		}
	}

	r.Enabled = true

	return nil
}
`````

## File: proxmox/nodes/vms/custom_numa_device_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"testing"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
)

func TestCustomNUMADevice_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		line    string
		want    *CustomNUMADevice
		wantErr bool
	}{
		{
			name: "numa device all options",
			line: `"cpus=1-2;3-4,hostnodes=1-2,memory=1024,policy=preferred"`,
			want: &CustomNUMADevice{
				CPUIDs:        []string{"1-2", "3-4"},
				HostNodeNames: &[]string{"1-2"},
				Memory:        ptr.Ptr(1024),
				Policy:        ptr.Ptr("preferred"),
			},
		},
		{
			name: "numa device cpus/memory only",
			line: `"cpus=1-2,memory=1024"`,
			want: &CustomNUMADevice{
				CPUIDs: []string{"1-2"},
				Memory: ptr.Ptr(1024),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &CustomNUMADevice{}
			if err := r.UnmarshalJSON([]byte(tt.line)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
`````

## File: proxmox/nodes/vms/custom_numa_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// CustomNUMADevice handles QEMU NUMA device parameters.
type CustomNUMADevice struct {
	CPUIDs        []string  `json:"cpus"                url:"cpus,semicolon"`
	HostNodeNames *[]string `json:"hostnodes,omitempty" url:"hostnodes,omitempty,semicolon"`
	Memory        *int      `json:"memory,omitempty"    url:"memory,omitempty"`
	Policy        *string   `json:"policy,omitempty"    url:"policy,omitempty"`
}

// CustomNUMADevices handles QEMU NUMA device parameters.
type CustomNUMADevices []CustomNUMADevice

// EncodeValues converts a CustomNUMADevice struct to a URL value.
func (r *CustomNUMADevice) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("cpus=%s", strings.Join(r.CPUIDs, ";")),
	}

	if r.HostNodeNames != nil {
		values = append(values, fmt.Sprintf("hostnodes=%s", strings.Join(*r.HostNodeNames, ";")))
	}

	if r.Memory != nil {
		values = append(values, fmt.Sprintf("memory=%d", *r.Memory))
	}

	if r.Policy != nil {
		values = append(values, fmt.Sprintf("policy=%s", *r.Policy))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// EncodeValues converts a CustomNUMADevices array to multiple URL values.
func (r CustomNUMADevices) EncodeValues(key string, v *url.Values) error {
	for i, d := range r {
		if err := d.EncodeValues(fmt.Sprintf("%s%d", key, i), v); err != nil {
			return fmt.Errorf("failed to encode NUMA device %d: %w", i, err)
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomNUMADevice string to an object.
func (r *CustomNUMADevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomNUMADevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")
		if len(v) == 2 {
			switch v[0] {
			case "cpus":
				r.CPUIDs = strings.Split(v[1], ";")
			case "hostnodes":
				hostnodes := strings.Split(v[1], ";")
				r.HostNodeNames = &hostnodes
			case "memory":
				memory, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse memory size: %w", err)
				}

				r.Memory = &memory
			case "policy":
				r.Policy = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_pci_device_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

func TestCustomPCIDevice_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		line    string
		want    *CustomPCIDevice
		wantErr bool
	}{
		{
			name: "id only pci device",
			line: `"0000:81:00.2"`,
			want: &CustomPCIDevice{
				DeviceIDs: &[]string{"0000:81:00.2"},
			},
		},
		{
			name: "pci device with more details",
			line: `"host=81:00.4,pcie=0,rombar=1,x-vga=0"`,
			want: &CustomPCIDevice{
				DeviceIDs:  &[]string{"81:00.4"},
				MDev:       nil,
				PCIExpress: types.CustomBool(false).Pointer(),
				ROMBAR:     types.CustomBool(true).Pointer(),
				ROMFile:    nil,
				XVGA:       types.CustomBool(false).Pointer(),
			},
		},
		{
			name: "pci device with mapping",
			line: `"mapping=mappeddevice,pcie=0,rombar=1,x-vga=0"`,
			want: &CustomPCIDevice{
				DeviceIDs:  nil,
				Mapping:    ptr.Ptr("mappeddevice"),
				MDev:       nil,
				PCIExpress: types.CustomBool(false).Pointer(),
				ROMBAR:     types.CustomBool(true).Pointer(),
				ROMFile:    nil,
				XVGA:       types.CustomBool(false).Pointer(),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &CustomPCIDevice{}
			if err := r.UnmarshalJSON([]byte(tt.line)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}

			require.Equal(t, tt.want, r)
		})
	}
}
`````

## File: proxmox/nodes/vms/custom_pci_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomPCIDevice handles QEMU host PCI device mapping parameters.
type CustomPCIDevice struct {
	DeviceIDs  *[]string         `json:"host,omitempty"    url:"host,omitempty,semicolon"`
	Mapping    *string           `json:"mapping,omitempty" url:"mapping,omitempty"`
	MDev       *string           `json:"mdev,omitempty"    url:"mdev,omitempty"`
	PCIExpress *types.CustomBool `json:"pcie,omitempty"    url:"pcie,omitempty,int"`
	ROMBAR     *types.CustomBool `json:"rombar,omitempty"  url:"rombar,omitempty,int"`
	ROMFile    *string           `json:"romfile,omitempty" url:"romfile,omitempty"`
	XVGA       *types.CustomBool `json:"x-vga,omitempty"   url:"x-vga,omitempty,int"`
}

// CustomPCIDevices handles QEMU host PCI device mapping parameters.
type CustomPCIDevices map[string]*CustomPCIDevice

// EncodeValues converts a CustomPCIDevice struct to a URL value.
func (d *CustomPCIDevice) EncodeValues(key string, v *url.Values) error {
	var values []string

	if d.DeviceIDs == nil && d.Mapping == nil {
		return fmt.Errorf("either device ID or resource mapping must be set")
	}

	if d.DeviceIDs != nil {
		values = append(values, fmt.Sprintf("host=%s", strings.Join(*d.DeviceIDs, ";")))
	}

	if d.Mapping != nil {
		values = append(values, fmt.Sprintf("mapping=%s", *d.Mapping))
	}

	if d.MDev != nil {
		values = append(values, fmt.Sprintf("mdev=%s", *d.MDev))
	}

	if d.PCIExpress != nil {
		if *d.PCIExpress {
			values = append(values, "pcie=1")
		} else {
			values = append(values, "pcie=0")
		}
	}

	if d.ROMBAR != nil {
		if *d.ROMBAR {
			values = append(values, "rombar=1")
		} else {
			values = append(values, "rombar=0")
		}
	}

	if d.ROMFile != nil {
		values = append(values, fmt.Sprintf("romfile=%s", *d.ROMFile))
	}

	if d.XVGA != nil {
		if *d.XVGA {
			values = append(values, "x-vga=1")
		} else {
			values = append(values, "x-vga=0")
		}
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// EncodeValues converts a CustomPCIDevices array to multiple URL values.
func (r CustomPCIDevices) EncodeValues(_ string, v *url.Values) error {
	for s, d := range r {
		if err := d.EncodeValues(s, v); err != nil {
			return fmt.Errorf("failed to encode PCI device %s: %w", s, err)
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomPCIDevice string to an object.
func (d *CustomPCIDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomPCIDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")
		if len(v) == 1 {
			dIDs := strings.Split(v[0], ";")
			d.DeviceIDs = &dIDs
		} else if len(v) == 2 {
			switch v[0] {
			case "host":
				dIDs := strings.Split(v[1], ";")
				d.DeviceIDs = &dIDs
			case "mapping":
				d.Mapping = &v[1]
			case "mdev":
				d.MDev = &v[1]
			case "pcie":
				bv := types.CustomBool(v[1] == "1")
				d.PCIExpress = &bv
			case "rombar":
				bv := types.CustomBool(v[1] == "1")
				d.ROMBAR = &bv
			case "romfile":
				d.ROMFile = &v[1]
			case "x-vga":
				bv := types.CustomBool(v[1] == "1")
				d.XVGA = &bv
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_rng_device_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"net/url"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
)

func TestCustomRNGDevice_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		line    string
		want    *CustomRNGDevice
		wantErr bool
	}{
		{
			name: "source only",
			line: `"source=urandom"`,
			want: &CustomRNGDevice{
				Source: "urandom",
			},
		},
		{
			name: "all options",
			line: `"source=/dev/random,max_bytes=1024,period=1000"`,
			want: &CustomRNGDevice{
				Source:   "/dev/random",
				MaxBytes: ptr.Ptr(1024),
				Period:   ptr.Ptr(1000),
			},
		},
		{
			name: "source with max_bytes",
			line: `"source=urandom,max_bytes=2048"`,
			want: &CustomRNGDevice{
				Source:   "urandom",
				MaxBytes: ptr.Ptr(2048),
			},
		},
		{
			name: "source with period",
			line: `"source=urandom,period=2000"`,
			want: &CustomRNGDevice{
				Source: "urandom",
				Period: ptr.Ptr(2000),
			},
		},
		{
			name:    "invalid JSON",
			line:    `{"source": "urandom"}`,
			wantErr: true,
		},
		{
			name:    "invalid max_bytes",
			line:    `"source=urandom,max_bytes=invalid"`,
			wantErr: true,
		},
		{
			name:    "invalid period",
			line:    `"source=urandom,period=invalid"`,
			wantErr: true,
		},
		{
			name: "single value source",
			line: `"urandom"`,
			want: &CustomRNGDevice{
				Source: "urandom",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &CustomRNGDevice{}
			err := r.UnmarshalJSON([]byte(tt.line))

			if tt.wantErr {
				require.Error(t, err)
				return
			}

			require.NoError(t, err)
			require.Equal(t, tt.want, r)
		})
	}
}

func TestCustomRNGDevice_EncodeValues(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		device   *CustomRNGDevice
		key      string
		expected string
	}{
		{
			name: "source only",
			device: &CustomRNGDevice{
				Source: "urandom",
			},
			key:      "rng0",
			expected: "source=urandom",
		},
		{
			name: "all options",
			device: &CustomRNGDevice{
				Source:   "/dev/random",
				MaxBytes: ptr.Ptr(1024),
				Period:   ptr.Ptr(1000),
			},
			key:      "rng0",
			expected: "source=/dev/random,max_bytes=1024,period=1000",
		},
		{
			name: "source with max_bytes",
			device: &CustomRNGDevice{
				Source:   "urandom",
				MaxBytes: ptr.Ptr(2048),
			},
			key:      "rng0",
			expected: "source=urandom,max_bytes=2048",
		},
		{
			name: "source with period",
			device: &CustomRNGDevice{
				Source: "urandom",
				Period: ptr.Ptr(2000),
			},
			key:      "rng0",
			expected: "source=urandom,period=2000",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			values := &url.Values{}
			err := tt.device.EncodeValues(tt.key, values)
			require.NoError(t, err)
			require.Equal(t, tt.expected, values.Get(tt.key))
		})
	}
}
`````

## File: proxmox/nodes/vms/custom_rng_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// CustomRNGDevice represents a random number generator device configuration.
type CustomRNGDevice struct {
	Source   string `json:"source,omitempty"    url:"source,omitempty"`
	MaxBytes *int   `json:"max_bytes,omitempty" url:"max_bytes,omitempty"`
	Period   *int   `json:"period,omitempty"    url:"period,omitempty"`
}

// EncodeValues converts a CustomRNGDevice struct to a URL value.
func (r *CustomRNGDevice) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.Source != "" {
		values = append(values, fmt.Sprintf("source=%s", r.Source))
	}

	if r.MaxBytes != nil {
		values = append(values, fmt.Sprintf("max_bytes=%d", *r.MaxBytes))
	}

	if r.Period != nil {
		values = append(values, fmt.Sprintf("period=%d", *r.Period))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON unmarshals a JSON object into a CustomRNGDevice struct.
func (r *CustomRNGDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomRNGDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")
		if len(v) == 1 {
			r.Source = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "source":
				r.Source = v[1]

			case "max_bytes":
				maxBytes, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse max_bytes: %w", err)
				}

				r.MaxBytes = &maxBytes

			case "period":
				period, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse period: %w", err)
				}

				r.Period = &period
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_serial_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"fmt"
	"net/url"
)

// CustomSerialDevices handles QEMU serial device parameters.
type CustomSerialDevices []string

// EncodeValues converts a CustomSerialDevices array to multiple URL values.
func (r CustomSerialDevices) EncodeValues(key string, v *url.Values) error {
	for i, d := range r {
		v.Add(fmt.Sprintf("%s%d", key, i), d)
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_shared_memory.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// CustomSharedMemory handles QEMU Inter-VM shared memory parameters.
type CustomSharedMemory struct {
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	Size int     `json:"size"           url:"size"`
}

// EncodeValues converts a CustomSharedMemory struct to a URL value.
func (r *CustomSharedMemory) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("size=%d", r.Size),
	}

	if r.Name != nil {
		values = append(values, fmt.Sprintf("name=%s", *r.Name))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomSharedMemory string to an object.
func (r *CustomSharedMemory) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomSharedMemory: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "name":
				r.Name = &v[1]
			case "size":
				var err error

				r.Size, err = strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse shared memory size: %w", err)
				}
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_smbios.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomSMBIOS handles QEMU SMBIOS parameters.
type CustomSMBIOS struct {
	Base64       *types.CustomBool `json:"base64,omitempty"       url:"base64,omitempty,int"`
	Family       *string           `json:"family,omitempty"       url:"family,omitempty"`
	Manufacturer *string           `json:"manufacturer,omitempty" url:"manufacturer,omitempty"`
	Product      *string           `json:"product,omitempty"      url:"product,omitempty"`
	Serial       *string           `json:"serial,omitempty"       url:"serial,omitempty"`
	SKU          *string           `json:"sku,omitempty"          url:"sku,omitempty"`
	UUID         *string           `json:"uuid,omitempty"         url:"uuid,omitempty"`
	Version      *string           `json:"version,omitempty"      url:"version,omitempty"`
}

// EncodeValues converts a CustomSMBIOS struct to a URL value.
func (r *CustomSMBIOS) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.Base64 != nil {
		if *r.Base64 {
			values = append(values, "base64=1")
		} else {
			values = append(values, "base64=0")
		}
	}

	if r.Family != nil {
		values = append(values, fmt.Sprintf("family=%s", *r.Family))
	}

	if r.Manufacturer != nil {
		values = append(values, fmt.Sprintf("manufacturer=%s", *r.Manufacturer))
	}

	if r.Product != nil {
		values = append(values, fmt.Sprintf("product=%s", *r.Product))
	}

	if r.Serial != nil {
		values = append(values, fmt.Sprintf("serial=%s", *r.Serial))
	}

	if r.SKU != nil {
		values = append(values, fmt.Sprintf("sku=%s", *r.SKU))
	}

	if r.UUID != nil {
		values = append(values, fmt.Sprintf("uuid=%s", *r.UUID))
	}

	if r.Version != nil {
		values = append(values, fmt.Sprintf("version=%s", *r.Version))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON converts a CustomSMBIOS string to an object.
func (r *CustomSMBIOS) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomSMBIOS: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.SplitN(strings.TrimSpace(p), "=", 2)

		if len(v) == 2 {
			switch v[0] {
			case "base64":
				base64 := types.CustomBool(v[1] == "1")
				r.Base64 = &base64
			case "family":
				r.Family = &v[1]
			case "manufacturer":
				r.Manufacturer = &v[1]
			case "product":
				r.Product = &v[1]
			case "serial":
				r.Serial = &v[1]
			case "sku":
				r.SKU = &v[1]
			case "uuid":
				r.UUID = &v[1]
			case "version":
				r.Version = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_spice_enhancements.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomSpiceEnhancements handles QEMU spice enhancement parameters.
type CustomSpiceEnhancements struct {
	FolderSharing  *types.CustomBool `json:"foldersharing,omitempty"  url:"foldersharing,omitempty"`
	VideoStreaming *string           `json:"videostreaming,omitempty" url:"videostreaming,omitempty"`
}

// EncodeValues converts a CustomSpiceEnhancements struct to a URL value.
func (r *CustomSpiceEnhancements) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.FolderSharing != nil {
		if *r.FolderSharing {
			values = append(values, "foldersharing=1")
		} else {
			values = append(values, "foldersharing=0")
		}
	}

	if r.VideoStreaming != nil {
		values = append(values, fmt.Sprintf("videostreaming=%s", *r.VideoStreaming))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON converts JSON to a CustomSpiceEnhancements struct.
func (r *CustomSpiceEnhancements) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomSpiceEnhancements: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "foldersharing":
				v := types.CustomBool(v[1] == "1")
				r.FolderSharing = &v
			case "videostreaming":
				r.VideoStreaming = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_startup_order.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// CustomStartupOrder handles QEMU startup order parameters.
type CustomStartupOrder struct {
	Down  *int `json:"down,omitempty"  url:"down,omitempty"`
	Order *int `json:"order,omitempty" url:"order,omitempty"`
	Up    *int `json:"up,omitempty"    url:"up,omitempty"`
}

// EncodeValues converts a CustomStartupOrder struct to a URL value.
func (r *CustomStartupOrder) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.Order != nil {
		values = append(values, fmt.Sprintf("order=%d", *r.Order))
	}

	if r.Up != nil {
		values = append(values, fmt.Sprintf("up=%d", *r.Up))
	}

	if r.Down != nil {
		values = append(values, fmt.Sprintf("down=%d", *r.Down))
	}

	if len(values) > 0 {
		v.Add(key, strings.Join(values, ","))
	}

	return nil
}

// UnmarshalJSON converts a CustomStartupOrder string to an object.
func (r *CustomStartupOrder) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomStartupOrder: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 2 {
			switch v[0] {
			case "order":
				order, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse int: %w", err)
				}

				r.Order = &order
			case "up":
				up, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse int: %w", err)
				}

				r.Up = &up
			case "down":
				down, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to parse int: %w", err)
				}

				r.Down = &down
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_storage_device_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

func TestCustomStorageDevice_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	ds8gig := types.DiskSizeFromGigabytes(8)
	tests := []struct {
		name    string
		line    string
		want    *CustomStorageDevice
		wantErr bool
	}{
		{
			name: "simple volume",
			line: `"local-lvm:vm-2041-disk-0,discard=on,ssd=1,iothread=1,size=8G,cache=writeback"`,
			want: &CustomStorageDevice{
				Cache:      ptr.Ptr("writeback"),
				Discard:    ptr.Ptr("on"),
				FileVolume: "local-lvm:vm-2041-disk-0",
				IOThread:   types.CustomBool(true).Pointer(),
				Size:       ds8gig,
				SSD:        types.CustomBool(true).Pointer(),
			},
		},
		{
			name: "volume with dot",
			line: `"volumes.hdd:base-269-disk-0,cache=writeback,discard=on,iothread=1,size=8G,ssd=1"`,
			want: &CustomStorageDevice{
				Cache:      ptr.Ptr("writeback"),
				Discard:    ptr.Ptr("on"),
				FileVolume: "volumes.hdd:base-269-disk-0",
				IOThread:   types.CustomBool(true).Pointer(),
				Size:       ds8gig,
				SSD:        types.CustomBool(true).Pointer(),
			},
		},
		{
			name: "raw volume type",
			line: `"nfs:2041/vm-2041-disk-0.raw,discard=ignore,ssd=1,iothread=1,size=8G"`,
			want: &CustomStorageDevice{
				Discard:    ptr.Ptr("ignore"),
				FileVolume: "nfs:2041/vm-2041-disk-0.raw",
				Format:     ptr.Ptr("raw"),
				IOThread:   types.CustomBool(true).Pointer(),
				Size:       ds8gig,
				SSD:        types.CustomBool(true).Pointer(),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &CustomStorageDevice{}
			if err := r.UnmarshalJSON([]byte(tt.line)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}

			require.Equal(t, tt.want, r)
		})
	}
}

func TestCustomStorageDevice_IsCloudInitDrive(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name   string
		device CustomStorageDevice
		want   bool
	}{
		{
			name: "simple volume",
			device: CustomStorageDevice{
				FileVolume: "local-lvm:vm-131-disk-0",
			},
			want: false,
		}, {
			name: "on directory storage",
			device: CustomStorageDevice{
				Media:      ptr.Ptr("cdrom"),
				FileVolume: "local:131/vm-131-cloudinit.qcow2",
			},
			want: true,
		}, {
			name: "on block storage",
			device: CustomStorageDevice{
				Media:      ptr.Ptr("cdrom"),
				FileVolume: "local-lvm:vm-131-cloudinit",
			},
			want: true,
		}, {
			name: "wrong VM ID",
			device: CustomStorageDevice{
				Media:      ptr.Ptr("cdrom"),
				FileVolume: "local-lvm:vm-123-cloudinit",
			},
			want: false,
		}, {
			name: "not a cdrom",
			device: CustomStorageDevice{
				FileVolume: "local-lvm:vm-123-cloudinit",
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got := tt.device.IsCloudInitDrive(131)
			assert.Equal(t, tt.want, got)
		})
	}
}
`````

## File: proxmox/nodes/vms/custom_storage_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// StorageInterfaces is a list of supported storage interfaces.
//
//nolint:gochecknoglobals
var StorageInterfaces = []string{"ide", "sata", "scsi", "virtio"}

// CustomStorageDevice handles QEMU SATA device parameters.
type CustomStorageDevice struct {
	// FileVolume is the path to the storage device in format
	// "STORAGE_ID:SIZE_IN_GiB" or "STORAGE_ID:PATH_TO_FILE".
	// This is a required field.
	FileVolume string `json:"file" url:"file"`

	AIO                     *string           `json:"aio,omitempty"         url:"aio,omitempty"`
	Backup                  *types.CustomBool `json:"backup,omitempty"      url:"backup,omitempty,int"`
	BurstableReadSpeedMbps  *int              `json:"mbps_rd_max,omitempty" url:"mbps_rd_max,omitempty"`
	BurstableWriteSpeedMbps *int              `json:"mbps_wr_max,omitempty" url:"mbps_wr_max,omitempty"`
	Cache                   *string           `json:"cache,omitempty"       url:"cache,omitempty"`
	Discard                 *string           `json:"discard,omitempty"     url:"discard,omitempty"`
	Format                  *string           `json:"format,omitempty"      url:"format,omitempty"`
	IopsRead                *int              `json:"iops_rd,omitempty"     url:"iops_rd,omitempty"`
	IopsWrite               *int              `json:"iops_wr,omitempty"     url:"iops_wr,omitempty"`
	IOThread                *types.CustomBool `json:"iothread,omitempty"    url:"iothread,omitempty,int"`
	MaxIopsRead             *int              `json:"iops_rd_max,omitempty" url:"iops_rd_max,omitempty"`
	MaxIopsWrite            *int              `json:"iops_wr_max,omitempty" url:"iops_wr_max,omitempty"`
	MaxReadSpeedMbps        *int              `json:"mbps_rd,omitempty"     url:"mbps_rd,omitempty"`
	MaxWriteSpeedMbps       *int              `json:"mbps_wr,omitempty"     url:"mbps_wr,omitempty"`
	Media                   *string           `json:"media,omitempty"       url:"media,omitempty"`
	Replicate               *types.CustomBool `json:"replicate,omitempty"   url:"replicate,omitempty,int"`
	Serial                  *string           `json:"serial,omitempty"      url:"serial,omitempty"`
	Size                    *types.DiskSize   `json:"size,omitempty"        url:"size,omitempty"`
	SSD                     *types.CustomBool `json:"ssd,omitempty"         url:"ssd,omitempty,int"`
	DatastoreID             *string           `json:"-"                     url:"-"`
	FileID                  *string           `json:"-"                     url:"-"`
}

// CustomStorageDevices handles map of QEMU storage device per disk interface.
type CustomStorageDevices map[string]*CustomStorageDevice

// PathInDatastore returns path part of FileVolume or nil if it is not yet allocated.
func (d *CustomStorageDevice) PathInDatastore() *string {
	probablyDatastoreID, pathInDatastore, hasDatastoreID := strings.Cut(d.FileVolume, ":")
	if !hasDatastoreID {
		// when no ':' separator is found, 'Cut' places the whole string to 'probablyDatastoreID',
		// we want it in 'pathInDatastore' (as it is absolute filesystem path)
		pathInDatastore = probablyDatastoreID

		return &pathInDatastore
	}

	pathInDatastoreWithoutDigits := strings.Map(
		func(c rune) rune {
			if c < '0' || c > '9' {
				return -1
			}

			return c
		},
		pathInDatastore)

	if pathInDatastoreWithoutDigits == "" {
		// FileVolume is not yet allocated, it is in the "STORAGE_ID:SIZE_IN_GiB" format
		return nil
	}

	return &pathInDatastore
}

// IsOwnedBy returns true, if CustomStorageDevice is owned by given VM.
// Not yet allocated volumes are not owned by any VM.
func (d *CustomStorageDevice) IsOwnedBy(vmID int) bool {
	pathInDatastore := d.PathInDatastore()
	if pathInDatastore == nil {
		// not yet allocated volume, consider disk not owned by any VM
		// NOTE: if needed, create IsOwnedByOtherThan(vmId) instead of changing this return value.
		return false
	}

	// ZFS uses "local-zfs:vm-123-disk-0"
	if strings.HasPrefix(*pathInDatastore, fmt.Sprintf("vm-%d-", vmID)) {
		return true
	}

	// directory uses "local:123/vm-123-disk-0"
	if strings.HasPrefix(*pathInDatastore, fmt.Sprintf("%d/vm-%d-", vmID, vmID)) {
		return true
	}

	return false
}

// IsCloudInitDrive returns true, if CustomStorageDevice is a cloud-init drive.
func (d *CustomStorageDevice) IsCloudInitDrive(vmID int) bool {
	return d.Media != nil && *d.Media == "cdrom" &&
		strings.Contains(d.FileVolume, fmt.Sprintf("vm-%d-cloudinit", vmID))
}

// EncodeOptions converts a CustomStorageDevice's common options a URL value.
func (d *CustomStorageDevice) EncodeOptions() string {
	var values []string

	if d.AIO != nil {
		values = append(values, fmt.Sprintf("aio=%s", *d.AIO))
	}

	if d.Backup != nil {
		if *d.Backup {
			values = append(values, "backup=1")
		} else {
			values = append(values, "backup=0")
		}
	}

	if d.IopsRead != nil {
		values = append(values, fmt.Sprintf("iops_rd=%d", *d.IopsRead))
	}

	if d.IopsWrite != nil {
		values = append(values, fmt.Sprintf("iops_wr=%d", *d.IopsWrite))
	}

	if d.MaxIopsRead != nil {
		values = append(values, fmt.Sprintf("iops_rd_max=%d", *d.MaxIopsRead))
	}

	if d.MaxIopsWrite != nil {
		values = append(values, fmt.Sprintf("iops_wr_max=%d", *d.MaxIopsWrite))
	}

	if d.IOThread != nil {
		if *d.IOThread {
			values = append(values, "iothread=1")
		} else {
			values = append(values, "iothread=0")
		}
	}

	if d.Serial != nil && *d.Serial != "" {
		values = append(values, fmt.Sprintf("serial=%s", *d.Serial))
	}

	if d.SSD != nil {
		if *d.SSD {
			values = append(values, "ssd=1")
		} else {
			values = append(values, "ssd=0")
		}
	}

	if d.Discard != nil && *d.Discard != "" {
		values = append(values, fmt.Sprintf("discard=%s", *d.Discard))
	}

	if d.Cache != nil && *d.Cache != "" {
		values = append(values, fmt.Sprintf("cache=%s", *d.Cache))
	}

	if d.BurstableReadSpeedMbps != nil {
		values = append(values, fmt.Sprintf("mbps_rd_max=%d", *d.BurstableReadSpeedMbps))
	}

	if d.BurstableWriteSpeedMbps != nil {
		values = append(values, fmt.Sprintf("mbps_wr_max=%d", *d.BurstableWriteSpeedMbps))
	}

	if d.MaxReadSpeedMbps != nil {
		values = append(values, fmt.Sprintf("mbps_rd=%d", *d.MaxReadSpeedMbps))
	}

	if d.MaxWriteSpeedMbps != nil {
		values = append(values, fmt.Sprintf("mbps_wr=%d", *d.MaxWriteSpeedMbps))
	}

	if d.Replicate != nil {
		if *d.Replicate {
			values = append(values, "replicate=1")
		} else {
			values = append(values, "replicate=0")
		}
	}

	return strings.Join(values, ",")
}

// EncodeValues converts a CustomStorageDevice struct to a URL value.
func (d *CustomStorageDevice) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("file=%s", d.FileVolume),
	}

	if d.Format != nil {
		values = append(values, fmt.Sprintf("format=%s", *d.Format))
	}

	if d.Media != nil {
		values = append(values, fmt.Sprintf("media=%s", *d.Media))
	}

	if d.Size != nil {
		values = append(values, fmt.Sprintf("size=%d", *d.Size))
	}

	values = append(values, d.EncodeOptions())

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomStorageDevice string to an object.
func (d *CustomStorageDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomStorageDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		//nolint:nestif
		if len(v) == 1 {
			d.FileVolume = v[0]

			// split file volume into datastore ID and path
			_, pathInDatastore, hasDatastoreID := strings.Cut(v[0], ":")
			if hasDatastoreID {
				// we don't set them here,... but probably should
				// d.DatastoreID = &probablyDatastoreID
				// d.FileID = &pathInDatastore
				ext := filepath.Ext(pathInDatastore)
				if ext != "" {
					format := string([]byte(ext)[1:])
					d.Format = &format
				}
			}
		} else if len(v) == 2 {
			switch v[0] {
			case "aio":
				d.AIO = &v[1]

			case "backup":
				bv := types.CustomBool(v[1] == "1")
				d.Backup = &bv

			case "cache":
				d.Cache = &v[1]

			case "discard":
				d.Discard = &v[1]

			case "file":
				d.FileVolume = v[1]

			case "format":
				d.Format = &v[1]

			case "iops_rd":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert iops_rd to int: %w", err)
				}

				d.IopsRead = &iv

			case "iops_rd_max":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert iops_rd_max to int: %w", err)
				}

				d.MaxIopsRead = &iv

			case "iops_wr":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert iops_wr to int: %w", err)
				}

				d.IopsWrite = &iv

			case "iops_wr_max":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert iops_wr_max to int: %w", err)
				}

				d.MaxIopsWrite = &iv

			case "iothread":
				bv := types.CustomBool(v[1] == "1")
				d.IOThread = &bv

			case "mbps_rd":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert mbps_rd to int: %w", err)
				}

				d.MaxReadSpeedMbps = &iv

			case "mbps_rd_max":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert mbps_rd_max to int: %w", err)
				}

				d.BurstableReadSpeedMbps = &iv

			case "mbps_wr":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert mbps_wr to int: %w", err)
				}

				d.MaxWriteSpeedMbps = &iv

			case "mbps_wr_max":
				iv, err := strconv.Atoi(v[1])
				if err != nil {
					return fmt.Errorf("failed to convert mbps_wr_max to int: %w", err)
				}

				d.BurstableWriteSpeedMbps = &iv

			case "media":
				d.Media = &v[1]

			case "replicate":
				bv := types.CustomBool(v[1] == "1")
				d.Replicate = &bv

			case "serial":
				d.Serial = &v[1]

			case "size":
				d.Size = new(types.DiskSize)

				err := d.Size.UnmarshalJSON([]byte(v[1]))
				if err != nil {
					return fmt.Errorf("failed to unmarshal disk size: %w", err)
				}

			case "ssd":
				bv := types.CustomBool(v[1] == "1")
				d.SSD = &bv
			}
		}
	}

	return nil
}

// MergeWith merges attributes of the given CustomStorageDevice with the current one.
// It will overwrite the current attributes with the given ones if they are not nil.
// The attributes that are not merged are:
//   - DatastoreID
//   - FileID
//   - FileVolume
//   - Format
//
// It will return true if any attribute of the current CustomStorageDevice was changed.
func (d *CustomStorageDevice) MergeWith(m CustomStorageDevice) bool {
	updated := ptr.UpdateIfChanged(&d.AIO, m.AIO)
	updated = ptr.UpdateIfChanged(&d.Backup, m.Backup) || updated
	updated = ptr.UpdateIfChanged(&d.BurstableReadSpeedMbps, m.BurstableReadSpeedMbps) || updated
	updated = ptr.UpdateIfChanged(&d.BurstableWriteSpeedMbps, m.BurstableWriteSpeedMbps) || updated
	updated = ptr.UpdateIfChanged(&d.Cache, m.Cache) || updated
	updated = ptr.UpdateIfChanged(&d.Discard, m.Discard) || updated
	updated = ptr.UpdateIfChanged(&d.IOThread, m.IOThread) || updated
	updated = ptr.UpdateIfChanged(&d.IopsRead, m.IopsRead) || updated
	updated = ptr.UpdateIfChanged(&d.IopsWrite, m.IopsWrite) || updated
	updated = ptr.UpdateIfChanged(&d.Media, m.Media) || updated
	updated = ptr.UpdateIfChanged(&d.MaxIopsRead, m.MaxIopsRead) || updated
	updated = ptr.UpdateIfChanged(&d.MaxIopsWrite, m.MaxIopsWrite) || updated
	updated = ptr.UpdateIfChanged(&d.MaxReadSpeedMbps, m.MaxReadSpeedMbps) || updated
	updated = ptr.UpdateIfChanged(&d.MaxWriteSpeedMbps, m.MaxWriteSpeedMbps) || updated
	updated = ptr.UpdateIfChanged(&d.Replicate, m.Replicate) || updated
	updated = ptr.UpdateIfChanged(&d.SSD, m.SSD) || updated
	updated = ptr.UpdateIfChanged(&d.Serial, m.Serial) || updated

	return updated
}

// Filter returns a map of CustomStorageDevices filtered by the given function.
func (d CustomStorageDevices) Filter(fn func(*CustomStorageDevice) bool) CustomStorageDevices {
	result := make(CustomStorageDevices)

	for k, v := range d {
		if fn(v) {
			result[k] = v
		}
	}

	return result
}

// EncodeValues converts a CustomStorageDevices array to multiple URL values.
func (d CustomStorageDevices) EncodeValues(_ string, v *url.Values) error {
	for s, d := range d {
		// Explicitly skip disks which have FileID set, so it won't be encoded in "Create" or "Update" operations.
		if d.FileID == nil || *d.FileID == "" {
			if err := d.EncodeValues(s, v); err != nil {
				return fmt.Errorf("error encoding storage device %s: %w", s, err)
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_tpm_state.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// CustomTPMState handles QEMU TPM state parameters.
type CustomTPMState struct {
	FileVolume string  `json:"file"              url:"file"`
	Version    *string `json:"version,omitempty" url:"version,omitempty"`
}

// EncodeValues converts a CustomTPMState struct to a URL value.
func (r *CustomTPMState) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("file=%s", r.FileVolume),
	}

	if r.Version != nil {
		values = append(values, fmt.Sprintf("version=%s", *r.Version))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomTPMState string to an object.
func (r *CustomTPMState) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomTPMState: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")
		if len(v) == 1 {
			r.FileVolume = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "file":
				r.FileVolume = v[1]
			case "version":
				r.Version = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_usb_device_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"testing"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

func TestCustomUSBDevice_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		line    string
		want    *CustomUSBDevice
		wantErr bool
	}{
		{
			name: "id only usb device",
			line: `"host=0000:81"`,
			want: &CustomUSBDevice{
				HostDevice: ptr.Ptr("0000:81"),
			},
		},
		{
			name: "usb device with more details",
			line: `"host=81:00,usb3=0"`,
			want: &CustomUSBDevice{
				HostDevice: ptr.Ptr("81:00"),
				USB3:       types.CustomBool(false).Pointer(),
			},
		},
		{
			name: "usb device with mapping",
			line: `"mapping=mappeddevice,usb=0"`,
			want: &CustomUSBDevice{
				HostDevice: nil,
				Mapping:    ptr.Ptr("mappeddevice"),
				USB3:       types.CustomBool(false).Pointer(),
			},
		},
		{
			name: "spice usb device",
			line: `"spice"`,
			want: &CustomUSBDevice{
				HostDevice: ptr.Ptr("spice"),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &CustomUSBDevice{}
			if err := r.UnmarshalJSON([]byte(tt.line)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
`````

## File: proxmox/nodes/vms/custom_usb_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomUSBDevice handles QEMU USB device parameters.
type CustomUSBDevice struct {
	HostDevice *string           `json:"host"              url:"host"`
	Mapping    *string           `json:"mapping,omitempty" url:"mapping,omitempty"`
	USB3       *types.CustomBool `json:"usb3,omitempty"    url:"usb3,omitempty,int"`
}

// CustomUSBDevices handles QEMU USB device parameters.
type CustomUSBDevices []CustomUSBDevice

// EncodeValues converts a CustomUSBDevice struct to a URL value.
func (r *CustomUSBDevice) EncodeValues(key string, v *url.Values) error {
	if r.HostDevice == nil && r.Mapping == nil {
		return fmt.Errorf("either device ID or resource mapping must be set")
	}

	var values []string
	if r.HostDevice != nil {
		values = append(values, fmt.Sprintf("host=%s", *(r.HostDevice)))
	}

	if r.Mapping != nil {
		values = append(values, fmt.Sprintf("mapping=%s", *r.Mapping))
	}

	if r.USB3 != nil {
		if *r.USB3 {
			values = append(values, "usb3=1")
		} else {
			values = append(values, "usb3=0")
		}
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// EncodeValues converts a CustomUSBDevices array to multiple URL values.
func (r CustomUSBDevices) EncodeValues(key string, v *url.Values) error {
	for i, d := range r {
		if err := d.EncodeValues(fmt.Sprintf("%s%d", key, i), v); err != nil {
			return fmt.Errorf("error encoding USB device %d: %w", i, err)
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomUSBDevice string to an object.
func (r *CustomUSBDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomUSBDevice: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")
		if len(v) == 1 {
			r.HostDevice = &v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "host":
				r.HostDevice = &v[1]
			case "mapping":
				r.Mapping = &v[1]
			case "usb3":
				bv := types.CustomBool(v[1] == "1")
				r.USB3 = &bv
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_vga_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// CustomVGADevice handles QEMU VGA device parameters.
type CustomVGADevice struct {
	Clipboard *string `json:"clipboard,omitempty" url:"memory,omitempty"`
	Memory    *int64  `json:"memory,omitempty"    url:"memory,omitempty"`
	Type      *string `json:"type,omitempty"      url:"type,omitempty"`
}

// EncodeValues converts a CustomVGADevice struct to a URL value.
func (r *CustomVGADevice) EncodeValues(key string, v *url.Values) error {
	var values []string

	if r.Clipboard != nil {
		values = append(values, fmt.Sprintf("clipboard=%s", *r.Clipboard))
	}

	if r.Memory != nil {
		values = append(values, fmt.Sprintf("memory=%d", *r.Memory))
	}

	if r.Type != nil {
		values = append(values, fmt.Sprintf("type=%s", *r.Type))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomVGADevice string to an object.
func (r *CustomVGADevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomVGADevice: %w", err)
	}

	if s == "" {
		return nil
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.Type = &v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "clipboard":
				r.Clipboard = &v[1]

			case "memory":
				m, err := strconv.ParseInt(v[1], 10, 64)
				if err != nil {
					return fmt.Errorf("failed to convert memory to int: %w", err)
				}

				r.Memory = &m
			case "type":
				r.Type = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_virtiofs_share_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"testing"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

func TestCustomVirtiofsShare_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		line    string
		want    *CustomVirtiofsShare
		wantErr bool
	}{
		{
			name: "id only virtiofs share",
			line: `"test"`,
			want: &CustomVirtiofsShare{
				DirId: "test",
			},
		},
		{
			name: "virtiofs share with more details",
			line: `"folder,cache=always"`,
			want: &CustomVirtiofsShare{
				DirId: "folder",
				Cache: ptr.Ptr("always"),
			},
		},
		{
			name: "virtiofs share with flags",
			line: `"folder,cache=never,direct-io=1,expose-acl=1"`,
			want: &CustomVirtiofsShare{
				DirId:       "folder",
				Cache:       ptr.Ptr("never"),
				DirectIo:    types.CustomBool(true).Pointer(),
				ExposeAcl:   types.CustomBool(true).Pointer(),
				ExposeXattr: types.CustomBool(true).Pointer(),
			},
		},
		{
			name: "virtiofs share with xattr",
			line: `"folder,expose-xattr=1"`,
			want: &CustomVirtiofsShare{
				DirId:       "folder",
				Cache:       nil,
				DirectIo:    types.CustomBool(false).Pointer(),
				ExposeAcl:   types.CustomBool(false).Pointer(),
				ExposeXattr: types.CustomBool(true).Pointer(),
			},
		},
		{
			name:    "virtiofs share invalid combination",
			line:    `"folder,expose-acl=1,expose-xattr=0"`,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &CustomVirtiofsShare{}
			if err := r.UnmarshalJSON([]byte(tt.line)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
`````

## File: proxmox/nodes/vms/custom_virtiofs_share.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomVirtiofsShare handles Virtiofs directory shares.
type CustomVirtiofsShare struct {
	DirId       string            `json:"dirid"                  url:"dirid"`
	Cache       *string           `json:"cache,omitempty"        url:"cache,omitempty"`
	DirectIo    *types.CustomBool `json:"direct-io,omitempty"    url:"direct-io,omitempty,int"`
	ExposeAcl   *types.CustomBool `json:"expose-acl,omitempty"   url:"expose-acl,omitempty,int"`
	ExposeXattr *types.CustomBool `json:"expose-xattr,omitempty" url:"expose-xattr,omitempty,int"`
}

// CustomVirtiofsShares handles Virtiofs directory shares.
type CustomVirtiofsShares map[string]*CustomVirtiofsShare

// EncodeValues converts a CustomVirtiofsShare struct to a URL value.
func (r *CustomVirtiofsShare) EncodeValues(key string, v *url.Values) error {
	if r.ExposeAcl != nil && *r.ExposeAcl && r.ExposeXattr != nil && !*r.ExposeXattr {
		// expose-xattr implies expose-acl
		return errors.New("expose_xattr must be omitted or true when expose_acl is enabled")
	}

	var values []string
	values = append(values, fmt.Sprintf("dirid=%s", r.DirId))

	if r.Cache != nil {
		values = append(values, fmt.Sprintf("cache=%s", *r.Cache))
	}

	if r.DirectIo != nil {
		if *r.DirectIo {
			values = append(values, "direct-io=1")
		} else {
			values = append(values, "direct-io=0")
		}
	}

	if r.ExposeAcl != nil {
		if *r.ExposeAcl {
			values = append(values, "expose-acl=1")
		} else {
			values = append(values, "expose-acl=0")
		}
	}

	if r.ExposeXattr != nil && (r.ExposeAcl == nil || !*r.ExposeAcl) {
		// expose-acl implies expose-xattr, omit it when unnecessary for consistency
		if *r.ExposeXattr {
			values = append(values, "expose-xattr=1")
		} else {
			values = append(values, "expose-xattr=0")
		}
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// EncodeValues converts a CustomVirtiofsShares dict to multiple URL values.
func (r CustomVirtiofsShares) EncodeValues(_ string, v *url.Values) error {
	for s, d := range r {
		if err := d.EncodeValues(s, v); err != nil {
			return fmt.Errorf("failed to encode virtiofs share %s: %w", s, err)
		}
	}

	return nil
}

// UnmarshalJSON converts a CustomVirtiofsShare string to an object.
func (r *CustomVirtiofsShare) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomVirtiofsShare: %w", err)
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.DirId = v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "dirid":
				r.DirId = v[1]
			case "cache":
				r.Cache = &v[1]
			case "direct-io":
				bv := types.CustomBool(v[1] == "1")
				r.DirectIo = &bv
			case "expose-acl":
				bv := types.CustomBool(v[1] == "1")
				r.ExposeAcl = &bv
			case "expose-xattr":
				bv := types.CustomBool(v[1] == "1")
				r.ExposeXattr = &bv
			}
		}
	}

	// expose-acl implies expose-xattr
	if r.ExposeAcl != nil && *r.ExposeAcl {
		if r.ExposeXattr == nil {
			bv := types.CustomBool(true)
			r.ExposeAcl = &bv
		} else if !*r.ExposeXattr {
			return fmt.Errorf("failed to unmarshal CustomVirtiofsShare: expose-xattr contradicts the value of expose-acl")
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_virtualio_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomVirtualIODevice handles QEMU VirtIO device parameters.
type CustomVirtualIODevice struct {
	AIO           *string           `json:"aio,omitempty"    url:"aio,omitempty"`
	BackupEnabled *types.CustomBool `json:"backup,omitempty" url:"backup,omitempty,int"`
	Enabled       bool              `json:"-"                url:"-"`
	FileVolume    string            `json:"file"             url:"file"`
}

// CustomVirtualIODevices handles QEMU VirtIO device parameters.
type CustomVirtualIODevices []CustomVirtualIODevice

// EncodeValues converts a CustomVirtualIODevice struct to a URL value.
func (r CustomVirtualIODevice) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("file=%s", r.FileVolume),
	}

	if r.AIO != nil {
		values = append(values, fmt.Sprintf("aio=%s", *r.AIO))
	}

	if r.BackupEnabled != nil {
		if *r.BackupEnabled {
			values = append(values, "backup=1")
		} else {
			values = append(values, "backup=0")
		}
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// EncodeValues converts a CustomVirtualIODevices array to multiple URL values.
func (r CustomVirtualIODevices) EncodeValues(key string, v *url.Values) error {
	for i, d := range r {
		if d.Enabled {
			if err := d.EncodeValues(fmt.Sprintf("%s%d", key, i), v); err != nil {
				return fmt.Errorf("error encoding virtual IO device %d: %w", i, err)
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/custom_watchdog_device.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// CustomWatchdogDevice handles QEMU watchdog device parameters.
type CustomWatchdogDevice struct {
	Action *string `json:"action,omitempty" url:"action,omitempty"`
	Model  *string `json:"model"            url:"model"`
}

// EncodeValues converts a CustomWatchdogDevice struct to a URL value.
func (r *CustomWatchdogDevice) EncodeValues(key string, v *url.Values) error {
	values := []string{
		fmt.Sprintf("model=%s", *r.Model),
	}

	if r.Action != nil {
		values = append(values, fmt.Sprintf("action=%s", *r.Action))
	}

	v.Add(key, strings.Join(values, ","))

	return nil
}

// UnmarshalJSON converts a CustomWatchdogDevice string to an object.
func (r *CustomWatchdogDevice) UnmarshalJSON(b []byte) error {
	var s string

	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("failed to unmarshal CustomWatchdogDevice: %w", err)
	}

	if s == "" {
		return nil
	}

	pairs := strings.Split(s, ",")

	for _, p := range pairs {
		v := strings.Split(strings.TrimSpace(p), "=")

		if len(v) == 1 {
			r.Model = &v[0]
		} else if len(v) == 2 {
			switch v[0] {
			case "action":
				r.Action = &v[1]
			case "model":
				r.Model = &v[1]
			}
		}
	}

	return nil
}
`````

## File: proxmox/nodes/vms/vms_types_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnmarshalGetResponseData(t *testing.T) {
	t.Parallel()

	jsonData := fmt.Sprintf(`{
		"archive": "test",
		"ide0": "%[1]s",
		"ide1": "%[1]s",
		"ide2": "%[1]s",
		"ide3": "%[1]s",
		"virtio13": "%[1]s",
		"scsi22": "%[1]s",
		"hostpci0": "0000:81:00.2",
		"hostpci1": "host=81:00.4,pcie=0,rombar=1,x-vga=0",
		"hostpci12": "mapping=mappeddevice,pcie=0,rombar=1,x-vga=0",
		"virtiofs0":"test,cache=always,direct-io=1,expose-acl=1"
	}`, "local-lvm:vm-100-disk-0,aio=io_uring,backup=1,cache=none,discard=ignore,replicate=1,size=8G,ssd=1")

	var data GetResponseData
	err := json.Unmarshal([]byte(jsonData), &data)
	require.NoError(t, err)

	assert.Equal(t, "test", *data.BackupFile)

	assert.NotNil(t, data.StorageDevices)
	assert.Len(t, data.StorageDevices, 6)
	assert.NotNil(t, data.StorageDevices["ide0"])
	assertDevice(t, data.StorageDevices["ide0"])
	assert.NotNil(t, data.StorageDevices["ide1"])
	assertDevice(t, data.StorageDevices["ide1"])
	assert.NotNil(t, data.StorageDevices["ide2"])
	assertDevice(t, data.StorageDevices["ide2"])
	assert.NotNil(t, data.StorageDevices["ide3"])
	assertDevice(t, data.StorageDevices["ide3"])
	assert.NotNil(t, data.StorageDevices["virtio13"])
	assertDevice(t, data.StorageDevices["virtio13"])
	assert.NotNil(t, data.StorageDevices["scsi22"])
	assertDevice(t, data.StorageDevices["scsi22"])

	assert.NotNil(t, data.PCIDevices)
	assert.Len(t, data.PCIDevices, 3)
	assert.NotNil(t, data.PCIDevices["hostpci0"])
	assert.NotNil(t, data.PCIDevices["hostpci1"])
	assert.NotNil(t, data.PCIDevices["hostpci12"])

	assert.NotNil(t, data.VirtiofsShares)
	assert.Len(t, data.VirtiofsShares, 1)
	assert.Equal(t, "always", *data.VirtiofsShares["virtiofs0"].Cache)
}

func assertDevice(t *testing.T, dev *CustomStorageDevice) {
	t.Helper()

	assert.Equal(t, "io_uring", *dev.AIO)
	assert.True(t, bool(*dev.Backup))
	assert.Equal(t, "none", *dev.Cache)
	assert.Equal(t, "ignore", *dev.Discard)
	assert.Equal(t, "local-lvm:vm-100-disk-0", dev.FileVolume)
	assert.True(t, bool(*dev.Replicate))
	assert.Equal(t, "8G", dev.Size.String())
	assert.True(t, bool(*dev.SSD))
}
`````

## File: proxmox/nodes/vms/vms_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"regexp"
	"strings"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

var (
	//nolint:gochecknoglobals
	// regexStorageInterface is a regex pattern for matching storage interface names.
	regexStorageInterface = func(prefix string) *regexp.Regexp {
		return regexp.MustCompile(`^` + prefix + `\d+$`)
	}
	// regexPCIDevice is a regex pattern for matching PCI device names.
	regexPCIDevice = regexp.MustCompile(`^hostpci\d+$`)
	// regexVirtiofsShare is a regex pattern for matching virtiofs share names.
	regexVirtiofsShare = regexp.MustCompile(`^virtiofs\d+$`)
)

// CloneRequestBody contains the data for an virtual machine clone request.
type CloneRequestBody struct {
	BandwidthLimit      *int              `json:"bwlimit,omitempty"     url:"bwlimit,omitempty"`
	Description         *string           `json:"description,omitempty" url:"description,omitempty"`
	FullCopy            *types.CustomBool `json:"full,omitempty"        url:"full,omitempty,int"`
	Name                *string           `json:"name,omitempty"        url:"name,omitempty"`
	PoolID              *string           `json:"pool,omitempty"        url:"pool,omitempty"`
	SnapshotName        *string           `json:"snapname,omitempty"    url:"snapname,omitempty"`
	TargetNodeName      *string           `json:"target,omitempty"      url:"target,omitempty"`
	TargetStorage       *string           `json:"storage,omitempty"     url:"storage,omitempty"`
	TargetStorageFormat *string           `json:"format,omitempty"      url:"format,omitempty"`
	VMIDNew             int               `json:"newid"                 url:"newid"`
}

// CreateRequestBody contains the data for a virtual machine create request.
type CreateRequestBody struct {
	ACPI                 *types.CustomBool              `json:"acpi,omitempty"               url:"acpi,omitempty,int"`
	Agent                *CustomAgent                   `json:"agent,omitempty"              url:"agent,omitempty"`
	AMDSEV               *CustomAMDSEV                  `json:"amd-sev,omitempty"            url:"amd-sev,omitempty"`
	AllowReboot          *types.CustomBool              `json:"reboot,omitempty"             url:"reboot,omitempty,int"`
	AudioDevices         CustomAudioDevices             `json:"audio,omitempty"              url:"audio,omitempty"`
	Autostart            *types.CustomBool              `json:"autostart,omitempty"          url:"autostart,omitempty,int"`
	BackupFile           *string                        `json:"archive,omitempty"            url:"archive,omitempty"`
	BandwidthLimit       *int                           `json:"bwlimit,omitempty"            url:"bwlimit,omitempty"`
	BIOS                 *string                        `json:"bios,omitempty"               url:"bios,omitempty"`
	Boot                 *CustomBoot                    `json:"boot,omitempty"               url:"boot,omitempty"`
	CDROM                *string                        `json:"cdrom,omitempty"              url:"cdrom,omitempty"`
	CloudInitConfig      *CustomCloudInitConfig         `json:"cloudinit,omitempty"          url:"cloudinit,omitempty"`
	CPUAffinity          *string                        `json:"affinity,omitempty"           url:"affinity,omitempty"`
	CPUArchitecture      *string                        `json:"arch,omitempty"               url:"arch,omitempty"`
	CPUCores             *int64                         `json:"cores,omitempty"              url:"cores,omitempty"`
	CPUEmulation         *CustomCPUEmulation            `json:"cpu,omitempty"                url:"cpu,omitempty"`
	CPULimit             *int64                         `json:"cpulimit,omitempty"           url:"cpulimit,omitempty"`
	CPUSockets           *int64                         `json:"sockets,omitempty"            url:"sockets,omitempty"`
	CPUUnits             *int64                         `json:"cpuunits,omitempty"           url:"cpuunits,omitempty"`
	DedicatedMemory      *int                           `json:"memory,omitempty"             url:"memory,omitempty"`
	Delete               []string                       `json:"delete,omitempty"             url:"delete,omitempty,comma"`
	DeletionProtection   *types.CustomBool              `json:"protection,omitempty"         url:"protection,omitempty,int"`
	Description          *string                        `json:"description,omitempty"        url:"description,omitempty"`
	EFIDisk              *CustomEFIDisk                 `json:"efidisk0,omitempty"           url:"efidisk0,omitempty"`
	FloatingMemory       *int                           `json:"balloon,omitempty"            url:"balloon,omitempty"`
	FloatingMemoryShares *int                           `json:"shares,omitempty"             url:"shares,omitempty"`
	Freeze               *types.CustomBool              `json:"freeze,omitempty"             url:"freeze,omitempty,int"`
	HookScript           *string                        `json:"hookscript,omitempty"         url:"hookscript,omitempty"`
	Hotplug              types.CustomCommaSeparatedList `json:"hotplug,omitempty"            url:"hotplug,omitempty,comma"`
	Hugepages            *string                        `json:"hugepages,omitempty"          url:"hugepages,omitempty"`
	KeepHugepages        *types.CustomBool              `json:"keephugepages,omitempty"      url:"keephugepages,omitempty,int"`
	KeyboardLayout       *string                        `json:"keyboard,omitempty"           url:"keyboard,omitempty"`
	KVMArguments         *string                        `json:"args,omitempty"               url:"args,omitempty,space"`
	KVMEnabled           *types.CustomBool              `json:"kvm,omitempty"                url:"kvm,omitempty,int"`
	LocalTime            *types.CustomBool              `json:"localtime,omitempty"          url:"localtime,omitempty,int"`
	Lock                 *string                        `json:"lock,omitempty"               url:"lock,omitempty"`
	Machine              *string                        `json:"machine,omitempty"            url:"machine,omitempty"`
	MigrateDowntime      *float64                       `json:"migrate_downtime,omitempty"   url:"migrate_downtime,omitempty"`
	MigrateSpeed         *int                           `json:"migrate_speed,omitempty"      url:"migrate_speed,omitempty"`
	Name                 *string                        `json:"name,omitempty"               url:"name,omitempty"`
	NetworkDevices       CustomNetworkDevices           `json:"net,omitempty"                url:"net,omitempty"`
	NUMADevices          CustomNUMADevices              `json:"numa_devices,omitempty"       url:"numa,omitempty"`
	NUMAEnabled          *types.CustomBool              `json:"numa,omitempty"               url:"numa,omitempty,int"`
	OSType               *string                        `json:"ostype,omitempty"             url:"ostype,omitempty"`
	Overwrite            *types.CustomBool              `json:"force,omitempty"              url:"force,omitempty,int"`
	PCIDevices           CustomPCIDevices               `json:"hostpci,omitempty"            url:"hostpci,omitempty"`
	PoolID               *string                        `json:"pool,omitempty"               url:"pool,omitempty"`
	Revert               *string                        `json:"revert,omitempty"             url:"revert,omitempty"`
	RNGDevice            *CustomRNGDevice               `json:"rng0,omitempty"               url:"rng0,omitempty"`
	SCSIHardware         *string                        `json:"scsihw,omitempty"             url:"scsihw,omitempty"`
	SerialDevices        CustomSerialDevices            `json:"serial,omitempty"             url:"serial,omitempty"`
	SharedMemory         *CustomSharedMemory            `json:"ivshmem,omitempty"            url:"ivshmem,omitempty"`
	SkipLock             *types.CustomBool              `json:"skiplock,omitempty"           url:"skiplock,omitempty,int"`
	SMBIOS               *CustomSMBIOS                  `json:"smbios1,omitempty"            url:"smbios1,omitempty"`
	SpiceEnhancements    *CustomSpiceEnhancements       `json:"spice_enhancements,omitempty" url:"spice_enhancements,omitempty"`
	StartDate            *string                        `json:"startdate,omitempty"          url:"startdate,omitempty"`
	StartOnBoot          *types.CustomBool              `json:"onboot,omitempty"             url:"onboot,omitempty,int"`
	StartupOrder         *CustomStartupOrder            `json:"startup,omitempty"            url:"startup,omitempty"`
	TabletDeviceEnabled  *types.CustomBool              `json:"tablet,omitempty"             url:"tablet,omitempty,int"`
	Tags                 *string                        `json:"tags,omitempty"               url:"tags,omitempty"`
	Template             *types.CustomBool              `json:"template,omitempty"           url:"template,omitempty,int"`
	TimeDriftFixEnabled  *types.CustomBool              `json:"tdf,omitempty"                url:"tdf,omitempty,int"`
	TPMState             *CustomTPMState                `json:"tpmstate0,omitempty"          url:"tpmstate0,omitempty"`
	USBDevices           CustomUSBDevices               `json:"usb,omitempty"                url:"usb,omitempty"`
	VGADevice            *CustomVGADevice               `json:"vga,omitempty"                url:"vga,omitempty"`
	VirtualCPUCount      *int64                         `json:"vcpus,omitempty"              url:"vcpus,omitempty"`
	VirtiofsShares       CustomVirtiofsShares           `json:"virtiofs,omitempty"           url:"virtiofs,omitempty"`
	VMGenerationID       *string                        `json:"vmgenid,omitempty"            url:"vmgenid,omitempty"`
	VMID                 int                            `json:"vmid,omitempty"               url:"vmid,omitempty"`
	VMStateDatastoreID   *string                        `json:"vmstatestorage,omitempty"     url:"vmstatestorage,omitempty"`
	WatchdogDevice       *CustomWatchdogDevice          `json:"watchdog,omitempty"           url:"watchdog,omitempty"`
	CustomStorageDevices CustomStorageDevices           `json:"-"`
}

// AddCustomStorageDevice adds a custom storage device to the create request body.
func (b *CreateRequestBody) AddCustomStorageDevice(iface string, device CustomStorageDevice) {
	if b.CustomStorageDevices == nil {
		b.CustomStorageDevices = make(CustomStorageDevices, 1)
	}

	b.CustomStorageDevices[iface] = &device
}

// CreateResponseBody contains the body from a create response.
type CreateResponseBody struct {
	TaskID *string `json:"data,omitempty"`
}

// DeleteResponseBody contains the body from a delete response.
type DeleteResponseBody struct {
	TaskID *string `json:"data,omitempty"`
}

// GetQEMUNetworkInterfacesResponseBody contains the body from a QEMU get network interfaces response.
type GetQEMUNetworkInterfacesResponseBody struct {
	Data *GetQEMUNetworkInterfacesResponseData `json:"data,omitempty"`
}

// GetQEMUNetworkInterfacesResponseData contains the data from a QEMU get network interfaces response.
type GetQEMUNetworkInterfacesResponseData struct {
	Result *[]GetQEMUNetworkInterfacesResponseResult `json:"result,omitempty"`
}

// GetQEMUNetworkInterfacesResponseResult contains the result from a QEMU get network interfaces response.
type GetQEMUNetworkInterfacesResponseResult struct {
	MACAddress  string                                             `json:"hardware-address"`
	Name        string                                             `json:"name"`
	Statistics  *GetQEMUNetworkInterfacesResponseResultStatistics  `json:"statistics,omitempty"`
	IPAddresses *[]GetQEMUNetworkInterfacesResponseResultIPAddress `json:"ip-addresses,omitempty"`
}

// GetQEMUNetworkInterfacesResponseResultIPAddress contains the IP address from a QEMU get network interfaces response.
type GetQEMUNetworkInterfacesResponseResultIPAddress struct {
	Address string `json:"ip-address"`
	Prefix  int    `json:"prefix"`
	Type    string `json:"ip-address-type"`
}

// GetQEMUNetworkInterfacesResponseResultStatistics contains the statistics from a QEMU get network interfaces response.
type GetQEMUNetworkInterfacesResponseResultStatistics struct {
	RXBytes   int `json:"rx-bytes"`
	RXDropped int `json:"rx-dropped"`
	RXErrors  int `json:"rx-errs"`
	RXPackets int `json:"rx-packets"`
	TXBytes   int `json:"tx-bytes"`
	TXDropped int `json:"tx-dropped"`
	TXErrors  int `json:"tx-errs"`
	TXPackets int `json:"tx-packets"`
}

// GetResponseBody contains the body from a virtual machine get response.
type GetResponseBody struct {
	Data *GetResponseData `json:"data,omitempty"`
}

// GetResponseData contains the data from an virtual machine get response.
type GetResponseData struct {
	ACPI                 *types.CustomBool               `json:"acpi,omitempty"`
	Agent                *CustomAgent                    `json:"agent,omitempty"`
	AMDSEV               *CustomAMDSEV                   `json:"amd-sev,omitempty"`
	AllowReboot          *types.CustomBool               `json:"reboot,omitempty"`
	AudioDevice          *CustomAudioDevice              `json:"audio0,omitempty"`
	Autostart            *types.CustomBool               `json:"autostart,omitempty"`
	BackupFile           *string                         `json:"archive,omitempty"`
	BandwidthLimit       *int                            `json:"bwlimit,omitempty"`
	BIOS                 *string                         `json:"bios,omitempty"`
	BootDisk             *string                         `json:"bootdisk,omitempty"`
	BootOrder            *string                         `json:"boot,omitempty"`
	CDROM                *string                         `json:"cdrom,omitempty"`
	CloudInitDNSDomain   *string                         `json:"searchdomain,omitempty"`
	CloudInitDNSServer   *string                         `json:"nameserver,omitempty"`
	CloudInitFiles       *CustomCloudInitFiles           `json:"cicustom,omitempty"`
	CloudInitPassword    *string                         `json:"cipassword,omitempty"`
	CloudInitSSHKeys     *CustomCloudInitSSHKeys         `json:"sshkeys,omitempty"`
	CloudInitType        *string                         `json:"citype,omitempty"`
	CloudInitUsername    *string                         `json:"ciuser,omitempty"`
	CloudInitUpgrade     *types.CustomBool               `json:"ciupgrade,omitempty"`
	CPUArchitecture      *string                         `json:"arch,omitempty"`
	CPUCores             *int64                          `json:"cores,omitempty"`
	CPUEmulation         *CustomCPUEmulation             `json:"cpu,omitempty"`
	CPULimit             *types.CustomInt64              `json:"cpulimit,omitempty"`
	CPUSockets           *int64                          `json:"sockets,omitempty"`
	CPUUnits             *int64                          `json:"cpuunits,omitempty"`
	CPUAffinity          *string                         `json:"affinity,omitempty"`
	DedicatedMemory      *types.CustomInt64              `json:"memory,omitempty"`
	DeletionProtection   *types.CustomBool               `json:"protection,omitempty"`
	Description          *string                         `json:"description,omitempty"`
	EFIDisk              *CustomEFIDisk                  `json:"efidisk0,omitempty"`
	FloatingMemory       *types.CustomInt64              `json:"balloon,omitempty"`
	FloatingMemoryShares *int                            `json:"shares,omitempty"`
	Freeze               *types.CustomBool               `json:"freeze,omitempty"`
	HookScript           *string                         `json:"hookscript,omitempty"`
	Hotplug              *types.CustomCommaSeparatedList `json:"hotplug,omitempty"`
	Hugepages            *string                         `json:"hugepages,omitempty"`
	IPConfig0            *CustomCloudInitIPConfig        `json:"ipconfig0,omitempty"`
	IPConfig1            *CustomCloudInitIPConfig        `json:"ipconfig1,omitempty"`
	IPConfig2            *CustomCloudInitIPConfig        `json:"ipconfig2,omitempty"`
	IPConfig3            *CustomCloudInitIPConfig        `json:"ipconfig3,omitempty"`
	IPConfig4            *CustomCloudInitIPConfig        `json:"ipconfig4,omitempty"`
	IPConfig5            *CustomCloudInitIPConfig        `json:"ipconfig5,omitempty"`
	IPConfig6            *CustomCloudInitIPConfig        `json:"ipconfig6,omitempty"`
	IPConfig7            *CustomCloudInitIPConfig        `json:"ipconfig7,omitempty"`
	IPConfig8            *CustomCloudInitIPConfig        `json:"ipconfig8,omitempty"`
	IPConfig9            *CustomCloudInitIPConfig        `json:"ipconfig9,omitempty"`
	IPConfig10           *CustomCloudInitIPConfig        `json:"ipconfig10,omitempty"`
	IPConfig11           *CustomCloudInitIPConfig        `json:"ipconfig11,omitempty"`
	IPConfig12           *CustomCloudInitIPConfig        `json:"ipconfig12,omitempty"`
	IPConfig13           *CustomCloudInitIPConfig        `json:"ipconfig13,omitempty"`
	IPConfig14           *CustomCloudInitIPConfig        `json:"ipconfig14,omitempty"`
	IPConfig15           *CustomCloudInitIPConfig        `json:"ipconfig15,omitempty"`
	IPConfig16           *CustomCloudInitIPConfig        `json:"ipconfig16,omitempty"`
	IPConfig17           *CustomCloudInitIPConfig        `json:"ipconfig17,omitempty"`
	IPConfig18           *CustomCloudInitIPConfig        `json:"ipconfig18,omitempty"`
	IPConfig19           *CustomCloudInitIPConfig        `json:"ipconfig19,omitempty"`
	IPConfig20           *CustomCloudInitIPConfig        `json:"ipconfig20,omitempty"`
	IPConfig21           *CustomCloudInitIPConfig        `json:"ipconfig21,omitempty"`
	IPConfig22           *CustomCloudInitIPConfig        `json:"ipconfig22,omitempty"`
	IPConfig23           *CustomCloudInitIPConfig        `json:"ipconfig23,omitempty"`
	IPConfig24           *CustomCloudInitIPConfig        `json:"ipconfig24,omitempty"`
	IPConfig25           *CustomCloudInitIPConfig        `json:"ipconfig25,omitempty"`
	IPConfig26           *CustomCloudInitIPConfig        `json:"ipconfig26,omitempty"`
	IPConfig27           *CustomCloudInitIPConfig        `json:"ipconfig27,omitempty"`
	IPConfig28           *CustomCloudInitIPConfig        `json:"ipconfig28,omitempty"`
	IPConfig29           *CustomCloudInitIPConfig        `json:"ipconfig29,omitempty"`
	IPConfig30           *CustomCloudInitIPConfig        `json:"ipconfig30,omitempty"`
	IPConfig31           *CustomCloudInitIPConfig        `json:"ipconfig31,omitempty"`
	KeepHugepages        *types.CustomBool               `json:"keephugepages,omitempty"`
	KeyboardLayout       *string                         `json:"keyboard,omitempty"`
	KVMArguments         *string                         `json:"args,omitempty"`
	KVMEnabled           *types.CustomBool               `json:"kvm,omitempty"`
	LocalTime            *types.CustomBool               `json:"localtime,omitempty"`
	Lock                 *string                         `json:"lock,omitempty"`
	Machine              *string                         `json:"machine,omitempty"`
	MigrateDowntime      *float64                        `json:"migrate_downtime,omitempty"`
	MigrateSpeed         *int                            `json:"migrate_speed,omitempty"`
	Name                 *string                         `json:"name,omitempty"`
	NetworkDevice0       *CustomNetworkDevice            `json:"net0,omitempty"`
	NetworkDevice1       *CustomNetworkDevice            `json:"net1,omitempty"`
	NetworkDevice2       *CustomNetworkDevice            `json:"net2,omitempty"`
	NetworkDevice3       *CustomNetworkDevice            `json:"net3,omitempty"`
	NetworkDevice4       *CustomNetworkDevice            `json:"net4,omitempty"`
	NetworkDevice5       *CustomNetworkDevice            `json:"net5,omitempty"`
	NetworkDevice6       *CustomNetworkDevice            `json:"net6,omitempty"`
	NetworkDevice7       *CustomNetworkDevice            `json:"net7,omitempty"`
	NetworkDevice8       *CustomNetworkDevice            `json:"net8,omitempty"`
	NetworkDevice9       *CustomNetworkDevice            `json:"net9,omitempty"`
	NetworkDevice10      *CustomNetworkDevice            `json:"net10,omitempty"`
	NetworkDevice11      *CustomNetworkDevice            `json:"net11,omitempty"`
	NetworkDevice12      *CustomNetworkDevice            `json:"net12,omitempty"`
	NetworkDevice13      *CustomNetworkDevice            `json:"net13,omitempty"`
	NetworkDevice14      *CustomNetworkDevice            `json:"net14,omitempty"`
	NetworkDevice15      *CustomNetworkDevice            `json:"net15,omitempty"`
	NetworkDevice16      *CustomNetworkDevice            `json:"net16,omitempty"`
	NetworkDevice17      *CustomNetworkDevice            `json:"net17,omitempty"`
	NetworkDevice18      *CustomNetworkDevice            `json:"net18,omitempty"`
	NetworkDevice19      *CustomNetworkDevice            `json:"net19,omitempty"`
	NetworkDevice20      *CustomNetworkDevice            `json:"net20,omitempty"`
	NetworkDevice21      *CustomNetworkDevice            `json:"net21,omitempty"`
	NetworkDevice22      *CustomNetworkDevice            `json:"net22,omitempty"`
	NetworkDevice23      *CustomNetworkDevice            `json:"net23,omitempty"`
	NetworkDevice24      *CustomNetworkDevice            `json:"net24,omitempty"`
	NetworkDevice25      *CustomNetworkDevice            `json:"net25,omitempty"`
	NetworkDevice26      *CustomNetworkDevice            `json:"net26,omitempty"`
	NetworkDevice27      *CustomNetworkDevice            `json:"net27,omitempty"`
	NetworkDevice28      *CustomNetworkDevice            `json:"net28,omitempty"`
	NetworkDevice29      *CustomNetworkDevice            `json:"net29,omitempty"`
	NetworkDevice30      *CustomNetworkDevice            `json:"net30,omitempty"`
	NetworkDevice31      *CustomNetworkDevice            `json:"net31,omitempty"`
	NUMAEnabled          *types.CustomBool               `json:"numa,omitempty"`
	NUMADevices0         *CustomNUMADevice               `json:"numa0,omitempty"`
	NUMADevices1         *CustomNUMADevice               `json:"numa1,omitempty"`
	NUMADevices2         *CustomNUMADevice               `json:"numa2,omitempty"`
	NUMADevices3         *CustomNUMADevice               `json:"numa3,omitempty"`
	NUMADevices4         *CustomNUMADevice               `json:"numa4,omitempty"`
	NUMADevices5         *CustomNUMADevice               `json:"numa5,omitempty"`
	NUMADevices6         *CustomNUMADevice               `json:"numa6,omitempty"`
	NUMADevices7         *CustomNUMADevice               `json:"numa7,omitempty"`
	OSType               *string                         `json:"ostype,omitempty"`
	Overwrite            *types.CustomBool               `json:"force,omitempty"`
	PoolID               *string                         `json:"pool,omitempty"`
	Revert               *string                         `json:"revert,omitempty"`
	RNGDevice            *CustomRNGDevice                `json:"rng0,omitempty"`
	SCSIHardware         *string                         `json:"scsihw,omitempty"`
	SerialDevice0        *string                         `json:"serial0,omitempty"`
	SerialDevice1        *string                         `json:"serial1,omitempty"`
	SerialDevice2        *string                         `json:"serial2,omitempty"`
	SerialDevice3        *string                         `json:"serial3,omitempty"`
	SharedMemory         *CustomSharedMemory             `json:"ivshmem,omitempty"`
	SkipLock             *types.CustomBool               `json:"skiplock,omitempty"`
	SMBIOS               *CustomSMBIOS                   `json:"smbios1,omitempty"`
	SpiceEnhancements    *CustomSpiceEnhancements        `json:"spice_enhancements,omitempty"`
	StartDate            *string                         `json:"startdate,omitempty"`
	StartOnBoot          *types.CustomBool               `json:"onboot,omitempty"`
	StartupOrder         *CustomStartupOrder             `json:"startup,omitempty"`
	TabletDeviceEnabled  *types.CustomBool               `json:"tablet,omitempty"`
	Tags                 *string                         `json:"tags,omitempty"`
	Template             *types.CustomBool               `json:"template,omitempty"`
	TimeDriftFixEnabled  *types.CustomBool               `json:"tdf,omitempty"`
	TPMState             *CustomTPMState                 `json:"tpmstate0,omitempty"`
	USBDevice0           *CustomUSBDevice                `json:"usb0,omitempty"`
	USBDevice1           *CustomUSBDevice                `json:"usb1,omitempty"`
	USBDevice2           *CustomUSBDevice                `json:"usb2,omitempty"`
	USBDevice3           *CustomUSBDevice                `json:"usb3,omitempty"`
	VGADevice            *CustomVGADevice                `json:"vga,omitempty"`
	VirtualCPUCount      *int64                          `json:"vcpus,omitempty"`
	VMGenerationID       *string                         `json:"vmgenid,omitempty"`
	VMStateDatastoreID   *string                         `json:"vmstatestorage,omitempty"`
	WatchdogDevice       *CustomWatchdogDevice           `json:"watchdog,omitempty"`
	StorageDevices       CustomStorageDevices            `json:"-"`
	PCIDevices           CustomPCIDevices                `json:"-"`
	VirtiofsShares       CustomVirtiofsShares            `json:"-"`
}

// GetStatusResponseBody contains the body from a VM get status response.
type GetStatusResponseBody struct {
	Data *GetStatusResponseData `json:"data,omitempty"`
}

// GetStatusResponseData contains the data from a VM get status response.
type GetStatusResponseData struct {
	AgentEnabled     *types.CustomBool `json:"agent,omitempty"`
	CPUCount         *int64            `json:"cpus,omitempty"`
	Lock             *string           `json:"lock,omitempty"`
	MemoryAllocation *int64            `json:"maxmem,omitempty"`
	Name             *string           `json:"name,omitempty"`
	PID              *int              `json:"pid,omitempty"`
	QMPStatus        *string           `json:"qmpstatus,omitempty"`
	RootDiskSize     *int64            `json:"maxdisk,omitempty"`
	SpiceSupport     *types.CustomBool `json:"spice,omitempty"`
	Status           string            `json:"status,omitempty"`
	Tags             *string           `json:"tags,omitempty"`
	Uptime           *int              `json:"uptime,omitempty"`
	VMID             *int              `json:"vmid,omitempty"`
}

// ListResponseBody contains the body from a virtual machine list response.
type ListResponseBody struct {
	Data []*ListResponseData `json:"data,omitempty"`
}

// ListResponseData contains the data from an virtual machine list response.
type ListResponseData struct {
	Name     *string           `json:"name,omitempty"`
	Tags     *string           `json:"tags,omitempty"`
	Template *types.CustomBool `json:"template,omitempty"`
	Status   *string           `json:"status,omitempty"`
	VMID     int               `json:"vmid,omitempty"`
}

// MigrateRequestBody contains the body for a VM migration request.
type MigrateRequestBody struct {
	OnlineMigration *types.CustomBool `json:"online,omitempty"           url:"online,omitempty,int"`
	TargetNode      string            `json:"target"                     url:"target"`
	TargetStorage   *string           `json:"targetstorage,omitempty"    url:"targetstorage,omitempty"`
	WithLocalDisks  *types.CustomBool `json:"with-local-disks,omitempty" url:"with-local-disks,omitempty,int"`
}

// MigrateResponseBody contains the body from a VM migrate response.
type MigrateResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// MoveDiskRequestBody contains the body for a VM move disk request.
type MoveDiskRequestBody struct {
	BandwidthLimit      *int              `json:"bwlimit,omitempty" url:"bwlimit,omitempty"`
	DeleteOriginalDisk  *types.CustomBool `json:"delete,omitempty"  url:"delete,omitempty,int"`
	Digest              *string           `json:"digest,omitempty"  url:"digest,omitempty"`
	Disk                string            `json:"disk"              url:"disk"`
	TargetStorage       string            `json:"storage"           url:"storage"`
	TargetStorageFormat *string           `json:"format,omitempty"  url:"format,omitempty"`
}

// MoveDiskResponseBody contains the body from a VM move disk response.
type MoveDiskResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// RebootRequestBody contains the body for a VM reboot request.
type RebootRequestBody struct {
	Timeout *int `json:"timeout,omitempty" url:"timeout,omitempty"`
}

// RebootResponseBody contains the body from a VM reboot response.
type RebootResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// ResizeDiskRequestBody contains the body for a VM resize disk request.
type ResizeDiskRequestBody struct {
	Digest   *string           `json:"digest,omitempty"   url:"digest,omitempty"`
	Disk     string            `json:"disk"               url:"disk"`
	Size     types.DiskSize    `json:"size"               url:"size"`
	SkipLock *types.CustomBool `json:"skiplock,omitempty" url:"skiplock,omitempty,int"`
}

// ShutdownRequestBody contains the body for a VM shutdown request.
type ShutdownRequestBody struct {
	ForceStop  *types.CustomBool `json:"forceStop,omitempty"  url:"forceStop,omitempty,int"`
	KeepActive *types.CustomBool `json:"keepActive,omitempty" url:"keepActive,omitempty,int"`
	SkipLock   *types.CustomBool `json:"skipLock,omitempty"   url:"skipLock,omitempty,int"`
	Timeout    *int              `json:"timeout,omitempty"    url:"timeout,omitempty"`
}

// ShutdownResponseBody contains the body from a VM shutdown response.
type ShutdownResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// StartRequestBody contains the body for a VM start request.
type StartRequestBody struct {
	ForceCPU         *string           `json:"force-cpu,omitempty"         url:"force-cpu,omitempty"`
	Machine          *string           `json:"machine,omitempty"           url:"machine,omitempty"`
	MigrateFrom      *string           `json:"migratefrom,omitempty"       url:"migratefrom,omitempty"`
	MigrationNetwork *string           `json:"migration_network,omitempty" url:"migration_network,omitempty"`
	MigrationType    *string           `json:"migration_type,omitempty"    url:"migration_type,omitempty"`
	SkipLock         *types.CustomBool `json:"skipLock,omitempty"          url:"skipLock,omitempty,int"`
	StateURI         *string           `json:"stateuri,omitempty"          url:"stateuri,omitempty"`
	TargetStorage    *string           `json:"targetstorage,omitempty"     url:"targetstorage,omitempty"`
	TimeoutSeconds   *int              `json:"timeout,omitempty"           url:"timeout,omitempty"`
}

// StartResponseBody contains the body from a VM start response.
type StartResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// StopResponseBody contains the body from a VM stop response.
type StopResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// UpdateAsyncResponseBody contains the body from a VM async update response.
type UpdateAsyncResponseBody struct {
	Data *string `json:"data,omitempty"`
}

// UpdateRequestBody contains the data for an virtual machine update request.
type UpdateRequestBody = CreateRequestBody

// UnmarshalJSON unmarshals the data from the JSON response, populating the CustomStorageDevices field.
func (d *GetResponseData) UnmarshalJSON(b []byte) error {
	type Alias GetResponseData

	var data Alias

	// get original struct
	if err := json.Unmarshal(b, &data); err != nil {
		return fmt.Errorf("failed to unmarshal data: %w", err)
	}

	var byAttr map[string]interface{}

	// now get map by attribute name
	err := json.Unmarshal(b, &byAttr)
	if err != nil {
		return fmt.Errorf("failed to unmarshal data: %w", err)
	}

	data.StorageDevices = make(CustomStorageDevices)
	data.PCIDevices = make(CustomPCIDevices)
	data.VirtiofsShares = make(CustomVirtiofsShares)

	for key, value := range byAttr {
		for _, prefix := range StorageInterfaces {
			// the device names can overlap with other fields, for example`scsi0` and `scsihw`, so just checking
			// the prefix is not enough
			if regexStorageInterface(prefix).MatchString(key) {
				var device CustomStorageDevice
				if err := json.Unmarshal([]byte(`"`+value.(string)+`"`), &device); err != nil {
					return fmt.Errorf("failed to unmarshal %s: %w", key, err)
				}

				data.StorageDevices[key] = &device
			}
		}

		if regexPCIDevice.MatchString(key) {
			var device CustomPCIDevice
			if err := json.Unmarshal([]byte(`"`+value.(string)+`"`), &device); err != nil {
				return fmt.Errorf("failed to unmarshal %s: %w", key, err)
			}

			data.PCIDevices[key] = &device
		}

		if regexVirtiofsShare.MatchString(key) {
			var share CustomVirtiofsShare
			if err := json.Unmarshal([]byte(`"`+value.(string)+`"`), &share); err != nil {
				return fmt.Errorf("failed to unmarshal %s: %w", key, err)
			}

			data.VirtiofsShares[key] = &share
		}
	}

	*d = GetResponseData(data)

	return nil
}

// ToDelete adds a field to the delete list. The field name should be the **actual** field name in the struct.
func (b *UpdateRequestBody) ToDelete(fieldName string) error {
	if b == nil {
		return errors.New("update request body is nil")
	}

	if field, ok := reflect.TypeOf(*b).FieldByName(fieldName); ok {
		fieldTag := field.Tag.Get("url")
		name := strings.Split(fieldTag, ",")[0]
		b.Delete = append(b.Delete, name)
	} else {
		return fmt.Errorf("field %s not found in struct %s", fieldName, reflect.TypeOf(b).Name())
	}

	return nil
}

// IsEmpty checks if the update request body is empty.
func (b *UpdateRequestBody) IsEmpty() bool {
	if b == nil {
		return true
	}

	return reflect.DeepEqual(*b, UpdateRequestBody{})
}
`````

## File: proxmox/nodes/vms/vms.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package vms

import (
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"

	"github.com/avast/retry-go/v4"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/tasks"
)

// CloneVM clones a virtual machine.
func (c *Client) CloneVM(ctx context.Context, retries int, d *CloneRequestBody) error {
	var err error

	resBody := &MoveDiskResponseBody{}

	// just a guard in case someone sets retries to zero unknowingly
	if retries <= 0 {
		retries = 1
	}

	err = retry.Do(
		func() error {
			err = c.DoRequest(ctx, http.MethodPost, c.ExpandPath("clone"), d, resBody)
			if err != nil {
				return fmt.Errorf("error cloning VM: %w", err)
			}

			if resBody.Data == nil {
				return api.ErrNoDataObjectInResponse
			}

			// ignoring warnings as per https://www.mail-archive.com/pve-devel@lists.proxmox.com/msg17724.html
			return c.Tasks().WaitForTask(ctx, *resBody.Data, tasks.WithIgnoreWarnings())
		},
		retry.Context(ctx),
		retry.Attempts(uint(retries)),
		retry.Delay(10*time.Second),
		retry.LastErrorOnly(false),
	)
	if err != nil {
		return fmt.Errorf("error waiting for VM clone: %w", err)
	}

	return nil
}

// CreateVM creates a virtual machine.
func (c *Client) CreateVM(ctx context.Context, d *CreateRequestBody) error {
	taskID, err := c.CreateVMAsync(ctx, d)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM creation: %w", err)
	}

	return nil
}

// CreateVMAsync creates a virtual machine asynchronously. Returns ID of the started task.
func (c *Client) CreateVMAsync(ctx context.Context, d *CreateRequestBody) (*string, error) {
	resBody := &CreateResponseBody{}
	retrying := false

	// retry the request if we get an error that the VM already exists
	// but only if we're retrying. If this error is returned by the first
	// request, we'll just return the error (i.e. can't "override" the VM).
	err := retry.Do(
		func() error {
			err := c.DoRequest(ctx, http.MethodPost, c.basePath(), d, resBody)
			if err != nil && retrying && strings.Contains(err.Error(), "already exists") {
				return nil
			}

			return err
		},
		retry.Context(ctx),
		retry.Attempts(3),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(false),
		retry.OnRetry(func(n uint, err error) {
			tflog.Warn(ctx, "retrying VM creation", map[string]interface{}{
				"attempt": n,
				"error":   err.Error(),
			})

			retrying = true
		}),
		retry.RetryIf(func(err error) bool {
			return strings.Contains(err.Error(), "got no worker upid")
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("error creating VM: %w", err)
	}

	if resBody.TaskID == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.TaskID, nil
}

// DeleteVM creates a virtual machine.
func (c *Client) DeleteVM(ctx context.Context) error {
	taskID, err := c.DeleteVMAsync(ctx)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM deletion: %w", err)
	}

	return nil
}

// DeleteVMAsync deletes a virtual machine asynchronously. Returns ID of the started task.
func (c *Client) DeleteVMAsync(ctx context.Context) (*string, error) {
	// PVE may return a 500 error "got no worker upid - start worker failed", so we retry few times.
	resBody := &DeleteResponseBody{}

	err := retry.Do(
		func() error {
			return c.DoRequest(ctx, http.MethodDelete, c.ExpandPath("?destroy-unreferenced-disks=1&purge=1"), nil, resBody)
		},
		retry.Context(ctx),
		retry.Attempts(3),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
		retry.RetryIf(func(err error) bool {
			return !errors.Is(err, api.ErrResourceDoesNotExist)
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("error deleting VM: %w", err)
	}

	return resBody.TaskID, nil
}

// GetVM retrieves a virtual machine.
func (c *Client) GetVM(ctx context.Context) (*GetResponseData, error) {
	resBody := &GetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("config"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving VM %d: %w", c.VMID, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// GetVMNetworkInterfacesFromAgent retrieves the network interfaces reported by the QEMU agent.
func (c *Client) GetVMNetworkInterfacesFromAgent(ctx context.Context) (*GetQEMUNetworkInterfacesResponseData, error) {
	resBody := &GetQEMUNetworkInterfacesResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("agent/network-get-interfaces"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving VM network interfaces from agent: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// GetVMStatus retrieves the status for a virtual machine.
func (c *Client) GetVMStatus(ctx context.Context) (*GetStatusResponseData, error) {
	resBody := &GetStatusResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("status/current"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving VM status: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// MigrateVM migrates a virtual machine.
func (c *Client) MigrateVM(ctx context.Context, d *MigrateRequestBody) error {
	taskID, err := c.MigrateVMAsync(ctx, d)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM migration: %w", err)
	}

	return nil
}

// MigrateVMAsync migrates a virtual machine asynchronously.
func (c *Client) MigrateVMAsync(ctx context.Context, d *MigrateRequestBody) (*string, error) {
	resBody := &MigrateResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("migrate"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error migrating VM: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// MoveVMDisk moves a virtual machine disk.
func (c *Client) MoveVMDisk(ctx context.Context, d *MoveDiskRequestBody) error {
	taskID, err := c.MoveVMDiskAsync(ctx, d)
	if err != nil {
		if strings.Contains(err.Error(), "you can't move to the same storage with same format") {
			// if someone tries to move to the same storage, the move is considered to be successful
			return nil
		}

		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM disk move: %w", err)
	}

	return nil
}

// MoveVMDiskAsync moves a virtual machine disk asynchronously.
func (c *Client) MoveVMDiskAsync(ctx context.Context, d *MoveDiskRequestBody) (*string, error) {
	resBody := &MoveDiskResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("move_disk"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error moving VM disk: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ListVMs retrieves a list of virtual machines.
func (c *Client) ListVMs(ctx context.Context) ([]*ListResponseData, error) {
	resBody := &ListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.basePath(), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving VMs: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// RebuildCloudInitDisk regenerates and changes cloud-init config drive.
func (c *Client) RebuildCloudInitDisk(ctx context.Context) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("cloudinit"), nil, nil)
	if err != nil {
		return fmt.Errorf("error rebuilding cloud-init drive: %w", err)
	}

	return nil
}

// RebootVMAndWaitForRunning reboots a virtual machine and waits for it to be running.
func (c *Client) RebootVMAndWaitForRunning(ctx context.Context, rebootTimeoutSec int) error {
	// We add 3 seconds padding to the timeout to account for retries and delays down the callstack.
	ctx, cancel := context.WithTimeout(ctx, time.Duration(rebootTimeoutSec+3)*time.Second)
	defer cancel()

	err := c.RebootVM(
		ctx,
		&RebootRequestBody{
			Timeout: &rebootTimeoutSec,
		},
	)
	if err != nil {
		return err
	}

	return c.WaitForVMStatus(ctx, "running")
}

// RebootVM reboots a virtual machine.
func (c *Client) RebootVM(ctx context.Context, d *RebootRequestBody) error {
	taskID, err := c.RebootVMAsync(ctx, d)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM reboot: %w", err)
	}

	return nil
}

// RebootVMAsync reboots a virtual machine asynchronously.
func (c *Client) RebootVMAsync(ctx context.Context, d *RebootRequestBody) (*string, error) {
	resBody := &RebootResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/reboot"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error rebooting VM: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ResizeVMDisk resizes a virtual machine disk.
func (c *Client) ResizeVMDisk(ctx context.Context, d *ResizeDiskRequestBody) error {
	err := retry.Do(
		func() error {
			taskID, err := c.ResizeVMDiskAsync(ctx, d)
			if err != nil {
				return err
			}

			return c.Tasks().WaitForTask(ctx, *taskID)
		},
		retry.Context(ctx),
		retry.Attempts(3),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(false),
		retry.RetryIf(func(err error) bool {
			return strings.Contains(err.Error(), "got timeout")
		}),
	)
	if err != nil {
		return fmt.Errorf("error waiting for VM disk resize: %w", err)
	}

	return nil
}

// ResizeVMDiskAsync resizes a virtual machine disk asynchronously.
func (c *Client) ResizeVMDiskAsync(ctx context.Context, d *ResizeDiskRequestBody) (*string, error) {
	resBody := &MoveDiskResponseBody{}

	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("resize"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error moving VM disk: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// ShutdownVM shuts down a virtual machine.
func (c *Client) ShutdownVM(ctx context.Context, d *ShutdownRequestBody) error {
	taskID, err := c.ShutdownVMAsync(ctx, d)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM shutdown: %w", err)
	}

	return nil
}

// ShutdownVMAsync shuts down a virtual machine asynchronously.
func (c *Client) ShutdownVMAsync(ctx context.Context, d *ShutdownRequestBody) (*string, error) {
	resBody := &ShutdownResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/shutdown"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error shutting down VM: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// StartVM starts a virtual machine.
// Returns the task log if the VM had warnings at startup, or fails to start.
func (c *Client) StartVM(ctx context.Context, timeoutSec int) ([]string, error) {
	taskID, err := c.StartVMAsync(ctx, timeoutSec)
	if err != nil {
		return nil, err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID, tasks.WithIgnoreStatus(599))
	if err != nil {
		log, e := c.Tasks().GetTaskLog(ctx, *taskID)
		if e != nil {
			tflog.Error(ctx, "error retrieving task log", map[string]interface{}{
				"task_id": *taskID,
				"error":   e.Error(),
			})

			log = []string{}
		}

		if strings.Contains(err.Error(), "WARNING") && len(log) > 0 {
			return log, nil
		}

		return log, fmt.Errorf("error waiting for VM start: %w", err)
	}

	return nil, nil
}

// StartVMAsync starts a virtual machine asynchronously.
func (c *Client) StartVMAsync(ctx context.Context, timeoutSec int) (*string, error) {
	reqBody := &StartRequestBody{
		TimeoutSeconds: &timeoutSec,
	}
	resBody := &StartResponseBody{}

	// PVE may return a 500 error "got no worker upid - start worker failed", so we retry few times.
	err := retry.Do(
		func() error {
			err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/start"), reqBody, resBody)
			if err != nil && strings.Contains(err.Error(), "already running") {
				return nil
			}

			return err
		},
		retry.Context(ctx),
		retry.Attempts(3),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
		retry.RetryIf(func(err error) bool {
			return strings.Contains(err.Error(), "got no worker upid")
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("error starting VM: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// StopVM stops a virtual machine.
func (c *Client) StopVM(ctx context.Context) error {
	taskID, err := c.StopVMAsync(ctx)
	if err != nil {
		return err
	}

	err = c.Tasks().WaitForTask(ctx, *taskID)
	if err != nil {
		return fmt.Errorf("error waiting for VM stop: %w", err)
	}

	return nil
}

// StopVMAsync stops a virtual machine asynchronously.
func (c *Client) StopVMAsync(ctx context.Context) (*string, error) {
	resBody := &StopResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("status/stop"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error stopping VM: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateVM updates a virtual machine.
func (c *Client) UpdateVM(ctx context.Context, d *UpdateRequestBody) error {
	err := retry.Do(
		func() error {
			return c.DoRequest(ctx, http.MethodPut, c.ExpandPath("config"), d, nil)
		},
		retry.Context(ctx),
		retry.Attempts(3),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
		retry.RetryIf(func(err error) bool {
			return strings.Contains(err.Error(), "got timeout")
		}),
	)
	if err != nil {
		return fmt.Errorf("error updating VM: %w", err)
	}

	return nil
}

// UpdateVMAsync updates a virtual machine asynchronously.
func (c *Client) UpdateVMAsync(ctx context.Context, d *UpdateRequestBody) (*string, error) {
	resBody := &UpdateAsyncResponseBody{}

	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("config"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error updating VM: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// WaitForNetworkInterfacesFromVMAgent waits for a virtual machine's QEMU agent to publish the network interfaces.
func (c *Client) WaitForNetworkInterfacesFromVMAgent(
	ctx context.Context,
	timeout int, // time in seconds to wait until giving up
	delay int, // the delay in seconds between requests to the agent
	waitForIP bool, // whether to block until an IP is found, or just block until the interfaces are published
) (*GetQEMUNetworkInterfacesResponseData, error) {
	delaySeconds := int64(delay)
	timeMaxSeconds := float64(timeout)
	timeStart := time.Now()
	timeElapsed := timeStart.Sub(timeStart)

	ch := make(chan os.Signal, 1)
	signal.Notify(ch, os.Interrupt)

	for timeElapsed.Seconds() < timeMaxSeconds {
		timeElapsed = time.Since(timeStart)

		// check if terraform wants to shut us down (we try to poll the ctx every 200ms)
		if ctx.Err() != nil {
			return nil, fmt.Errorf("error waiting for VM network interfaces: %w", ctx.Err())
		}

		select {
		case <-ch:
			{
				// the returned error will be eaten by the terraform runtime, so we log it here as well
				const msg = "interrupted by signal"

				tflog.Warn(ctx, msg)

				return nil, errors.New(msg)
			}
		default:
		}

		// sleep another 200 milliseconds if we haven't delayed enough since our last call
		if int64(timeElapsed.Seconds())%delaySeconds != 0 {
			time.Sleep(200 * time.Millisecond)
			continue
		}

		// request the network interfaces from the agent
		data, err := c.GetVMNetworkInterfacesFromAgent(ctx)

		// tick ahead and continue if we got an error from the api
		if err != nil || data == nil || data.Result == nil {
			time.Sleep(1 * time.Second)
			continue
		}

		// If we're waiting for an IP, check if we have one yet; if not then keep looping
		if waitForIP {
			for _, nic := range *data.Result {
				// skip the loopback interface
				if nic.Name == "lo" {
					continue
				}

				// skip the interface if it has no IP addresses
				if nic.IPAddresses == nil ||
					(nic.IPAddresses != nil && len(*nic.IPAddresses) == 0) {
					continue
				}

				// return if the interface has any global unicast addresses
				for _, addr := range *nic.IPAddresses {
					if ip := net.ParseIP(addr.Address); ip != nil && ip.IsGlobalUnicast() {
						return data, err
					}
				}
			}

			// no IP address has come through the agent yet
			time.Sleep(1 * time.Second)
			continue //nolint
		}

		// if not waiting for an IP, and the agent sent us an interface, return
		if data.Result != nil && len(*data.Result) > 0 {
			return data, err
		}

		// we didn't get any interfaces so tick ahead to keep looping
		time.Sleep(1 * time.Second)
	}

	return nil, fmt.Errorf(
		"timeout while waiting for the QEMU agent on VM \"%d\" to publish the network interfaces",
		c.VMID,
	)
}

// WaitForVMConfigUnlock waits for a virtual machine configuration to become unlocked.
func (c *Client) WaitForVMConfigUnlock(ctx context.Context, ignoreErrorResponse bool) error {
	stillLocked := errors.New("still locked")

	err := retry.Do(
		func() error {
			data, err := c.GetVMStatus(ctx)
			if err != nil {
				return err
			}

			if data.Lock != nil && *data.Lock != "" {
				return stillLocked
			}

			return nil
		},
		retry.Context(ctx),
		retry.UntilSucceeded(),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
		retry.RetryIf(func(err error) bool {
			return errors.Is(err, stillLocked) || ignoreErrorResponse
		}),
	)

	if errors.Is(err, context.DeadlineExceeded) {
		return fmt.Errorf("timeout while waiting for VM %d configuration to become unlocked", c.VMID)
	}

	if err != nil && !ignoreErrorResponse {
		return fmt.Errorf("error waiting for VM %d configuration to become unlocked: %w", c.VMID, err)
	}

	return nil
}

// WaitForVMStatus waits for a virtual machine to reach a specific status.
func (c *Client) WaitForVMStatus(ctx context.Context, status string) error {
	status = strings.ToLower(status)

	unexpectedStatus := fmt.Errorf("unexpected status %q", status)

	err := retry.Do(
		func() error {
			data, err := c.GetVMStatus(ctx)
			if err != nil {
				return err
			}

			if data.Status != status {
				return unexpectedStatus
			}

			return nil
		},
		retry.Context(ctx),
		retry.UntilSucceeded(),
		retry.Delay(1*time.Second),
		retry.LastErrorOnly(true),
		retry.RetryIf(func(err error) bool {
			return errors.Is(err, unexpectedStatus)
		}),
	)

	if errors.Is(err, context.DeadlineExceeded) {
		return fmt.Errorf("timeout while waiting for VM %d to enter the status %q", c.VMID, status)
	}

	if err != nil {
		return fmt.Errorf("error waiting for VM %d to enter the status %q: %w", c.VMID, status, err)
	}

	return nil
}
`````

## File: proxmox/nodes/certificate_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CertificateDeleteRequestBody contains the data for a custom certificate delete request.
type CertificateDeleteRequestBody struct {
	Restart *types.CustomBool `json:"restart,omitempty" url:"restart,omitempty,int"`
}

// CertificateListResponseBody contains the body from a certificate list response.
type CertificateListResponseBody struct {
	Data *[]CertificateListResponseData `json:"data,omitempty"`
}

// CertificateListResponseData contains the data from a certificate list response.
type CertificateListResponseData struct {
	Certificates            *string                `json:"pem,omitempty"`
	FileName                *string                `json:"filename,omitempty"`
	Fingerprint             *string                `json:"fingerprint,omitempty"`
	Issuer                  *string                `json:"issuer,omitempty"`
	NotAfter                *types.CustomTimestamp `json:"notafter,omitempty"`
	NotBefore               *types.CustomTimestamp `json:"notbefore,omitempty"`
	PublicKeyBits           *int                   `json:"public-key-bits,omitempty"`
	PublicKeyType           *string                `json:"public-key-type,omitempty"`
	Subject                 *string                `json:"subject,omitempty"`
	SubjectAlternativeNames *[]string              `json:"san,omitempty"`
}

// CertificateUpdateRequestBody contains the body for a custom certificate update request.
type CertificateUpdateRequestBody struct {
	Certificates string            `json:"certificates"      url:"certificates"`
	Force        *types.CustomBool `json:"force,omitempty"   url:"force,omitempty,int"`
	PrivateKey   *string           `json:"key,omitempty"     url:"key,omitempty"`
	Restart      *types.CustomBool `json:"restart,omitempty" url:"restart,omitempty,int"`
}
`````

## File: proxmox/nodes/certificate.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// DeleteCertificate deletes the custom certificate for a node.
func (c *Client) DeleteCertificate(ctx context.Context, d *CertificateDeleteRequestBody) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath("certificates/custom"), d, nil)
	if err != nil {
		return fmt.Errorf("error deleting certificate: %w", err)
	}

	return nil
}

// ListCertificates retrieves the list of certificates for a node.
func (c *Client) ListCertificates(ctx context.Context) (*[]CertificateListResponseData, error) {
	resBody := &CertificateListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("certificates/info"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving certificate list: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateCertificate updates the custom certificate for a node.
func (c *Client) UpdateCertificate(ctx context.Context, d *CertificateUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("certificates/custom"), d, nil)
	if err != nil {
		return fmt.Errorf("error updating certificate: %w", err)
	}

	return nil
}
`````

## File: proxmox/nodes/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"fmt"
	"net/url"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/apt"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/containers"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/storage"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/tasks"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
)

// Client is an interface for accessing the Proxmox node API.
type Client struct {
	api.Client
	NodeName string
}

// ExpandPath expands a relative path to a full node API path.
func (c *Client) ExpandPath(path string) string {
	return fmt.Sprintf("nodes/%s/%s", url.PathEscape(c.NodeName), path)
}

// APT returns a client for managing APT related settings.
func (c *Client) APT() *apt.Client {
	return &apt.Client{
		Client: c,
	}
}

// Container returns a client for managing a specific container.
func (c *Client) Container(vmID int) *containers.Client {
	return &containers.Client{
		Client: c,
		VMID:   vmID,
	}
}

// VM returns a client for managing a specific VM.
func (c *Client) VM(vmID int) *vms.Client {
	return &vms.Client{
		Client: c,
		VMID:   vmID,
	}
}

// Storage returns a client for managing a specific storage.
func (c *Client) Storage(storageName string) *storage.Client {
	return &storage.Client{
		Client:      c,
		StorageName: storageName,
	}
}

// Tasks returns a client for managing VM tasks.
func (c *Client) Tasks() *tasks.Client {
	return &tasks.Client{
		Client: c,
	}
}
`````

## File: proxmox/nodes/config_types_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"net/url"
	"testing"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
)

func TestACMEConfig_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		config  ACMEConfig
		str     string
		wantErr bool
	}{
		{
			name: "account only",
			config: ACMEConfig{
				Account: ptr.Ptr("foo"),
				Domains: nil,
			},
			str: `"account=foo"`,
		},
		{
			name: "account and domains",
			config: ACMEConfig{
				Account: ptr.Ptr("foo"),
				Domains: []string{"bar", "baz"},
			},
			str: `"account=foo,domains=bar;baz"`,
		},
		{
			name: "domains only",
			config: ACMEConfig{
				Account: nil,
				Domains: []string{"bar", "baz"},
			},
			str: `"domains=bar;baz"`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if err := tt.config.UnmarshalJSON([]byte(tt.str)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestACMEConfig_EncodeValues(t *testing.T) {
	t.Parallel()

	type args struct {
		key string
		v   *url.Values
	}

	tests := []struct {
		name    string
		config  ACMEConfig
		args    args
		wantErr bool
	}{
		{
			name: "account only",
			config: ACMEConfig{
				Account: ptr.Ptr("foo"),
				Domains: nil,
			},
			args: args{
				"acme",
				&url.Values{
					"account": {"foo"},
				},
			},
		},
		{
			name: "account and domains",
			config: ACMEConfig{
				Account: ptr.Ptr("foo"),
				Domains: []string{"bar", "baz"},
			},
			args: args{
				"acme",
				&url.Values{
					"account": {"foo"},
					"domains": {"bar;baz"},
				},
			},
		},
		{
			name: "domains only",
			config: ACMEConfig{
				Account: nil,
				Domains: []string{"bar", "baz"},
			},
			args: args{
				"acme",
				&url.Values{
					"domains": {"bar;baz"},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if err := tt.config.EncodeValues(tt.args.key, tt.args.v); (err != nil) != tt.wantErr {
				t.Errorf("EncodeValues() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestACMEDomainConfig_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		config  ACMEDomainConfig
		str     string
		wantErr bool
	}{
		{
			name: "domain only",
			config: ACMEDomainConfig{
				Domain: "foo",
			},
			str: `"foo"`,
		},
		{
			name: "domain only with key",
			config: ACMEDomainConfig{
				Domain: "foo",
			},
			str: `"domain=foo"`,
		},
		{
			name: "domain and alias",
			config: ACMEDomainConfig{
				Domain: "foo",
				Alias:  ptr.Ptr("bar"),
			},
			str: `"domain=foo,alias=bar"`,
		},
		{
			name: "domain and plugin",
			config: ACMEDomainConfig{
				Domain: "foo",
				Plugin: ptr.Ptr("bar"),
			},
			str: `"domain=foo,plugin=bar"`,
		},
		{
			name: "domain, alias, and plugin",
			config: ACMEDomainConfig{
				Domain: "foo",
				Alias:  ptr.Ptr("bar"),
				Plugin: ptr.Ptr("baz"),
			},
			str: `"domain=foo,alias=bar,plugin=baz"`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if err := tt.config.UnmarshalJSON([]byte(tt.str)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestACMEDomainConfig_EncodeValues(t *testing.T) {
	t.Parallel()

	type args struct {
		key string
		v   *url.Values
	}

	tests := []struct {
		name    string
		config  ACMEDomainConfig
		args    args
		wantErr bool
	}{
		{
			name: "domain only",
			config: ACMEDomainConfig{
				Domain: "foo",
			},
			args: args{
				"acme",
				&url.Values{
					"domain": {"foo"},
				},
			},
		},
		{
			name: "domain and alias",
			config: ACMEDomainConfig{
				Domain: "foo",
				Alias:  ptr.Ptr("bar"),
			},
			args: args{
				"acme",
				&url.Values{
					"domain": {"foo"},
					"alias":  {"bar"},
				},
			},
		},
		{
			name: "domain and plugin",
			config: ACMEDomainConfig{
				Domain: "foo",
				Plugin: ptr.Ptr("bar"),
			},
			args: args{
				"acme",
				&url.Values{
					"domain": {"foo"},
					"plugin": {"bar"},
				},
			},
		},
		{
			name: "domain, alias, and plugin",
			config: ACMEDomainConfig{
				Domain: "foo",
				Alias:  ptr.Ptr("bar"),
				Plugin: ptr.Ptr("baz"),
			},
			args: args{
				"acme",
				&url.Values{
					"domain": {"foo"},
					"alias":  {"bar"},
					"plugin": {"baz"},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if err := tt.config.EncodeValues(tt.args.key, tt.args.v); (err != nil) != tt.wantErr {
				t.Errorf("EncodeValues() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestWakeOnLandConfig_UnmarshalJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		config  WakeOnLandConfig
		str     string
		wantErr bool
	}{
		{
			name: "mac only",
			config: WakeOnLandConfig{
				MACAddress: "00:11:22:33:44:55",
			},
			str: `"00:11:22:33:44:55"`,
		},
		{
			name: "mac only with key",
			config: WakeOnLandConfig{
				MACAddress: "00:11:22:33:44:55",
			},
			str: `"mac=00:11:22:33:44:55"`,
		},
		{
			name: "mac and bind interface",
			config: WakeOnLandConfig{
				MACAddress:    "00:11:22:33:44:55",
				BindInterface: ptr.Ptr("eth0"),
			},
			str: `"mac=00:11:22:33:44:55,bind-interface=eth0"`,
		},
		{
			name: "mac and broadcast address",
			config: WakeOnLandConfig{
				MACAddress:       "00:11:22:33:44:55",
				BroadcastAddress: ptr.Ptr("192.168.0.155"),
			},
			str: `"mac=00:11:22:33:44:55,broadcast-address=192.168.0.255"`,
		},
		{
			name: "mac, bind interface, and broadcast address",
			config: WakeOnLandConfig{
				MACAddress:       "00:11:22:33:44:55",
				BindInterface:    ptr.Ptr("eth0"),
				BroadcastAddress: ptr.Ptr("192.168.0.255"),
			},
			str: `"mac=00:11:22:33:44:55,bind-interface=eth0,broadcast-address=192.168.0.255"`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if err := tt.config.UnmarshalJSON([]byte(tt.str)); (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestWakeOnLandConfig_EncodeValues(t *testing.T) {
	t.Parallel()

	type args struct {
		key string
		v   *url.Values
	}

	tests := []struct {
		name    string
		config  WakeOnLandConfig
		args    args
		wantErr bool
	}{
		{
			name: "mac only",
			config: WakeOnLandConfig{
				MACAddress: "00:11:22:33:44:55",
			},
			args: args{
				"wakeonlan",
				&url.Values{
					"mac": {"00:11:22:33:44:55"},
				},
			},
		},
		{
			name: "mac and bind interface",
			config: WakeOnLandConfig{
				MACAddress:    "00:11:22:33:44:55",
				BindInterface: ptr.Ptr("eth0"),
			},
			args: args{
				"wakeonlan",
				&url.Values{
					"mac":            {"00:11:22:33:44:55"},
					"bind-interface": {"eth0"},
				},
			},
		},
		{
			name: "mac and broadcast address",
			config: WakeOnLandConfig{
				MACAddress:       "00:11:22:33:44:55",
				BroadcastAddress: ptr.Ptr("192.168.0.255"),
			},
			args: args{
				"wakeonlan",
				&url.Values{
					"mac":               {"00:11:22:33:44:55"},
					"broadcast-address": {"192.168.0.255"},
				},
			},
		},
		{
			name: "mac, bind interface, and broadcast address",
			config: WakeOnLandConfig{
				MACAddress:       "00:11:22:33:44:55",
				BindInterface:    ptr.Ptr("eth0"),
				BroadcastAddress: ptr.Ptr("10.255.255.255"),
			},
			args: args{
				"wakeonlan",
				&url.Values{
					"mac":               {"00:11:22:33:44:55"},
					"bind-interface":    {"eth0"},
					"broadcast-address": {"10.255.255.255"},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if err := tt.config.EncodeValues(tt.args.key, tt.args.v); (err != nil) != tt.wantErr {
				t.Errorf("EncodeValues() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
`````

## File: proxmox/nodes/config_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
)

// ConfigGetResponseBody contains the body from a config get response.
type ConfigGetResponseBody struct {
	Data *[]ConfigGetResponseData `json:"data,omitempty"`
}

// ConfigGetResponseData contains the data from a config get response.
type ConfigGetResponseData struct {
	// Node specific ACME settings.
	ACME *ACMEConfig `json:"acme,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain0 *ACMEDomainConfig `json:"acmedomain0,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain1 *ACMEDomainConfig `json:"acmedomain1,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain2 *ACMEDomainConfig `json:"acmedomain2,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain3 *ACMEDomainConfig `json:"acmedomain3,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain4 *ACMEDomainConfig `json:"acmedomain4,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain5 *ACMEDomainConfig `json:"acmedomain5,omitempty"`
	// Description for the Node. Shown in the web-interface node notes panel. This is saved as comment inside the configuration file.
	Description *string `json:"description,omitempty"`
	// Prevent changes if current configuration file has different SHA1 digest. This can be used to prevent concurrent modifications.
	Digest *string `json:"digest,omitempty"`
	// Initial delay in seconds, before starting all the Virtual Guests with on-boot enabled.
	StartAllOnbootDelay *int `json:"startall-onboot-delay,omitempty"`
	// Node specific wake on LAN settings.
	WakeOnLan *WakeOnLandConfig `json:"wakeonlan,omitempty"`
}

// ConfigUpdateRequestBody contains the body for a config update request.
type ConfigUpdateRequestBody struct {
	// Node specific ACME settings.
	ACME *ACMEConfig `json:"acme,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain0 *ACMEDomainConfig `json:"acmedomain0,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain1 *ACMEDomainConfig `json:"acmedomain1,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain2 *ACMEDomainConfig `json:"acmedomain2,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain3 *ACMEDomainConfig `json:"acmedomain3,omitempty"`
	// ACME domain and validation plugin
	ACMEDomain4 *ACMEDomainConfig `json:"acmedomain4,omitempty"`
	Delete      *string           `json:"delete,omitempty"`
	// Description for the Node. Shown in the web-interface node notes panel. This is saved as comment inside the configuration file.
	Description *string `json:"description,omitempty"`
	// Prevent changes if current configuration file has different SHA1 digest. This can be used to prevent concurrent modifications.
	Digest *string `json:"digest,omitempty"`
	// Initial delay in seconds, before starting all the Virtual Guests with on-boot enabled.
	StartAllOnbootDelay *int `json:"startall-onboot-delay,omitempty"`
	// Node specific wake on LAN settings.
	WakeOnLan *WakeOnLandConfig `json:"wakeonlan,omitempty"`
}

// ACMEConfig contains the ACME account / domains configuration that use the "standalone" plugin (http challenge).
type ACMEConfig struct {
	// account name
	Account *string
	// domains
	Domains []string
}

// UnmarshalJSON unmarshals a ACMEConfig struct from JSON.
func (a *ACMEConfig) UnmarshalJSON(b []byte) error {
	config := ACMEConfig{}

	s := ""
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling json: %w", err)
	}

	parts := strings.Split(s, ",")
	for _, part := range parts {
		kv := strings.Split(part, "=")
		if len(kv) != 2 {
			return fmt.Errorf("invalid key-value pair: %s", part)
		}

		switch kv[0] {
		case "account":
			config.Account = &kv[1]
		case "domains":
			config.Domains = strings.Split(kv[1], ";")
		default:
			return fmt.Errorf("unknown key: %s", kv[0])
		}
	}

	*a = config

	return nil
}

// EncodeValues encodes a ACMEConfig struct into a string.
func (a *ACMEConfig) EncodeValues(key string, v *url.Values) error {
	value := ""
	if a.Account != nil {
		value = fmt.Sprintf("account=%s", *a.Account)
	}

	value = fmt.Sprintf("%s,%s", value, strings.Join(a.Domains, ";"))
	v.Add(key, value)

	return nil
}

// ACMEDomainConfig contains the ACME domain configuration for domains using the dns challenge plugin.
type ACMEDomainConfig struct {
	// domain name
	Domain string
	// alias for the domain
	Alias *string
	// name of the plugin configuration
	Plugin *string
}

// UnmarshalJSON unmarshals a ACMEDomainConfig struct from JSON.
func (a *ACMEDomainConfig) UnmarshalJSON(b []byte) error {
	config := ACMEDomainConfig{}

	s := ""
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling json: %w", err)
	}

	parts := strings.Split(s, ",")
	for _, part := range parts {
		kv := strings.Split(part, "=")
		if len(kv) == 1 {
			config.Domain = kv[0]
		} else {
			switch kv[0] {
			case "domain":
				config.Domain = kv[1]
			case "alias":
				config.Alias = &kv[1]
			case "plugin":
				config.Plugin = &kv[1]
			default:
				return fmt.Errorf("unknown key: %s", kv[0])
			}
		}
	}

	*a = config

	return nil
}

// EncodeValues encodes a ACMEDomainConfig struct into a string.
func (a *ACMEDomainConfig) EncodeValues(key string, v *url.Values) error {
	value := a.Domain
	if a.Alias != nil {
		value = fmt.Sprintf("%s,alias=%s", value, *a.Alias)
	}

	if a.Plugin != nil {
		value = fmt.Sprintf("%s,plugin=%s", value, *a.Plugin)
	}

	v.Add(key, value)

	return nil
}

// WakeOnLandConfig contains the wake on LAN configuration.
type WakeOnLandConfig struct {
	// MAC address
	MACAddress string
	// bind interface
	BindInterface *string
	// IPv4 broadcast address
	BroadcastAddress *string
}

// UnmarshalJSON unmarshals a WakeOnLandConfig struct from JSON.
func (a *WakeOnLandConfig) UnmarshalJSON(b []byte) error {
	config := WakeOnLandConfig{}

	s := ""
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling json: %w", err)
	}

	parts := strings.Split(s, ",")
	for _, part := range parts {
		kv := strings.Split(part, "=")
		if len(kv) == 1 {
			config.MACAddress = kv[0]
		} else {
			switch kv[0] {
			case "mac":
				config.MACAddress = kv[1]
			case "bind-interface":
				config.BindInterface = &kv[1]
			case "broadcast-address":
				config.BroadcastAddress = &kv[1]
			default:
				return fmt.Errorf("unknown key: %s", kv[0])
			}
		}
	}

	*a = config

	return nil
}

// EncodeValues encodes a WakeOnLandConfig struct into a string.
func (a *WakeOnLandConfig) EncodeValues(key string, v *url.Values) error {
	value := a.MACAddress
	if a.BindInterface != nil {
		value = fmt.Sprintf("%s,bind-interface=%s", value, *a.BindInterface)
	}

	if a.BroadcastAddress != nil {
		value = fmt.Sprintf("%s,broadcast-address=%s", value, *a.BroadcastAddress)
	}

	v.Add(key, value)

	return nil
}
`````

## File: proxmox/nodes/config.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetConfig retrieves the config for a node.
func (c *Client) GetConfig(ctx context.Context) (*[]ConfigGetResponseData, error) {
	resBody := &ConfigGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("config"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving node config: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateConfig updates the config for a node.
func (c *Client) UpdateConfig(ctx context.Context, d *ConfigUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("config"), d, nil)
	if err != nil {
		return fmt.Errorf("error updating node config: %w", err)
	}

	return nil
}
`````

## File: proxmox/nodes/dns_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

// DNSGetResponseBody contains the body from a DNS get response.
type DNSGetResponseBody struct {
	Data *DNSGetResponseData `json:"data,omitempty"`
}

// DNSGetResponseData contains the data from a DNS get response.
type DNSGetResponseData struct {
	Server1      *string `json:"dns1,omitempty"   url:"dns1,omitempty"`
	Server2      *string `json:"dns2,omitempty"   url:"dns2,omitempty"`
	Server3      *string `json:"dns3,omitempty"   url:"dns3,omitempty"`
	SearchDomain *string `json:"search,omitempty" url:"search,omitempty"`
}

// DNSUpdateRequestBody contains the body for a DNS update request.
type DNSUpdateRequestBody struct {
	Server1      *string `json:"dns1,omitempty"   url:"dns1,omitempty"`
	Server2      *string `json:"dns2,omitempty"   url:"dns2,omitempty"`
	Server3      *string `json:"dns3,omitempty"   url:"dns3,omitempty"`
	SearchDomain *string `json:"search,omitempty" url:"search,omitempty"`
}
`````

## File: proxmox/nodes/dns.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetDNS retrieves the DNS configuration for a node.
func (c *Client) GetDNS(ctx context.Context) (*DNSGetResponseData, error) {
	resBody := &DNSGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("dns"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving DNS configuration: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateDNS updates the DNS configuration for a node.
func (c *Client) UpdateDNS(ctx context.Context, d *DNSUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("dns"), d, nil)
	if err != nil {
		return fmt.Errorf("error updating DNS configuration: %w", err)
	}

	return nil
}
`````

## File: proxmox/nodes/hosts_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

// HostsGetResponseBody contains the body from a hosts get response.
type HostsGetResponseBody struct {
	Data *HostsGetResponseData `json:"data,omitempty"`
}

// HostsGetResponseData contains the data from a hosts get response.
type HostsGetResponseData struct {
	Data   string  `json:"data"`
	Digest *string `json:"digest,omitempty"`
}

// HostsUpdateRequestBody contains the body for a hosts update request.
type HostsUpdateRequestBody struct {
	Data   string  `json:"data"             url:"data"`
	Digest *string `json:"digest,omitempty" url:"digest,omitempty"`
}
`````

## File: proxmox/nodes/hosts.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetHosts retrieves the Hosts configuration for a node.
func (c *Client) GetHosts(ctx context.Context) (*HostsGetResponseData, error) {
	resBody := &HostsGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("hosts"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving hosts configuration: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateHosts updates the Hosts configuration for a node.
func (c *Client) UpdateHosts(ctx context.Context, d *HostsUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("hosts"), d, nil)
	if err != nil {
		return fmt.Errorf("error updating hosts configuration: %w", err)
	}

	return nil
}
`````

## File: proxmox/nodes/network_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// NetworkInterfaceListResponseBody contains the body from a node network interface list response.
type NetworkInterfaceListResponseBody struct {
	Data []*NetworkInterfaceListResponseData `json:"data,omitempty"`
}

// NetworkInterfaceListResponseData contains the data from a node network interface list response.
type NetworkInterfaceListResponseData struct {
	// There seems to be inconsistency in the APIs between certain versions of Proxmox.
	// See https://github.com/bpg/terraform-provider-proxmox/issues/410
	// BridgeFD        *int              `json:"bridge_fd,omitempty"`

	Active          *types.CustomBool `json:"active,omitempty"`
	Address         *string           `json:"address,omitempty"`
	Address6        *string           `json:"address6,omitempty"`
	Autostart       *types.CustomBool `json:"autostart,omitempty"`
	BridgePorts     *string           `json:"bridge_ports,omitempty"`
	BridgeSTP       *string           `json:"bridge_stp,omitempty"`
	BridgeVIDs      *string           `json:"bridge_vids,omitempty"`
	BridgeVLANAware *types.CustomBool `json:"bridge_vlan_aware,omitempty"`
	CIDR            *string           `json:"cidr,omitempty"`
	CIDR6           *string           `json:"cidr6,omitempty"`
	Comments        *string           `json:"comments,omitempty"`
	Exists          *types.CustomBool `json:"exists,omitempty"`
	Families        *[]string         `json:"families,omitempty"`
	Gateway         *string           `json:"gateway,omitempty"`
	Gateway6        *string           `json:"gateway6,omitempty"`
	Iface           string            `json:"iface"`
	MethodIPv4      *string           `json:"method,omitempty"`
	MethodIPv6      *string           `json:"method6,omitempty"`
	MTU             *string           `json:"mtu,omitempty"`
	Netmask         *string           `json:"netmask,omitempty"`
	VLANID          *string           `json:"vlan-id,omitempty"`
	VLANRawDevice   *string           `json:"vlan-raw-device,omitempty"`
	Priority        int               `json:"priority"`
	Type            string            `json:"type"`
}

// NetworkInterfaceCreateUpdateRequestBody contains the body for a node network interface create / update request.
type NetworkInterfaceCreateUpdateRequestBody struct {
	Iface string `json:"iface" url:"iface"`
	Type  string `json:"type"  url:"type"`

	Address            *string           `json:"address,omitempty"               url:"address,omitempty"`
	Address6           *string           `json:"address6,omitempty"              url:"address6,omitempty"`
	Autostart          *types.CustomBool `json:"autostart,omitempty"             url:"autostart,omitempty,int"`
	BondPrimary        *string           `json:"bond-primary,omitempty"          url:"bond-primary,omitempty"`
	BondMode           *string           `json:"bond_mode,omitempty"             url:"bond_mode,omitempty"`
	BondXmitHashPolicy *string           `json:"bond_xmit_hash_policy,omitempty" url:"bond_xmit_hash_policy,omitempty"`
	BridgePorts        *string           `json:"bridge_ports,omitempty"          url:"bridge_ports,omitempty"`
	BridgeVLANAware    *types.CustomBool `json:"bridge_vlan_aware,omitempty"     url:"bridge_vlan_aware,omitempty,int"`
	CIDR               *string           `json:"cidr,omitempty"                  url:"cidr,omitempty"`
	CIDR6              *string           `json:"cidr6,omitempty"                 url:"cidr6,omitempty"`
	Comments           *string           `json:"comments,omitempty"              url:"comments,omitempty"`
	Comments6          *string           `json:"comments6,omitempty"             url:"comments6,omitempty"`
	Gateway            *string           `json:"gateway,omitempty"               url:"gateway,omitempty"`
	Gateway6           *string           `json:"gateway6,omitempty"              url:"gateway6,omitempty"`
	Delete             *[]string         `json:"delete,omitempty"                url:"delete,omitempty"`
	MTU                *int64            `json:"mtu,omitempty"                   url:"mtu,omitempty"`
	Netmask            *string           `json:"netmask,omitempty"               url:"netmask,omitempty"`
	Netmask6           *string           `json:"netmask6,omitempty"              url:"netmask6,omitempty"`
	OVSBonds           *string           `json:"ovs_bonds,omitempty"             url:"ovs_bonds,omitempty"`
	OVSBridge          *string           `json:"ovs_bridge,omitempty"            url:"ovs_bridge,omitempty"`
	OVSOptions         *string           `json:"ovs_options,omitempty"           url:"ovs_options,omitempty"`
	OVSPorts           *string           `json:"ovs_ports,omitempty"             url:"ovs_ports,omitempty"`
	OVSTag             *string           `json:"ovs_tag,omitempty"               url:"ovs_tag,omitempty"`
	Slaves             *string           `json:"slaves,omitempty"                url:"slaves,omitempty"`
	VLANID             *int64            `json:"vlan-id,omitempty"               url:"vlan-id,omitempty"`
	VLANRawDevice      *string           `json:"vlan-raw-device,omitempty"       url:"vlan-raw-device,omitempty"`
}

// ReloadNetworkResponseBody contains the body from a node network reload response.
type ReloadNetworkResponseBody struct {
	Data *string `json:"data,omitempty"`
}
`````

## File: proxmox/nodes/network.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/avast/retry-go/v4"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

const (
	networkReloadTimeout = 10 * time.Second
)

// reloadLock is used to prevent concurrent network reloads.
// global variable by design.
//
//nolint:gochecknoglobals
var reloadLock sync.Mutex

// ListNetworkInterfaces retrieves a list of network interfaces for a specific nodes.
func (c *Client) ListNetworkInterfaces(ctx context.Context) ([]*NetworkInterfaceListResponseData, error) {
	resBody := &NetworkInterfaceListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("network"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get network interfaces for node \"%s\": %w", c.NodeName, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Priority < resBody.Data[j].Priority
	})

	return resBody.Data, nil
}

// CreateNetworkInterface creates a network interface for a specific node.
func (c *Client) CreateNetworkInterface(ctx context.Context, d *NetworkInterfaceCreateUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, c.ExpandPath("network"), d, nil)
	if err != nil {
		return fmt.Errorf(
			"failed to create network interface \"%s\" for node \"%s\": %w",
			d.Iface, c.NodeName, err,
		)
	}

	return nil
}

// ReloadNetworkConfiguration reloads the network configuration for a specific node.
func (c *Client) ReloadNetworkConfiguration(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, networkReloadTimeout)
	defer cancel()

	reloadLock.Lock()
	defer reloadLock.Unlock()

	resBody := &ReloadNetworkResponseBody{}

	err := retry.Do(
		func() error {
			err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("network"), nil, resBody)
			if err != nil {
				return err
			}

			if resBody.Data == nil {
				return api.ErrNoDataObjectInResponse
			}

			return c.Tasks().WaitForTask(ctx, *resBody.Data)
		},
		retry.Context(ctx),
		retry.Delay(1*time.Second),
		retry.Attempts(3),
		retry.RetryIf(func(err error) bool {
			return strings.Contains(err.Error(), "exit code 89")
		}),
	)
	if err != nil {
		return fmt.Errorf("failed to reload network configuration for node \"%s\": %w", c.NodeName, err)
	}

	return nil
}

// RevertNetworkConfiguration reverts the network configuration changes for a specific node.
func (c *Client) RevertNetworkConfiguration(ctx context.Context) error {
	err := c.DoRequest(ctx, http.MethodDelete, c.ExpandPath("network"), nil, nil)
	if err != nil {
		return fmt.Errorf("failed to revert network configuration for node \"%s\": %w", c.NodeName, err)
	}

	return nil
}

// UpdateNetworkInterface updates a network interface for a specific node.
func (c *Client) UpdateNetworkInterface(
	ctx context.Context,
	iface string,
	d *NetworkInterfaceCreateUpdateRequestBody,
) error {
	err := c.DoRequest(
		ctx,
		http.MethodPut,
		c.ExpandPath(fmt.Sprintf("network/%s", url.PathEscape(iface))),
		d,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to update network interface \"%s\" for node \"%s\": %w",
			d.Iface, c.NodeName, err,
		)
	}

	return nil
}

// DeleteNetworkInterface deletes a network interface configuration for a specific node.
func (c *Client) DeleteNetworkInterface(ctx context.Context, iface string) error {
	err := c.DoRequest(
		ctx,
		http.MethodDelete,
		c.ExpandPath(fmt.Sprintf("network/%s", url.PathEscape(iface))),
		nil,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to delete network interface \"%s\" for node \"%s\": %w",
			iface, c.NodeName, err,
		)
	}

	return nil
}
`````

## File: proxmox/nodes/nodes_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"encoding/json"
	"fmt"
	"net/url"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// CustomCommands contains an array of commands to execute.
type CustomCommands []string

// ExecuteRequestBody contains the data for a node execute request.
type ExecuteRequestBody struct {
	Commands CustomCommands `json:"commands" url:"commands"`
}

// GetTimeResponseBody contains the body from a node time zone get response.
type GetTimeResponseBody struct {
	Data *GetTimeResponseData `json:"data,omitempty"`
}

// GetTimeResponseData contains the data from a node list response.
type GetTimeResponseData struct {
	LocalTime types.CustomTimestamp `json:"localtime"`
	TimeZone  string                `json:"timezone"`
	UTCTime   types.CustomTimestamp `json:"time"`
}

// GetInfoResponseBody contains the body from a node info get response.
type GetInfoResponseBody struct {
	Data *GetInfoResponseData `json:"data,omitempty"`
}

// GetInfoResponseData contains the data from a node info response.
type GetInfoResponseData struct {
	CPUInfo struct {
		CPUCores   *int    `json:"cores,omitempty"`
		CPUSockets *int    `json:"sockets,omitempty"`
		CPUModel   *string `json:"model"`
	} `json:"cpuinfo"`
	MemoryInfo struct {
		Free  *int `json:"free,omitempty"`
		Used  *int `json:"used,omitempty"`
		Total *int `json:"total,omitempty"`
	} `json:"memory"`
	Uptime *int `json:"uptime"`
}

// ListResponseBody contains the body from a node list response.
type ListResponseBody struct {
	Data []*ListResponseData `json:"data,omitempty"`
}

// ListResponseData contains the data from a node list response.
type ListResponseData struct {
	CPUCount        *int     `json:"maxcpu,omitempty"`
	CPUUtilization  *float64 `json:"cpu,omitempty"`
	MemoryAvailable *int     `json:"maxmem,omitempty"`
	MemoryUsed      *int     `json:"mem,omitempty"`
	Name            string   `json:"node"`
	SSLFingerprint  *string  `json:"ssl_fingerprint,omitempty"`
	Status          *string  `json:"status"`
	SupportLevel    *string  `json:"level,omitempty"`
	Uptime          *int     `json:"uptime"`
}

// UpdateTimeRequestBody contains the body for a node time update request.
type UpdateTimeRequestBody struct {
	TimeZone string `json:"timezone" url:"timezone"`
}

// EncodeValues converts a CustomCommands array to a JSON encoded URL value.
func (r CustomCommands) EncodeValues(key string, v *url.Values) error {
	jsonArrayBytes, err := json.Marshal(r)
	if err != nil {
		return fmt.Errorf("error marshalling CustomCommands array: %w", err)
	}

	v.Add(key, string(jsonArrayBytes))

	return nil
}
`````

## File: proxmox/nodes/nodes.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// ListNodes retrieves a list of nodes.
func (c *Client) ListNodes(ctx context.Context) ([]*ListResponseData, error) {
	resBody := &ListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, "nodes", nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get nodes: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].Name < resBody.Data[j].Name
	})

	return resBody.Data, nil
}

// GetTime retrieves the time information for a node.
func (c *Client) GetTime(ctx context.Context) (*GetTimeResponseData, error) {
	resBody := &GetTimeResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("time"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get time information for node \"%s\": %w", c.NodeName, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}

// UpdateTime updates the time on a node.
func (c *Client) UpdateTime(ctx context.Context, d *UpdateTimeRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, c.ExpandPath("time"), d, nil)
	if err != nil {
		return fmt.Errorf("failed to update node time: %w", err)
	}

	return nil
}

// GetInfo retrieves the information of the node.
func (c *Client) GetInfo(ctx context.Context) (*GetInfoResponseData, error) {
	resBody := &GetInfoResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("status"), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get status of the node \"%s\": %w", c.NodeName, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/nodes/query_url_metadata_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import "github.com/bpg/terraform-provider-proxmox/proxmox/types"

// QueryURLMetadataGetResponseBody contains the body from a QueryURLMetadata get response.
type QueryURLMetadataGetResponseBody struct {
	Data *QueryURLMetadataGetResponseData `json:"data,omitempty"`
}

// QueryURLMetadataGetResponseData contains the data from a QueryURLMetadata get response.
type QueryURLMetadataGetResponseData struct {
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	Mimetype *string `json:"mimetype,omitempty" url:"mimetype,omitempty"`
	Size     *int64  `json:"size,omitempty"     url:"size,omitempty"`
}

// QueryURLMetadataGetRequestBody contains the body for a QueryURLMetadata get request.
type QueryURLMetadataGetRequestBody struct {
	Verify *types.CustomBool `json:"verify-certificates,omitempty" url:"verify-certificates,omitempty,int"`
	URL    string            `json:"url"                           url:"url"`
}
`````

## File: proxmox/nodes/query_url_metadata.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package nodes

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// GetQueryURLMetadata retrieves the URL filename details for a node.
func (c *Client) GetQueryURLMetadata(
	ctx context.Context,
	d *QueryURLMetadataGetRequestBody,
) (*QueryURLMetadataGetResponseData, error) {
	resBody := &QueryURLMetadataGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, c.ExpandPath("query-url-metadata"), d, resBody)
	if err != nil {
		return nil, fmt.Errorf("error retrieving URL metadata for %q: %w", d.URL, err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/pools/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package pools

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox pools API.
type Client struct {
	api.Client
}
`````

## File: proxmox/pools/pool_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package pools

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// PoolCreateRequestBody contains the data for a pool create request.
type PoolCreateRequestBody struct {
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	ID      string  `json:"groupid"           url:"poolid"`
}

// PoolGetResponseBody contains the body from a pool get response.
type PoolGetResponseBody struct {
	Data *PoolGetResponseData `json:"data,omitempty"`
}

// PoolGetResponseData contains the data from a pool get response.
type PoolGetResponseData struct {
	Comment *string                                    `json:"comment,omitempty"`
	Members []VirtualEnvironmentPoolGetResponseMembers `json:"members,omitempty"`
}

// VirtualEnvironmentPoolGetResponseMembers contains the members data from a pool get response.
type VirtualEnvironmentPoolGetResponseMembers struct {
	ID          string  `json:"id"`
	Node        string  `json:"node"`
	DatastoreID *string `json:"storage,omitempty"`
	Type        string  `json:"type"`
	VMID        *int    `json:"vmid"`
}

// PoolListResponseBody contains the body from a pool list response.
type PoolListResponseBody struct {
	Data []*PoolListResponseData `json:"data,omitempty"`
}

// PoolListResponseData contains the data from a pool list response.
type PoolListResponseData struct {
	Comment *string `json:"comment,omitempty"`
	ID      string  `json:"poolid"`
}

// PoolUpdateRequestBody contains the data for an pool update request.
type PoolUpdateRequestBody struct {
	// The pool's comment
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	// If this is set to 1, VMs and datastores will be removed from the pool instead of added.
	Delete *types.CustomBool `json:"delete,omitempty" url:"delete,omitempty,int"`
	// The list of virtual machines to add or delete.
	VMs *types.CustomCommaSeparatedList `json:"vms,omitempty" url:"vms,omitempty,comma"`
	// The list of datastores to add or delete.
	Storage *types.CustomCommaSeparatedList `json:"storage,omitempty" url:"storage,omitempty,comma"`
}
`````

## File: proxmox/pools/pool.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package pools

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"sort"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// CreatePool creates a pool.
func (c *Client) CreatePool(ctx context.Context, d *PoolCreateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPost, "pools", d, nil)
	if err != nil {
		return fmt.Errorf("error creating pool: %w", err)
	}

	return nil
}

// DeletePool deletes a pool.
func (c *Client) DeletePool(ctx context.Context, id string) error {
	err := c.DoRequest(ctx, http.MethodDelete, fmt.Sprintf("pools/%s", url.PathEscape(id)), nil, nil)
	if err != nil {
		return fmt.Errorf("error deleting pool: %w", err)
	}

	return nil
}

// GetPool retrieves a pool.
func (c *Client) GetPool(ctx context.Context, id string) (*PoolGetResponseData, error) {
	resBody := &PoolGetResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, fmt.Sprintf("pools/%s", url.PathEscape(id)), nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error getting pool: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data.Members, func(i, j int) bool {
		return resBody.Data.Members[i].ID < resBody.Data.Members[j].ID
	})

	return resBody.Data, nil
}

// ListPools retrieves a list of pools.
func (c *Client) ListPools(ctx context.Context) ([]*PoolListResponseData, error) {
	resBody := &PoolListResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, "pools", nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("error listing pools: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	sort.Slice(resBody.Data, func(i, j int) bool {
		return resBody.Data[i].ID < resBody.Data[j].ID
	})

	return resBody.Data, nil
}

// UpdatePool updates a pool.
func (c *Client) UpdatePool(ctx context.Context, id string, d *PoolUpdateRequestBody) error {
	err := c.DoRequest(ctx, http.MethodPut, fmt.Sprintf("pools/%s", url.PathEscape(id)), d, nil)
	if err != nil {
		return fmt.Errorf("error updating pool: %w", err)
	}

	return nil
}
`````

## File: proxmox/ssh/client_notwindows.go
`````go
//go:build !windows

package ssh

import (
	"errors"
	"fmt"
	"net"
)

// dialSocket dials a Unix domain socket.
func dialSocket(address string) (net.Conn, error) {
	if address == "" {
		return nil, errors.New("failed connecting to SSH agent socket: the socket file is not defined, " +
			"authentication will fall back to password")
	}

	conn, err := net.Dial("unix", address)
	if err != nil {
		return nil, fmt.Errorf("error dialing unix socket: %w", err)
	}

	return conn, nil
}
`````

## File: proxmox/ssh/client_windows.go
`````go
//go:build windows

package ssh

import (
	"fmt"
	"net"

	"github.com/Microsoft/go-winio"
)

// dialSocket dials a Windows named pipe. If address is empty, it dials the default ssh-agent pipe.
func dialSocket(address string) (net.Conn, error) {
	if address == "" {
		address = `\\.\pipe\openssh-ssh-agent`
	}

	conn, err := winio.DialPipe(address, nil)
	if err != nil {
		return nil, fmt.Errorf("error dialing named pipe: %w", err)
	}

	return conn, nil
}
`````

## File: proxmox/ssh/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ssh

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/pkg/sftp"
	"github.com/skeema/knownhosts"
	"golang.org/x/crypto/ssh"
	"golang.org/x/crypto/ssh/agent"
	"golang.org/x/net/proxy"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

const (
	// TrySudo is a shell function that tries to execute a command with sudo if the user has sudo permissions.
	TrySudo = `try_sudo(){ if [ $(sudo -n pvesm apiinfo 2>&1 | grep "APIVER" | wc -l) -gt 0 ]; then sudo $1; else $1; fi }`
)

// NewErrUserHasNoPermission creates a new error indicating that the SSH user does not have required permissions.
func NewErrUserHasNoPermission(username string) error {
	return fmt.Errorf("the SSH user '%s' does not have required permissions. "+
		"Make sure 'sudo' is installed and the user is configured in sudoers file. "+
		"Refer to the documentation for more details", username)
}

// Client is an interface for performing SSH requests against the Proxmox Nodes.
type Client interface {
	// Username returns the SSH username.
	Username() string

	// ExecuteNodeCommands executes a command on a node.
	ExecuteNodeCommands(ctx context.Context, nodeName string, commands []string) ([]byte, error)

	// NodeUpload uploads a file to a node.
	NodeUpload(ctx context.Context, nodeName string,
		remoteFileDir string, fileUploadRequest *api.FileUploadRequest) error

	// NodeStreamUpload uploads a file to a node by streaming its content over SSH.
	NodeStreamUpload(ctx context.Context, nodeName string,
		remoteFileDir string, fileUploadRequest *api.FileUploadRequest) error
}

type client struct {
	username       string
	password       string
	agent          bool
	agentSocket    string
	privateKey     string
	socks5Server   string
	socks5Username string
	socks5Password string
	nodeResolver   NodeResolver
}

// NewClient creates a new SSH client.
func NewClient(
	username string, password string,
	agent bool, agentSocket string,
	privateKey string,
	socks5Server string, socks5Username string, socks5Password string,
	nodeResolver NodeResolver,
) (Client, error) {
	if agent &&
		runtime.GOOS != "linux" &&
		runtime.GOOS != "darwin" &&
		runtime.GOOS != "freebsd" &&
		runtime.GOOS != "windows" {
		return nil, errors.New(
			"the ssh agent flag is only supported on POSIX and Windows systems, please set it to 'false'" +
				" or remove it from your provider configuration",
		)
	}

	if (socks5Username != "" || socks5Password != "") && socks5Server == "" {
		return nil, errors.New("socks5 server is required when socks5 username or password is set")
	}

	if nodeResolver == nil {
		return nil, errors.New("node resolver is required")
	}

	return &client{
		username:       username,
		password:       password,
		agent:          agent,
		agentSocket:    agentSocket,
		privateKey:     privateKey,
		socks5Server:   socks5Server,
		socks5Username: socks5Username,
		socks5Password: socks5Password,
		nodeResolver:   nodeResolver,
	}, nil
}

func (c *client) Username() string {
	return c.username
}

// ExecuteNodeCommands executes commands on a given node.
func (c *client) ExecuteNodeCommands(ctx context.Context, nodeName string, commands []string) ([]byte, error) {
	node, err := c.nodeResolver.Resolve(ctx, nodeName)
	if err != nil {
		return nil, fmt.Errorf("failed to find node endpoint: %w", err)
	}

	tflog.Debug(ctx, "executing commands on the node using SSH", map[string]interface{}{
		"node_address": node.Address,
		"node_port":    node.Port,
		"commands":     commands,
	})

	sshClient, err := c.openNodeShell(ctx, node)
	if err != nil {
		return nil, err
	}

	defer func(sshClient *ssh.Client) {
		e := sshClient.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close SSH client", map[string]interface{}{
				"error": e,
			})
		}
	}(sshClient)

	output, err := c.executeCommands(ctx, sshClient, commands)
	if err != nil {
		return nil, err
	}

	return output, nil
}

func (c *client) executeCommands(ctx context.Context, sshClient *ssh.Client, commands []string) ([]byte, error) {
	sshSession, err := sshClient.NewSession()
	if err != nil {
		return nil, fmt.Errorf("failed to create SSH session: %w", err)
	}

	defer func(session *ssh.Session) {
		e := session.Close()
		if e != nil && !errors.Is(e, io.EOF) {
			tflog.Warn(ctx, "failed to close SSH session", map[string]interface{}{
				"error": e,
			})
		}
	}(sshSession)

	script := strings.Join(commands, "; ")

	output, err := sshSession.CombinedOutput(
		fmt.Sprintf(
			// explicitly use bash to support shell features like pipes and var assignment
			"/bin/bash -c '%s'",
			// shell script escaping for single quotes
			strings.ReplaceAll(script, `'`, `'"'"'`),
		),
	)
	if err != nil {
		return nil, errors.New(string(output))
	}

	return output, nil
}

func (c *client) NodeUpload(
	ctx context.Context,
	nodeName string,
	remoteFileDir string,
	d *api.FileUploadRequest,
) error {
	ip, err := c.nodeResolver.Resolve(ctx, nodeName)
	if err != nil {
		return fmt.Errorf("failed to find node endpoint: %w", err)
	}

	tflog.Debug(ctx, "uploading file to the node datastore using SFTP", map[string]interface{}{
		"node_address": ip,
		"remote_dir":   remoteFileDir,
		"file_name":    d.FileName,
		"content_type": d.ContentType,
	})

	fileInfo, err := d.File.Stat()
	if err != nil {
		return fmt.Errorf("failed to get file info: %w", err)
	}

	fileSize := fileInfo.Size()

	sshClient, err := c.openNodeShell(ctx, ip)
	if err != nil {
		return fmt.Errorf("failed to open SSH client: %w", err)
	}

	defer func(sshClient *ssh.Client) {
		e := sshClient.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close SSH client", map[string]interface{}{
				"error": e,
			})
		}
	}(sshClient)

	if d.ContentType != "" {
		remoteFileDir = filepath.Join(remoteFileDir, d.ContentType)
	}

	remoteFilePath := strings.ReplaceAll(filepath.Join(remoteFileDir, d.FileName), `\`, "/")

	sftpClient, err := sftp.NewClient(sshClient)
	if err != nil {
		return fmt.Errorf("failed to create SFTP client: %w", err)
	}

	defer func(sftpClient *sftp.Client) {
		e := sftpClient.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close SFTP client", map[string]interface{}{
				"error": e,
			})
		}
	}(sftpClient)

	err = sftpClient.MkdirAll(remoteFileDir)
	if err != nil {
		return fmt.Errorf("failed to create directory %s: %w", remoteFileDir, err)
	}

	remoteFile, err := sftpClient.Create(remoteFilePath)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", remoteFilePath, err)
	}

	defer func(remoteFile *sftp.File) {
		e := remoteFile.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close remote file", map[string]interface{}{
				"error": e,
			})
		}
	}(remoteFile)

	bytesUploaded, err := remoteFile.ReadFrom(d.File)
	if err != nil {
		return fmt.Errorf("failed to upload file %s: %w", remoteFilePath, err)
	}

	if bytesUploaded != fileSize {
		return fmt.Errorf("failed to upload file %s: uploaded %d bytes, expected %d bytes",
			remoteFilePath, bytesUploaded, fileSize)
	}

	tflog.Debug(ctx, "uploaded file to datastore", map[string]interface{}{
		"remote_file_path": remoteFilePath,
		"size":             bytesUploaded,
	})

	return nil
}

func (c *client) NodeStreamUpload(
	ctx context.Context,
	nodeName string,
	remoteFileDir string,
	d *api.FileUploadRequest,
) error {
	ip, err := c.nodeResolver.Resolve(ctx, nodeName)
	if err != nil {
		return fmt.Errorf("failed to find node endpoint: %w", err)
	}

	tflog.Debug(ctx, "uploading file to the node datastore via SSH input stream ", map[string]interface{}{
		"node_address": ip,
		"remote_dir":   remoteFileDir,
		"file_name":    d.FileName,
		"content_type": d.ContentType,
	})

	fileInfo, err := d.File.Stat()
	if err != nil {
		return fmt.Errorf("failed to get file info: %w", err)
	}

	fileSize := fileInfo.Size()

	sshClient, err := c.openNodeShell(ctx, ip)
	if err != nil {
		return fmt.Errorf("failed to open SSH client: %w", err)
	}

	defer func(sshClient *ssh.Client) {
		e := sshClient.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close SSH client", map[string]interface{}{
				"error": e,
			})
		}
	}(sshClient)

	if d.ContentType != "" {
		remoteFileDir = filepath.Join(remoteFileDir, d.ContentType)
	}

	remoteFilePath := strings.ReplaceAll(filepath.Join(remoteFileDir, d.FileName), `\`, "/")

	err = c.uploadFile(ctx, sshClient, d, remoteFilePath)
	if err != nil {
		return err
	}

	err = c.checkUploadedFile(ctx, sshClient, remoteFilePath, fileSize)
	if err != nil {
		return err
	}

	if d.Mode != "" {
		parsedFileMode, parseErr := strconv.ParseUint(d.Mode, 8, 12)
		if parseErr != nil {
			return fmt.Errorf("failed to parse file mode %q: %w", d.Mode, parseErr)
		}

		mode := uint32(parsedFileMode)
		if err = c.changeModeUploadedFile(ctx, sshClient, remoteFilePath, os.FileMode(mode)); err != nil {
			return err
		}
	}

	tflog.Debug(ctx, "uploaded file to datastore", map[string]interface{}{
		"remote_file_path": remoteFilePath,
	})

	return nil
}

func (c *client) uploadFile(
	ctx context.Context,
	sshClient *ssh.Client,
	req *api.FileUploadRequest,
	remoteFilePath string,
) error {
	sshSession, err := sshClient.NewSession()
	if err != nil {
		return fmt.Errorf("failed to create SSH session: %w", err)
	}

	defer func(session *ssh.Session) {
		e := session.Close()
		if e != nil && !errors.Is(e, io.EOF) {
			tflog.Warn(ctx, "failed to close SSH session", map[string]interface{}{
				"error": e,
			})
		}
	}(sshSession)

	sshSession.Stdin = req.File

	output, err := sshSession.CombinedOutput(
		fmt.Sprintf(`%s; try_sudo "/usr/bin/tee %s"`, TrySudo, remoteFilePath),
	)
	if err != nil {
		return fmt.Errorf("error transferring file: %s", string(output))
	}

	return nil
}

func (c *client) checkUploadedFile(
	ctx context.Context,
	sshClient *ssh.Client,
	remoteFilePath string,
	fileSize int64,
) error {
	sftpClient, err := sftp.NewClient(sshClient)
	if err != nil {
		return fmt.Errorf("failed to create SFTP client: %w", err)
	}

	defer func(sftpClient *sftp.Client) {
		e := sftpClient.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close SFTP client", map[string]interface{}{
				"error": e,
			})
		}
	}(sftpClient)

	remoteFile, err := sftpClient.Open(remoteFilePath)
	if err != nil {
		return fmt.Errorf("failed to open remote file %s: %w", remoteFilePath, err)
	}

	remoteStat, err := remoteFile.Stat()
	if err != nil {
		return fmt.Errorf("failed to read remote file %s: %w", remoteFilePath, err)
	}

	bytesUploaded := remoteStat.Size()
	if bytesUploaded != fileSize {
		return fmt.Errorf("failed to upload file %s: uploaded %d bytes, expected %d bytes",
			remoteFilePath, bytesUploaded, fileSize)
	}

	return nil
}

func (c *client) changeModeUploadedFile(
	ctx context.Context,
	sshClient *ssh.Client,
	remoteFilePath string,
	fileMode os.FileMode,
) error {
	sftpClient, err := sftp.NewClient(sshClient)
	if err != nil {
		return fmt.Errorf("failed to create SFTP client: %w", err)
	}

	defer func(sftpClient *sftp.Client) {
		e := sftpClient.Close()
		if e != nil {
			tflog.Warn(ctx, "failed to close SFTP client", map[string]interface{}{
				"error": e,
			})
		}
	}(sftpClient)

	remoteFile, err := sftpClient.Open(remoteFilePath)
	if err != nil {
		return fmt.Errorf("failed to open remote file %s: %w", remoteFilePath, err)
	}

	remoteStat, err := remoteFile.Stat()
	if err != nil {
		return fmt.Errorf("failed to read remote file %s: %w", remoteFilePath, err)
	}

	if err = sftpClient.Chmod(remoteFilePath, fileMode); err != nil {
		return fmt.Errorf("failed to change file mode of remote file from %#o (%s) to %#o (%s): %w",
			remoteStat.Mode().Perm(), remoteStat.Mode(), fileMode.Perm(), fileMode, err)
	}

	tflog.Debug(ctx, "changed mode of uploaded file", map[string]interface{}{
		"before": fmt.Sprintf("%#o (%s)", remoteStat.Mode().Perm(), remoteStat.Mode()),
		"after":  fmt.Sprintf("%#o (%s)", fileMode.Perm(), fileMode),
	})

	return nil
}

// openNodeShell establishes a new SSH connection to a node.
func (c *client) openNodeShell(ctx context.Context, node ProxmoxNode) (*ssh.Client, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to determine the home directory: %w", err)
	}

	var sshHost string
	if strings.Contains(node.Address, ":") {
		// IPv6
		sshHost = fmt.Sprintf("[%s]:%d", node.Address, node.Port)
	} else {
		// IPv4
		sshHost = fmt.Sprintf("%s:%d", node.Address, node.Port)
	}

	sshPath := path.Join(homeDir, ".ssh")
	if _, err = os.Stat(sshPath); os.IsNotExist(err) {
		e := os.Mkdir(sshPath, 0o700)
		if e != nil && !os.IsExist(e) {
			return nil, fmt.Errorf("failed to create %s: %w", sshPath, e)
		}
	}

	khPath := path.Join(sshPath, "known_hosts")
	if _, err = os.Stat(khPath); os.IsNotExist(err) {
		e := os.WriteFile(khPath, []byte{}, 0o600)
		if e != nil {
			return nil, fmt.Errorf("failed to create %s: %w", khPath, e)
		}
	}

	kh, err := knownhosts.NewDB(khPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read %s: %w", khPath, err)
	}

	// Create a custom permissive host key callback which still errors on hosts
	// with changed keys, but allows unknown hosts and adds them to known_hosts
	cb := ssh.HostKeyCallback(func(hostname string, remote net.Addr, key ssh.PublicKey) error {
		khErr := kh.HostKeyCallback()(hostname, remote, key)
		if knownhosts.IsHostKeyChanged(khErr) {
			return fmt.Errorf("REMOTE HOST IDENTIFICATION HAS CHANGED for host %s! This may indicate a MitM attack", hostname)
		}

		if knownhosts.IsHostUnknown(khErr) {
			f, fErr := os.OpenFile(khPath, os.O_APPEND|os.O_WRONLY, 0o600)
			if fErr == nil {
				defer utils.CloseOrLogError(ctx)(f)
				fErr = knownhosts.WriteKnownHost(f, hostname, remote, key)
			}

			if fErr == nil {
				tflog.Info(ctx, fmt.Sprintf("Added host %s to known_hosts", hostname))
			} else {
				tflog.Error(ctx, fmt.Sprintf("Failed to add host %s to known_hosts", hostname), map[string]interface{}{
					"error": khErr,
				})
			}

			return nil
		}

		return khErr
	})

	tflog.Info(ctx, fmt.Sprintf("agent is set to %t", c.agent))

	var sshClient *ssh.Client
	if c.agent {
		sshClient, err = c.createSSHClientAgent(ctx, cb, kh, sshHost)
		if err == nil {
			return sshClient, nil
		}

		tflog.Error(ctx, "Failed SSH connection through agent",
			map[string]interface{}{
				"error": err,
			})
	}

	if c.privateKey != "" {
		sshClient, err = c.createSSHClientWithPrivateKey(ctx, cb, kh, sshHost)
		if err == nil {
			return sshClient, nil
		}

		tflog.Error(ctx, "Failed SSH connection with private key",
			map[string]interface{}{
				"error": err,
			})
	}

	tflog.Info(ctx, "Falling back to password authentication for SSH connection")

	sshClient, err = c.createSSHClient(ctx, cb, kh, sshHost)
	if err != nil {
		return nil, fmt.Errorf("unable to authenticate user %q over SSH to %q. Please verify that ssh-agent is "+
			"correctly loaded with an authorized key via 'ssh-add -L' (NOTE: configurations in ~/.ssh/config are "+
			"not considered by the provider): %w", c.username, sshHost, err)
	}

	return sshClient, nil
}

func (c *client) createSSHClient(
	ctx context.Context,
	cb ssh.HostKeyCallback,
	kh *knownhosts.HostKeyDB,
	sshHost string,
) (*ssh.Client, error) {
	if c.password == "" {
		tflog.Error(ctx, "Using password authentication fallback for SSH connection, but the SSH password is empty")
	}

	sshConfig := &ssh.ClientConfig{
		User:              c.username,
		Auth:              []ssh.AuthMethod{ssh.Password(c.password)},
		HostKeyCallback:   cb,
		HostKeyAlgorithms: kh.HostKeyAlgorithms(sshHost),
	}

	return c.connect(ctx, sshHost, sshConfig)
}

// createSSHClientAgent establishes an ssh connection through the agent authentication mechanism.
func (c *client) createSSHClientAgent(
	ctx context.Context,
	cb ssh.HostKeyCallback,
	kh *knownhosts.HostKeyDB,
	sshHost string,
) (*ssh.Client, error) {
	conn, err := dialSocket(c.agentSocket)
	if err != nil {
		return nil, fmt.Errorf("failed connecting to SSH auth socket '%s': %w", c.agentSocket, err)
	}

	ag := agent.NewClient(conn)

	sshConfig := &ssh.ClientConfig{
		User:              c.username,
		Auth:              []ssh.AuthMethod{ssh.PublicKeysCallback(ag.Signers), ssh.Password(c.password)},
		HostKeyCallback:   cb,
		HostKeyAlgorithms: kh.HostKeyAlgorithms(sshHost),
	}

	return c.connect(ctx, sshHost, sshConfig)
}

func (c *client) createSSHClientWithPrivateKey(
	ctx context.Context,
	cb ssh.HostKeyCallback,
	kh *knownhosts.HostKeyDB,
	sshHost string,
) (*ssh.Client, error) {
	privateKey, err := ssh.ParsePrivateKey([]byte(c.privateKey))
	if err != nil {
		return nil, fmt.Errorf("failed to parse private key: %w", err)
	}

	sshConfig := &ssh.ClientConfig{
		User:              c.username,
		Auth:              []ssh.AuthMethod{ssh.PublicKeys(privateKey)},
		HostKeyCallback:   cb,
		HostKeyAlgorithms: kh.HostKeyAlgorithms(sshHost),
	}

	return c.connect(ctx, sshHost, sshConfig)
}

func (c *client) connect(ctx context.Context, sshHost string, sshConfig *ssh.ClientConfig) (*ssh.Client, error) {
	if c.socks5Server != "" {
		sshClient, err := c.socks5SSHClient(sshHost, sshConfig)
		if err != nil {
			return nil, fmt.Errorf("failed to dial %s via SOCKS5 proxy %s: %w", sshHost, c.socks5Server, err)
		}

		tflog.Debug(ctx, "SSH connection via SOCKS5 established", map[string]interface{}{
			"host":          sshHost,
			"socks5_server": c.socks5Server,
			"user":          c.username,
		})

		return sshClient, nil
	}

	sshClient, err := ssh.Dial("tcp", sshHost, sshConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to dial %s: %w", sshHost, err)
	}

	tflog.Debug(ctx, "SSH connection established", map[string]interface{}{
		"host": sshHost,
		"user": c.username,
	})

	return sshClient, nil
}

func (c *client) socks5SSHClient(sshServerAddress string, sshConfig *ssh.ClientConfig) (*ssh.Client, error) {
	dialer, err := proxy.SOCKS5("tcp", c.socks5Server, &proxy.Auth{
		User:     c.socks5Username,
		Password: c.socks5Password,
	}, proxy.Direct)
	if err != nil {
		return nil, fmt.Errorf("failed to create SOCKS5 proxy dialer: %w", err)
	}

	conn, err := dialer.Dial("tcp", sshServerAddress)
	if err != nil {
		return nil, fmt.Errorf("failed to dial %s via SOCKS5 proxy %s: %w", sshServerAddress, c.socks5Server, err)
	}

	sshConn, ch, reqs, err := ssh.NewClientConn(conn, sshServerAddress, sshConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to create SSH client connection: %w", err)
	}

	return ssh.NewClient(sshConn, ch, reqs), nil
}
`````

## File: proxmox/ssh/resolver.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ssh

import (
	"context"
)

// ProxmoxNode represents node address and port for SSH connection.
type ProxmoxNode struct {
	Address string
	Port    int32
}

// NodeResolver is an interface for resolving node names to IP addresses to use for SSH connection.
type NodeResolver interface {
	Resolve(ctx context.Context, nodeName string) (ProxmoxNode, error)
}
`````

## File: proxmox/storage/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox storage API.
type Client struct {
	api.Client
}
`````

## File: proxmox/storage/storage_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// DatastoreGetResponseBody contains the body from a datastore get response.
type DatastoreGetResponseBody struct {
	Data *DatastoreGetResponseData `json:"data,omitempty"`
}

// DatastoreGetResponseData contains the data from a datastore get response.
type DatastoreGetResponseData struct {
	Content types.CustomCommaSeparatedList `json:"content,omitempty" url:"content,omitempty,comma"`
	Digest  *string                        `json:"digest,omitempty"`
	Path    *string                        `json:"path,omitempty"`
	Shared  *types.CustomBool              `json:"shared,omitempty"`
	Storage *string                        `json:"storage,omitempty"`
	Type    *string                        `json:"type,omitempty"`
}
`````

## File: proxmox/storage/storage.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package storage

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
)

// GetDatastore retrieves information about a datastore.
/*
Using undocumented API endpoints is not recommended, but sometimes it's the only way to get things done.
$ pvesh get /storage/local
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ key     ‚îÇ value                                     ‚îÇ
‚ïû‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï°
‚îÇ content ‚îÇ images,vztmpl,iso,backup,snippets,rootdir ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ digest  ‚îÇ 5b65ede80f34631d6039e6922845cfa4abc956be  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ path    ‚îÇ /var/lib/vz                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ shared  ‚îÇ 0                                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ storage ‚îÇ local                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ type    ‚îÇ dir                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò.
*/
func (c *Client) GetDatastore(
	ctx context.Context,
	datastoreID string,
) (*DatastoreGetResponseData, error) {
	resBody := &DatastoreGetResponseBody{}

	err := c.DoRequest(
		ctx,
		http.MethodGet,
		fmt.Sprintf("storage/%s", url.PathEscape(datastoreID)),
		nil,
		resBody,
	)
	if err != nil {
		return nil, fmt.Errorf("error retrieving datastore %s: %w", datastoreID, err)
	}

	return resBody.Data, nil
}
`````

## File: proxmox/types/hardwaremapping/device_id.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package hardwaremapping

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"regexp"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

const (
	// attrNameDeviceID is the attribute name of the device ID in a hardware mapping.
	attrNameDeviceID = "id"

	// attrNameSubsystemID is the attribute name of the device subsystem ID in a hardware mapping.
	attrNameSubsystemID = "subsystem-id"
)

// DeviceIDAttrValueRegEx is the regular expression for device ID attribute value in a hardware mapping.
var DeviceIDAttrValueRegEx = regexp.MustCompile(`^[0-9A-Fa-f]{4}:[0-9A-Fa-f]{4}$`)

// Ensure the hardware mapping device ID type implements required interfaces.
var (
	_ fmt.Stringer     = new(DeviceID)
	_ json.Marshaler   = new(DeviceID)
	_ json.Unmarshaler = new(DeviceID)
	_ query.Encoder    = new(DeviceID)
)

// DeviceID represents a hardware mapping device ID.
// An ID is composed of two parts, either‚Ä¶
//   - a Vendor ID and device ID.
//     This is the device class and subclass (two 8-bit numbers).
//   - Subsystem ID and Subsystem device ID.
//     This identifies the assembly in which the device is contained.
//     Subsystems have their vendor ID (from the same namespace as device vendors) and subsystem ID.
//
// References:
//   - [Linux Kernel Documentation ‚Äî PCI drivers]
//   - [Linux Hardware Database]
//   - [Linux USB ID Repository]
//   - [man(5) ‚Äî pci.ids]
//
// [Linux Kernel Documentation ‚Äî PCI drivers]: https://docs.kernel.org/admin-guide/media/pci-cardlist.html
// [Linux Hardware Database]: https://linux-hardware.org
// [Linux USB ID Repository]: http://www.linux-usb.org/usb-ids.html
// [man(5) ‚Äî pci.ids]: https://man.archlinux.org/man/core/pciutils/pci.ids.5.en#INTRODUCTION
type DeviceID string

// EncodeValues encodes a hardware mapping device ID field into a URL-encoded set of values.
func (did DeviceID) EncodeValues(key string, v *url.Values) error {
	v.Add(key, did.String())

	return nil
}

// MarshalJSON marshals a hardware mapping device ID into JSON value.
func (did DeviceID) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(did)
	if err != nil {
		return nil, errors.Join(ErrDeviceIDMarshal, err)
	}

	return bytes, nil
}

// String converts a DeviceID value into a string.
func (did DeviceID) String() string {
	return string(did)
}

// ToValue converts a hardware mapping device ID into a Terraform value.
func (did DeviceID) ToValue() types.String {
	return types.StringValue(did.String())
}

// UnmarshalJSON unmarshals a hardware mapping device ID.
func (did *DeviceID) UnmarshalJSON(b []byte) error {
	var pciMapID string

	err := json.Unmarshal(b, &pciMapID)
	if err != nil {
		return errors.Join(ErrDeviceIDUnmarshal, err)
	}

	resType, err := ParseDeviceID(pciMapID)
	if err == nil {
		*did = resType
	}

	return err
}

// ParseDeviceID parses a string that represents a hardware mapping device ID into a DeviceID.
func ParseDeviceID(input string) (DeviceID, error) {
	if !DeviceIDAttrValueRegEx.MatchString(input) {
		return "", ErrDeviceIDParsing(input)
	}

	return DeviceID(input), nil
}
`````

## File: proxmox/types/hardwaremapping/errors.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package hardwaremapping

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/function"
)

//nolint:gochecknoglobals
var (
	// ErrIDMarshal indicates an error while marshalling a hardware mapping ID.
	ErrIDMarshal = function.NewFuncError("cannot unmarshal hardware mapping ID")

	// ErrIDParsing indicates an error while parsing a hardware mapping ID.
	ErrIDParsing = func(hmID string) error {
		return function.NewFuncError(fmt.Sprintf("%q is not a valid hardware mapping ID", hmID))
	}

	// ErrDeviceIDMarshal indicates an error while marshalling a hardware mapping device ID.
	ErrDeviceIDMarshal = function.NewFuncError("cannot marshal hardware mapping device ID")

	// ErrDeviceIDParsing indicates an error while parsing a hardware mapping device ID.
	ErrDeviceIDParsing = func(hmID string) error {
		return function.NewFuncError(
			fmt.Sprintf(
				"invalid value %q for hardware mapping device ID attribute %q: no match for regular expression %q",
				hmID,
				attrNameDeviceID,
				DeviceIDAttrValueRegEx.String(),
			),
		)
	}

	// ErrDeviceIDUnmarshal indicates an error while unmarshalling a hardware mapping device ID.
	ErrDeviceIDUnmarshal = function.NewFuncError("cannot unmarshal hardware mapping device ID")

	// ErrMapMarshal indicates an error while marshalling a hardware mapping.
	ErrMapMarshal = function.NewFuncError("cannot marshal hardware mapping")

	// ErrMapParsingFormat indicates an error the format of a hardware mapping while parsing.
	ErrMapParsingFormat = func(format string, attrs ...any) error {
		return function.NewFuncError(fmt.Sprintf(format, attrs...))
	}

	// ErrMapUnknownAttribute indicates an unknown hardware mapping attribute.
	ErrMapUnknownAttribute = func(attr string) error {
		return function.NewFuncError(fmt.Sprintf("unknown hardware mapping attribute %q", attr))
	}

	// ErrMapUnmarshal indicates an error while unmarshalling a hardware mapping.
	ErrMapUnmarshal = function.NewFuncError("cannot unmarshal hardware mapping")

	// ErrTypeIllegal indicates an error for an illegal hardware mapping type.
	ErrTypeIllegal = func(hmTypeName string) error {
		return function.NewFuncError(fmt.Sprintf("illegal hardware mapping type %q", hmTypeName))
	}

	// ErrTypeMarshal indicates an error while marshalling a hardware mapping type.
	ErrTypeMarshal = function.NewFuncError("cannot marshal hardware mapping type")

	// ErrTypeUnmarshal indicates an error while unmarshalling a hardware mapping type.
	ErrTypeUnmarshal = function.NewFuncError("cannot unmarshal hardware mapping type")
)
`````

## File: proxmox/types/hardwaremapping/id.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package hardwaremapping

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// ID represents a hardware mapping ID, composed of the type and identifier.
type ID struct {
	// Name is the name of the hardware mapping.
	Name string

	// Type is the type of the hardware mapping.
	Type Type
}

// Ensure the hardware mapping ID type implements required interfaces.
var (
	_ fmt.Stringer     = &ID{}
	_ json.Marshaler   = &ID{}
	_ json.Unmarshaler = &ID{}
	_ query.Encoder    = &ID{}
)

// EncodeValues encodes a hardware mapping ID field into a URL-encoded set of values.
func (hmid ID) EncodeValues(key string, v *url.Values) error {
	v.Add(key, hmid.String())
	return nil
}

// MarshalJSON marshals a hardware mapping ID into JSON value.
func (hmid ID) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(hmid.String())
	if err != nil {
		return nil, errors.Join(ErrIDMarshal, err)
	}

	return bytes, nil
}

// String converts an ID value into a string.
func (hmid ID) String() string {
	return fmt.Sprintf("%s:%s", hmid.Type, hmid.Name)
}

// ToValue converts a hardware mapping ID into a Terraform value.
func (hmid ID) ToValue() types.String {
	return types.StringValue(hmid.String())
}

// UnmarshalJSON unmarshals a hardware mapping ID.
func (hmid *ID) UnmarshalJSON(b []byte) error {
	var hmIDString string

	err := json.Unmarshal(b, &hmIDString)
	if err != nil {
		return errors.Join(ErrTypeUnmarshal, err)
	}

	hmID, err := ParseID(hmIDString)
	if err == nil {
		*hmid = hmID
	}

	return err
}

// ParseID parses a string that represents a hardware mapping ID into a value of `ID`.
func ParseID(input string) (ID, error) {
	hmID := ID{}

	inParts := strings.SplitN(input, ":", 2)
	if len(inParts) < 2 {
		return hmID, ErrIDParsing(input)
	}

	hmType, err := ParseType(inParts[0])
	if err != nil {
		return hmID, errors.Join(fmt.Errorf("could not extract type from hardware mapping ID %q", input), err)
	}

	hmID.Type = hmType
	hmID.Name = inParts[1]

	return hmID, nil
}
`````

## File: proxmox/types/hardwaremapping/map.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package hardwaremapping

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strconv"
	"strings"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

const (
	// attrCountMax is the maximum number of attributes for a hardware mapping where only TypePCI can reach
	// this limit.
	attrCountMax = 6

	// attrNameIOMMUGroup is the attribute key name of the IOMMU group in a hardware mapping.
	attrNameIOMMUGroup = "iommugroup"

	// attrNameNode is the attribute key name of the node in a hardware mapping.
	attrNameNode = "node"

	// attrNameNode is the attribute key name of the path in a hardware mapping.
	attrNamePath = "path"

	// attrSeparator is the separator for the attributes in a hardware mapping PCI map.
	attrSeparator = ','

	// attrValueSeparator is the separator for the attribute key-value pairs in a hardware mapping.
	attrValueSeparator = '='

	// AttrNameDescription is the attribute key name of the description in a hardware mapping.
	// The Proxmox VE API attribute is named "description" while we name it "comment" internally since this naming is
	// generally used across the Proxmox VE web UI and API documentations. This still follows the
	// [Terraform "best practices"] as it improves the user experience by matching the field name to the naming used in
	// the human-facing interfaces.
	//
	// [Terraform "best practices"]: https://developer.hashicorp.com/terraform/plugin/best-practices/hashicorp-provider-design-principles#resource-and-attribute-schema-should-closely-match-the-underlying-api
	AttrNameDescription = "description"
)

// Ensure the hardware mapping type implements required interfaces.
var (
	_ fmt.Stringer     = &Map{}
	_ json.Marshaler   = &Map{}
	_ json.Unmarshaler = &Map{}
	_ query.Encoder    = &Map{}
)

// Map represents a hardware mapping composed of multiple attributes.
type Map struct {
	// Description is the optional "description" for a hardware mapping for both TypePCI and TypeUSB.
	Description *string

	// Description is the required "ID" for a hardware mapping for both TypePCI and TypeUSB.
	ID DeviceID

	// IOMMUGroup is the optional "IOMMU group" for a hardware mapping for TypePCI.
	// The value is not mandatory for the Proxmox VE API, but causes a TypePCI to be incomplete when not set.
	// It is not used for TypeUSB.
	//
	// Using a pointer is required to prevent the default value of 0 to be used as a valid IOMMU group but differentiate
	// between and unset value instead.
	//
	// References:
	//   - [Proxmox VE Wiki ‚Äî PCI Passthrough]
	//   - [Linux Kernel Documentations ‚Äî VFIO - "Virtual Function I/O"]
	//   - [IOMMU DB]
	//
	// [Proxmox VE Wiki ‚Äî PCI Passthrough]: https://pve.proxmox.com/wiki/PCI_Passthrough
	// [Linux Kernel Documentations ‚Äî VFIO - "Virtual Function I/O"]: https://docs.kernel.org/driver-api/vfio.html
	// [IOMMU DB]: https://iommu.info
	IOMMUGroup *int64

	// Node is the required "node name" for a hardware mapping for both TypePCI and TypeUSB.
	Node string

	// Path is the "path" for a hardware mapping where this field is required for TypePCI but optional for
	// TypeUSB.
	Path *string

	// SubsystemID is the optional "subsystem ID" for a hardware mapping for TypePCI.
	// The value is not mandatory for the Proxmox VE API, but causes a TypePCI to be incomplete when not set.
	// It is not used for TypeUSB.
	SubsystemID DeviceID
}

// EncodeValues encodes a cluster mapping PCI map field into a URL-encoded set of values.
func (hm Map) EncodeValues(key string, v *url.Values) error {
	v.Add(key, hm.String())
	return nil
}

// MarshalJSON marshals a hardware mapping into JSON value.
func (hm Map) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(hm.String())
	if err != nil {
		return nil, errors.Join(ErrMapMarshal, err)
	}

	return bytes, nil
}

// String converts a Map value into a string.
func (hm Map) String() string {
	joinKV := func(k, v string) string {
		return fmt.Sprintf("%s%s%s", k, string(attrValueSeparator), v)
	}
	attrs := make([]string, 0, attrCountMax)

	// ID is optional for directory mappings
	if hm.ID != "" {
		attrs = append(attrs, joinKV(attrNameDeviceID, hm.ID.String()))
	}

	// Node is common among all mappings
	attrs = append(attrs, joinKV(attrNameNode, hm.Node))

	if hm.Path != nil {
		attrs = append(attrs, joinKV(attrNamePath, *hm.Path))
	}

	if hm.Description != nil {
		attrs = append(attrs, joinKV(AttrNameDescription, *hm.Description))
	}

	if hm.IOMMUGroup != nil {
		attrs = append(attrs, joinKV(attrNameIOMMUGroup, strconv.FormatInt(*hm.IOMMUGroup, 10)))
	}

	if hm.SubsystemID != "" {
		attrs = append(attrs, joinKV(attrNameSubsystemID, hm.SubsystemID.String()))
	}

	return strings.Join(attrs, string(attrSeparator))
}

// ToValue converts a hardware mapping into a Terraform value.
func (hm Map) ToValue() types.String {
	return types.StringValue(hm.String())
}

// UnmarshalJSON unmarshals a hardware mapping.
func (hm *Map) UnmarshalJSON(b []byte) error {
	var hmString string

	err := json.Unmarshal(b, &hmString)
	if err != nil {
		return errors.Join(ErrMapUnmarshal, err)
	}

	resType, err := ParseMap(hmString)
	if err == nil {
		*hm = resType
	}

	return err
}

// ParseMap parses a string that represents a hardware mapping into a Map.
func ParseMap(input string) (Map, error) {
	hm := Map{}
	// Scoped function to return an error when a regular expression for an attribute did not match.
	regExNotMatchErr := func(attr, attrName string, err error) error {
		return errors.Join(
			ErrMapParsingFormat(
				fmt.Sprintf(
					"invalid format %q for hardware mapping %q attribute",
					attr,
					attrName,
				),
			), err,
		)
	}

	// Split the full PCI map string into its attributes‚Ä¶
	attrs := strings.Split(input, string(attrSeparator))
	// ‚Ä¶and iterate over each attribute to parse it into the struct fields.
	for _, attr := range attrs {
		attrSplit := strings.Split(attr, string(attrValueSeparator))
		if len(attrSplit) != 2 {
			return hm, ErrMapParsingFormat(
				fmt.Sprintf(
					`invalid "key=value" format for hardware mapping attribute %q`,
					attr,
				),
			)
		}

		switch attrSplit[0] {
		case AttrNameDescription:
			hm.Description = &attrSplit[1]

		case attrNameDeviceID:
			id, err := ParseDeviceID(attrSplit[1])
			if err != nil {
				return hm, regExNotMatchErr(attrSplit[1], attrNameDeviceID, err)
			}

			hm.ID = id

		case attrNameNode:
			hm.Node = attrSplit[1]

		case attrNamePath:
			hm.Path = &attrSplit[1]

		case attrNameIOMMUGroup:
			iommuGroup, err := strconv.ParseInt(attrSplit[1], 10, 0)
			if err != nil {
				return hm, regExNotMatchErr(attrSplit[1], attrNameIOMMUGroup, err)
			}

			hm.IOMMUGroup = &iommuGroup

		case attrNameSubsystemID:
			subsystemID, err := ParseDeviceID(attrSplit[1])
			if err != nil {
				return hm, regExNotMatchErr(attrSplit[1], attrNameSubsystemID, err)
			}

			hm.SubsystemID = subsystemID

		default:
			return hm, ErrMapUnknownAttribute(attr)
		}
	}

	return hm, nil
}
`````

## File: proxmox/types/hardwaremapping/type.go
`````go
package hardwaremapping

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

//nolint:gochecknoglobals
var (
	// TypeDir is an identifier for a directory mapping type.
	// Do not modify this package-global variable as it acts as a safer variant compared to "iota" based constants!
	TypeDir = Type{"dir"}

	// TypePCI is an identifier for a PCI hardware mapping type.
	// Do not modify this package-global variable as it acts as a safer variant compared to "iota" based constants!
	TypePCI = Type{"pci"}

	// TypeUSB is an identifier for a USB hardware mapping type.
	// Do not modify this package-global variable as it acts as a safer variant compared to "iota" based constants!
	TypeUSB = Type{"usb"}
)

// Ensure the hardware mapping type supports required interfaces.
var (
	_ fmt.Stringer     = new(Type)
	_ json.Marshaler   = new(Type)
	_ json.Unmarshaler = new(Type)
	_ query.Encoder    = new(Type)
)

// Type is the type of the hardware mapping.
type Type struct {
	name string
}

// EncodeValues encodes a hardware mapping type field into a URL-encoded set of values.
func (t Type) EncodeValues(key string, v *url.Values) error {
	v.Add(key, t.String())
	return nil
}

// MarshalJSON marshals a hardware mapping type into JSON value.
func (t Type) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(t.String())
	if err != nil {
		return nil, errors.Join(ErrTypeMarshal, err)
	}

	return bytes, nil
}

// String converts a Type value into a string.
func (t Type) String() string {
	return t.name
}

// ToValue converts a hardware mapping type into a Terraform value.
func (t Type) ToValue() types.String {
	return types.StringValue(t.String())
}

// UnmarshalJSON unmarshals a hardware mapping type.
func (t *Type) UnmarshalJSON(b []byte) error {
	var rtString string

	err := json.Unmarshal(b, &rtString)
	if err != nil {
		return errors.Join(ErrTypeUnmarshal, err)
	}

	resType, err := ParseType(rtString)
	if err == nil {
		*t = resType
	}

	return err
}

// ParseType converts the string representation of a hardware mapping type into the corresponding value.
// An error is returned if the input string does not match any known type.
func ParseType(input string) (Type, error) {
	switch input {
	case TypeDir.String():
		return TypeDir, nil
	case TypePCI.String():
		return TypePCI, nil
	case TypeUSB.String():
		return TypeUSB, nil
	default:
		return Type{}, ErrTypeIllegal(input)
	}
}
`````

## File: proxmox/types/nodes/apt/repositories/ceph_version_name.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package repositories

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

const (
	// CephStandardRepoHandlePrefix is the prefix for Ceph APT standard repositories.
	CephStandardRepoHandlePrefix = "ceph"
)

// Do not modify any of these package-global variables as they act as safer variants compared to "iota" based constants!
//
//nolint:gochecknoglobals
var (
	// CephVersionNameQuincy is the name for the "Quincy" Ceph major version.
	CephVersionNameQuincy = CephVersionName{"quincy"}

	// CephVersionNameReef is the name for the "Reef" Ceph major version.
	CephVersionNameReef = CephVersionName{"reef"}

	// CephVersionNameUnknown is the name for an unknown Ceph major version.
	CephVersionNameUnknown = CephVersionName{"unknown"}
)

// Ensure the hardware mapping type supports required interfaces.
var (
	_ fmt.Stringer     = new(CephVersionName)
	_ json.Marshaler   = new(CephVersionName)
	_ json.Unmarshaler = new(CephVersionName)
	_ query.Encoder    = new(CephVersionName)
)

// CephVersionName is the name a Ceph major version.
type CephVersionName struct {
	name string
}

// EncodeValues encodes Ceph major version name field into a URL-encoded set of values.
func (n CephVersionName) EncodeValues(key string, v *url.Values) error {
	v.Add(key, n.String())
	return nil
}

// MarshalJSON marshals a Ceph major version name into JSON value.
func (n CephVersionName) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(n.String())
	if err != nil {
		return nil, errors.Join(ErrCephVersionNameMarshal, err)
	}

	return bytes, nil
}

// String converts a CephVersionName value into a string.
func (n CephVersionName) String() string {
	return n.name
}

// ToValue converts a Ceph major version name into a Terraform value.
func (n CephVersionName) ToValue() types.String {
	return types.StringValue(n.String())
}

// UnmarshalJSON unmarshals a Ceph major version name.
func (n *CephVersionName) UnmarshalJSON(b []byte) error {
	var rtString string

	err := json.Unmarshal(b, &rtString)
	if err != nil {
		return errors.Join(ErrCephVersionNameUnmarshal, err)
	}

	resType, err := ParseCephVersionName(rtString)
	if err == nil {
		*n = resType
	}

	return err
}

// ParseCephVersionName converts the string representation of a Ceph major version name into the corresponding value.
// An error is returned if the input string does not match any known type.
func ParseCephVersionName(input string) (CephVersionName, error) {
	switch input {
	case CephVersionNameQuincy.String():
		return CephVersionNameQuincy, nil
	case CephVersionNameReef.String():
		return CephVersionNameReef, nil
	default:
		return CephVersionName{}, ErrCephVersionNameIllegal(input)
	}
}
`````

## File: proxmox/types/nodes/apt/repositories/errors.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package repositories

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/function"
)

//nolint:gochecknoglobals
var (
	// ErrCephVersionNameIllegal indicates an error for an illegal Ceph major version name.
	ErrCephVersionNameIllegal = func(name string) error {
		return function.NewFuncError(fmt.Sprintf("illegal Ceph major version name %q", name))
	}

	// ErrCephVersionNameMarshal indicates an error while marshalling a Ceph major version name.
	ErrCephVersionNameMarshal = function.NewFuncError("cannot marshal Ceph major version name")

	// ErrCephVersionNameUnmarshal indicates an error while unmarshalling a Ceph major version name.
	ErrCephVersionNameUnmarshal = function.NewFuncError("cannot unmarshal Ceph major version name")

	// ErrStandardRepoHandleKindIllegal indicates an error for an illegal APT standard repository handle.
	ErrStandardRepoHandleKindIllegal = func(handle string) error {
		return function.NewFuncError(fmt.Sprintf("illegal APT standard repository handle kind %q", handle))
	}

	// ErrStandardRepoHandleKindMarshal indicates an error while marshalling an APT standard repository handle kind.
	ErrStandardRepoHandleKindMarshal = function.NewFuncError("cannot marshal APT standard repository handle kind")

	// ErrStandardRepoHandleKindUnmarshal indicates an error while unmarshalling an APT standard repository handle kind.
	ErrStandardRepoHandleKindUnmarshal = function.NewFuncError("cannot unmarshal APT standard repository handle kind")
)
`````

## File: proxmox/types/nodes/apt/repositories/standard_repo_file_path.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package repositories

// Note that "hard-coded" slashes are used since Proxmox VE is built on top of Linux (Debian).
const (
	// StandardRepoFilePathCeph is the default Proxmox VE pre-defined (absolute) file path for the APT source list of Ceph
	// repositories.
	StandardRepoFilePathCeph = "/etc/apt/sources.list.d/ceph.list"

	// StandardRepoFilePathEnterprise is the default Proxmox VE pre-defined (absolute) file path for the APT source list
	// of enterprise repositories.
	StandardRepoFilePathEnterprise = "/etc/apt/sources.list.d/pve-enterprise.list"

	// StandardRepoFilePathMain is the default Proxmox VE pre-defined (absolute) file path for the APT source list of main
	// OS (Debian) repositories.
	StandardRepoFilePathMain = "/etc/apt/sources.list"
)
`````

## File: proxmox/types/nodes/apt/repositories/standard_repo_handle_kind.go
`````go
/*
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

package repositories

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Do not modify any of these package-global variables as they act as safer variants compared to "iota" based constants!
//
//nolint:gochecknoglobals
var (
	// StandardRepoHandleKindEnterprise is the name for the "Enterprise" APT standard repository handle kind.
	StandardRepoHandleKindEnterprise = StandardRepoHandleKind{"enterprise"}

	// StandardRepoHandleKindNoSubscription is the name for the "No Subscription" APT standard repository handle kind.
	StandardRepoHandleKindNoSubscription = StandardRepoHandleKind{"no-subscription"}

	// StandardRepoHandleKindTest is the name for the "Test" APT standard repository handle kind.
	StandardRepoHandleKindTest = StandardRepoHandleKind{"test"}

	// StandardRepoHandleKindUnknown is the name for an unknown APT standard repository handle kind.
	StandardRepoHandleKindUnknown = StandardRepoHandleKind{"unknown"}
)

// Ensure the hardware mapping type supports required interfaces.
var (
	_ fmt.Stringer     = new(StandardRepoHandleKind)
	_ json.Marshaler   = new(StandardRepoHandleKind)
	_ json.Unmarshaler = new(StandardRepoHandleKind)
	_ query.Encoder    = new(StandardRepoHandleKind)
)

// StandardRepoHandleKind is the kind of APT standard repository handle.
type StandardRepoHandleKind struct {
	handle string
}

// EncodeValues encodes the APT standard repository handle kind field into a URL-encoded set of values.
func (h *StandardRepoHandleKind) EncodeValues(key string, v *url.Values) error {
	v.Add(key, h.String())
	return nil
}

// MarshalJSON marshals an APT standard repository handle kind into JSON value.
func (h *StandardRepoHandleKind) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(h.String())
	if err != nil {
		return nil, errors.Join(ErrStandardRepoHandleKindMarshal, err)
	}

	return bytes, nil
}

// String converts a StandardRepoHandleKind value into a string.
func (h StandardRepoHandleKind) String() string {
	return h.handle
}

// ToValue converts an APT standard repository handle kind into a Terraform value.
func (h *StandardRepoHandleKind) ToValue() types.String {
	return types.StringValue(h.String())
}

// UnmarshalJSON unmarshals an APT standard repository handle kind.
func (h *StandardRepoHandleKind) UnmarshalJSON(b []byte) error {
	var rtString string

	err := json.Unmarshal(b, &rtString)
	if err != nil {
		return errors.Join(ErrStandardRepoHandleKindUnmarshal, err)
	}

	resType, err := ParseStandardRepoHandleKind(rtString)
	if err == nil {
		*h = resType
	}

	return err
}

// ParseStandardRepoHandleKind converts the string representation of an APT standard repository handle kind into the
// corresponding type.
// StandardRepoHandleKindUnknown and an error is returned if the input string does not match any known handle kind.
func ParseStandardRepoHandleKind(input string) (StandardRepoHandleKind, error) {
	switch input {
	case StandardRepoHandleKindEnterprise.String():
		return StandardRepoHandleKindEnterprise, nil
	case StandardRepoHandleKindNoSubscription.String():
		return StandardRepoHandleKindNoSubscription, nil
	case StandardRepoHandleKindTest.String():
		return StandardRepoHandleKindTest, nil
	}

	return StandardRepoHandleKindUnknown, fmt.Errorf(
		"parse APT standard repository handle kind: %w",
		ErrStandardRepoHandleKindIllegal(input),
	)
}
`````

## File: proxmox/types/common_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
)

// CustomBool allows a JSON boolean value to also be an integer.
type CustomBool bool

// CustomCommaSeparatedList allows a JSON string to also be a string array.
type CustomCommaSeparatedList []string

// CustomFloat64 allows a JSON float64 value to also be a string.
type CustomFloat64 float64

// CustomInt allows a JSON integer value to also be a string.
type CustomInt int

// CustomInt64 allows a JSON int64 value to also be a string.
type CustomInt64 int64

// CustomLineBreakSeparatedList allows a multiline JSON string to also be a string array.
type CustomLineBreakSeparatedList []string

// CustomPrivileges allows a JSON object of privileges to also be a string array.
type CustomPrivileges []string

// CustomTimestamp allows a JSON boolean value to also be a unix timestamp.
type CustomTimestamp time.Time

// CustomBoolPtr creates a pointer to a CustomBool.
func CustomBoolPtr(b *bool) *CustomBool {
	if b == nil {
		return nil
	}

	return ptr.Ptr(CustomBool(*b))
}

// MarshalJSON converts a boolean to a JSON value.
func (r CustomBool) MarshalJSON() ([]byte, error) {
	buffer := new(bytes.Buffer)

	if r {
		buffer.WriteString("1")
	} else {
		buffer.WriteString("0")
	}

	return buffer.Bytes(), nil
}

// UnmarshalJSON converts a JSON value to a boolean.
func (r *CustomBool) UnmarshalJSON(b []byte) error {
	s := string(b)
	*r = s == "1" || s == "true"

	return nil
}

// Pointer returns a pointers.
func (r CustomBool) Pointer() *CustomBool {
	return &r
}

// PointerBool returns a pointer to a boolean.
func (r *CustomBool) PointerBool() *bool {
	return (*bool)(r)
}

// ToValue returns a Terraform attribute value.
func (r CustomBool) ToValue() types.Bool {
	return types.BoolValue(bool(r))
}

// FromValue sets the numeric boolean based on the value of a Terraform attribute.
func (r *CustomBool) FromValue(tfValue types.Bool) {
	*r = CustomBool(tfValue.ValueBool())
}

// MarshalJSON converts a boolean to a JSON value.
func (r *CustomCommaSeparatedList) MarshalJSON() ([]byte, error) {
	s := strings.Join(*r, ",")

	return json.Marshal(s)
}

// UnmarshalJSON converts a JSON value to a boolean.
func (r *CustomCommaSeparatedList) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}

	*r = strings.Split(s, ",")

	return nil
}

// UnmarshalJSON converts a JSON value to a float64 value.
func (r *CustomFloat64) UnmarshalJSON(b []byte) error {
	s := string(b)

	if strings.HasPrefix(s, "\"") && strings.HasSuffix(s, "\"") {
		s = s[1 : len(s)-1]
	}

	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return fmt.Errorf("cannot parse float64 %q: %w", s, err)
	}

	*r = CustomFloat64(f)

	return nil
}

// PointerFloat64 returns a pointer to a float64.
func (r *CustomFloat64) PointerFloat64() *float64 {
	return (*float64)(r)
}

// UnmarshalJSON converts a JSON value to an integer.
func (r *CustomInt) UnmarshalJSON(b []byte) error {
	s := string(b)

	if strings.HasPrefix(s, "\"") && strings.HasSuffix(s, "\"") {
		s = s[1 : len(s)-1]
	}

	i, err := strconv.ParseInt(s, 10, 32)
	if err != nil {
		return fmt.Errorf("cannot parse int %q: %w", s, err)
	}

	*r = CustomInt(i)

	return nil
}

// UnmarshalJSON converts a JSON value to an integer.
func (r *CustomInt64) UnmarshalJSON(b []byte) error {
	s := string(b)

	if strings.HasPrefix(s, "\"") && strings.HasSuffix(s, "\"") {
		s = s[1 : len(s)-1]
	}

	i, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return fmt.Errorf("cannot parse int64 %q: %w", s, err)
	}

	*r = CustomInt64(i)

	return nil
}

// PointerInt64 returns a pointer to an int64.
func (r *CustomInt64) PointerInt64() *int64 {
	return (*int64)(r)
}

// MarshalJSON converts a boolean to a JSON value.
func (r *CustomLineBreakSeparatedList) MarshalJSON() ([]byte, error) {
	s := strings.Join(*r, "\n")

	return json.Marshal(s)
}

// UnmarshalJSON converts a JSON value to a boolean.
func (r *CustomLineBreakSeparatedList) UnmarshalJSON(b []byte) error {
	var s string

	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}

	*r = strings.Split(s, "\n")

	return nil
}

// MarshalJSON converts a boolean to a JSON value.
func (r *CustomPrivileges) MarshalJSON() ([]byte, error) {
	privileges := map[string]CustomBool{}

	for _, v := range *r {
		privileges[v] = true
	}

	return json.Marshal(privileges)
}

// UnmarshalJSON converts a JSON value to a boolean.
func (r *CustomPrivileges) UnmarshalJSON(b []byte) error {
	var privileges interface{}

	err := json.Unmarshal(b, &privileges)
	if err != nil {
		return err
	}

	switch s := privileges.(type) {
	case string:
		if s != "" {
			*r = strings.Split(s, ",")
		} else {
			*r = CustomPrivileges{}
		}
	default:
		*r = CustomPrivileges{}

		for k, v := range privileges.(map[string]interface{}) {
			if v.(float64) >= 1 {
				*r = append(*r, k)
			}
		}
	}

	return nil
}

// MarshalJSON converts a timestamp to a JSON value.
func (r CustomTimestamp) MarshalJSON() ([]byte, error) {
	timestamp := time.Time(r)
	buffer := bytes.NewBufferString(strconv.FormatInt(timestamp.Unix(), 10))

	return buffer.Bytes(), nil
}

// UnmarshalJSON converts a JSON value to a timestamp.
func (r *CustomTimestamp) UnmarshalJSON(b []byte) error {
	s := string(b)
	i, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return err
	}

	*r = CustomTimestamp(time.Unix(i, 0).UTC())

	return nil
}
`````

## File: proxmox/types/disk_size_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestParseDiskSize(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		size    string
		want    int64
		wantErr bool
	}{
		{"parse TB", "2TB", 2199023255552, false},
		{"parse T", "2T", 2199023255552, false},
		{"parse fraction T", "2.2T", 2418925581108, false},
		{"parse GB", "2GB", 2147483648, false},
		{"parse G", "2G", 2147483648, false},
		{"parse M", "2048M", 2147483648, false},
		{"parse MB", "2048MB", 2147483648, false},
		{"parse MiB", "2048MiB", 2147483648, false},
		{"parse K", "1K", 1024, false},
		{"parse KB", "2KB", 2048, false},
		{"parse KiB", "4KiB", 4096, false},
		{"parse no units as bytes", "12345", 12345, false},
		{"error on bad format string", "20l8G", -1, true},
		{"error on unknown unit string", "2048W", -1, true},
		{"error on arbitrary string", "something", -1, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := ParseDiskSize(tt.size)

			if (err != nil) != tt.wantErr {
				t.Errorf("parseDiskSize() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if int64(got) != tt.want {
				t.Errorf("parseDiskSize() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFormatDiskSize(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		size int64
		want string
	}{
		{"handle 0 size", 0, "0"},
		{"handle bytes", 1001, "1001"},
		{"handle kilobytes", 1234, "1.21K"},
		{"handle megabytes", 2097152, "2M"},
		{"handle gigabytes", 2147483648, "2G"},
		{"handle terabytes", 2199023255552, "2T"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			size := DiskSize(tt.size)

			if got := FormatDiskSize(&size); got != tt.want {
				t.Errorf("formatDiskSize() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestToFromGigabytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		size int64
		want string
	}{
		{"handle 0 size", 0, "0"},
		{"handle 99 GB", 99, "99G"},
		{"handle 100 GB", 100, "100G"},
		{"handle 101 GB", 101, "101G"},
		{"handle 1023 GB", 1023, "1023G"},
		{"handle 1024 GB", 1024, "1T"},
		{"handle 1025 GB", 1025, "1.01T"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			ds := DiskSizeFromGigabytes(tt.size)

			gb := ds.InGigabytes()
			assert.Equal(t, tt.size, gb)

			if got := ds.String(); got != tt.want {
				t.Errorf("DiskSize.String() = %v, want %v", got, tt.want)
			}
		})
	}
}
`````

## File: proxmox/types/disk_size.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"encoding/json"
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"
)

// Regex used to identify size strings. Case-insensitive. Covers megabytes, gigabytes and terabytes.
var sizeRegex = regexp.MustCompile(`(?i)^(\d+(\.\d+)?)(k|kb|kib|m|mb|mib|g|gb|gib|t|tb|tib)?$`)

// DiskSize allows a JSON integer value to also be a string. This is mapped to `<DiskSize>` data type in Proxmox API.
// Represents a disk size in bytes.
type DiskSize int64

// String returns the string representation of the disk size.
func (r *DiskSize) String() string {
	return FormatDiskSize(r)
}

// InMegabytes returns the disk size in megabytes.
func (r *DiskSize) InMegabytes() int64 {
	if r == nil {
		return 0
	}

	return int64(*r) / 1024 / 1024
}

// InGigabytes returns the disk size in gigabytes.
func (r *DiskSize) InGigabytes() int64 {
	if r == nil {
		return 0
	}

	return int64(*r) / 1024 / 1024 / 1024
}

// DiskSizeFromGigabytes creates a DiskSize from gigabytes.
func DiskSizeFromGigabytes(size int64) *DiskSize {
	ds := DiskSize(size * 1024 * 1024 * 1024)

	return &ds
}

// MarshalJSON marshals a disk size into a Proxmox API `<DiskSize>` string.
func (r *DiskSize) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(FormatDiskSize(r))
	if err != nil {
		return nil, fmt.Errorf("cannot marshal disk size: %w", err)
	}

	return bytes, nil
}

// UnmarshalJSON unmarshals a disk size from a Proxmox API `<DiskSize>` string.
func (r *DiskSize) UnmarshalJSON(b []byte) error {
	s := string(b)

	size, err := ParseDiskSize(s)
	if err != nil {
		return err
	}

	*r = size

	return nil
}

// ParseDiskSize parses a disk size string into a number of bytes.
func ParseDiskSize(size string) (DiskSize, error) {
	matches := sizeRegex.FindStringSubmatch(size)
	if len(matches) > 0 {
		fSize, err := strconv.ParseFloat(matches[1], 64)
		if err != nil {
			return -1, fmt.Errorf("cannot parse disk size \"%s\": %w", size, err)
		}

		switch strings.ToLower(matches[3]) {
		case "k", "kb", "kib":
			fSize *= 1024
		case "m", "mb", "mib":
			fSize = fSize * 1024 * 1024
		case "g", "gb", "gib":
			fSize = fSize * 1024 * 1024 * 1024
		case "t", "tb", "tib":
			fSize = fSize * 1024 * 1024 * 1024 * 1024
		}

		return DiskSize(math.Ceil(fSize)), nil
	}

	return -1, fmt.Errorf("cannot parse disk size \"%s\"", size)
}

// FormatDiskSize turns a number of bytes into a disk size string.
func FormatDiskSize(size *DiskSize) string {
	if size == nil || *size < 0 {
		return ""
	}

	if *size < 1024 {
		return fmt.Sprintf("%d", *size)
	}

	round := func(f float64) string {
		return strconv.FormatFloat(math.Ceil(f*100)/100, 'f', -1, 64)
	}

	if *size < 1024*1024 {
		return round(float64(*size)/1024) + "K"
	}

	if *size < 1024*1024*1024 {
		return round(float64(*size)/1024/1024) + "M"
	}

	if *size < 1024*1024*1024*1024 {
		return round(float64(*size)/1024/1024/1024) + "G"
	}

	return round(float64(*size)/1024/1024/1024/1024) + "T"
}
`````

## File: proxmox/types/ha_resource_id_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"bytes"
	"encoding/json"
	"testing"
)

func TestParseHAResourceID(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		input   string
		want    HAResourceID
		wantErr bool
	}{
		{"VM value", "vm:123", HAResourceID{HAResourceTypeVM, "123"}, false},
		{"container value", "ct:123", HAResourceID{HAResourceTypeContainer, "123"}, false},
		{"no semicolon", "ct", HAResourceID{}, true},
		{"invalid type", "blah:123", HAResourceID{}, true},
		{"invalid VM name", "vm:moo", HAResourceID{}, true},
		{"invalid container name", "ct:moo", HAResourceID{}, true},
		{"VM name too low", "vm:99", HAResourceID{}, true},
		{"VM name too high", "vm:1000000000", HAResourceID{}, true},
		{"container name too low", "ct:99", HAResourceID{}, true},
		{"container name too high", "ct:1000000000", HAResourceID{}, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := ParseHAResourceID(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseHAResourceID() error = %v, wantErr %v", err, tt.wantErr)
			}

			if got != tt.want {
				t.Errorf("ParseHAResourceID() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceIDToString(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		state HAResourceID
		want  string
	}{
		{"stringify VM", HAResourceID{HAResourceTypeVM, "123"}, "vm:123"},
		{"stringify CT", HAResourceID{HAResourceTypeContainer, "123"}, "ct:123"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if got := tt.state.String(); got != tt.want {
				t.Errorf("HAResourceID.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceIDToJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		state HAResourceID
		want  string
	}{
		{"jsonify VM", HAResourceID{HAResourceTypeVM, "123"}, `"vm:123"`},
		{"jsonify CT", HAResourceID{HAResourceTypeContainer, "123"}, `"ct:123"`},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := json.Marshal(tt.state)
			if err != nil {
				t.Errorf("json.Marshal(HAResourceID): err = %v", err)
			} else if !bytes.Equal(got, []byte(tt.want)) {
				t.Errorf("json.Marshal(HAResourceID) = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceIDFromJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		json    string
		want    HAResourceID
		wantErr bool
	}{
		{"VM", `"vm:123"`, HAResourceID{HAResourceTypeVM, "123"}, false},
		{"container", `"ct:123"`, HAResourceID{HAResourceTypeContainer, "123"}, false},
		{"invalid JSON", `\\/yo`, HAResourceID{}, true},
		{"incompatible type", `["yo"]`, HAResourceID{}, true},
		{"invalid content", `"nope:notatall"`, HAResourceID{}, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var got HAResourceID

			err := json.Unmarshal([]byte(tt.json), &got)
			if (err != nil) != tt.wantErr {
				t.Errorf("json.Unmarshal(HAResourceID) error = %v, wantErr %v", err, tt.wantErr)
			}

			if got != tt.want {
				t.Errorf("json.Unmarshal(HAResourceID) got = %v, want %v", got, tt.want)
			}
		})
	}
}
`````

## File: proxmox/types/ha_resource_id.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// NOTE: the linter believes the `HAResourceID` structure below should be tagged with `json:` due to some values of it
// being passed to a JSON marshaler in the tests. As far as I can tell this is unnecessary, so I'm silencing the lint.

// HAResourceID represents a HA resource identifier, composed of a resource type and identifier.
type HAResourceID struct {
	Type HAResourceType // The type of this HA resource.
	Name string         // The name of the element the HA resource refers to.
}

// Ensure the HA resource identifier type implements various interfaces.
var (
	_ fmt.Stringer     = &HAResourceID{}
	_ json.Marshaler   = &HAResourceID{}
	_ json.Unmarshaler = &HAResourceID{}
	_ query.Encoder    = &HAResourceID{}
)

// ParseHAResourceID parses a string that represents a HA resource identifier into a value of `HAResourceID`.
func ParseHAResourceID(input string) (HAResourceID, error) {
	resID := HAResourceID{}

	inParts := strings.SplitN(input, ":", 2)
	if len(inParts) < 2 {
		return resID, fmt.Errorf("'%s' is not a valid HA resource identifier", input)
	}

	resType, err := ParseHAResourceType(inParts[0])
	if err != nil {
		return resID, fmt.Errorf("could not extract type from HA resource identifier '%s': %w", input, err)
	}

	// For types VM and Container, we know the resource "name" should be a valid integer between 100
	// and 999_999_999.
	if resType == HAResourceTypeVM || resType == HAResourceTypeContainer {
		id, err := strconv.Atoi(inParts[1])
		if err != nil {
			return resID, fmt.Errorf("invalid %s HA resource name '%s': %w", resType, inParts[1], err)
		}

		if id < 100 {
			return resID, fmt.Errorf("invalid %s HA resource name '%s': minimum value is 100", resType, inParts[1])
		}

		if id > 999_999_999 {
			return resID, fmt.Errorf("invalid %s HA resource name '%s': maximum value is 999999999", resType, inParts[1])
		}
	}

	resID.Type = resType
	resID.Name = inParts[1]

	return resID, nil
}

// String converts a HAResourceID value into a string.
func (rid HAResourceID) String() string {
	return fmt.Sprintf("%s:%s", rid.Type, rid.Name)
}

// MarshalJSON marshals a HA resource identifier into JSON value.
func (rid HAResourceID) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(rid.String())
	if err != nil {
		return nil, fmt.Errorf("cannot marshal HA resource identifier: %w", err)
	}

	return bytes, nil
}

// UnmarshalJSON unmarshals a Proxmox HA resource identifier.
func (rid *HAResourceID) UnmarshalJSON(b []byte) error {
	var ridString string

	err := json.Unmarshal(b, &ridString)
	if err != nil {
		return fmt.Errorf("cannot unmarshal HA resource type: %w", err)
	}

	resType, err := ParseHAResourceID(ridString)
	if err == nil {
		*rid = resType
	}

	return err
}

// EncodeValues encodes a HA resource ID field into an URL-encoded set of values.
func (rid HAResourceID) EncodeValues(key string, v *url.Values) error {
	v.Add(key, rid.String())
	return nil
}

// ToValue converts a HA resource ID into a Terraform value.
func (rid HAResourceID) ToValue() types.String {
	return types.StringValue(rid.String())
}
`````

## File: proxmox/types/ha_resource_state_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"bytes"
	"encoding/json"
	"testing"
)

func TestParseHAResourceState(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		input   string
		want    HAResourceState
		wantErr bool
	}{
		{"valid value started", "started", HAResourceStateStarted, false},
		{"valid value enabled", "enabled", HAResourceStateStarted, false},
		{"valid value stopped", "stopped", HAResourceStateStopped, false},
		{"valid value disabled", "disabled", HAResourceStateDisabled, false},
		{"valid value ignored", "ignored", HAResourceStateIgnored, false},
		{"empty value", "", HAResourceStateIgnored, true},
		{"invalid value", "blah", HAResourceStateIgnored, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := ParseHAResourceState(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseHAResourceState() error = %v, wantErr %v", err, tt.wantErr)
			}

			if got != tt.want {
				t.Errorf("ParseHAResourceState() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceStateToString(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		state HAResourceState
		want  string
	}{
		{"stringify started", HAResourceStateStarted, "started"},
		{"stringify stopped", HAResourceStateStopped, "stopped"},
		{"stringify disabled", HAResourceStateDisabled, "disabled"},
		{"stringify ignored", HAResourceStateIgnored, "ignored"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if got := tt.state.String(); got != tt.want {
				t.Errorf("HAResourceState.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceStateToJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		state HAResourceState
		want  string
	}{
		{"jsonify started", HAResourceStateStarted, `"started"`},
		{"jsonify stopped", HAResourceStateStopped, `"stopped"`},
		{"jsonify disabled", HAResourceStateDisabled, `"disabled"`},
		{"jsonify ignored", HAResourceStateIgnored, `"ignored"`},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := json.Marshal(tt.state)
			if err != nil {
				t.Errorf("json.Marshal(HAResourceState): err = %v", err)
			} else if !bytes.Equal(got, []byte(tt.want)) {
				t.Errorf("json.Marshal(HAResourceState) = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceStateFromJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		json    string
		want    HAResourceState
		wantErr bool
	}{
		{"started", `"started"`, HAResourceStateStarted, false},
		{"stopped", `"stopped"`, HAResourceStateStopped, false},
		{"disabled", `"disabled"`, HAResourceStateDisabled, false},
		{"ignored", `"ignored"`, HAResourceStateIgnored, false},
		{"invalid JSON", `\\/yo`, HAResourceStateIgnored, true},
		{"incompatible type", `["yo"]`, HAResourceStateIgnored, true},
		{"invalid content", `"nope"`, HAResourceStateIgnored, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var got HAResourceState

			err := json.Unmarshal([]byte(tt.json), &got)
			if (err != nil) != tt.wantErr {
				t.Errorf("json.Unmarshal(HAResourceState) error = %v, wantErr %v", err, tt.wantErr)
			}

			if err == nil && got != tt.want {
				t.Errorf("json.Unmarshal(HAResourceState) got = %v, want %v", got, tt.want)
			}
		})
	}
}
`````

## File: proxmox/types/ha_resource_state.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"encoding/json"
	"fmt"
	"net/url"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// HAResourceState represents the requested state of a HA resource.
type HAResourceState int

// Ensure various interfaces are supported by the HA resource state type.
// NOTE: the global variable created here is only meant to be used in this block. There is, to my knowledge, no
// other way to enforce interface implementation at compile time unless the value is wrapped into a struct. Because
// of this, the linter is disabled.
var (
	//nolint:gochecknoglobals
	_haResourceStateValue HAResourceState
	_                     fmt.Stringer     = &_haResourceStateValue
	_                     json.Marshaler   = &_haResourceStateValue
	_                     json.Unmarshaler = &_haResourceStateValue
	_                     query.Encoder    = &_haResourceStateValue
)

const (
	// HAResourceStateStarted indicates that a HA resource should be started.
	HAResourceStateStarted HAResourceState = 0
	// HAResourceStateStopped indicates that a HA resource should be stopped, but that it should still be relocated
	// on node failure.
	HAResourceStateStopped HAResourceState = 1
	// HAResourceStateDisabled indicates that a HA resource should be stopped. No relocation should occur on node failure.
	HAResourceStateDisabled HAResourceState = 2
	// HAResourceStateIgnored indicates that a HA resource is not managed by the cluster resource manager. No relocation
	// or status change will occur.
	HAResourceStateIgnored HAResourceState = 3
)

// ParseHAResourceState converts the string representation of a HA resource state into the corresponding
// enum value. An error is returned if the input string does not match any known state. This function also
// parses the `enabled` value which is an alias for `started`.
func ParseHAResourceState(input string) (HAResourceState, error) {
	switch input {
	case "started":
		return HAResourceStateStarted, nil
	case "enabled":
		return HAResourceStateStarted, nil
	case "stopped":
		return HAResourceStateStopped, nil
	case "disabled":
		return HAResourceStateDisabled, nil
	case "ignored":
		return HAResourceStateIgnored, nil
	default:
		return HAResourceStateIgnored, fmt.Errorf("illegal HA resource state '%s'", input)
	}
}

// String converts a HAResourceState value into a string.
func (s HAResourceState) String() string {
	switch s {
	case HAResourceStateStarted:
		return "started"
	case HAResourceStateStopped:
		return "stopped"
	case HAResourceStateDisabled:
		return "disabled"
	case HAResourceStateIgnored:
		return "ignored"
	default:
		panic(fmt.Sprintf("unknown HA resource state value: %d", s))
	}
}

// MarshalJSON marshals a HA resource state into JSON value.
func (s HAResourceState) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(s.String())
	if err != nil {
		return nil, fmt.Errorf("cannot marshal HA resource state: %w", err)
	}

	return bytes, nil
}

// UnmarshalJSON unmarshals a Proxmox HA resource state.
func (s *HAResourceState) UnmarshalJSON(b []byte) error {
	var stateString string

	err := json.Unmarshal(b, &stateString)
	if err != nil {
		return fmt.Errorf("cannot unmarshal HA resource state: %w", err)
	}

	state, err := ParseHAResourceState(stateString)
	if err == nil {
		*s = state
	}

	return err
}

// EncodeValues encodes a HA resource state field into an URL-encoded set of values.
func (s HAResourceState) EncodeValues(key string, v *url.Values) error {
	v.Add(key, s.String())
	return nil
}

// ToValue converts a HA resource state into a Terraform value.
func (s HAResourceState) ToValue() types.String {
	return types.StringValue(s.String())
}
`````

## File: proxmox/types/ha_resource_type_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"bytes"
	"encoding/json"
	"testing"
)

func TestParseHAResourceType(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		input   string
		want    HAResourceType
		wantErr bool
	}{
		{"valid value vm", "vm", HAResourceTypeVM, false},
		{"valid value ct", "ct", HAResourceTypeContainer, false},
		{"empty value", "", _haResourceTypeValue, true},
		{"invalid value", "blah", _haResourceTypeValue, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := ParseHAResourceType(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseHAResourceType() error = %v, wantErr %v", err, tt.wantErr)
			}

			if got != tt.want {
				t.Errorf("ParseHAResourceType() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceTypeToString(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		resType HAResourceType
		want    string
	}{
		{"stringify vm", HAResourceTypeVM, "vm"},
		{"stringify ct", HAResourceTypeContainer, "ct"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			if got := tt.resType.String(); got != tt.want {
				t.Errorf("HAResourceType.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceTypeToJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		state HAResourceType
		want  string
	}{
		{"jsonify vm", HAResourceTypeVM, `"vm"`},
		{"jsonify container", HAResourceTypeContainer, `"ct"`},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := json.Marshal(tt.state)
			if err != nil {
				t.Errorf("json.Marshal(HAResourceType): err = %v", err)
			} else if !bytes.Equal(got, []byte(tt.want)) {
				t.Errorf("json.Marshal(HAResourceType) = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHAResourceTypeFromJSON(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		json    string
		want    HAResourceType
		wantErr bool
	}{
		{"started", `"vm"`, HAResourceTypeVM, false},
		{"container", `"ct"`, HAResourceTypeContainer, false},
		{"invalid JSON", `\\/yo`, HAResourceTypeVM, true},
		{"incompatible type", `["yo"]`, HAResourceTypeVM, true},
		{"invalid content", `"nope"`, HAResourceTypeVM, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var got HAResourceType

			err := json.Unmarshal([]byte(tt.json), &got)
			if (err != nil) != tt.wantErr {
				t.Errorf("json.Unmarshal(HAResourceType) error = %v, wantErr %v", err, tt.wantErr)
			}

			if err == nil && got != tt.want {
				t.Errorf("json.Unmarshal(HAResourceType) got = %v, want %v", got, tt.want)
			}
		})
	}
}
`````

## File: proxmox/types/ha_resource_type.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package types

import (
	"encoding/json"
	"fmt"
	"net/url"

	"github.com/google/go-querystring/query"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// HAResourceType represents the type of HA resource.
type HAResourceType int

// Ensure various interfaces are supported by the HA resource type type.
// NOTE: to my knowledge, this "global" here is required for the static type checks to work.
var (
	//nolint:gochecknoglobals
	_haResourceTypeValue HAResourceType
	_                    fmt.Stringer     = &_haResourceTypeValue
	_                    json.Marshaler   = &_haResourceTypeValue
	_                    json.Unmarshaler = &_haResourceTypeValue
	_                    query.Encoder    = &_haResourceTypeValue
)

const (
	// HAResourceTypeVM indicates that a HA resource refers to a virtual machine.
	HAResourceTypeVM HAResourceType = 0
	// HAResourceTypeContainer indicates that a HA resource refers to a container.
	HAResourceTypeContainer HAResourceType = 1
)

// ParseHAResourceType converts the string representation of a HA resource type into the corresponding
// enum value. An error is returned if the input string does not match any known type.
func ParseHAResourceType(input string) (HAResourceType, error) {
	switch input {
	case "vm":
		return HAResourceTypeVM, nil
	case "ct":
		return HAResourceTypeContainer, nil
	default:
		return _haResourceTypeValue, fmt.Errorf("illegal HA resource type '%s'", input)
	}
}

// String converts a HAResourceType value into a string.
func (t HAResourceType) String() string {
	switch t {
	case HAResourceTypeVM:
		return "vm"
	case HAResourceTypeContainer:
		return "ct"
	default:
		panic(fmt.Sprintf("unknown HA resource type value: %d", t))
	}
}

// MarshalJSON marshals a HA resource type into JSON value.
func (t HAResourceType) MarshalJSON() ([]byte, error) {
	bytes, err := json.Marshal(t.String())
	if err != nil {
		return nil, fmt.Errorf("cannot marshal HA resource type: %w", err)
	}

	return bytes, nil
}

// UnmarshalJSON unmarshals a Proxmox HA resource type.
func (t *HAResourceType) UnmarshalJSON(b []byte) error {
	var rtString string

	err := json.Unmarshal(b, &rtString)
	if err != nil {
		return fmt.Errorf("cannot unmarshal HA resource type: %w", err)
	}

	resType, err := ParseHAResourceType(rtString)
	if err == nil {
		*t = resType
	}

	return err
}

// EncodeValues encodes a HA resource type field into an URL-encoded set of values.
func (t HAResourceType) EncodeValues(key string, v *url.Values) error {
	v.Add(key, t.String())
	return nil
}

// ToValue converts a HA resource type into a Terraform value.
func (t HAResourceType) ToValue() types.String {
	return types.StringValue(t.String())
}
`````

## File: proxmox/version/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package version

import (
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Client is an interface for accessing the Proxmox version API.
type Client struct {
	api.Client
}
`````

## File: proxmox/version/version_types.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package version

// ResponseBody contains the body from a version response.
type ResponseBody struct {
	Data *ResponseData `json:"data,omitempty"`
}

// ResponseData contains the data from a version response.
type ResponseData struct {
	Console      string `json:"console"`
	Release      string `json:"release"`
	RepositoryID string `json:"repoid"`
	Version      string `json:"version"`
}
`````

## File: proxmox/version/version.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package version

import (
	"context"
	"fmt"
	"net/http"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
)

// Version retrieves the version information.
func (c *Client) Version(ctx context.Context) (*ResponseData, error) {
	resBody := &ResponseBody{}

	err := c.DoRequest(ctx, http.MethodGet, "version", nil, resBody)
	if err != nil {
		return nil, fmt.Errorf("failed to get version information: %w", err)
	}

	if resBody.Data == nil {
		return nil, api.ErrNoDataObjectInResponse
	}

	return resBody.Data, nil
}
`````

## File: proxmox/client.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package proxmox

import (
	"os"

	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmox/pools"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"
	"github.com/bpg/terraform-provider-proxmox/proxmox/storage"
	"github.com/bpg/terraform-provider-proxmox/proxmox/version"
)

// Client defines a client interface for the Proxmox Virtual Environment API.
type Client interface {
	// Access returns a client for managing access control.
	Access() *access.Client

	// Cluster returns a client for managing the cluster.
	Cluster() *cluster.Client

	// Node returns a client for managing resources on a specific node.
	Node(nodeName string) *nodes.Client

	// Pool returns a client for managing resource pools.
	Pool() *pools.Client

	// Storage returns a client for managing storage.
	Storage() *storage.Client

	// Version returns a client for getting the version of the Proxmox Virtual Environment API.
	Version() *version.Client

	// API returns a lower-level REST API client.
	API() api.Client

	// SSH returns a lower-level SSH client.
	SSH() ssh.Client

	// TempDir returns (possibly overridden) os.TempDir().
	TempDir() string
}

type client struct {
	apiClient      api.Client
	sshClient      ssh.Client
	tmpDirOverride string
}

// NewClient creates a new API client.
func NewClient(apiClient api.Client, sshClient ssh.Client, tmpDirOverride string) Client {
	return &client{apiClient: apiClient, sshClient: sshClient, tmpDirOverride: tmpDirOverride}
}

// Access returns a client for managing access control.
func (c *client) Access() *access.Client {
	return &access.Client{Client: c.apiClient}
}

// Cluster returns a client for managing the cluster.
func (c *client) Cluster() *cluster.Client {
	return &cluster.Client{Client: c.apiClient}
}

// Node returns a client for managing resources on a specific node.
func (c *client) Node(nodeName string) *nodes.Client {
	return &nodes.Client{Client: c.apiClient, NodeName: nodeName}
}

// Pool returns a client for managing resource pools.
func (c *client) Pool() *pools.Client {
	return &pools.Client{Client: c.apiClient}
}

// Storage returns a client for managing storage.
func (c *client) Storage() *storage.Client {
	return &storage.Client{Client: c.apiClient}
}

// Version returns a client for getting the version of the Proxmox Virtual Environment API.
func (c *client) Version() *version.Client {
	return &version.Client{Client: c.apiClient}
}

// API returns a lower-lever REST API client.
func (c *client) API() api.Client {
	return c.apiClient
}

// SSH returns a lower-lever SSH client.
func (c *client) SSH() ssh.Client {
	return c.sshClient
}

// TempDir returns (possibly overridden) os.TempDir().
func (c *client) TempDir() string {
	if c.tmpDirOverride != "" {
		return c.tmpDirOverride
	}

	return os.TempDir()
}
`````

## File: proxmoxtf/datasource/container_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestContainerInstantiation tests whether the Container instance can be instantiated.
func TestContainerInstantiation(t *testing.T) {
	t.Parallel()

	s := Container()

	if s == nil {
		t.Fatalf("Cannot instantiate Container")
	}
}

// TestContainerSchema tests the Container schema.
func TestContainerSchema(t *testing.T) {
	t.Parallel()

	s := Container().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentContainerName,
		mkDataSourceVirtualEnvironmentContainerTags,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentContainerName:     schema.TypeString,
		mkDataSourceVirtualEnvironmentContainerNodeName: schema.TypeString,
		mkDataSourceVirtualEnvironmentContainerTags:     schema.TypeList,
		mkDataSourceVirtualEnvironmentContainerTemplate: schema.TypeBool,
		mkDataSourceVirtualEnvironmentContainerStatus:   schema.TypeString,
		mkDataSourceVirtualEnvironmentContainerVMID:     schema.TypeInt,
	})
}
`````

## File: proxmoxtf/datasource/container.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

//nolint:dupl
package datasource

import (
	"context"
	"errors"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentContainerName     = "name"
	mkDataSourceVirtualEnvironmentContainerNodeName = "node_name"
	mkDataSourceVirtualEnvironmentContainerTags     = "tags"
	mkDataSourceVirtualEnvironmentContainerTemplate = "template"
	mkDataSourceVirtualEnvironmentContainerStatus   = "status"
	mkDataSourceVirtualEnvironmentContainerVMID     = "vm_id"
)

// Container returns a resource for a single Proxmox Container.
func Container() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentContainerName: {
				Type:        schema.TypeString,
				Description: "The Container name",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentContainerNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
			mkDataSourceVirtualEnvironmentContainerTags: {
				Type:        schema.TypeList,
				Description: "Tags of the Container",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentContainerTemplate: {
				Type:        schema.TypeBool,
				Description: "Is Container a template (true) or a regular Container (false)",
				Optional:    true,
			},
			mkDataSourceVirtualEnvironmentContainerStatus: {
				Type:        schema.TypeString,
				Description: "Status of the Container",
				Optional:    true,
			},
			mkDataSourceVirtualEnvironmentContainerVMID: {
				Type:        schema.TypeInt,
				Description: "The Container identifier",
				Required:    true,
			},
		},
		ReadContext: containerRead,
	}
}

// containerRead reads the data of a Container by ID.
func containerRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkDataSourceVirtualEnvironmentContainerNodeName).(string)
	containerID := d.Get(mkDataSourceVirtualEnvironmentContainerVMID).(int)

	containerStatus, err := client.Node(nodeName).Container(containerID).GetContainerStatus(ctx)
	if err != nil {
		if errors.Is(err, api.ErrNoDataObjectInResponse) {
			d.SetId("")

			return nil
		}

		return diag.FromErr(err)
	}

	containerConfig, err := client.Node(nodeName).Container(containerID).GetContainer(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if containerStatus.Name != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentContainerName, *containerStatus.Name)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentContainerName, "")
	}

	diags = append(diags, diag.FromErr(err)...)

	var tags []string

	if containerStatus.Tags != nil {
		for _, tag := range strings.Split(*containerStatus.Tags, ";") {
			t := strings.TrimSpace(tag)
			if len(t) > 0 {
				tags = append(tags, t)
			}
		}

		sort.Strings(tags)
	}

	err = d.Set(mkDataSourceVirtualEnvironmentContainerStatus, containerStatus.Status)
	diags = append(diags, diag.FromErr(err)...)

	if containerConfig.Template == nil {
		err = d.Set(mkDataSourceVirtualEnvironmentContainerTemplate, false)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentContainerTemplate, *containerConfig.Template)
	}

	diags = append(diags, diag.FromErr(err)...)

	err = d.Set(mkDataSourceVirtualEnvironmentContainerTags, tags)
	diags = append(diags, diag.FromErr(err)...)

	d.SetId(strconv.Itoa(containerID))

	return diags
}
`````

## File: proxmoxtf/datasource/dns_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestDNSInstantiation tests whether the DNS instance can be instantiated.
func TestDNSInstantiation(t *testing.T) {
	t.Parallel()

	s := DNS()
	if s == nil {
		t.Fatalf("Cannot instantiate DNS")
	}
}

// TestDNSSchema tests the DNS schema.
func TestDNSSchema(t *testing.T) {
	t.Parallel()

	s := DNS().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentDNSNodeName,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentDNSDomain,
		mkDataSourceVirtualEnvironmentDNSServers,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentDNSDomain:   schema.TypeString,
		mkDataSourceVirtualEnvironmentDNSNodeName: schema.TypeString,
		mkDataSourceVirtualEnvironmentDNSServers:  schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/dns.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentDNSDomain   = "domain"
	mkDataSourceVirtualEnvironmentDNSNodeName = "node_name"
	mkDataSourceVirtualEnvironmentDNSServers  = "servers"
)

// DNS returns a resource for DNS settings on a node.
func DNS() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentDNSDomain: {
				Type:        schema.TypeString,
				Description: "The DNS search domain",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentDNSNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
			mkDataSourceVirtualEnvironmentDNSServers: {
				Type:        schema.TypeList,
				Description: "The DNS servers",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		ReadContext: dnsRead,
	}
}

func dnsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkDataSourceVirtualEnvironmentDNSNodeName).(string)

	dns, err := api.Node(nodeName).GetDNS(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(fmt.Sprintf("%s_dns", nodeName))

	if dns.SearchDomain != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentDNSDomain, *dns.SearchDomain)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentDNSDomain, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	var servers []interface{}

	if dns.Server1 != nil {
		servers = append(servers, *dns.Server1)
	}

	if dns.Server2 != nil {
		servers = append(servers, *dns.Server2)
	}

	if dns.Server3 != nil {
		servers = append(servers, *dns.Server3)
	}

	err = d.Set(mkDataSourceVirtualEnvironmentDNSServers, servers)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/group_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestGroupInstantiation tests whether the Group instance can be instantiated.
func TestGroupInstantiation(t *testing.T) {
	t.Parallel()

	s := Group()
	if s == nil {
		t.Fatalf("Cannot instantiate Group")
	}
}

// TestGroupSchema tests the Group schema.
func TestGroupSchema(t *testing.T) {
	t.Parallel()

	s := Group().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentGroupID,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentGroupACL,
		mkDataSourceVirtualEnvironmentGroupComment,
		mkDataSourceVirtualEnvironmentGroupMembers,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentGroupACL:     schema.TypeSet,
		mkDataSourceVirtualEnvironmentGroupID:      schema.TypeString,
		mkDataSourceVirtualEnvironmentGroupComment: schema.TypeString,
		mkDataSourceVirtualEnvironmentGroupMembers: schema.TypeSet,
	})

	aclSchema := test.AssertNestedSchemaExistence(t, s, mkDataSourceVirtualEnvironmentGroupACL)

	test.AssertComputedAttributes(t, aclSchema, []string{
		mkDataSourceVirtualEnvironmentGroupACLPath,
		mkDataSourceVirtualEnvironmentGroupACLPropagate,
		mkDataSourceVirtualEnvironmentGroupACLRoleID,
	})

	test.AssertValueTypes(t, aclSchema, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentGroupACLPath:      schema.TypeString,
		mkDataSourceVirtualEnvironmentGroupACLPropagate: schema.TypeBool,
		mkDataSourceVirtualEnvironmentGroupACLRoleID:    schema.TypeString,
	})
}
`````

## File: proxmoxtf/datasource/group.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentGroupACL          = "acl"
	mkDataSourceVirtualEnvironmentGroupACLPath      = "path"
	mkDataSourceVirtualEnvironmentGroupACLPropagate = "propagate"
	mkDataSourceVirtualEnvironmentGroupACLRoleID    = "role_id"
	mkDataSourceVirtualEnvironmentGroupComment      = "comment"
	mkDataSourceVirtualEnvironmentGroupID           = "group_id"
	mkDataSourceVirtualEnvironmentGroupMembers      = "members"
)

// Group returns a resource for the Proxmox user group.
func Group() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentGroupACL: {
				Type:        schema.TypeSet,
				Description: "The access control list",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDataSourceVirtualEnvironmentGroupACLPath: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The path",
						},
						mkDataSourceVirtualEnvironmentGroupACLPropagate: {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Whether to propagate to child paths",
						},
						mkDataSourceVirtualEnvironmentGroupACLRoleID: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The role id",
						},
					},
				},
			},
			mkDataSourceVirtualEnvironmentGroupComment: {
				Type:        schema.TypeString,
				Description: "The group comment",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentGroupID: {
				Type:        schema.TypeString,
				Description: "The group id",
				Required:    true,
			},
			mkDataSourceVirtualEnvironmentGroupMembers: {
				Type:        schema.TypeSet,
				Description: "The group members",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		ReadContext: groupRead,
	}
}

func groupRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	groupID := d.Get(mkDataSourceVirtualEnvironmentGroupID).(string)
	group, err := api.Access().GetGroup(ctx, groupID)
	if err != nil {
		return diag.FromErr(err)
	}

	acl, err := api.Access().GetACL(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(groupID)

	var aclParsed []interface{}

	for _, v := range acl {
		if v.Type == "group" && v.UserOrGroupID == groupID {
			aclEntry := map[string]interface{}{}

			aclEntry[mkDataSourceVirtualEnvironmentGroupACLPath] = v.Path

			if v.Propagate != nil {
				aclEntry[mkDataSourceVirtualEnvironmentGroupACLPropagate] = bool(*v.Propagate)
			} else {
				aclEntry[mkDataSourceVirtualEnvironmentGroupACLPropagate] = false
			}

			aclEntry[mkDataSourceVirtualEnvironmentGroupACLRoleID] = v.RoleID

			aclParsed = append(aclParsed, aclEntry)
		}
	}

	err = d.Set(mkDataSourceVirtualEnvironmentGroupACL, aclParsed)
	diags = append(diags, diag.FromErr(err)...)

	if group.Comment != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentGroupComment, group.Comment)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentGroupComment, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	err = d.Set(mkDataSourceVirtualEnvironmentGroupMembers, group.Members)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/groups_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestGroupsInstantiation tests whether the Groups instance can be instantiated.
func TestGroupsInstantiation(t *testing.T) {
	t.Parallel()

	s := Groups()
	if s == nil {
		t.Fatalf("Cannot instantiate Groups")
	}
}

// TestGroupsSchema tests the Groups schema.
func TestGroupsSchema(t *testing.T) {
	t.Parallel()

	s := Groups().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentGroupsComments,
		mkDataSourceVirtualEnvironmentGroupsGroupIDs,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentGroupsComments: schema.TypeList,
		mkDataSourceVirtualEnvironmentGroupsGroupIDs: schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/groups.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentGroupsComments = "comments"
	mkDataSourceVirtualEnvironmentGroupsGroupIDs = "group_ids"
)

// Groups returns a resource for the Proxmox user groups.
func Groups() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentGroupsComments: {
				Type:        schema.TypeList,
				Description: "The group comments",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentGroupsGroupIDs: {
				Type:        schema.TypeList,
				Description: "The group ids",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		ReadContext: groupsRead,
	}
}

func groupsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	list, err := api.Access().ListGroups(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	comments := make([]interface{}, len(list))
	groupIDs := make([]interface{}, len(list))

	for i, v := range list {
		if v.Comment != nil {
			comments[i] = v.Comment
		} else {
			comments[i] = ""
		}

		groupIDs[i] = v.ID
	}

	d.SetId("groups")

	err = d.Set(mkDataSourceVirtualEnvironmentGroupsComments, comments)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentGroupsGroupIDs, groupIDs)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/hosts_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestHostsInstantiation tests whether the Hosts instance can be instantiated.
func TestHostsInstantiation(t *testing.T) {
	t.Parallel()

	s := Hosts()
	if s == nil {
		t.Fatalf("Cannot instantiate Hosts")
	}
}

// TestHostsSchema tests the Hosts schema.
func TestHostsSchema(t *testing.T) {
	t.Parallel()

	s := Hosts().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentHostsNodeName,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentHostsAddresses,
		mkDataSourceVirtualEnvironmentHostsDigest,
		mkDataSourceVirtualEnvironmentHostsEntries,
		mkDataSourceVirtualEnvironmentHostsHostnames,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentHostsAddresses: schema.TypeList,
		mkDataSourceVirtualEnvironmentHostsDigest:    schema.TypeString,
		mkDataSourceVirtualEnvironmentHostsEntries:   schema.TypeList,
		mkDataSourceVirtualEnvironmentHostsHostnames: schema.TypeList,
		mkDataSourceVirtualEnvironmentHostsNodeName:  schema.TypeString,
	})

	entriesSchema := test.AssertNestedSchemaExistence(t, s, mkDataSourceVirtualEnvironmentHostsEntries)

	test.AssertComputedAttributes(t, entriesSchema, []string{
		mkDataSourceVirtualEnvironmentHostsEntriesAddress,
		mkDataSourceVirtualEnvironmentHostsEntriesHostnames,
	})

	test.AssertValueTypes(t, entriesSchema, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentHostsEntriesAddress:   schema.TypeString,
		mkDataSourceVirtualEnvironmentHostsEntriesHostnames: schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/hosts.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentHostsAddresses        = "addresses"
	mkDataSourceVirtualEnvironmentHostsDigest           = "digest"
	mkDataSourceVirtualEnvironmentHostsEntries          = "entries"
	mkDataSourceVirtualEnvironmentHostsEntriesAddress   = "address"
	mkDataSourceVirtualEnvironmentHostsEntriesHostnames = "hostnames"
	mkDataSourceVirtualEnvironmentHostsHostnames        = "hostnames"
	mkDataSourceVirtualEnvironmentHostsNodeName         = "node_name"
)

// Hosts returns a resource for the Proxmox hosts.
func Hosts() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentHostsAddresses: {
				Type:        schema.TypeList,
				Description: "The addresses",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentHostsDigest: {
				Type:        schema.TypeString,
				Description: "The SHA1 digest",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentHostsEntries: {
				Type:        schema.TypeList,
				Description: "The host entries",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDataSourceVirtualEnvironmentHostsEntriesAddress: {
							Type:        schema.TypeString,
							Description: "The address",
							Computed:    true,
						},
						mkDataSourceVirtualEnvironmentHostsEntriesHostnames: {
							Type:        schema.TypeList,
							Description: "The hostnames",
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			mkDataSourceVirtualEnvironmentHostsHostnames: {
				Type:        schema.TypeList,
				Description: "The hostnames",
				Computed:    true,
				Elem: &schema.Schema{
					Type: schema.TypeList,
					Elem: &schema.Schema{Type: schema.TypeString},
				},
			},
			mkDataSourceVirtualEnvironmentHostsNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
		},
		ReadContext: hostsRead,
	}
}

func hostsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkDataSourceVirtualEnvironmentHostsNodeName).(string)

	hosts, err := api.Node(nodeName).GetHosts(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(fmt.Sprintf("%s_hosts", nodeName))

	// Parse the entries in the hosts file.
	var addresses []interface{}
	var entries []interface{}
	var hostnames []interface{}
	lines := strings.Split(hosts.Data, "\n")

	for _, line := range lines {
		if strings.HasPrefix(line, "#") {
			continue
		}

		line = strings.ReplaceAll(line, "\t", " ")
		values := strings.Split(line, " ")

		if values[0] == "" {
			continue
		}

		addresses = append(addresses, values[0])
		entry := map[string]interface{}{}
		var hostnamesForAddress []interface{}

		for _, hostname := range values[1:] {
			if hostname != "" {
				hostnamesForAddress = append(hostnamesForAddress, hostname)
			}
		}

		entry[mkDataSourceVirtualEnvironmentHostsEntriesAddress] = values[0]
		entry[mkDataSourceVirtualEnvironmentHostsEntriesHostnames] = hostnamesForAddress

		entries = append(entries, entry)
		hostnames = append(hostnames, hostnamesForAddress)
	}

	err = d.Set(mkDataSourceVirtualEnvironmentHostsAddresses, addresses)
	diags = append(diags, diag.FromErr(err)...)

	if hosts.Digest != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentHostsDigest, *hosts.Digest)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentHostsDigest, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	err = d.Set(mkDataSourceVirtualEnvironmentHostsEntries, entries)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentHostsHostnames, hostnames)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/node.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentNodeCPUCores        = "cpu_count"
	mkDataSourceVirtualEnvironmentNodeCPUSockets      = "cpu_sockets"
	mkDataSourceVirtualEnvironmentNodeCPUModel        = "cpu_model"
	mkDataSourceVirtualEnvironmentNodeMemoryAvailable = "memory_available"
	mkDataSourceVirtualEnvironmentNodeMemoryUsed      = "memory_used"
	mkDataSourceVirtualEnvironmentNodeMemoryTotal     = "memory_total"
	mkDataSourceVirtualEnvironmentNodeUptime          = "uptime"
	mkDataSourceVirtualEnvironmentNodeName            = "node_name"
)

// Node returns a resource for the Proxmox node.
func Node() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentNodeCPUCores: {
				Type:        schema.TypeInt,
				Description: "The CPU count on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeCPUSockets: {
				Type:        schema.TypeInt,
				Description: "The CPU sockets on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeCPUModel: {
				Type:        schema.TypeString,
				Description: "The CPU model on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeMemoryAvailable: {
				Type:        schema.TypeInt,
				Description: "The available memory in bytes on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeMemoryUsed: {
				Type:        schema.TypeInt,
				Description: "The used memory in bytes on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeMemoryTotal: {
				Type:        schema.TypeInt,
				Description: "The total memory in bytes on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeUptime: {
				Type:        schema.TypeInt,
				Description: "The uptime in seconds on the node",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
		},
		ReadContext: nodeRead,
	}
}

func nodeRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)

	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeID := d.Get(mkDataSourceVirtualEnvironmentNodeName).(string)

	node, err := api.Node(nodeID).GetInfo(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(nodeID)

	if node.CPUInfo.CPUCores != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeCPUCores, *node.CPUInfo.CPUCores)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeCPUCores, 1)
	}

	diags = append(diags, diag.FromErr(err)...)

	if node.CPUInfo.CPUSockets != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeCPUSockets, *node.CPUInfo.CPUSockets)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeCPUSockets, 1)
	}

	diags = append(diags, diag.FromErr(err)...)

	if node.CPUInfo.CPUModel != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeCPUModel, *node.CPUInfo.CPUModel)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeCPUModel, "")
	}

	diags = append(diags, diag.FromErr(err)...)

	if node.MemoryInfo.Total != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeMemoryAvailable, node.MemoryInfo.Free)
		diags = append(diags, diag.FromErr(err)...)
		err = d.Set(mkDataSourceVirtualEnvironmentNodeMemoryUsed, node.MemoryInfo.Used)
		diags = append(diags, diag.FromErr(err)...)
		err = d.Set(mkDataSourceVirtualEnvironmentNodeMemoryTotal, node.MemoryInfo.Total)
		diags = append(diags, diag.FromErr(err)...)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeMemoryAvailable, 0)
		diags = append(diags, diag.FromErr(err)...)
		err = d.Set(mkDataSourceVirtualEnvironmentNodeMemoryUsed, 0)
		diags = append(diags, diag.FromErr(err)...)
		err = d.Set(mkDataSourceVirtualEnvironmentNodeMemoryTotal, 0)
		diags = append(diags, diag.FromErr(err)...)
	}

	if node.Uptime != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeUptime, *node.Uptime)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentNodeUptime, 0)
	}

	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/nodes_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestNodesInstantiation tests whether the Nodes instance can be instantiated.
func TestNodesInstantiation(t *testing.T) {
	t.Parallel()

	s := Nodes()
	if s == nil {
		t.Fatalf("Cannot instantiate Nodes")
	}
}

// TestNodesSchema tests the Nodes schema.
func TestNodesSchema(t *testing.T) {
	t.Parallel()

	s := Nodes().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentNodesCPUCount,
		mkDataSourceVirtualEnvironmentNodesCPUUtilization,
		mkDataSourceVirtualEnvironmentNodesMemoryAvailable,
		mkDataSourceVirtualEnvironmentNodesMemoryUsed,
		mkDataSourceVirtualEnvironmentNodesNames,
		mkDataSourceVirtualEnvironmentNodesOnline,
		mkDataSourceVirtualEnvironmentNodesSSLFingerprints,
		mkDataSourceVirtualEnvironmentNodesSupportLevels,
		mkDataSourceVirtualEnvironmentNodesUptime,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentNodesCPUCount:        schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesCPUUtilization:  schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesMemoryAvailable: schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesMemoryUsed:      schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesNames:           schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesOnline:          schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesSSLFingerprints: schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesSupportLevels:   schema.TypeList,
		mkDataSourceVirtualEnvironmentNodesUptime:          schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/nodes.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"math"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentNodesCPUCount        = "cpu_count"
	mkDataSourceVirtualEnvironmentNodesCPUUtilization  = "cpu_utilization"
	mkDataSourceVirtualEnvironmentNodesMemoryAvailable = "memory_available"
	mkDataSourceVirtualEnvironmentNodesMemoryUsed      = "memory_used"
	mkDataSourceVirtualEnvironmentNodesNames           = "names"
	mkDataSourceVirtualEnvironmentNodesOnline          = "online"
	mkDataSourceVirtualEnvironmentNodesSSLFingerprints = "ssl_fingerprints"
	mkDataSourceVirtualEnvironmentNodesSupportLevels   = "support_levels"
	mkDataSourceVirtualEnvironmentNodesUptime          = "uptime"
)

// Nodes returns a resource for the Proxmox nodes.
func Nodes() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentNodesCPUCount: {
				Type:        schema.TypeList,
				Description: "The CPU count for each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeInt},
			},
			mkDataSourceVirtualEnvironmentNodesCPUUtilization: {
				Type:        schema.TypeList,
				Description: "The CPU utilization on each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeFloat},
			},
			mkDataSourceVirtualEnvironmentNodesMemoryAvailable: {
				Type:        schema.TypeList,
				Description: "The available memory in bytes on each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeInt},
			},
			mkDataSourceVirtualEnvironmentNodesMemoryUsed: {
				Type:        schema.TypeList,
				Description: "The used memory in bytes on each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeInt},
			},
			mkDataSourceVirtualEnvironmentNodesNames: {
				Type:        schema.TypeList,
				Description: "The node names",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentNodesOnline: {
				Type:        schema.TypeList,
				Description: "Whether a node is online",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeBool},
			},
			mkDataSourceVirtualEnvironmentNodesSSLFingerprints: {
				Type:        schema.TypeList,
				Description: "The SSL fingerprint for each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentNodesSupportLevels: {
				Type:        schema.TypeList,
				Description: "The support level for each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentNodesUptime: {
				Type:        schema.TypeList,
				Description: "The uptime in seconds for each node",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeInt},
			},
		},
		ReadContext: nodesRead,
	}
}

func nodesRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	list, err := api.Node("").ListNodes(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	cpuCount := make([]interface{}, len(list))
	cpuUtilization := make([]interface{}, len(list))
	memoryAvailable := make([]interface{}, len(list))
	memoryUsed := make([]interface{}, len(list))
	name := make([]interface{}, len(list))
	online := make([]interface{}, len(list))
	sslFingerprints := make([]interface{}, len(list))
	supportLevels := make([]interface{}, len(list))
	uptime := make([]interface{}, len(list))

	for i, v := range list {
		if v.CPUCount != nil {
			cpuCount[i] = v.CPUCount
		} else {
			cpuCount[i] = 0
		}

		if v.CPUUtilization != nil {
			cpuUtilization[i] = math.Round(*v.CPUUtilization*100) / 100
		} else {
			cpuUtilization[i] = 0
		}

		if v.MemoryAvailable != nil {
			memoryAvailable[i] = v.MemoryAvailable
		} else {
			memoryAvailable[i] = 0
		}

		if v.MemoryUsed != nil {
			memoryUsed[i] = v.MemoryUsed
		} else {
			memoryUsed[i] = 0
		}

		name[i] = v.Name

		if v.Status != nil {
			online[i] = *v.Status == "online"
		} else {
			online[i] = false
		}

		if v.SSLFingerprint != nil {
			sslFingerprints[i] = v.SSLFingerprint
		} else {
			sslFingerprints[i] = 0
		}

		if v.SupportLevel != nil {
			supportLevels[i] = v.SupportLevel
		} else {
			supportLevels[i] = ""
		}

		if v.Uptime != nil {
			uptime[i] = v.Uptime
		} else {
			uptime[i] = 0
		}
	}

	d.SetId("nodes")

	err = d.Set(mkDataSourceVirtualEnvironmentNodesCPUCount, cpuCount)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesCPUUtilization, cpuUtilization)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesMemoryAvailable, memoryAvailable)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesMemoryUsed, memoryUsed)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesNames, name)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesOnline, online)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesSSLFingerprints, sslFingerprints)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesSupportLevels, supportLevels)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentNodesUptime, uptime)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/pool_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestPoolInstantiation tests whether the Pool instance can be instantiated.
func TestPoolInstantiation(t *testing.T) {
	t.Parallel()

	s := Pool()
	if s == nil {
		t.Fatalf("Cannot instantiate Pool")
	}
}

// TestPoolSchema tests the Pool schema.
func TestPoolSchema(t *testing.T) {
	t.Parallel()

	s := Pool().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentPoolPoolID,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentPoolComment,
		mkDataSourceVirtualEnvironmentPoolMembers,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentPoolComment: schema.TypeString,
		mkDataSourceVirtualEnvironmentPoolMembers: schema.TypeList,
		mkDataSourceVirtualEnvironmentPoolPoolID:  schema.TypeString,
	})

	membersSchema := test.AssertNestedSchemaExistence(t, s, mkDataSourceVirtualEnvironmentPoolMembers)

	test.AssertComputedAttributes(t, membersSchema, []string{
		mkDataSourceVirtualEnvironmentPoolMembersDatastoreID,
		mkDataSourceVirtualEnvironmentPoolMembersID,
		mkDataSourceVirtualEnvironmentPoolMembersNodeName,
		mkDataSourceVirtualEnvironmentPoolMembersType,
		mkDataSourceVirtualEnvironmentPoolMembersVMID,
	})

	test.AssertValueTypes(t, membersSchema, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentPoolMembersDatastoreID: schema.TypeString,
		mkDataSourceVirtualEnvironmentPoolMembersID:          schema.TypeString,
		mkDataSourceVirtualEnvironmentPoolMembersNodeName:    schema.TypeString,
		mkDataSourceVirtualEnvironmentPoolMembersType:        schema.TypeString,
		mkDataSourceVirtualEnvironmentPoolMembersVMID:        schema.TypeInt,
	})
}
`````

## File: proxmoxtf/datasource/pool.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentPoolComment            = "comment"
	mkDataSourceVirtualEnvironmentPoolMembers            = "members"
	mkDataSourceVirtualEnvironmentPoolMembersDatastoreID = "datastore_id"
	mkDataSourceVirtualEnvironmentPoolMembersID          = "id"
	mkDataSourceVirtualEnvironmentPoolMembersNodeName    = "node_name"
	mkDataSourceVirtualEnvironmentPoolMembersType        = "type"
	mkDataSourceVirtualEnvironmentPoolMembersVMID        = "vm_id"
	mkDataSourceVirtualEnvironmentPoolPoolID             = "pool_id"
)

// Pool returns a resource for a single Proxmox pool.
func Pool() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentPoolComment: {
				Type:        schema.TypeString,
				Description: "The pool comment",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentPoolMembers: {
				Type:        schema.TypeList,
				Description: "The pool members",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDataSourceVirtualEnvironmentPoolMembersDatastoreID: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The datastore id",
						},
						mkDataSourceVirtualEnvironmentPoolMembersID: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The member id",
						},
						mkDataSourceVirtualEnvironmentPoolMembersNodeName: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The node name",
						},
						mkDataSourceVirtualEnvironmentPoolMembersType: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The member type",
						},
						mkDataSourceVirtualEnvironmentPoolMembersVMID: {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "The virtual machine id",
						},
					},
				},
			},
			mkDataSourceVirtualEnvironmentPoolPoolID: {
				Type:        schema.TypeString,
				Description: "The pool id",
				Required:    true,
			},
		},
		ReadContext: poolRead,
	}
}

func poolRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	poolID := d.Get(mkDataSourceVirtualEnvironmentPoolPoolID).(string)
	pool, err := api.Pool().GetPool(ctx, poolID)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(poolID)

	if pool.Comment != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentPoolComment, pool.Comment)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentPoolComment, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	members := make([]interface{}, len(pool.Members))

	for i, v := range pool.Members {
		values := map[string]interface{}{}

		values[mkDataSourceVirtualEnvironmentPoolMembersID] = v.ID
		values[mkDataSourceVirtualEnvironmentPoolMembersNodeName] = v.Node

		if v.DatastoreID != nil {
			values[mkDataSourceVirtualEnvironmentPoolMembersDatastoreID] = v.DatastoreID
		} else {
			values[mkDataSourceVirtualEnvironmentPoolMembersDatastoreID] = ""
		}

		values[mkDataSourceVirtualEnvironmentPoolMembersType] = v.Type

		if v.VMID != nil {
			values[mkDataSourceVirtualEnvironmentPoolMembersVMID] = v.VMID
		} else {
			values[mkDataSourceVirtualEnvironmentPoolMembersVMID] = 0
		}

		members[i] = values
	}

	err = d.Set(mkDataSourceVirtualEnvironmentPoolMembers, members)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/pools_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestPoolsInstantiation tests whether the Pools instance can be instantiated.
func TestPoolsInstantiation(t *testing.T) {
	t.Parallel()

	s := Pools()
	if s == nil {
		t.Fatalf("Cannot instantiate Pools")
	}
}

// TestPoolsSchema tests the Pools schema.
func TestPoolsSchema(t *testing.T) {
	t.Parallel()

	s := Pools().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentPoolsPoolIDs,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentPoolsPoolIDs: schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/pools.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentPoolsPoolIDs = "pool_ids"
)

// Pools returns a resource for the Proxmox pools.
func Pools() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentPoolsPoolIDs: {
				Type:        schema.TypeList,
				Description: "The pool ids",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		ReadContext: poolsRead,
	}
}

func poolsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	list, err := api.Pool().ListPools(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	poolIDs := make([]interface{}, len(list))

	for i, v := range list {
		poolIDs[i] = v.ID
	}

	d.SetId("pools")

	err = d.Set(mkDataSourceVirtualEnvironmentPoolsPoolIDs, poolIDs)

	return diag.FromErr(err)
}
`````

## File: proxmoxtf/datasource/role_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestRoleInstantiation tests whether the Role instance can be instantiated.
func TestRoleInstantiation(t *testing.T) {
	t.Parallel()

	s := Role()
	if s == nil {
		t.Fatalf("Cannot instantiate Role")
	}
}

// TestRoleSchema tests the Role schema.
func TestRoleSchema(t *testing.T) {
	t.Parallel()

	s := Role().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentRoleID,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentRolePrivileges,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentRoleID:         schema.TypeString,
		mkDataSourceVirtualEnvironmentRolePrivileges: schema.TypeSet,
	})
}
`````

## File: proxmoxtf/datasource/role.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentRoleID         = "role_id"
	mkDataSourceVirtualEnvironmentRolePrivileges = "privileges"
)

// Role returns a resource for a single user role.
func Role() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentRoleID: {
				Type:        schema.TypeString,
				Description: "The role id",
				Required:    true,
			},
			mkDataSourceVirtualEnvironmentRolePrivileges: {
				Type:        schema.TypeSet,
				Description: "The role privileges",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		ReadContext: roleRead,
	}
}

func roleRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	roleID := d.Get(mkDataSourceVirtualEnvironmentRoleID).(string)
	accessRole, err := api.Access().GetRole(ctx, roleID)
	if err != nil {
		return diag.FromErr(err)
	}

	privileges := schema.NewSet(schema.HashString, []interface{}{})

	if *accessRole != nil {
		for _, v := range *accessRole {
			privileges.Add(v)
		}
	}

	d.SetId(roleID)

	err = d.Set(mkDataSourceVirtualEnvironmentRolePrivileges, privileges)

	return diag.FromErr(err)
}
`````

## File: proxmoxtf/datasource/roles_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestRolesInstantiation tests whether the Roles instance can be instantiated.
func TestRolesInstantiation(t *testing.T) {
	t.Parallel()

	s := Roles()
	if s == nil {
		t.Fatalf("Cannot instantiate Roles")
	}
}

// TestRolesSchema tests the Roles schema.
func TestRolesSchema(t *testing.T) {
	t.Parallel()

	s := Roles().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentRolesPrivileges,
		mkDataSourceVirtualEnvironmentRolesRoleIDs,
		mkDataSourceVirtualEnvironmentRolesSpecial,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentRolesPrivileges: schema.TypeList,
		mkDataSourceVirtualEnvironmentRolesRoleIDs:    schema.TypeList,
		mkDataSourceVirtualEnvironmentRolesSpecial:    schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/roles.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentRolesPrivileges = "privileges"
	mkDataSourceVirtualEnvironmentRolesRoleIDs    = "role_ids"
	mkDataSourceVirtualEnvironmentRolesSpecial    = "special"
)

// Roles returns a resource for the user roles.
func Roles() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentRolesPrivileges: {
				Type:        schema.TypeList,
				Description: "The role privileges",
				Computed:    true,
				Elem: &schema.Schema{
					Type: schema.TypeSet,
					Elem: &schema.Schema{Type: schema.TypeString},
				},
			},
			mkDataSourceVirtualEnvironmentRolesRoleIDs: {
				Type:        schema.TypeList,
				Description: "The role ids",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentRolesSpecial: {
				Type:        schema.TypeList,
				Description: "Whether the role is special (built-in)",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeBool},
			},
		},
		ReadContext: rolesRead,
	}
}

func rolesRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	list, err := api.Access().ListRoles(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	privileges := make([]interface{}, len(list))
	roleIDs := make([]interface{}, len(list))
	special := make([]interface{}, len(list))

	for i, v := range list {
		if v.Privileges != nil {
			p := schema.NewSet(schema.HashString, []interface{}{})

			for _, v := range *v.Privileges {
				p.Add(v)
			}

			privileges[i] = p
		} else {
			privileges[i] = map[string]interface{}{}
		}

		roleIDs[i] = v.ID

		if v.Special != nil {
			special[i] = v.Special
		} else {
			special[i] = false
		}
	}

	d.SetId("roles")

	err = d.Set(mkDataSourceVirtualEnvironmentRolesPrivileges, privileges)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentRolesRoleIDs, roleIDs)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentRolesSpecial, special)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/time_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestTimeInstantiation tests whether the Roles instance can be instantiated.
func TestTimeInstantiation(t *testing.T) {
	t.Parallel()

	s := Time()
	if s == nil {
		t.Fatalf("Cannot instantiate Time")
	}
}

// TestTimeSchema tests the Time schema.
func TestTimeSchema(t *testing.T) {
	t.Parallel()

	s := Time().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentTimeNodeName,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentTimeLocalTime,
		mkDataSourceVirtualEnvironmentTimeTimeZone,
		mkDataSourceVirtualEnvironmentTimeUTCTime,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentTimeLocalTime: schema.TypeString,
		mkDataSourceVirtualEnvironmentTimeNodeName:  schema.TypeString,
		mkDataSourceVirtualEnvironmentTimeTimeZone:  schema.TypeString,
		mkDataSourceVirtualEnvironmentTimeUTCTime:   schema.TypeString,
	})
}
`````

## File: proxmoxtf/datasource/time.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentTimeLocalTime = "local_time"
	mkDataSourceVirtualEnvironmentTimeNodeName  = "node_name"
	mkDataSourceVirtualEnvironmentTimeTimeZone  = "time_zone"
	mkDataSourceVirtualEnvironmentTimeUTCTime   = "utc_time"
)

// Time returns a resource for the Proxmox time.
func Time() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentTimeLocalTime: {
				Type:        schema.TypeString,
				Description: "The local timestamp",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentTimeNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
			mkDataSourceVirtualEnvironmentTimeTimeZone: {
				Type:        schema.TypeString,
				Description: "The time zone",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentTimeUTCTime: {
				Type:        schema.TypeString,
				Description: "The UTC timestamp",
				Computed:    true,
			},
		},
		ReadContext: timeRead,
	}
}

func timeRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkDataSourceVirtualEnvironmentTimeNodeName).(string)
	nodeTime, err := api.Node(nodeName).GetTime(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	localLocation, err := time.LoadLocation(nodeTime.TimeZone)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(fmt.Sprintf("%s_time", nodeName))

	localTimeOffset := time.Time(nodeTime.LocalTime).Sub(time.Now().UTC())
	localTime := time.Time(nodeTime.LocalTime).Add(-localTimeOffset).In(localLocation)

	err = d.Set(mkDataSourceVirtualEnvironmentTimeLocalTime, localTime.Format(time.RFC3339))
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentTimeTimeZone, nodeTime.TimeZone)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(
		mkDataSourceVirtualEnvironmentTimeUTCTime,
		time.Time(nodeTime.UTCTime).Format(time.RFC3339),
	)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/user_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestUserInstantiation tests whether the User instance can be instantiated.
func TestUserInstantiation(t *testing.T) {
	t.Parallel()

	s := User()
	if s == nil {
		t.Fatalf("Cannot instantiate User")
	}
}

// TestUserSchema tests the User schema.
func TestUserSchema(t *testing.T) {
	t.Parallel()

	s := User().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkDataSourceVirtualEnvironmentUserUserID,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentUserACL,
		mkDataSourceVirtualEnvironmentUserComment,
		mkDataSourceVirtualEnvironmentUserEmail,
		mkDataSourceVirtualEnvironmentUserEnabled,
		mkDataSourceVirtualEnvironmentUserExpirationDate,
		mkDataSourceVirtualEnvironmentUserFirstName,
		mkDataSourceVirtualEnvironmentUserGroups,
		mkDataSourceVirtualEnvironmentUserKeys,
		mkDataSourceVirtualEnvironmentUserLastName,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentUserACL:            schema.TypeSet,
		mkDataSourceVirtualEnvironmentUserComment:        schema.TypeString,
		mkDataSourceVirtualEnvironmentUserEmail:          schema.TypeString,
		mkDataSourceVirtualEnvironmentUserEnabled:        schema.TypeBool,
		mkDataSourceVirtualEnvironmentUserExpirationDate: schema.TypeString,
		mkDataSourceVirtualEnvironmentUserFirstName:      schema.TypeString,
		mkDataSourceVirtualEnvironmentUserGroups:         schema.TypeList,
		mkDataSourceVirtualEnvironmentUserKeys:           schema.TypeString,
		mkDataSourceVirtualEnvironmentUserLastName:       schema.TypeString,
	})

	aclSchema := test.AssertNestedSchemaExistence(t, s, mkDataSourceVirtualEnvironmentGroupACL)

	test.AssertComputedAttributes(t, aclSchema, []string{
		mkDataSourceVirtualEnvironmentUserACLPath,
		mkDataSourceVirtualEnvironmentUserACLPropagate,
		mkDataSourceVirtualEnvironmentUserACLRoleID,
	})

	test.AssertValueTypes(t, aclSchema, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentUserACLPath:      schema.TypeString,
		mkDataSourceVirtualEnvironmentUserACLPropagate: schema.TypeBool,
		mkDataSourceVirtualEnvironmentUserACLRoleID:    schema.TypeString,
	})
}
`````

## File: proxmoxtf/datasource/user.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentUserACL            = "acl"
	mkDataSourceVirtualEnvironmentUserACLPath        = "path"
	mkDataSourceVirtualEnvironmentUserACLPropagate   = "propagate"
	mkDataSourceVirtualEnvironmentUserACLRoleID      = "role_id"
	mkDataSourceVirtualEnvironmentUserComment        = "comment"
	mkDataSourceVirtualEnvironmentUserEmail          = "email"
	mkDataSourceVirtualEnvironmentUserEnabled        = "enabled"
	mkDataSourceVirtualEnvironmentUserExpirationDate = "expiration_date"
	mkDataSourceVirtualEnvironmentUserFirstName      = "first_name"
	mkDataSourceVirtualEnvironmentUserGroups         = "groups"
	mkDataSourceVirtualEnvironmentUserKeys           = "keys"
	mkDataSourceVirtualEnvironmentUserLastName       = "last_name"
	mkDataSourceVirtualEnvironmentUserUserID         = "user_id"
)

// User returns a resource for a single Proxmox user.
func User() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentUserACL: {
				Type:        schema.TypeSet,
				Description: "The access control list",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDataSourceVirtualEnvironmentUserACLPath: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The path",
						},
						mkDataSourceVirtualEnvironmentUserACLPropagate: {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Whether to propagate to child paths",
						},
						mkDataSourceVirtualEnvironmentUserACLRoleID: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The role id",
						},
					},
				},
			},
			mkDataSourceVirtualEnvironmentUserComment: {
				Type:        schema.TypeString,
				Description: "The user comment",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserEmail: {
				Type:        schema.TypeString,
				Description: "The user's email address",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserEnabled: {
				Type:        schema.TypeBool,
				Description: "Whether the user account is enabled",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserExpirationDate: {
				Type:        schema.TypeString,
				Description: "The user account's expiration date",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserFirstName: {
				Type:        schema.TypeString,
				Description: "The user's first name",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserGroups: {
				Type:        schema.TypeList,
				Description: "The user's groups",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUserKeys: {
				Type:        schema.TypeString,
				Description: "The user's keys",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserLastName: {
				Type:        schema.TypeString,
				Description: "The user's last name",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentUserUserID: {
				Type:        schema.TypeString,
				Description: "The user id",
				Required:    true,
			},
		},
		ReadContext: userRead,
	}
}

func userRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	userID := d.Get(mkDataSourceVirtualEnvironmentUserUserID).(string)
	v, err := api.Access().GetUser(ctx, userID)
	if err != nil {
		return diag.FromErr(err)
	}

	acl, err := api.Access().GetACL(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(userID)

	var aclParsed []interface{}

	for _, v := range acl {
		if v.Type == "user" && v.UserOrGroupID == userID {
			aclEntry := map[string]interface{}{}

			aclEntry[mkDataSourceVirtualEnvironmentUserACLPath] = v.Path

			if v.Propagate != nil {
				aclEntry[mkDataSourceVirtualEnvironmentUserACLPropagate] = bool(*v.Propagate)
			} else {
				aclEntry[mkDataSourceVirtualEnvironmentUserACLPropagate] = false
			}

			aclEntry[mkDataSourceVirtualEnvironmentUserACLRoleID] = v.RoleID

			aclParsed = append(aclParsed, aclEntry)
		}
	}

	err = d.Set(mkDataSourceVirtualEnvironmentUserACL, aclParsed)
	diags = append(diags, diag.FromErr(err)...)

	if v.Comment != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUserComment, v.Comment)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserComment, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.Email != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUserEmail, v.Email)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserEmail, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.Enabled != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUserEnabled, v.Enabled)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserEnabled, true)
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.ExpirationDate != nil {
		t := time.Unix(*v.ExpirationDate, 0)
		if t.Unix() > 0 {
			err = d.Set(
				mkDataSourceVirtualEnvironmentUserExpirationDate,
				t.UTC().Format(time.RFC3339),
			)
		} else {
			err = d.Set(mkDataSourceVirtualEnvironmentUserExpirationDate, time.Unix(0, 0).UTC().Format(time.RFC3339))
		}
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserExpirationDate, time.Unix(0, 0).UTC().Format(time.RFC3339))
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.FirstName != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUserFirstName, v.FirstName)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserFirstName, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.Groups != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUserGroups, v.Groups)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserGroups, []string{})
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.Keys != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUsersKeys, v.Keys)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUsersKeys, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if v.LastName != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentUserLastName, v.LastName)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentUserLastName, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/users_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestUsersInstantiation tests whether the Users instance can be instantiated.
func TestUsersInstantiation(t *testing.T) {
	t.Parallel()

	s := Users()
	if s == nil {
		t.Fatalf("Cannot instantiate Users")
	}
}

// TestUsersSchema tests the Users schema.
func TestUsersSchema(t *testing.T) {
	t.Parallel()

	s := Users().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentUsersComments,
		mkDataSourceVirtualEnvironmentUsersEmails,
		mkDataSourceVirtualEnvironmentUsersEnabled,
		mkDataSourceVirtualEnvironmentUsersExpirationDates,
		mkDataSourceVirtualEnvironmentUsersFirstNames,
		mkDataSourceVirtualEnvironmentUsersGroups,
		mkDataSourceVirtualEnvironmentUsersKeys,
		mkDataSourceVirtualEnvironmentUsersLastNames,
		mkDataSourceVirtualEnvironmentUsersUserIDs,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentUsersComments:        schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersEmails:          schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersEnabled:         schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersExpirationDates: schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersFirstNames:      schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersGroups:          schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersKeys:            schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersLastNames:       schema.TypeList,
		mkDataSourceVirtualEnvironmentUsersUserIDs:         schema.TypeList,
	})
}
`````

## File: proxmoxtf/datasource/users.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentUsersComments        = "comments"
	mkDataSourceVirtualEnvironmentUsersEmails          = "emails"
	mkDataSourceVirtualEnvironmentUsersEnabled         = "enabled"
	mkDataSourceVirtualEnvironmentUsersExpirationDates = "expiration_dates"
	mkDataSourceVirtualEnvironmentUsersFirstNames      = "first_names"
	mkDataSourceVirtualEnvironmentUsersGroups          = "groups"
	mkDataSourceVirtualEnvironmentUsersKeys            = "keys"
	mkDataSourceVirtualEnvironmentUsersLastNames       = "last_names"
	mkDataSourceVirtualEnvironmentUsersUserIDs         = "user_ids"
)

// Users returns a resource for the Proxmox users.
func Users() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentUsersComments: {
				Type:        schema.TypeList,
				Description: "The user comments",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUsersEmails: {
				Type:        schema.TypeList,
				Description: "The users' email addresses",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUsersEnabled: {
				Type:        schema.TypeList,
				Description: "Whether a user account is enabled",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeBool},
			},
			mkDataSourceVirtualEnvironmentUsersExpirationDates: {
				Type:        schema.TypeList,
				Description: "The user accounts' expiration dates",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUsersFirstNames: {
				Type:        schema.TypeList,
				Description: "The users' first names",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUsersGroups: {
				Type:        schema.TypeList,
				Description: "The users' groups",
				Computed:    true,
				Elem: &schema.Schema{
					Type: schema.TypeList,
					Elem: &schema.Schema{Type: schema.TypeString},
				},
			},
			mkDataSourceVirtualEnvironmentUsersKeys: {
				Type:        schema.TypeList,
				Description: "The users' keys",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUsersLastNames: {
				Type:        schema.TypeList,
				Description: "The users' last names",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentUsersUserIDs: {
				Type:        schema.TypeList,
				Description: "The user ids",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		ReadContext: usersRead,
	}
}

func usersRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	list, err := api.Access().ListUsers(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	comments := make([]interface{}, len(list))
	emails := make([]interface{}, len(list))
	enabled := make([]interface{}, len(list))
	expirationDates := make([]interface{}, len(list))
	firstNames := make([]interface{}, len(list))
	groups := make([]interface{}, len(list))
	keys := make([]interface{}, len(list))
	lastNames := make([]interface{}, len(list))
	userIDs := make([]interface{}, len(list))

	for i, v := range list {
		if v.Comment != nil {
			comments[i] = v.Comment
		} else {
			comments[i] = ""
		}

		if v.Email != nil {
			emails[i] = v.Email
		} else {
			emails[i] = ""
		}

		if v.Enabled != nil {
			enabled[i] = v.Enabled
		} else {
			enabled[i] = true
		}

		if v.ExpirationDate != nil {
			t := time.Unix(*v.ExpirationDate, 0)

			if t.Unix() > 0 {
				expirationDates[i] = t.UTC().Format(time.RFC3339)
			} else {
				expirationDates[i] = time.Unix(0, 0).UTC().Format(time.RFC3339)
			}
		} else {
			expirationDates[i] = time.Unix(0, 0).UTC().Format(time.RFC3339)
		}

		if v.FirstName != nil {
			firstNames[i] = v.FirstName
		} else {
			firstNames[i] = ""
		}

		if v.Groups != nil {
			groups[i] = v.Groups
		} else {
			groups[i] = []string{}
		}

		if v.Keys != nil {
			keys[i] = v.Keys
		} else {
			keys[i] = ""
		}

		if v.LastName != nil {
			lastNames[i] = v.LastName
		} else {
			lastNames[i] = ""
		}

		userIDs[i] = v.ID
	}

	d.SetId("users")

	err = d.Set(mkDataSourceVirtualEnvironmentUsersComments, comments)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersEmails, emails)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersEnabled, enabled)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersExpirationDates, expirationDates)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersFirstNames, firstNames)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersGroups, groups)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersKeys, keys)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersLastNames, lastNames)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkDataSourceVirtualEnvironmentUsersUserIDs, userIDs)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}
`````

## File: proxmoxtf/datasource/vm_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestVMInstantiation tests whether the VM instance can be instantiated.
func TestVMInstantiation(t *testing.T) {
	t.Parallel()

	s := VM()

	if s == nil {
		t.Fatalf("Cannot instantiate VM")
	}
}

// TestVMSchema tests the VM schema.
func TestVMSchema(t *testing.T) {
	t.Parallel()

	s := VM().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentVMName,
		mkDataSourceVirtualEnvironmentVMTags,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentVMName:     schema.TypeString,
		mkDataSourceVirtualEnvironmentVMNodeName: schema.TypeString,
		mkDataSourceVirtualEnvironmentVMTags:     schema.TypeList,
		mkDataSourceVirtualEnvironmentVMTemplate: schema.TypeBool,
		mkDataSourceVirtualEnvironmentVMStatus:   schema.TypeString,
		mkDataSourceVirtualEnvironmentVMVMID:     schema.TypeInt,
	})
}
`````

## File: proxmoxtf/datasource/vm.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

//nolint:dupl
package datasource

import (
	"context"
	"errors"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentVMName     = "name"
	mkDataSourceVirtualEnvironmentVMNodeName = "node_name"
	mkDataSourceVirtualEnvironmentVMTags     = "tags"
	mkDataSourceVirtualEnvironmentVMTemplate = "template"
	mkDataSourceVirtualEnvironmentVMStatus   = "status"
	mkDataSourceVirtualEnvironmentVMVMID     = "vm_id"
)

// VM returns a resource for a single Proxmox VM.
func VM() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentVMName: {
				Type:        schema.TypeString,
				Description: "The VM name",
				Computed:    true,
			},
			mkDataSourceVirtualEnvironmentVMNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
			mkDataSourceVirtualEnvironmentVMTags: {
				Type:        schema.TypeList,
				Description: "Tags of the VM",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceVirtualEnvironmentVMTemplate: {
				Type:        schema.TypeBool,
				Description: "Is VM a template (true) or a regular VM (false)",
				Optional:    true,
			},
			mkDataSourceVirtualEnvironmentVMStatus: {
				Type:        schema.TypeString,
				Description: "Status of the VM",
				Optional:    true,
			},
			mkDataSourceVirtualEnvironmentVMVMID: {
				Type:        schema.TypeInt,
				Description: "The VM identifier",
				Required:    true,
			},
		},
		ReadContext: vmRead,
	}
}

// vmRead reads the data of a VM by ID.
func vmRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkDataSourceVirtualEnvironmentVMNodeName).(string)
	vmID := d.Get(mkDataSourceVirtualEnvironmentVMVMID).(int)

	vmStatus, err := client.Node(nodeName).VM(vmID).GetVMStatus(ctx)
	if err != nil {
		if errors.Is(err, api.ErrNoDataObjectInResponse) {
			d.SetId("")

			return nil
		}

		return diag.FromErr(err)
	}

	vmConfig, err := client.Node(nodeName).VM(vmID).GetVM(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if vmStatus.Name != nil {
		err = d.Set(mkDataSourceVirtualEnvironmentVMName, *vmStatus.Name)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentVMName, "")
	}

	diags = append(diags, diag.FromErr(err)...)

	var tags []string

	if vmStatus.Tags != nil {
		for _, tag := range strings.Split(*vmStatus.Tags, ";") {
			t := strings.TrimSpace(tag)
			if len(t) > 0 {
				tags = append(tags, t)
			}
		}

		sort.Strings(tags)
	}

	err = d.Set(mkDataSourceVirtualEnvironmentVMStatus, vmStatus.Status)
	diags = append(diags, diag.FromErr(err)...)

	if vmConfig.Template == nil {
		err = d.Set(mkDataSourceVirtualEnvironmentVMTemplate, false)
	} else {
		err = d.Set(mkDataSourceVirtualEnvironmentVMTemplate, *vmConfig.Template)
	}

	diags = append(diags, diag.FromErr(err)...)

	err = d.Set(mkDataSourceVirtualEnvironmentVMTags, tags)
	diags = append(diags, diag.FromErr(err)...)

	d.SetId(strconv.Itoa(vmID))

	return diags
}
`````

## File: proxmoxtf/datasource/vms_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestVMsInstantiation tests whether the dataSourceVirtualEnvironmentVMs instance can be instantiated.
func TestVMsInstantiation(t *testing.T) {
	t.Parallel()

	s := VMs()

	if s == nil {
		t.Fatalf("Cannot instantiate dataSourceVirtualEnvironmentVMs")
	}
}

// TestVMsSchema tests the dataSourceVirtualEnvironmentVMs schema.
func TestVMsSchema(t *testing.T) {
	t.Parallel()

	s := VMs().Schema

	test.AssertComputedAttributes(t, s, []string{
		mkDataSourceVirtualEnvironmentVMs,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentVMNodeName: schema.TypeString,
		mkDataSourceVirtualEnvironmentVMTags:     schema.TypeList,
		mkDataSourceFilter:                       schema.TypeList,
		mkDataSourceVirtualEnvironmentVMs:        schema.TypeList,
	})

	vmsSchema := test.AssertNestedSchemaExistence(t, s, mkDataSourceVirtualEnvironmentVMs)

	test.AssertComputedAttributes(t, vmsSchema, []string{
		mkDataSourceVirtualEnvironmentVMName,
		mkDataSourceVirtualEnvironmentVMTags,
	})

	test.AssertValueTypes(t, vmsSchema, map[string]schema.ValueType{
		mkDataSourceVirtualEnvironmentVMName:     schema.TypeString,
		mkDataSourceVirtualEnvironmentVMNodeName: schema.TypeString,
		mkDataSourceVirtualEnvironmentVMTags:     schema.TypeList,
		mkDataSourceVirtualEnvironmentVMVMID:     schema.TypeInt,
	})

	filterSchema := test.AssertNestedSchemaExistence(t, s, mkDataSourceFilter)
	test.AssertValueTypes(t, filterSchema, map[string]schema.ValueType{
		mkDataSourceFilterName:   schema.TypeString,
		mkDataSourceFilterValues: schema.TypeList,
		mkDataSourceFilterRegex:  schema.TypeBool,
	})
}
`````

## File: proxmoxtf/datasource/vms.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package datasource

import (
	"context"
	"errors"
	"fmt"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"

	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	proxmoxapi "github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkDataSourceVirtualEnvironmentVMs = "vms"
	mkDataSourceFilter                = "filter"
	mkDataSourceFilterName            = "name"
	mkDataSourceFilterValues          = "values"
	mkDataSourceFilterRegex           = "regex"
)

// VMs returns a resource for the Proxmox VMs.
func VMs() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkDataSourceVirtualEnvironmentVMNodeName: {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The node name. All cluster nodes will be queried in case this is omitted",
			},
			mkDataSourceVirtualEnvironmentVMTags: {
				Type:        schema.TypeList,
				Description: "Tags of the VM to match",
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkDataSourceFilter: {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Filter blocks",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDataSourceFilterName: {
							Type:        schema.TypeString,
							Description: "Attribute to filter on. One of [name, template, status, node_name]",
							Required:    true,
						},
						mkDataSourceFilterValues: {
							Type:        schema.TypeList,
							Description: "List of values to pass the filter (OR logic)",
							Required:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						mkDataSourceFilterRegex: {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     false,
							Description: "Treat values as regex patterns",
						},
					},
				},
			},
			mkDataSourceVirtualEnvironmentVMs: {
				Type:        schema.TypeList,
				Description: "VMs",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: VM().Schema,
				},
			},
		},
		ReadContext: vmsRead,
	}
}

// vmRead reads the VMs.
func vmsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)

	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeNames, err := getNodeNames(ctx, d, api)
	if err != nil {
		return diag.FromErr(err)
	}

	var filterTags []string

	tagsData := d.Get(mkDataSourceVirtualEnvironmentVMTags).([]interface{})
	for _, tagData := range tagsData {
		tag := strings.TrimSpace(tagData.(string))
		if len(tag) > 0 {
			filterTags = append(filterTags, tag)
		}
	}

	sort.Strings(filterTags)

	filters := d.Get(mkDataSourceFilter).([]interface{})

	var vms []interface{}

	for _, nodeName := range nodeNames {
		listData, e := api.Node(nodeName).VM(0).ListVMs(ctx)
		if e != nil {
			var httpError *proxmoxapi.HTTPError
			if errors.As(e, &httpError) && httpError.Code == 595 {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Warning,
					Summary:  fmt.Sprintf("node %q is not available - VM list may be incomplete", nodeName),
				})

				continue
			}

			diags = append(diags, diag.FromErr(e)...)
		}

		sort.Slice(listData, func(i, j int) bool {
			return listData[i].VMID < listData[j].VMID
		})

		for _, data := range listData {
			vm := map[string]interface{}{
				mkDataSourceVirtualEnvironmentVMNodeName: nodeName,
				mkDataSourceVirtualEnvironmentVMVMID:     data.VMID,
			}

			if data.Name != nil {
				vm[mkDataSourceVirtualEnvironmentVMName] = *data.Name
			} else {
				vm[mkDataSourceVirtualEnvironmentVMName] = ""
			}

			var tags []string
			if data.Tags != nil && *data.Tags != "" {
				tags = strings.Split(*data.Tags, ";")
				sort.Strings(tags)
				vm[mkDataSourceVirtualEnvironmentVMTags] = tags
			}

			if len(filterTags) > 0 {
				match := true

				for _, tag := range filterTags {
					if !slices.Contains(tags, tag) {
						match = false
						break
					}
				}

				if !match {
					continue
				}
			}

			if data.Template != (*types.CustomBool)(nil) && *data.Template {
				vm[mkDataSourceVirtualEnvironmentVMTemplate] = true
			} else {
				vm[mkDataSourceVirtualEnvironmentVMTemplate] = false
			}

			vm[mkDataSourceVirtualEnvironmentVMStatus] = *data.Status

			if len(filters) > 0 {
				allFiltersMatched, err := checkVMMatchFilters(vm, filters)
				diags = append(diags, diag.FromErr(err)...)

				if !allFiltersMatched {
					continue
				}
			}

			vms = append(vms, vm)
		}
	}

	err = d.Set(mkDataSourceVirtualEnvironmentVMs, vms)
	diags = append(diags, diag.FromErr(err)...)

	d.SetId(uuid.New().String())

	return diags
}

func getNodeNames(ctx context.Context, d *schema.ResourceData, api proxmox.Client) ([]string, error) {
	var nodeNames []string

	nodeName := d.Get(mkDataSourceVirtualEnvironmentVMNodeName).(string)
	if nodeName != "" {
		nodeNames = append(nodeNames, nodeName)
	} else {
		nodes, err := api.Node(nodeName).ListNodes(ctx)
		if err != nil {
			return nil, fmt.Errorf("error listing nodes: %w", err)
		}

		for _, node := range nodes {
			nodeNames = append(nodeNames, node.Name)
		}
	}

	sort.Strings(nodeNames)

	return nodeNames, nil
}

func checkVMMatchFilters(vm map[string]interface{}, filters []interface{}) (bool, error) {
	for _, v := range filters {
		filter := v.(map[string]interface{})
		filterName := filter["name"]
		filterValues := filter["values"].([]interface{})
		filterRegex := filter["regex"].(bool)

		var vmValue string

		switch filterName {
		case "template":
			vmValue = strconv.FormatBool(vm[mkDataSourceVirtualEnvironmentVMTemplate].(bool))
		case "status":
			vmValue = vm[mkDataSourceVirtualEnvironmentVMStatus].(string)
		case "name":
			vmValue = vm[mkDataSourceVirtualEnvironmentVMName].(string)
		case "node_name":
			vmValue = vm[mkDataSourceVirtualEnvironmentVMNodeName].(string)
		default:
			return false, fmt.Errorf(
				"unknown filter name '%s', should be one of [name, template, status, node_name]",
				filterName,
			)
		}

		atLeastOneValueMatched := false

		for _, filterValue := range filterValues {
			if filterRegex {
				r, err := regexp.Compile(filterValue.(string))
				if err != nil {
					return false, fmt.Errorf("error interpreting filter '%s' value '%s' as regex: %w", filterName, filterValue, err)
				}

				if r.MatchString(vmValue) {
					atLeastOneValueMatched = true
					break
				}
			} else if filterValue == vmValue {
				atLeastOneValueMatched = true
				break
			}
		}

		if !atLeastOneValueMatched {
			return false, nil
		}
	}

	return true, nil
}
`````

## File: proxmoxtf/provider/datasources.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package provider

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/datasource"
)

func createDatasourceMap() map[string]*schema.Resource {
	return map[string]*schema.Resource{
		"proxmox_virtual_environment_dns":       datasource.DNS(),
		"proxmox_virtual_environment_group":     datasource.Group(),
		"proxmox_virtual_environment_groups":    datasource.Groups(),
		"proxmox_virtual_environment_hosts":     datasource.Hosts(),
		"proxmox_virtual_environment_node":      datasource.Node(),
		"proxmox_virtual_environment_nodes":     datasource.Nodes(),
		"proxmox_virtual_environment_pool":      datasource.Pool(),
		"proxmox_virtual_environment_pools":     datasource.Pools(),
		"proxmox_virtual_environment_role":      datasource.Role(),
		"proxmox_virtual_environment_roles":     datasource.Roles(),
		"proxmox_virtual_environment_time":      datasource.Time(),
		"proxmox_virtual_environment_user":      datasource.User(),
		"proxmox_virtual_environment_users":     datasource.Users(),
		"proxmox_virtual_environment_vm":        datasource.VM(),
		"proxmox_virtual_environment_vms":       datasource.VMs(),
		"proxmox_virtual_environment_container": datasource.Container(),
	}
}
`````

## File: proxmoxtf/provider/provider_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package provider

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestProviderInstantiation() tests whether the ProxmoxVirtualEnvironment instance can be instantiated.
func TestProviderInstantiation(t *testing.T) {
	t.Parallel()

	s := ProxmoxVirtualEnvironment()
	if s == nil {
		t.Fatalf("Cannot instantiate ProxmoxVirtualEnvironment")
	}
}

// TestProviderSchema() tests the ProxmoxVirtualEnvironment schema.
func TestProviderSchema(t *testing.T) {
	t.Parallel()

	s := ProxmoxVirtualEnvironment().Schema

	test.AssertOptionalArguments(t, s, []string{
		mkProviderEndpoint,
		mkProviderInsecure,
		mkProviderMinTLS,
		mkProviderAuthTicket,
		mkProviderCSRFPreventionToken,
		mkProviderOTP,
		mkProviderUsername,
		mkProviderPassword,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkProviderEndpoint:            schema.TypeString,
		mkProviderInsecure:            schema.TypeBool,
		mkProviderMinTLS:              schema.TypeString,
		mkProviderAuthTicket:          schema.TypeString,
		mkProviderCSRFPreventionToken: schema.TypeString,
		mkProviderOTP:                 schema.TypeString,
		mkProviderUsername:            schema.TypeString,
		mkProviderPassword:            schema.TypeString,
	})

	providerSSHSchema := test.AssertNestedSchemaExistence(t, s, mkProviderSSH)

	// do not limit number of nodes in the cluster
	test.AssertListMaxItems(t, providerSSHSchema, mkProviderSSHNode, 0)
}
`````

## File: proxmoxtf/provider/provider.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package provider

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

// ProxmoxVirtualEnvironment returns the object for this provider.
func ProxmoxVirtualEnvironment() *schema.Provider {
	return &schema.Provider{
		ConfigureContextFunc: providerConfigure,
		DataSourcesMap:       createDatasourceMap(),
		ResourcesMap:         createResourceMap(),
		Schema:               createSchema(),
	}
}

func providerConfigure(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) {
	var err error

	var diags diag.Diagnostics

	var apiClient api.Client

	var sshClient ssh.Client

	var creds api.Credentials

	var conn *api.Connection

	tflog.Info(ctx, "Configuring the SDK Proxmox provider...")

	// Check environment variables
	endpoint := utils.GetAnyStringEnv("PROXMOX_VE_ENDPOINT", "PM_VE_ENDPOINT")
	insecure := utils.GetAnyBoolEnv("PROXMOX_VE_INSECURE", "PM_VE_INSECURE")
	minTLS := utils.GetAnyStringEnv("PROXMOX_VE_MIN_TLS", "PM_VE_MIN_TLS")
	authTicket := utils.GetAnyStringEnv("PROXMOX_VE_AUTH_TICKET", "PM_VE_AUTH_TICKET")
	csrfPreventionToken := utils.GetAnyStringEnv("PROXMOX_VE_CSRF_PREVENTION_TOKEN", "PM_VE_CSRF_PREVENTION_TOKEN")
	apiToken := utils.GetAnyStringEnv("PROXMOX_VE_API_TOKEN", "PM_VE_API_TOKEN")
	otp := utils.GetAnyStringEnv("PROXMOX_VE_OTP", "PM_VE_OTP")
	username := utils.GetAnyStringEnv("PROXMOX_VE_USERNAME", "PM_VE_USERNAME")
	password := utils.GetAnyStringEnv("PROXMOX_VE_PASSWORD", "PM_VE_PASSWORD")

	if v, ok := d.GetOk(mkProviderEndpoint); ok {
		endpoint = v.(string)
	}

	if v, ok := d.GetOk(mkProviderInsecure); ok {
		insecure = v.(bool)
	}

	if v, ok := d.GetOk(mkProviderMinTLS); ok {
		minTLS = v.(string)
	}

	if v, ok := d.GetOk(mkProviderAuthTicket); ok {
		authTicket = v.(string)
	}

	if v, ok := d.GetOk(mkProviderCSRFPreventionToken); ok {
		csrfPreventionToken = v.(string)
	}

	//nolint:staticcheck
	if v, ok := d.GetOkExists(mkProviderAPIToken); ok {
		apiToken = v.(string)
	}

	if v, ok := d.GetOk(mkProviderOTP); ok {
		otp = v.(string)
	}

	///nolint:staticcheck
	if v, ok := d.GetOkExists(mkProviderUsername); ok {
		username = v.(string)
	}

	//nolint:staticcheck
	if v, ok := d.GetOkExists(mkProviderPassword); ok {
		password = v.(string)
	}

	creds, err = api.NewCredentials(username, password, otp, apiToken, authTicket, csrfPreventionToken)
	diags = append(diags, diag.FromErr(err)...)

	conn, err = api.NewConnection(endpoint, insecure, minTLS)
	diags = append(diags, diag.FromErr(err)...)

	if diags.HasError() {
		return nil, diags
	}

	apiClient, err = api.NewClient(creds, conn)
	if err != nil {
		return nil, diag.Errorf("error creating virtual environment client: %s", err)
	}

	// ////////////////////////////////////////////////////////////////////////////////////

	sshConf := map[string]interface{}{}

	sshBlock := d.Get(mkProviderSSH).([]interface{})
	if len(sshBlock) > 0 {
		sshConf = sshBlock[0].(map[string]interface{})
	}

	sshUsername := utils.GetAnyStringEnv("PROXMOX_VE_SSH_USERNAME", "PM_VE_SSH_USERNAME")
	sshPassword := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PASSWORD", "PM_VE_SSH_PASSWORD")
	sshAgent := utils.GetAnyBoolEnv("PROXMOX_VE_SSH_AGENT", "PM_VE_SSH_AGENT")
	sshAgentSocket := utils.GetAnyStringEnv("SSH_AUTH_SOCK", "PROXMOX_VE_SSH_AUTH_SOCK", "PM_VE_SSH_AUTH_SOCK")
	sshPrivateKey := utils.GetAnyStringEnv("PROXMOX_VE_SSH_PRIVATE_KEY")
	sshSocks5Server := utils.GetAnyStringEnv("PROXMOX_VE_SSH_SOCKS5_SERVER")
	sshSocks5Username := utils.GetAnyStringEnv("PROXMOX_VE_SSH_SOCKS5_USERNAME")
	sshSocks5Password := utils.GetAnyStringEnv("PROXMOX_VE_SSH_SOCKS5_PASSWORD")

	if v, ok := sshConf[mkProviderSSHUsername]; !ok || v.(string) == "" {
		switch {
		case sshUsername != "":
			sshConf[mkProviderSSHUsername] = sshUsername
		case creds.UserCredentials != nil:
			sshConf[mkProviderSSHUsername] = strings.Split(creds.UserCredentials.Username, "@")[0]
		default:
			sshConf[mkProviderSSHUsername] = ""
		}
	}

	if v, ok := sshConf[mkProviderSSHPassword]; !ok || v.(string) == "" {
		switch {
		case sshPassword != "":
			sshConf[mkProviderSSHPassword] = sshPassword
		case creds.UserCredentials != nil:
			sshConf[mkProviderSSHPassword] = creds.UserCredentials.Password
		default:
			sshConf[mkProviderSSHPassword] = ""
		}
	}

	if _, ok := sshConf[mkProviderSSHAgent]; !ok {
		sshConf[mkProviderSSHAgent] = sshAgent
	}

	if v, ok := sshConf[mkProviderSSHAgentSocket]; !ok || v.(string) == "" {
		sshConf[mkProviderSSHAgentSocket] = sshAgentSocket
	}

	if v, ok := sshConf[mkProviderSSHPrivateKey]; !ok || v.(string) == "" {
		sshConf[mkProviderSSHPrivateKey] = sshPrivateKey
	}

	if v, ok := sshConf[mkProviderSSHSocks5Server]; !ok || v.(string) == "" {
		sshConf[mkProviderSSHSocks5Server] = sshSocks5Server
	}

	if v, ok := sshConf[mkProviderSSHSocks5Username]; !ok || v.(string) == "" {
		sshConf[mkProviderSSHSocks5Username] = sshSocks5Username
	}

	if v, ok := sshConf[mkProviderSSHSocks5Password]; !ok || v.(string) == "" {
		sshConf[mkProviderSSHSocks5Password] = sshSocks5Password
	}

	nodeOverrides := map[string]ssh.ProxmoxNode{}

	if ns, ok := sshConf[mkProviderSSHNode]; ok {
		for _, n := range ns.([]interface{}) {
			node := n.(map[string]interface{})
			nodeOverrides[node[mkProviderSSHNodeName].(string)] = ssh.ProxmoxNode{
				Address: node[mkProviderSSHNodeAddress].(string),

				Port: int32(node[mkProviderSSHNodePort].(int)),
			}
		}
	}

	sshClient, err = ssh.NewClient(
		sshConf[mkProviderSSHUsername].(string),
		sshConf[mkProviderSSHPassword].(string),
		sshConf[mkProviderSSHAgent].(bool),
		sshConf[mkProviderSSHAgentSocket].(string),
		sshConf[mkProviderSSHPrivateKey].(string),
		sshConf[mkProviderSSHSocks5Server].(string),
		sshConf[mkProviderSSHSocks5Username].(string),
		sshConf[mkProviderSSHSocks5Password].(string),
		&apiResolverWithOverrides{
			ar:        apiResolver{c: apiClient},
			overrides: nodeOverrides,
		},
	)
	if err != nil {
		return nil, diag.Errorf("error creating SSH client: %s", err)
	}

	// Intentionally use 'PROXMOX_VE_TMPDIR' with 'TMP' instead of 'TEMP', to match os.TempDir's use of $TMPDIR
	tmpDirOverride := utils.GetAnyStringEnv("PROXMOX_VE_TMPDIR", "PM_VE_TMPDIR")

	if v, ok := d.GetOk(mkProviderTmpDir); ok {
		tmpDirOverride = v.(string)
	}

	idCfg := cluster.IDGeneratorConfig{}

	if v, ok := d.GetOk(mkProviderRandomVMIDs); ok {
		idCfg.RandomIDs = v.(bool)
	}

	if v, ok := d.GetOk(mkProviderRandomVMIDStart); ok {
		idCfg.RandomIDStat = v.(int)
	}

	if v, ok := d.GetOk(mkProviderRandomVMIDEnd); ok {
		idCfg.RandomIDEnd = v.(int)
	}

	config, err := proxmoxtf.NewProviderConfiguration(apiClient, sshClient, tmpDirOverride, idCfg)
	if err != nil {
		return nil, diag.Errorf("error creating provider's configuration: %s", err)
	}

	return config, nil
}

type apiResolver struct {
	c api.Client
}

func (r *apiResolver) Resolve(ctx context.Context, nodeName string) (ssh.ProxmoxNode, error) {
	nc := &nodes.Client{Client: r.c, NodeName: nodeName}

	networkDevices, err := nc.ListNetworkInterfaces(ctx)
	if err != nil {
		return ssh.ProxmoxNode{}, fmt.Errorf("failed to list network devices of node %q: %w", nc.NodeName, err)
	}

	nodeAddress := ""

	// try IPv4 address on the interface with IPv4 gateway
	tflog.Debug(ctx, "Attempting to find interfaces with both a static IPV4 address and gateway.")

	for _, d := range networkDevices {
		if d.Gateway != nil && d.Address != nil {
			nodeAddress = *d.Address
			break
		}
	}

	if nodeAddress == "" {
		// fallback 1: try IPv6 address on the interface with IPv6 gateway
		tflog.Debug(ctx, "Attempting to find interfaces with both a static IPV6 address and gateway.")

		for _, d := range networkDevices {
			if d.Gateway6 != nil && d.Address6 != nil {
				nodeAddress = *d.Address6
				break
			}
		}
	}

	if nodeAddress == "" {
		// fallback 2: use first interface with any IPv4 address
		tflog.Debug(ctx, "Attempting to find interfaces with at least a static IPV4 address.")

		for _, d := range networkDevices {
			if d.Address != nil {
				nodeAddress = *d.Address
				break
			}
		}
	}

	if nodeAddress == "" {
		// fallback 3: do a good old DNS lookup
		tflog.Debug(ctx, fmt.Sprintf("Attempting a DNS lookup of node %q.", nc.NodeName))

		ips, err := net.LookupIP(nodeName)
		if err == nil {
			for _, ip := range ips {
				if ipv4 := ip.To4(); ipv4 != nil {
					nodeAddress = ipv4.String()
					break
				}
			}
		} else {
			tflog.Debug(ctx, fmt.Sprintf("Failed to do a DNS lookup of the node: %s", err.Error()))
		}
	}

	if nodeAddress == "" {
		return ssh.ProxmoxNode{}, fmt.Errorf("failed to determine the IP address of node \"%s\"", nc.NodeName)
	}

	nodeAddressParts := strings.Split(nodeAddress, "/")
	node := ssh.ProxmoxNode{Address: nodeAddressParts[0], Port: 22}

	return node, nil
}

type apiResolverWithOverrides struct {
	ar        apiResolver
	overrides map[string]ssh.ProxmoxNode
}

func (r *apiResolverWithOverrides) Resolve(ctx context.Context, nodeName string) (ssh.ProxmoxNode, error) {
	if node, ok := r.overrides[nodeName]; ok {
		return node, nil
	}

	return r.ar.Resolve(ctx, nodeName)
}
`````

## File: proxmoxtf/provider/resources.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package provider

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource"
	clusterfirewall "github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/cluster/firewall"
	container "github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/container"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/firewall"
	vm "github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm"
)

func createResourceMap() map[string]*schema.Resource {
	return map[string]*schema.Resource{
		"proxmox_virtual_environment_certificate":                     resource.Certificate(),
		"proxmox_virtual_environment_cluster_firewall":                clusterfirewall.Firewall(),
		"proxmox_virtual_environment_cluster_firewall_security_group": clusterfirewall.SecurityGroup(),
		"proxmox_virtual_environment_container":                       container.Container(),
		"proxmox_virtual_environment_dns":                             resource.DNS(),
		"proxmox_virtual_environment_file":                            resource.File(),
		"proxmox_virtual_environment_firewall_alias":                  firewall.Alias(),
		"proxmox_virtual_environment_firewall_ipset":                  firewall.IPSet(),
		"proxmox_virtual_environment_firewall_options":                firewall.Options(),
		"proxmox_virtual_environment_firewall_rules":                  firewall.Rules(),
		"proxmox_virtual_environment_group":                           resource.Group(),
		"proxmox_virtual_environment_hosts":                           resource.Hosts(),
		"proxmox_virtual_environment_pool":                            resource.Pool(),
		"proxmox_virtual_environment_role":                            resource.Role(),
		"proxmox_virtual_environment_time":                            resource.Time(),
		"proxmox_virtual_environment_user":                            resource.User(),
		"proxmox_virtual_environment_vm":                              vm.VM(),
	}
}
`````

## File: proxmoxtf/provider/schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package provider

import (
	"os"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

const (
	mkProviderEndpoint            = "endpoint"
	mkProviderInsecure            = "insecure"
	mkProviderMinTLS              = "min_tls"
	mkProviderAuthTicket          = "auth_ticket"
	mkProviderCSRFPreventionToken = "csrf_prevention_token" // #nosec G101
	mkProviderAPIToken            = "api_token"
	mkProviderOTP                 = "otp"
	mkProviderPassword            = "password"
	mkProviderUsername            = "username"
	mkProviderTmpDir              = "tmp_dir"
	mkProviderRandomVMIDs         = "random_vm_ids"
	mkProviderRandomVMIDStart     = "random_vm_id_start"
	mkProviderRandomVMIDEnd       = "random_vm_id_end"
	mkProviderSSH                 = "ssh"
	mkProviderSSHUsername         = "username"
	mkProviderSSHPassword         = "password"
	mkProviderSSHAgent            = "agent"
	mkProviderSSHAgentSocket      = "agent_socket"
	mkProviderSSHPrivateKey       = "private_key"
	mkProviderSSHSocks5Server     = "socks5_server"
	mkProviderSSHSocks5Username   = "socks5_username"
	mkProviderSSHSocks5Password   = "socks5_password"

	mkProviderSSHNode        = "node"
	mkProviderSSHNodeName    = "name"
	mkProviderSSHNodeAddress = "address"
	mkProviderSSHNodePort    = "port"
)

func createSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		mkProviderEndpoint: {
			Type:         schema.TypeString,
			Optional:     true,
			Description:  "The endpoint for the Proxmox VE API.",
			ValidateFunc: validation.IsURLWithHTTPorHTTPS,
		},
		mkProviderInsecure: {
			Type:        schema.TypeBool,
			Optional:    true,
			Description: "Whether to skip the TLS verification step.",
		},
		mkProviderMinTLS: {
			Type:     schema.TypeString,
			Optional: true,
			Description: "The minimum required TLS version for API calls." +
				"Supported values: `1.0|1.1|1.2|1.3`. Defaults to `1.3`.",
		},
		mkProviderAuthTicket: {
			Type:         schema.TypeString,
			Optional:     true,
			Sensitive:    true,
			Description:  "The pre-authenticated Ticket for the Proxmox VE API.",
			ValidateFunc: validation.StringIsNotEmpty,
		},
		mkProviderCSRFPreventionToken: {
			Type:         schema.TypeString,
			Optional:     true,
			Sensitive:    true,
			Description:  "The pre-authenticated CSRF Prevention Token for the Proxmox VE API.",
			ValidateFunc: validation.StringIsNotEmpty,
		},
		mkProviderAPIToken: {
			Type:        schema.TypeString,
			Optional:    true,
			Sensitive:   true,
			Description: "The API token for the Proxmox VE API.",
			// note: we allow empty string as a valid value, as it is used to unset the token in tests
		},
		mkProviderOTP: {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "The one-time password for the Proxmox VE API.",
			Deprecated: "The `otp` attribute is deprecated and will be removed in a future release. " +
				"Please use the `api_token` attribute instead.",
		},
		mkProviderUsername: {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "The username for the Proxmox VE API.",
			// note: we allow empty string as a valid value, as it is used to unset the username in tests
		},
		mkProviderPassword: {
			Type:        schema.TypeString,
			Optional:    true,
			Sensitive:   true,
			Description: "The password for the Proxmox VE API.",
			// note: we allow empty string as a valid value, as it is used to unset the password in tests
		},
		mkProviderSSH: {
			Type:        schema.TypeList,
			Optional:    true,
			MaxItems:    1,
			Description: "The SSH configuration for the Proxmox nodes.",
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkProviderSSHUsername: {
						Type:     schema.TypeString,
						Optional: true,
						Description: "The username used for the SSH connection. " +
							"Defaults to the value of the `username` field of the " +
							"`provider` block.",
						DefaultFunc: schema.MultiEnvDefaultFunc(
							[]string{"PROXMOX_VE_SSH_USERNAME", "PM_VE_SSH_USERNAME"},
							nil,
						),
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkProviderSSHPassword: {
						Type:      schema.TypeString,
						Optional:  true,
						Sensitive: true,
						Description: "The password used for the SSH connection. " +
							"Defaults to the value of the `password` field of the " +
							"`provider` block.",
						DefaultFunc: schema.MultiEnvDefaultFunc(
							[]string{"PROXMOX_VE_SSH_PASSWORD", "PM_VE_SSH_PASSWORD"},
							nil,
						),
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkProviderSSHAgent: {
						Type:     schema.TypeBool,
						Optional: true,
						Description: "Whether to use the SSH agent for authentication. Takes precedence over " +
							"the `private_key` and `password` fields. Defaults to the value of the " +
							"`PROXMOX_VE_SSH_AGENT` environment variable, or `false` if not set.",
						DefaultFunc: func() (interface{}, error) {
							for _, k := range []string{"PROXMOX_VE_SSH_AGENT", "PM_VE_SSH_AGENT"} {
								v := os.Getenv(k)

								if v == "true" || v == "1" {
									return true, nil
								}
							}

							return false, nil
						},
					},
					mkProviderSSHAgentSocket: {
						Type:     schema.TypeString,
						Optional: true,
						Description: "The path to the SSH agent socket. Defaults to the value of the `SSH_AUTH_SOCK` " +
							"environment variable.",
						DefaultFunc: schema.MultiEnvDefaultFunc(
							[]string{"SSH_AUTH_SOCK", "PROXMOX_VE_SSH_AUTH_SOCK", "PM_VE_SSH_AUTH_SOCK"},
							nil,
						),
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkProviderSSHPrivateKey: {
						Type:      schema.TypeString,
						Optional:  true,
						Sensitive: true,
						Description: "The unencrypted private key (in PEM format) used for the SSH connection. " +
							"Defaults to the value of the `PROXMOX_VE_SSH_PRIVATE_KEY` environment variable.",
					},
					mkProviderSSHSocks5Server: {
						Type:     schema.TypeString,
						Optional: true,
						Description: "The address:port of the SOCKS5 proxy server. " +
							"Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_SERVER` environment variable.",
						DefaultFunc: schema.MultiEnvDefaultFunc(
							[]string{"PROXMOX_VE_SSH_SOCKS5_SERVER"},
							nil,
						),
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkProviderSSHSocks5Username: {
						Type:     schema.TypeString,
						Optional: true,
						Description: "The username for the SOCKS5 proxy server. " +
							"Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_USERNAME` environment variable.",
						DefaultFunc: schema.MultiEnvDefaultFunc(
							[]string{"PROXMOX_VE_SSH_SOCKS5_USERNAME"},
							nil,
						),
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkProviderSSHSocks5Password: {
						Type:      schema.TypeString,
						Optional:  true,
						Sensitive: true,
						Description: "The password for the SOCKS5 proxy server. " +
							"Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_PASSWORD` environment variable.",
						DefaultFunc: schema.MultiEnvDefaultFunc(
							[]string{"PROXMOX_VE_SSH_SOCKS5_PASSWORD"},
							nil,
						),
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkProviderSSHNode: {
						Type:        schema.TypeList,
						Optional:    true,
						MinItems:    0,
						Description: "Overrides for SSH connection configuration for a Proxmox VE node.",
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								mkProviderSSHNodeName: {
									Type:         schema.TypeString,
									Required:     true,
									Description:  "The name of the Proxmox VE node.",
									ValidateFunc: validation.StringIsNotEmpty,
								},
								mkProviderSSHNodeAddress: {
									Type:         schema.TypeString,
									Required:     true,
									Description:  "The address of the Proxmox VE node.",
									ValidateFunc: validation.StringIsNotEmpty,
								},
								mkProviderSSHNodePort: {
									Type:         schema.TypeInt,
									Optional:     true,
									Description:  "The port of the Proxmox VE node.",
									Default:      22,
									ValidateFunc: validation.IsPortNumber,
								},
							},
						},
					},
				},
			},
		},
		mkProviderTmpDir: {
			Type:         schema.TypeString,
			Optional:     true,
			Description:  "The alternative temporary directory.",
			ValidateFunc: validation.StringIsNotEmpty,
		},
		mkProviderRandomVMIDs: {
			Type:        schema.TypeBool,
			Optional:    true,
			Description: "Whether to generate random VM / Container IDs.",
		},
		mkProviderRandomVMIDStart: {
			Type:         schema.TypeInt,
			Optional:     true,
			Description:  "The starting number for random VM / Container IDs.",
			ValidateFunc: validation.IntBetween(100, 999999999),
		},
		mkProviderRandomVMIDEnd: {
			Type:         schema.TypeInt,
			Optional:     true,
			Description:  "The ending number for random VM / Container IDs.",
			ValidateFunc: validation.IntBetween(100, 999999999),
		},
	}
}
`````

## File: proxmoxtf/resource/cluster/firewall/firewall.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
)

const (
	dvLogRatelimiEnabled = true
	dvLogRatelimitBurst  = 5
	dvLogRatelimitRate   = "1/second"
	dvPolicyIn           = "DROP"
	dvPolicyOut          = "ACCEPT"

	mkEBTables            = "ebtables"
	mkEnabled             = "enabled"
	mkLogRatelimit        = "log_ratelimit"
	mkLogRatelimitEnabled = "enabled"
	mkLogRatelimitBurst   = "burst"
	mkLogRatelimitRate    = "rate"
	mkPolicyIn            = "input_policy"
	mkPolicyOut           = "output_policy"
)

// Firewall returns a resource to manage firewall options.
func Firewall() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkEBTables: {
				Type:        schema.TypeBool,
				Description: "Enable ebtables cluster-wide",
				Optional:    true,
			},
			mkEnabled: {
				Type:        schema.TypeBool,
				Description: "Enable or disable the firewall cluster-wide",
				Optional:    true,
			},
			mkLogRatelimit: {
				Type:        schema.TypeList,
				Description: "Log ratelimiting settings",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{
						map[string]interface{}{
							mkLogRatelimitEnabled: dvLogRatelimiEnabled,
							mkLogRatelimitBurst:   dvLogRatelimitBurst,
							mkLogRatelimitRate:    dvLogRatelimitRate,
						},
					}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkLogRatelimitEnabled: {
							Type:        schema.TypeBool,
							Description: "Enable or disable log ratelimiting",
							Optional:    true,
							Default:     dvLogRatelimiEnabled,
						},
						mkLogRatelimitBurst: {
							Type:        schema.TypeInt,
							Description: "Initial burst of packages which will always get logged before the rate is applied",
							Optional:    true,
							Default:     dvLogRatelimitBurst,
						},
						mkLogRatelimitRate: {
							Type:             schema.TypeString,
							Description:      "Frequency with which the burst bucket gets refilled",
							Optional:         true,
							Default:          dvLogRatelimitRate,
							ValidateDiagFunc: validators.FirewallRate(),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkPolicyIn: {
				Type:             schema.TypeString,
				Description:      "Default policy for incoming traffic",
				Optional:         true,
				Default:          dvPolicyIn,
				ValidateDiagFunc: validators.FirewallPolicy(),
			},
			mkPolicyOut: {
				Type:             schema.TypeString,
				Description:      "Default policy for outgoing traffic",
				Optional:         true,
				Default:          dvPolicyOut,
				ValidateDiagFunc: validators.FirewallPolicy(),
			},
		},
		CreateContext: selectFirewallAPI(firewallCreate),
		ReadContext:   selectFirewallAPI(firewallRead),
		UpdateContext: selectFirewallAPI(firewallUpdate),
		DeleteContext: selectFirewallAPI(firewallDelete),
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func firewallCreate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	diags := setOptions(ctx, api, d)
	if diags.HasError() {
		return diags
	}

	return firewallRead(ctx, api, d)
}

func setOptions(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	policyIn := d.Get(mkPolicyIn).(string)
	policyOut := d.Get(mkPolicyOut).(string)
	body := &firewall.OptionsPutRequestBody{
		PolicyIn:  &policyIn,
		PolicyOut: &policyOut,
	}

	logRatelimit := d.Get(mkLogRatelimit).([]interface{})
	if len(logRatelimit) > 0 {
		m := logRatelimit[0].(map[string]interface{})
		burst := m[mkLogRatelimitBurst].(int)
		rate := m[mkLogRatelimitRate].(string)
		rl := firewall.CustomLogRateLimit{
			Enable: types.CustomBool(m[mkLogRatelimitEnabled].(bool)),
			Burst:  &burst,
			Rate:   &rate,
		}
		body.LogRateLimit = &rl
	}

	ebtablesBool := types.CustomBool(d.Get(mkEBTables).(bool))
	body.EBTables = &ebtablesBool

	enabledBool := types.CustomBool(d.Get(mkEnabled).(bool))
	body.Enable = &enabledBool

	err := api.SetGlobalOptions(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("cluster-firewall")

	return nil
}

func firewallRead(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	var diags diag.Diagnostics

	options, err := api.GetGlobalOptions(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if options.EBTables != nil {
		err = d.Set(mkEBTables, *options.EBTables)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.Enable != nil {
		err = d.Set(mkEnabled, *options.Enable)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.LogRateLimit != nil {
		err = d.Set(mkLogRatelimit, []interface{}{
			map[string]interface{}{
				mkLogRatelimitEnabled: options.LogRateLimit.Enable,
				mkLogRatelimitBurst:   *options.LogRateLimit.Burst,
				mkLogRatelimitRate:    *options.LogRateLimit.Rate,
			},
		})
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.PolicyIn != nil {
		err = d.Set(mkPolicyIn, *options.PolicyIn)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.PolicyOut != nil {
		err = d.Set(mkPolicyOut, *options.PolicyOut)
		diags = append(diags, diag.FromErr(err)...)
	}

	return diags
}

func firewallUpdate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	diags := setOptions(ctx, api, d)
	if diags.HasError() {
		return diags
	}

	return firewallRead(ctx, api, d)
}

func firewallDelete(_ context.Context, _ firewall.API, d *schema.ResourceData) diag.Diagnostics {
	d.SetId("")

	return nil
}

func selectFirewallAPI(
	f func(context.Context, firewall.API, *schema.ResourceData) diag.Diagnostics,
) func(context.Context, *schema.ResourceData, interface{}) diag.Diagnostics {
	return func(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		config := m.(proxmoxtf.ProviderConfiguration)

		api, err := config.GetClient()
		if err != nil {
			return diag.FromErr(err)
		}

		return f(ctx, api.Cluster().Firewall(), d)
	}
}
`````

## File: proxmoxtf/resource/cluster/firewall/security_group_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestSecurityGroupInstantiation tests whether the SecurityGroup instance can be instantiated.
func TestSecurityGroupInstantiation(t *testing.T) {
	t.Parallel()
	require.NotNilf(t, SecurityGroup(), "Cannot instantiate SecurityGroup")
}

// TestSecurityGroupSchema tests the SecurityGroup Schema.
func TestSecurityGroupSchema(t *testing.T) {
	t.Parallel()

	s := SecurityGroup().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkSecurityGroupName,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkSecurityGroupComment,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkSecurityGroupName:    schema.TypeString,
		mkSecurityGroupComment: schema.TypeString,
	})

	test.AssertNestedSchemaExistence(t, s, firewall.MkRule)
}
`````

## File: proxmoxtf/resource/cluster/firewall/security_group.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	clusterfirewall "github.com/bpg/terraform-provider-proxmox/proxmox/cluster/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
)

const (
	dvSecurityGroupComment = ""

	mkSecurityGroupName    = "name"
	mkSecurityGroupComment = "comment"
)

// SecurityGroup returns a resource to manage security groups.
func SecurityGroup() *schema.Resource {
	s := map[string]*schema.Schema{
		mkSecurityGroupName: {
			Type:        schema.TypeString,
			Description: "Security group name",
			Required:    true,
			ForceNew:    false,
		},
		mkSecurityGroupComment: {
			Type:        schema.TypeString,
			Description: "Security group comment",
			Optional:    true,
			Default:     dvSecurityGroupComment,
		},
	}

	structure.MergeSchema(s, firewall.Rules().Schema)

	return &schema.Resource{
		Schema:        s,
		CreateContext: selectFirewallAPI(SecurityGroupCreate),
		ReadContext:   selectFirewallAPI(SecurityGroupRead),
		UpdateContext: selectFirewallAPI(SecurityGroupUpdate),
		DeleteContext: selectFirewallAPI(SecurityGroupDelete),
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

// SecurityGroupCreate creates a new security group.
func SecurityGroupCreate(ctx context.Context, api clusterfirewall.API, d *schema.ResourceData) diag.Diagnostics {
	comment := d.Get(mkSecurityGroupComment).(string)
	name := d.Get(mkSecurityGroupName).(string)

	body := &clusterfirewall.GroupCreateRequestBody{
		Comment: &comment,
		Group:   name,
	}

	err := api.CreateGroup(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	diags := firewall.RulesCreate(ctx, api.SecurityGroup(name), d)
	if diags.HasError() {
		return diags
	}

	d.SetId(name)

	return SecurityGroupRead(ctx, api, d)
}

// SecurityGroupRead reads the security group from the API and updates the state.
func SecurityGroupRead(ctx context.Context, api clusterfirewall.API, d *schema.ResourceData) diag.Diagnostics {
	diags := diag.Diagnostics{}

	name := d.Id()

	allGroups, err := api.ListGroups(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	for _, v := range allGroups {
		if v.Group == name {
			err = d.Set(mkSecurityGroupName, v.Group)
			diags = append(diags, diag.FromErr(err)...)
			err = d.Set(mkSecurityGroupComment, v.Comment)
			diags = append(diags, diag.FromErr(err)...)

			break
		}
	}

	if diags.HasError() {
		return diags
	}

	return firewall.RulesRead(ctx, api.SecurityGroup(name), d)
}

// SecurityGroupUpdate updates a security group.
func SecurityGroupUpdate(ctx context.Context, api clusterfirewall.API, d *schema.ResourceData) diag.Diagnostics {
	comment := d.Get(mkSecurityGroupComment).(string)
	newName := d.Get(mkSecurityGroupName).(string)
	previousName := d.Id()

	body := &clusterfirewall.GroupUpdateRequestBody{
		Group:   newName,
		ReName:  &previousName,
		Comment: &comment,
	}

	err := api.UpdateGroup(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	diags := firewall.RulesUpdate(ctx, api.SecurityGroup(previousName), d)
	if diags.HasError() {
		return diags
	}

	d.SetId(newName)

	return SecurityGroupRead(ctx, api, d)
}

// SecurityGroupDelete deletes a security group.
func SecurityGroupDelete(ctx context.Context, api clusterfirewall.API, d *schema.ResourceData) diag.Diagnostics {
	group := d.Id()

	diags := firewall.RulesDelete(ctx, api.SecurityGroup(group), d)
	if diags.HasError() {
		return diags
	}

	err := api.DeleteGroup(ctx, group)
	if err != nil {
		if strings.Contains(err.Error(), "no such security group") {
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/container/container_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestContainerInstantiation tests whether the Container instance can be instantiated.
func TestContainerInstantiation(t *testing.T) {
	t.Parallel()

	s := Container()
	if s == nil {
		t.Fatalf("Cannot instantiate Container")
	}
}

// TestContainerSchema tests the Container schema.
func TestContainerSchema(t *testing.T) {
	t.Parallel()

	s := Container().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkNodeName,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkCPU,
		mkDescription,
		mkDisk,
		mkInitialization,
		mkHookScriptFileID,
		mkMemory,
		mkDevicePassthrough,
		mkMountPoint,
		mkOperatingSystem,
		mkPoolID,
		mkProtection,
		mkStarted,
		mkTags,
		mkTemplate,
		mkUnprivileged,
		mkStartOnBoot,
		mkFeatures,
		mkVMID,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkCPU:               schema.TypeList,
		mkDescription:       schema.TypeString,
		mkDisk:              schema.TypeList,
		mkInitialization:    schema.TypeList,
		mkHookScriptFileID:  schema.TypeString,
		mkMemory:            schema.TypeList,
		mkDevicePassthrough: schema.TypeList,
		mkMountPoint:        schema.TypeList,
		mkOperatingSystem:   schema.TypeList,
		mkPoolID:            schema.TypeString,
		mkProtection:        schema.TypeBool,
		mkStarted:           schema.TypeBool,
		mkTags:              schema.TypeList,
		mkTemplate:          schema.TypeBool,
		mkUnprivileged:      schema.TypeBool,
		mkStartOnBoot:       schema.TypeBool,
		mkFeatures:          schema.TypeList,
		mkVMID:              schema.TypeInt,
	})

	cloneSchema := test.AssertNestedSchemaExistence(t, s, mkClone)

	test.AssertRequiredArguments(t, cloneSchema, []string{
		mkCloneVMID,
	})

	test.AssertOptionalArguments(t, cloneSchema, []string{
		mkCloneDatastoreID,
		mkCloneNodeName,
	})

	test.AssertValueTypes(t, cloneSchema, map[string]schema.ValueType{
		mkCloneDatastoreID: schema.TypeString,
		mkCloneNodeName:    schema.TypeString,
		mkCloneVMID:        schema.TypeInt,
	})

	cpuSchema := test.AssertNestedSchemaExistence(t, s, mkCPU)

	test.AssertOptionalArguments(t, cpuSchema, []string{
		mkCPUArchitecture,
		mkCPUCores,
		mkCPUUnits,
	})

	test.AssertValueTypes(t, cpuSchema, map[string]schema.ValueType{
		mkCPUArchitecture: schema.TypeString,
		mkCPUCores:        schema.TypeInt,
		mkCPUUnits:        schema.TypeInt,
	})

	diskSchema := test.AssertNestedSchemaExistence(t, s, mkDisk)

	test.AssertOptionalArguments(t, diskSchema, []string{
		mkDiskDatastoreID,
	})

	test.AssertValueTypes(t, diskSchema, map[string]schema.ValueType{
		mkDiskDatastoreID: schema.TypeString,
	})

	featuresSchema := test.AssertNestedSchemaExistence(t, s, mkFeatures)

	test.AssertOptionalArguments(t, featuresSchema, []string{
		mkFeaturesNesting,
		mkFeaturesKeyControl,
		mkFeaturesFUSE,
	})

	test.AssertValueTypes(t, featuresSchema, map[string]schema.ValueType{
		mkFeaturesNesting:    schema.TypeBool,
		mkFeaturesKeyControl: schema.TypeBool,
		mkFeaturesFUSE:       schema.TypeBool,
	})

	initializationSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		mkInitialization,
	)

	test.AssertOptionalArguments(t, initializationSchema, []string{
		mkInitializationDNS,
		mkInitializationHostname,
		mkInitializationIPConfig,
		mkInitializationUserAccount,
	})

	test.AssertValueTypes(t, initializationSchema, map[string]schema.ValueType{
		mkInitializationDNS:         schema.TypeList,
		mkInitializationHostname:    schema.TypeString,
		mkInitializationIPConfig:    schema.TypeList,
		mkInitializationUserAccount: schema.TypeList,
	})

	initializationDNSSchema := test.AssertNestedSchemaExistence(
		t,
		initializationSchema,
		mkInitializationDNS,
	)

	test.AssertOptionalArguments(t, initializationDNSSchema, []string{
		mkInitializationDNSDomain,
		mkInitializationDNSServer,
		mkInitializationDNSServers,
	})

	test.AssertValueTypes(t, initializationDNSSchema, map[string]schema.ValueType{
		mkInitializationDNSDomain:  schema.TypeString,
		mkInitializationDNSServer:  schema.TypeString,
		mkInitializationDNSServers: schema.TypeList,
	})

	initializationIPConfigSchema := test.AssertNestedSchemaExistence(
		t,
		initializationSchema,
		mkInitializationIPConfig,
	)

	test.AssertOptionalArguments(t, initializationIPConfigSchema, []string{
		mkInitializationIPConfigIPv4,
		mkInitializationIPConfigIPv6,
	})

	test.AssertValueTypes(t, initializationIPConfigSchema, map[string]schema.ValueType{
		mkInitializationIPConfigIPv4: schema.TypeList,
		mkInitializationIPConfigIPv6: schema.TypeList,
	})

	initializationIPConfigIPv4Schema := test.AssertNestedSchemaExistence(
		t,
		initializationIPConfigSchema,
		mkInitializationIPConfigIPv4,
	)

	test.AssertOptionalArguments(t, initializationIPConfigIPv4Schema, []string{
		mkInitializationIPConfigIPv4Address,
		mkInitializationIPConfigIPv4Gateway,
	})

	test.AssertValueTypes(t, initializationIPConfigIPv4Schema, map[string]schema.ValueType{
		mkInitializationIPConfigIPv4Address: schema.TypeString,
		mkInitializationIPConfigIPv4Gateway: schema.TypeString,
	})

	initializationIPConfigIPv6Schema := test.AssertNestedSchemaExistence(
		t,
		initializationIPConfigSchema,
		mkInitializationIPConfigIPv6,
	)

	test.AssertOptionalArguments(t, initializationIPConfigIPv6Schema, []string{
		mkInitializationIPConfigIPv6Address,
		mkInitializationIPConfigIPv6Gateway,
	})

	test.AssertValueTypes(t, initializationIPConfigIPv6Schema, map[string]schema.ValueType{
		mkInitializationIPConfigIPv6Address: schema.TypeString,
		mkInitializationIPConfigIPv6Gateway: schema.TypeString,
	})

	initializationUserAccountSchema := test.AssertNestedSchemaExistence(
		t,
		initializationSchema,
		mkInitializationUserAccount,
	)

	test.AssertOptionalArguments(t, initializationUserAccountSchema, []string{
		mkInitializationUserAccountKeys,
		mkInitializationUserAccountPassword,
	})

	test.AssertValueTypes(t, initializationUserAccountSchema, map[string]schema.ValueType{
		mkInitializationUserAccountKeys:     schema.TypeList,
		mkInitializationUserAccountPassword: schema.TypeString,
	})

	memorySchema := test.AssertNestedSchemaExistence(t, s, mkMemory)

	test.AssertOptionalArguments(t, memorySchema, []string{
		mkMemoryDedicated,
		mkMemorySwap,
	})

	test.AssertValueTypes(t, memorySchema, map[string]schema.ValueType{
		mkMemoryDedicated: schema.TypeInt,
		mkMemorySwap:      schema.TypeInt,
	})

	devicePassthroughSchema := test.AssertNestedSchemaExistence(t, s, mkDevicePassthrough)

	test.AssertRequiredArguments(t, devicePassthroughSchema, []string{
		mkDevicePassthroughPath,
	})

	test.AssertOptionalArguments(t, devicePassthroughSchema, []string{
		mkDevicePassthroughDenyWrite,
		mkDevicePassthroughGID,
		mkDevicePassthroughMode,
		mkDevicePassthroughUID,
	})

	test.AssertValueTypes(t, devicePassthroughSchema, map[string]schema.ValueType{
		mkDevicePassthroughDenyWrite: schema.TypeBool,
		mkDevicePassthroughGID:       schema.TypeInt,
		mkDevicePassthroughMode:      schema.TypeString,
		mkDevicePassthroughPath:      schema.TypeString,
		mkDevicePassthroughUID:       schema.TypeInt,
	})

	mountPointSchema := test.AssertNestedSchemaExistence(t, s, mkMountPoint)

	test.AssertOptionalArguments(t, mountPointSchema, []string{
		mkMountPointACL,
		mkMountPointBackup,
		mkMountPointMountOptions,
		mkMountPointQuota,
		mkMountPointReadOnly,
		mkMountPointReplicate,
		mkMountPointShared,
		mkMountPointSize,
	})

	test.AssertValueTypes(t, mountPointSchema, map[string]schema.ValueType{
		mkMountPointACL:          schema.TypeBool,
		mkMountPointBackup:       schema.TypeBool,
		mkMountPointMountOptions: schema.TypeList,
		mkMountPointPath:         schema.TypeString,
		mkMountPointQuota:        schema.TypeBool,
		mkMountPointReadOnly:     schema.TypeBool,
		mkMountPointReplicate:    schema.TypeBool,
		mkMountPointShared:       schema.TypeBool,
		mkMountPointSize:         schema.TypeString,
		mkMountPointVolume:       schema.TypeString,
	})

	networkInterfaceSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		mkNetworkInterface,
	)

	test.AssertRequiredArguments(t, networkInterfaceSchema, []string{
		mkNetworkInterfaceName,
	})

	test.AssertOptionalArguments(t, networkInterfaceSchema, []string{
		mkNetworkInterfaceBridge,
		mkNetworkInterfaceEnabled,
		mkNetworkInterfaceMACAddress,
		mkNetworkInterfaceRateLimit,
		mkNetworkInterfaceVLANID,
		mkNetworkInterfaceMTU,
	})

	test.AssertValueTypes(t, networkInterfaceSchema, map[string]schema.ValueType{
		mkNetworkInterfaceBridge:     schema.TypeString,
		mkNetworkInterfaceEnabled:    schema.TypeBool,
		mkNetworkInterfaceMACAddress: schema.TypeString,
		mkNetworkInterfaceName:       schema.TypeString,
		mkNetworkInterfaceRateLimit:  schema.TypeFloat,
		mkNetworkInterfaceVLANID:     schema.TypeInt,
		mkNetworkInterfaceMTU:        schema.TypeInt,
	})

	operatingSystemSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		mkOperatingSystem,
	)

	test.AssertRequiredArguments(t, operatingSystemSchema, []string{
		mkOperatingSystemTemplateFileID,
	})

	test.AssertOptionalArguments(t, operatingSystemSchema, []string{
		mkOperatingSystemType,
	})

	test.AssertValueTypes(t, operatingSystemSchema, map[string]schema.ValueType{
		mkOperatingSystemTemplateFileID: schema.TypeString,
		mkOperatingSystemType:           schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/container/container.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"errors"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/containers"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
	resource "github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

const (
	dvCloneDatastoreID                  = ""
	dvCloneNodeName                     = ""
	dvConsoleEnabled                    = true
	dvConsoleMode                       = "tty"
	dvConsoleTTYCount                   = 2
	dvInitializationDNSDomain           = ""
	dvInitializationDNSServer           = ""
	dvInitializationIPConfigIPv4Address = ""
	dvInitializationIPConfigIPv4Gateway = ""
	dvInitializationIPConfigIPv6Address = ""
	dvInitializationIPConfigIPv6Gateway = ""
	dvInitializationHostname            = ""
	dvInitializationUserAccountPassword = ""
	dvCPUArchitecture                   = "amd64"
	dvCPUCores                          = 1
	dvCPUUnits                          = 1024
	dvDescription                       = ""
	dvDevicePassthroughMode             = "0660"
	dvDiskDatastoreID                   = "local"
	dvDiskSize                          = 4
	dvFeaturesNesting                   = false
	dvFeaturesKeyControl                = false
	dvFeaturesFUSE                      = false
	dvHookScript                        = ""
	dvMemoryDedicated                   = 512
	dvMemorySwap                        = 0
	dvMountPointACL                     = false
	dvMountPointBackup                  = false
	dvMountPointPath                    = ""
	dvMountPointQuota                   = false
	dvMountPointReadOnly                = false
	dvMountPointReplicate               = true
	dvMountPointShared                  = false
	dvMountPointSize                    = ""
	dvNetworkInterfaceBridge            = "vmbr0"
	dvNetworkInterfaceEnabled           = true
	dvNetworkInterfaceFirewall          = false
	dvNetworkInterfaceMACAddress        = ""
	dvNetworkInterfaceRateLimit         = 0
	dvNetworkInterfaceVLANID            = 0
	dvNetworkInterfaceMTU               = 0
	dvOperatingSystemType               = "unmanaged"
	dvPoolID                            = ""
	dvProtection                        = false
	dvStarted                           = true
	dvStartupOrder                      = -1
	dvStartupUpDelay                    = -1
	dvStartupDownDelay                  = -1
	dvStartOnBoot                       = true
	dvTemplate                          = false
	dvTimeoutCreate                     = 1800
	dvTimeoutClone                      = 1800
	dvTimeoutUpdate                     = 1800
	dvTimeoutDelete                     = 60
	dvUnprivileged                      = false

	maxNetworkInterfaces  = 10
	maxPassthroughDevices = 128
	maxMountPoints        = 256

	mkClone                             = "clone"
	mkCloneDatastoreID                  = "datastore_id"
	mkCloneNodeName                     = "node_name"
	mkCloneVMID                         = "vm_id"
	mkConsole                           = "console"
	mkConsoleEnabled                    = "enabled"
	mkConsoleMode                       = "type"
	mkConsoleTTYCount                   = "tty_count"
	mkCPU                               = "cpu"
	mkCPUArchitecture                   = "architecture"
	mkCPUCores                          = "cores"
	mkCPUUnits                          = "units"
	mkDescription                       = "description"
	mkDisk                              = "disk"
	mkDiskDatastoreID                   = "datastore_id"
	mkDiskSize                          = "size"
	mkFeatures                          = "features"
	mkFeaturesNesting                   = "nesting"
	mkFeaturesKeyControl                = "keyctl"
	mkFeaturesFUSE                      = "fuse"
	mkFeaturesMountTypes                = "mount"
	mkHookScriptFileID                  = "hook_script_file_id"
	mkInitialization                    = "initialization"
	mkInitializationDNS                 = "dns"
	mkInitializationDNSDomain           = "domain"
	mkInitializationDNSServer           = "server"
	mkInitializationDNSServers          = "servers"
	mkInitializationHostname            = "hostname"
	mkInitializationIPConfig            = "ip_config"
	mkInitializationIPConfigIPv4        = "ipv4"
	mkInitializationIPConfigIPv4Address = "address"
	mkInitializationIPConfigIPv4Gateway = "gateway"
	mkInitializationIPConfigIPv6        = "ipv6"
	mkInitializationIPConfigIPv6Address = "address"
	mkInitializationIPConfigIPv6Gateway = "gateway"
	mkInitializationUserAccount         = "user_account"
	mkInitializationUserAccountKeys     = "keys"
	mkInitializationUserAccountPassword = "password"
	mkMemory                            = "memory"
	mkMemoryDedicated                   = "dedicated"
	mkMemorySwap                        = "swap"
	mkMountPoint                        = "mount_point"
	mkMountPointACL                     = "acl"
	mkMountPointBackup                  = "backup"
	mkMountPointMountOptions            = "mount_options"
	mkMountPointPath                    = "path"
	mkMountPointQuota                   = "quota"
	mkMountPointReadOnly                = "read_only"
	mkMountPointReplicate               = "replicate"
	mkMountPointShared                  = "shared"
	mkMountPointSize                    = "size"
	mkMountPointVolume                  = "volume"
	mkDevicePassthroughDenyWrite        = "deny_write"
	mkDevicePassthrough                 = "device_passthrough" // #nosec G101
	mkDevicePassthroughPath             = "path"
	mkDevicePassthroughUID              = "uid"
	mkDevicePassthroughGID              = "gid"
	mkDevicePassthroughMode             = "mode"
	mkNetworkInterface                  = "network_interface"
	mkNetworkInterfaceBridge            = "bridge"
	mkNetworkInterfaceEnabled           = "enabled"
	mkNetworkInterfaceFirewall          = "firewall"
	mkNetworkInterfaceMACAddress        = "mac_address"
	mkNetworkInterfaceName              = "name"
	mkNetworkInterfaceRateLimit         = "rate_limit"
	mkNetworkInterfaceVLANID            = "vlan_id"
	mkNetworkInterfaceMTU               = "mtu"
	mkNodeName                          = "node_name"
	mkOperatingSystem                   = "operating_system"
	mkOperatingSystemTemplateFileID     = "template_file_id"
	mkOperatingSystemType               = "type"
	mkPoolID                            = "pool_id"
	mkProtection                        = "protection"
	mkStarted                           = "started"
	mkStartup                           = "startup"
	mkStartupOrder                      = "order"
	mkStartupUpDelay                    = "up_delay"
	mkStartupDownDelay                  = "down_delay"
	mkStartOnBoot                       = "start_on_boot"
	mkTags                              = "tags"
	mkTemplate                          = "template"
	mkTimeoutCreate                     = "timeout_create"
	mkTimeoutClone                      = "timeout_clone"
	mkTimeoutUpdate                     = "timeout_update"
	mkTimeoutDelete                     = "timeout_delete"
	mkUnprivileged                      = "unprivileged"
	mkVMID                              = "vm_id"
)

// Container returns a resource that manages a container.
func Container() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkClone: {
				Type:        schema.TypeList,
				Description: "The cloning configuration",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkCloneDatastoreID: {
							Type:        schema.TypeString,
							Description: "The ID of the target datastore",
							Optional:    true,
							ForceNew:    true,
							Default:     dvCloneDatastoreID,
						},
						mkCloneNodeName: {
							Type:        schema.TypeString,
							Description: "The name of the source node",
							Optional:    true,
							ForceNew:    true,
							Default:     dvCloneNodeName,
						},
						mkCloneVMID: {
							Type:             schema.TypeInt,
							Description:      "The ID of the source container",
							Required:         true,
							ForceNew:         true,
							ValidateDiagFunc: resource.VMIDValidator(),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkConsole: {
				Type:        schema.TypeList,
				Description: "The console configuration",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{
						map[string]interface{}{
							mkConsoleEnabled:  dvConsoleEnabled,
							mkConsoleMode:     dvConsoleMode,
							mkConsoleTTYCount: dvConsoleTTYCount,
						},
					}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkConsoleEnabled: {
							Type:        schema.TypeBool,
							Description: "Whether to enable the console device",
							Optional:    true,
							Default:     dvConsoleEnabled,
						},
						mkConsoleMode: {
							Type:             schema.TypeString,
							Description:      "The console mode",
							Optional:         true,
							Default:          dvConsoleMode,
							ValidateDiagFunc: ConsoleModeValidator(),
						},
						mkConsoleTTYCount: {
							Type:             schema.TypeInt,
							Description:      "The number of available TTY",
							Optional:         true,
							Default:          dvConsoleTTYCount,
							ValidateDiagFunc: validation.ToDiagFunc(validation.IntBetween(0, 6)),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkCPU: {
				Type:        schema.TypeList,
				Description: "The CPU allocation",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{
						map[string]interface{}{
							mkCPUArchitecture: dvCPUArchitecture,
							mkCPUCores:        dvCPUCores,
							mkCPUUnits:        dvCPUUnits,
						},
					}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkCPUArchitecture: {
							Type:             schema.TypeString,
							Description:      "The CPU architecture",
							Optional:         true,
							Default:          dvCPUArchitecture,
							ValidateDiagFunc: CPUArchitectureValidator(),
						},
						mkCPUCores: {
							Type:             schema.TypeInt,
							Description:      "The number of CPU cores",
							Optional:         true,
							Default:          dvCPUCores,
							ValidateDiagFunc: validation.ToDiagFunc(validation.IntBetween(1, 128)),
						},
						mkCPUUnits: {
							Type:        schema.TypeInt,
							Description: "The CPU units",
							Optional:    true,
							Default:     dvCPUUnits,
							ValidateDiagFunc: validation.ToDiagFunc(
								validation.IntBetween(0, 500000),
							),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkDescription: {
				Type:        schema.TypeString,
				Description: "The description",
				Optional:    true,
				Default:     dvDescription,
				StateFunc: func(i interface{}) string {
					// PVE always adds a newline to the description, so we have to do the same,
					// also taking in account the CLRF case (Windows)
					if i.(string) != "" {
						return strings.ReplaceAll(strings.TrimSpace(i.(string)), "\r\n", "\n") + "\n"
					}
					return ""
				},
			},
			mkDisk: {
				Type:        schema.TypeList,
				Description: "The disks",
				Optional:    true,
				ForceNew:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{
						map[string]interface{}{
							mkDiskDatastoreID: dvDiskDatastoreID,
							mkDiskSize:        dvDiskSize,
						},
					}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDiskDatastoreID: {
							Type:        schema.TypeString,
							Description: "The datastore id",
							Optional:    true,
							ForceNew:    true,
							Default:     dvDiskDatastoreID,
						},
						mkDiskSize: {
							Type:             schema.TypeInt,
							Description:      "The rootfs size in gigabytes",
							Optional:         true,
							ForceNew:         true,
							Default:          dvDiskSize,
							ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(0)),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkFeatures: {
				Type:        schema.TypeList,
				Description: "Features",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{
						map[string]interface{}{
							mkFeaturesNesting:    dvFeaturesNesting,
							mkFeaturesKeyControl: dvFeaturesKeyControl,
							mkFeaturesFUSE:       dvFeaturesFUSE,
							mkFeaturesMountTypes: []interface{}{},
						},
					}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkFeaturesNesting: {
							Type:        schema.TypeBool,
							Description: "Whether the container runs as nested",
							Optional:    true,
							Default:     dvFeaturesNesting,
						},
						mkFeaturesKeyControl: {
							Type:        schema.TypeBool,
							Description: "Whether the container supports `keyctl()` system call",
							Optional:    true,
							Default:     dvFeaturesKeyControl,
						},
						mkFeaturesFUSE: {
							Type:        schema.TypeBool,
							Description: "Whether the container supports FUSE mounts",
							Optional:    true,
							Default:     dvFeaturesFUSE,
						},
						mkFeaturesMountTypes: {
							Type:        schema.TypeList,
							Description: "List of allowed mount types",
							Optional:    true,
							Elem: &schema.Schema{
								Type:             schema.TypeString,
								ValidateDiagFunc: MountTypeValidator(),
							},
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkHookScriptFileID: {
				Type:        schema.TypeString,
				Description: "A hook script",
				Optional:    true,
				Default:     dvHookScript,
			},
			mkInitialization: {
				Type:        schema.TypeList,
				Description: "The initialization configuration",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkInitializationDNS: {
							Type:        schema.TypeList,
							Description: "The DNS configuration",
							Optional:    true,
							DefaultFunc: func() (interface{}, error) {
								return []interface{}{}, nil
							},
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									mkInitializationDNSDomain: {
										Type:        schema.TypeString,
										Description: "The DNS search domain",
										Optional:    true,
										Default:     dvInitializationDNSDomain,
									},
									mkInitializationDNSServer: {
										Type:        schema.TypeString,
										Description: "The DNS server",
										Deprecated: "The `server` attribute is deprecated and will be removed in a future release. " +
											"Please use the `servers` attribute instead.",
										Optional: true,
										Default:  dvInitializationDNSServer,
									},
									mkInitializationDNSServers: {
										Type:        schema.TypeList,
										Description: "The list of DNS servers",
										Optional:    true,
										Elem:        &schema.Schema{Type: schema.TypeString, ValidateFunc: validation.IsIPAddress},
										MinItems:    0,
									},
								},
							},
							MaxItems: 1,
							MinItems: 0,
						},
						mkInitializationHostname: {
							Type:        schema.TypeString,
							Description: "The hostname",
							Optional:    true,
							Default:     dvInitializationHostname,
						},
						mkInitializationIPConfig: {
							Type:        schema.TypeList,
							Description: "The IP configuration",
							Optional:    true,
							DefaultFunc: func() (interface{}, error) {
								return []interface{}{}, nil
							},
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									mkInitializationIPConfigIPv4: {
										Type:        schema.TypeList,
										Description: "The IPv4 configuration",
										Optional:    true,
										DefaultFunc: func() (interface{}, error) {
											return []interface{}{}, nil
										},
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												mkInitializationIPConfigIPv4Address: {
													Type:        schema.TypeString,
													Description: "The IPv4 address",
													Optional:    true,
													Default:     dvInitializationIPConfigIPv4Address,
												},
												mkInitializationIPConfigIPv4Gateway: {
													Type:        schema.TypeString,
													Description: "The IPv4 gateway",
													Optional:    true,
													Default:     dvInitializationIPConfigIPv4Gateway,
												},
											},
										},
										MaxItems: 1,
										MinItems: 0,
									},
									mkInitializationIPConfigIPv6: {
										Type:        schema.TypeList,
										Description: "The IPv6 configuration",
										Optional:    true,
										DefaultFunc: func() (interface{}, error) {
											return []interface{}{}, nil
										},
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												mkInitializationIPConfigIPv6Address: {
													Type:        schema.TypeString,
													Description: "The IPv6 address",
													Optional:    true,
													Default:     dvInitializationIPConfigIPv6Address,
												},
												mkInitializationIPConfigIPv6Gateway: {
													Type:        schema.TypeString,
													Description: "The IPv6 gateway",
													Optional:    true,
													Default:     dvInitializationIPConfigIPv6Gateway,
												},
											},
										},
										MaxItems: 1,
										MinItems: 0,
									},
								},
							},
							MaxItems: 8,
							MinItems: 0,
						},
						mkInitializationUserAccount: {
							Type:        schema.TypeList,
							Description: "The user account configuration",
							Optional:    true,
							ForceNew:    true,
							DefaultFunc: func() (interface{}, error) {
								return []interface{}{}, nil
							},
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									mkInitializationUserAccountKeys: {
										Type:        schema.TypeList,
										Description: "The SSH keys",
										Optional:    true,
										ForceNew:    true,
										DefaultFunc: func() (interface{}, error) {
											return []interface{}{}, nil
										},
										Elem: &schema.Schema{Type: schema.TypeString},
									},
									mkInitializationUserAccountPassword: {
										Type:        schema.TypeString,
										Description: "The SSH password",
										Optional:    true,
										ForceNew:    true,
										Sensitive:   true,
										Default:     dvInitializationUserAccountPassword,
										DiffSuppressFunc: func(_, oldVal, _ string, _ *schema.ResourceData) bool {
											return len(oldVal) > 0 &&
												strings.ReplaceAll(oldVal, "*", "") == ""
										},
									},
								},
							},
							MaxItems: 1,
							MinItems: 0,
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkMemory: {
				Type:        schema.TypeList,
				Description: "The memory allocation",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{
						map[string]interface{}{
							mkMemoryDedicated: dvMemoryDedicated,
							mkMemorySwap:      dvMemorySwap,
						},
					}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkMemoryDedicated: {
							Type:        schema.TypeInt,
							Description: "The dedicated memory in megabytes",
							Optional:    true,
							Default:     dvMemoryDedicated,
							ValidateDiagFunc: validation.ToDiagFunc(
								validation.IntBetween(16, 268435456),
							),
						},
						mkMemorySwap: {
							Type:        schema.TypeInt,
							Description: "The swap size in megabytes",
							Optional:    true,
							Default:     dvMemorySwap,
							ValidateDiagFunc: validation.ToDiagFunc(
								validation.IntBetween(0, 268435456),
							),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkMountPoint: {
				Type:        schema.TypeList,
				Description: "A mount point",
				Optional:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkMountPointACL: {
							Type:        schema.TypeBool,
							Description: "Explicitly enable or disable ACL support",
							Optional:    true,
							Default:     dvMountPointACL,
						},
						mkMountPointBackup: {
							Type:        schema.TypeBool,
							Description: "Whether to include the mount point in backups (only used for volume mount points)",
							Optional:    true,
							Default:     dvMountPointBackup,
						},
						mkMountPointMountOptions: {
							Type:        schema.TypeList,
							Description: "Extra mount options.",
							Optional:    true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						mkMountPointPath: {
							Type:        schema.TypeString,
							Description: "Path to the mount point as seen from inside the container",
							Required:    true,
							// StateFunc: func(i interface{}) string {
							// 	// PVE strips leading slashes from the path, so we have to do the same
							// 	return strings.TrimPrefix(i.(string), "/")
							// },
							DiffSuppressFunc: func(_, oldVal, newVal string, _ *schema.ResourceData) bool {
								return "/"+oldVal == newVal
							},
						},
						mkMountPointQuota: {
							Type:        schema.TypeBool,
							Description: "Enable user quotas inside the container (not supported with volume mounts)",
							Optional:    true,
							Default:     dvMountPointQuota,
						},
						mkMountPointReadOnly: {
							Type:        schema.TypeBool,
							Description: "Read-only mount point",
							Optional:    true,
							Default:     dvMountPointReadOnly,
						},
						mkMountPointReplicate: {
							Type:        schema.TypeBool,
							Description: "Will include this volume to a storage replica job",
							Optional:    true,
							Default:     dvMountPointReplicate,
						},
						mkMountPointShared: {
							Type:        schema.TypeBool,
							Description: "Mark this non-volume mount point as available on all nodes",
							Optional:    true,
							Default:     dvMountPointShared,
						},
						mkMountPointSize: {
							Type:             schema.TypeString,
							Description:      "Volume size (only used for volume mount points)",
							Optional:         true,
							Default:          dvMountPointSize,
							ValidateDiagFunc: validators.FileSize(),
						},
						mkMountPointVolume: {
							Type:        schema.TypeString,
							Description: "Volume, device or directory to mount into the container",
							Required:    true,
							DiffSuppressFunc: func(_, oldVal, newVal string, _ *schema.ResourceData) bool {
								// For *new* volume mounts PVE returns an actual volume ID which is saved in the stare,
								// so on reapply the provider will try override it:"
								//   "local-lvm" -> "local-lvm:vm-101-disk-1"
								//   "local-lvm:8" -> "local-lvm:vm-101-disk-1"
								// There is also an option to mount an existing volume, so
								//   "local-lvm:vm-101-disk-1" -> "local-lvm:vm-101-disk-1"
								// which is a valid case.
								return oldVal == newVal || strings.HasPrefix(oldVal, strings.Split(newVal, ":")[0]+":")
							},
						},
					},
				},
				MaxItems: maxMountPoints,
				MinItems: 0,
			},
			mkDevicePassthrough: {
				Type:        schema.TypeList,
				Description: "Device to pass through to the container",
				Optional:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkDevicePassthroughDenyWrite: {
							Type:        schema.TypeBool,
							Description: "Deny the container to write to the device",
							Optional:    true,
							Default:     false,
						},
						mkDevicePassthroughGID: {
							Type:             schema.TypeInt,
							Description:      "Group ID to be assigned to the device node",
							Optional:         true,
							ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(0)),
						},
						mkDevicePassthroughMode: {
							Type:        schema.TypeString,
							Description: "Access mode to be set on the device node (e.g. 0666)",
							Optional:    true,
							Default:     dvDevicePassthroughMode,
							ValidateDiagFunc: validation.ToDiagFunc(validation.StringMatch(
								regexp.MustCompile(`0[0-7]{3}`), "Octal access mode",
							)),
						},
						mkDevicePassthroughPath: {
							Type:             schema.TypeString,
							Description:      "Device to pass through to the container",
							Required:         true,
							ValidateDiagFunc: validation.ToDiagFunc(validation.StringIsNotEmpty),
						},
						mkDevicePassthroughUID: {
							Type:             schema.TypeInt,
							Description:      "Device UID in the container",
							Optional:         true,
							ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(0)),
						},
					},
				},
				MaxItems: maxPassthroughDevices,
				MinItems: 0,
			},
			mkNetworkInterface: {
				Type:        schema.TypeList,
				Description: "The network interfaces",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return make([]interface{}, 1), nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkNetworkInterfaceBridge: {
							Type:        schema.TypeString,
							Description: "The bridge",
							Optional:    true,
							Default:     dvNetworkInterfaceBridge,
						},
						mkNetworkInterfaceEnabled: {
							Type:        schema.TypeBool,
							Description: "Whether to enable the network device",
							Optional:    true,
							Default:     dvNetworkInterfaceEnabled,
						},
						mkNetworkInterfaceFirewall: {
							Type:        schema.TypeBool,
							Description: "Whether this interface's firewall rules should be used.",
							Optional:    true,
							Default:     dvNetworkInterfaceFirewall,
						},
						mkNetworkInterfaceMACAddress: {
							Type:        schema.TypeString,
							Description: "The MAC address",
							Optional:    true,
							Default:     dvNetworkInterfaceMACAddress,
							DiffSuppressFunc: func(_, _, newVal string, _ *schema.ResourceData) bool {
								return newVal == ""
							},
							ValidateDiagFunc: validators.MACAddress(),
						},
						mkNetworkInterfaceName: {
							Type:        schema.TypeString,
							Description: "The network interface name",
							Required:    true,
						},
						mkNetworkInterfaceRateLimit: {
							Type:        schema.TypeFloat,
							Description: "The rate limit in megabytes per second",
							Optional:    true,
							Default:     dvNetworkInterfaceRateLimit,
						},
						mkNetworkInterfaceVLANID: {
							Type:        schema.TypeInt,
							Description: "The VLAN identifier",
							Optional:    true,
							Default:     dvNetworkInterfaceVLANID,
						},
						mkNetworkInterfaceMTU: {
							Type:        schema.TypeInt,
							Description: "Maximum transmission unit (MTU)",
							Optional:    true,
							Default:     dvNetworkInterfaceMTU,
						},
					},
				},
				MaxItems: maxNetworkInterfaces,
				MinItems: 0,
			},
			mkNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
				ForceNew:    true,
			},
			mkOperatingSystem: {
				Type:        schema.TypeList,
				Description: "The operating system configuration",
				Optional:    true,
				ForceNew:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkOperatingSystemTemplateFileID: {
							Type:             schema.TypeString,
							Description:      "The ID of an OS template file",
							Required:         true,
							ForceNew:         true,
							ValidateDiagFunc: validators.FileID(),
						},
						mkOperatingSystemType: {
							Type:             schema.TypeString,
							Description:      "The type",
							Optional:         true,
							Default:          dvOperatingSystemType,
							ValidateDiagFunc: OperatingSystemTypeValidator(),
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkPoolID: {
				Type:        schema.TypeString,
				Description: "The ID of the pool to assign the container to",
				Optional:    true,
				ForceNew:    true,
				Default:     dvPoolID,
			},
			mkProtection: {
				Type: schema.TypeBool,
				Description: "Whether to set the protection flag of the container. " +
					"This will prevent the container itself and its disk for remove/update operations.",
				Optional: true,
				ForceNew: false,
				Default:  dvProtection,
			},
			mkStarted: {
				Type:        schema.TypeBool,
				Description: "Whether to start the container",
				Optional:    true,
				Default:     dvStarted,
				DiffSuppressFunc: func(_, _, _ string, d *schema.ResourceData) bool {
					return d.Get(mkTemplate).(bool)
				},
			},
			mkStartup: {
				Type:        schema.TypeList,
				Description: "Defines startup and shutdown behavior of the container",
				Optional:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkStartupOrder: {
							Type:        schema.TypeInt,
							Description: "A non-negative number defining the general startup order",
							Optional:    true,
							Default:     dvStartupOrder,
						},
						mkStartupUpDelay: {
							Type:        schema.TypeInt,
							Description: "A non-negative number defining the delay in seconds before the next container is started",
							Optional:    true,
							Default:     dvStartupUpDelay,
						},
						mkStartupDownDelay: {
							Type:        schema.TypeInt,
							Description: "A non-negative number defining the delay in seconds before the next container is shut down",
							Optional:    true,
							Default:     dvStartupDownDelay,
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkStartOnBoot: {
				Type:        schema.TypeBool,
				Description: "Automatically start container when the host system boots.",
				Optional:    true,
				ForceNew:    false,
				Default:     dvStartOnBoot,
			},
			mkTags: {
				Type:        schema.TypeList,
				Description: "Tags of the container. This is only meta information.",
				Optional:    true,
				Elem: &schema.Schema{
					Type:         schema.TypeString,
					ValidateFunc: validation.StringIsNotEmpty,
				},
				DiffSuppressFunc:      structure.SuppressIfListsAreEqualIgnoringOrder,
				DiffSuppressOnRefresh: true,
			},
			mkTemplate: {
				Type:        schema.TypeBool,
				Description: "Whether to create a template",
				Optional:    true,
				ForceNew:    true,
				Default:     dvTemplate,
			},
			mkTimeoutCreate: {
				Type:        schema.TypeInt,
				Description: "Create container timeout",
				Optional:    true,
				Default:     dvTimeoutCreate,
			},
			mkTimeoutClone: {
				Type:        schema.TypeInt,
				Description: "Clone container timeout",
				Optional:    true,
				Default:     dvTimeoutClone,
			},
			mkTimeoutUpdate: {
				Type:        schema.TypeInt,
				Description: "Update container timeout",
				Optional:    true,
				Default:     dvTimeoutUpdate,
			},
			mkTimeoutDelete: {
				Type:        schema.TypeInt,
				Description: "Delete container timeout",
				Optional:    true,
				Default:     dvTimeoutDelete,
			},
			"timeout_start": {
				Type:        schema.TypeInt,
				Description: "Start container timeout",
				Optional:    true,
				Default:     300,
				Deprecated: "This field is deprecated and will be removed in a future release. " +
					"An overall operation timeout (`timeout_create` / `timeout_clone`) is used instead.",
			},
			mkUnprivileged: {
				Type:        schema.TypeBool,
				Description: "Whether the container runs as unprivileged on the host",
				Optional:    true,
				ForceNew:    true,
				Default:     dvUnprivileged,
			},
			mkVMID: {
				Type:             schema.TypeInt,
				Description:      "The VM identifier",
				Optional:         true,
				Computed:         true,
				ValidateDiagFunc: resource.VMIDValidator(),
			},
		},
		CreateContext: containerCreate,
		ReadContext:   containerRead,
		UpdateContext: containerUpdate,
		DeleteContext: containerDelete,
		CustomizeDiff: customdiff.All(
			customdiff.ForceNewIf(
				mkVMID,
				func(_ context.Context, d *schema.ResourceDiff, _ interface{}) bool {
					newValue := d.Get(mkVMID)

					// 'vm_id' is ForceNew, except when changing 'vm_id' to existing correct id
					// (automatic fix from -1 to actual vm_id must not re-create VM)
					return strconv.Itoa(newValue.(int)) != d.Id()
				},
			),
		),
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				node, id, err := parseImportIDWithNodeName(d.Id())
				if err != nil {
					return nil, err
				}

				d.SetId(id)
				err = d.Set(mkNodeName, node)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func containerCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	clone := d.Get(mkClone).([]interface{})

	if len(clone) > 0 {
		return containerCreateClone(ctx, d, m)
	}

	return containerCreateCustom(ctx, d, m)
}

func containerCreateClone(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	cloneTimeoutSec := d.Get(mkTimeoutClone).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(cloneTimeoutSec)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	clone := d.Get(mkClone).([]interface{})
	cloneBlock := clone[0].(map[string]interface{})
	cloneDatastoreID := cloneBlock[mkCloneDatastoreID].(string)
	cloneNodeName := cloneBlock[mkCloneNodeName].(string)
	cloneVMID := cloneBlock[mkCloneVMID].(int)

	description := d.Get(mkDescription).(string)

	initialization := d.Get(mkInitialization).([]interface{})
	initializationHostname := ""

	if len(initialization) > 0 && initialization[0] != nil {
		initializationBlock := initialization[0].(map[string]interface{})
		initializationHostname = initializationBlock[mkInitializationHostname].(string)
	}

	nodeName := d.Get(mkNodeName).(string)
	poolID := d.Get(mkPoolID).(string)
	tags := d.Get(mkTags).([]interface{})
	vmIDUntyped, hasVMID := d.GetOk(mkVMID)
	vmID := vmIDUntyped.(int)

	if !hasVMID {
		vmIDNew, err := config.GetIDGenerator().NextID(ctx)
		if err != nil {
			return diag.FromErr(err)
		}

		vmID = vmIDNew

		err = d.Set(mkVMID, vmID)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	fullCopy := types.CustomBool(true)

	cloneBody := &containers.CloneRequestBody{
		FullCopy: &fullCopy,
		VMIDNew:  vmID,
	}

	if cloneDatastoreID != "" {
		cloneBody.TargetStorage = &cloneDatastoreID
	}

	if description != "" {
		cloneBody.Description = &description
	}

	if initializationHostname != "" {
		cloneBody.Hostname = &initializationHostname
	}

	if poolID != "" {
		cloneBody.PoolID = &poolID
	}

	if cloneNodeName != "" && cloneNodeName != nodeName {
		cloneBody.TargetNodeName = &nodeName

		err = client.Node(cloneNodeName).Container(cloneVMID).CloneContainer(ctx, cloneBody)
	} else {
		err = client.Node(nodeName).Container(cloneVMID).CloneContainer(ctx, cloneBody)
	}

	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(strconv.Itoa(vmID))

	containerAPI := client.Node(nodeName).Container(vmID)

	// Wait for the container to be created and its configuration lock to be released.
	err = containerAPI.WaitForContainerConfigUnlock(ctx, true)
	if err != nil {
		return diag.FromErr(err)
	}

	// Now that the virtual machine has been cloned, we need to perform some modifications.
	updateBody := &containers.UpdateRequestBody{}

	startOnBoot := types.CustomBool(d.Get(mkStartOnBoot).(bool))
	updateBody.StartOnBoot = &startOnBoot

	protection := types.CustomBool(d.Get(mkProtection).(bool))
	updateBody.Protection = &protection

	updateBody.StartupBehavior = containerGetStartupBehavior(d)

	console := d.Get(mkConsole).([]interface{})

	if len(console) > 0 && console[0] != nil {
		consoleBlock := console[0].(map[string]interface{})

		consoleEnabled := types.CustomBool(
			consoleBlock[mkConsoleEnabled].(bool),
		)
		consoleMode := consoleBlock[mkConsoleMode].(string)
		consoleTTYCount := consoleBlock[mkConsoleTTYCount].(int)

		updateBody.ConsoleEnabled = &consoleEnabled
		updateBody.ConsoleMode = &consoleMode
		updateBody.TTY = &consoleTTYCount
	}

	cpu := d.Get(mkCPU).([]interface{})

	if len(cpu) > 0 && cpu[0] != nil {
		cpuBlock := cpu[0].(map[string]interface{})

		cpuArchitecture := cpuBlock[mkCPUArchitecture].(string)
		cpuCores := cpuBlock[mkCPUCores].(int)
		cpuUnits := cpuBlock[mkCPUUnits].(int)

		updateBody.CPUArchitecture = &cpuArchitecture
		updateBody.CPUCores = &cpuCores
		updateBody.CPUUnits = &cpuUnits
	}

	hookScript := d.Get(mkHookScriptFileID).(string)

	if hookScript != "" {
		updateBody.HookScript = &hookScript
	}

	var initializationIPConfigIPv4Address []string

	var initializationIPConfigIPv4Gateway []string

	var initializationIPConfigIPv6Address []string

	var initializationIPConfigIPv6Gateway []string

	if len(initialization) > 0 && initialization[0] != nil {
		initializationBlock := initialization[0].(map[string]interface{})
		initializationDNS := initializationBlock[mkInitializationDNS].([]interface{})

		if len(initializationDNS) > 0 && initializationDNS[0] != nil {
			initializationDNSBlock := initializationDNS[0].(map[string]interface{})
			initializationDNSDomain := initializationDNSBlock[mkInitializationDNSDomain].(string)
			updateBody.DNSDomain = &initializationDNSDomain

			servers := initializationDNSBlock[mkInitializationDNSServers].([]interface{})
			deprecatedServer := initializationDNSBlock[mkInitializationDNSServer].(string)

			if len(servers) > 0 {
				nameserver := strings.Join(utils.ConvertToStringSlice(servers), " ")

				updateBody.DNSServer = &nameserver
			} else {
				updateBody.DNSServer = &deprecatedServer
			}
		}

		initializationHostname := initializationBlock[mkInitializationHostname].(string)

		if initializationHostname != dvInitializationHostname {
			updateBody.Hostname = &initializationHostname
		}

		initializationIPConfig := initializationBlock[mkInitializationIPConfig].([]interface{})

		for _, c := range initializationIPConfig {
			configBlock := c.(map[string]interface{})
			ipv4 := configBlock[mkInitializationIPConfigIPv4].([]interface{})

			if len(ipv4) > 0 && ipv4[0] != nil {
				ipv4Block := ipv4[0].(map[string]interface{})

				initializationIPConfigIPv4Address = append(
					initializationIPConfigIPv4Address,
					ipv4Block[mkInitializationIPConfigIPv4Address].(string),
				)

				initializationIPConfigIPv4Gateway = append(
					initializationIPConfigIPv4Gateway,
					ipv4Block[mkInitializationIPConfigIPv4Gateway].(string),
				)
			} else {
				initializationIPConfigIPv4Address = append(initializationIPConfigIPv4Address, "")
				initializationIPConfigIPv4Gateway = append(initializationIPConfigIPv4Gateway, "")
			}

			ipv6 := configBlock[mkInitializationIPConfigIPv6].([]interface{})

			if len(ipv6) > 0 && ipv6[0] != nil {
				ipv6Block := ipv6[0].(map[string]interface{})

				initializationIPConfigIPv6Address = append(
					initializationIPConfigIPv6Address,
					ipv6Block[mkInitializationIPConfigIPv6Address].(string),
				)

				initializationIPConfigIPv6Gateway = append(
					initializationIPConfigIPv6Gateway,
					ipv6Block[mkInitializationIPConfigIPv6Gateway].(string),
				)
			} else {
				initializationIPConfigIPv6Address = append(initializationIPConfigIPv6Address, "")
				initializationIPConfigIPv6Gateway = append(initializationIPConfigIPv6Gateway, "")
			}
		}

		initializationUserAccount := initializationBlock[mkInitializationUserAccount].([]interface{})

		if len(initializationUserAccount) > 0 && initializationUserAccount[0] != nil {
			initializationUserAccountBlock := initializationUserAccount[0].(map[string]interface{})
			keys := initializationUserAccountBlock[mkInitializationUserAccountKeys].([]interface{})

			if len(keys) > 0 {
				initializationUserAccountKeys := make(
					containers.CustomSSHKeys,
					len(keys),
				)

				for ki, kv := range keys {
					initializationUserAccountKeys[ki] = kv.(string)
				}

				updateBody.SSHKeys = &initializationUserAccountKeys
			} else {
				updateBody.Delete = append(updateBody.Delete, "ssh-public-keys")
			}

			initializationUserAccountPassword := initializationUserAccountBlock[mkInitializationUserAccountPassword].(string)

			if initializationUserAccountPassword != dvInitializationUserAccountPassword {
				updateBody.Password = &initializationUserAccountPassword
			} else {
				updateBody.Delete = append(updateBody.Delete, "password")
			}
		}
	}

	memory := d.Get(mkMemory).([]interface{})

	if len(memory) > 0 && memory[0] != nil {
		memoryBlock := memory[0].(map[string]interface{})

		memoryDedicated := memoryBlock[mkMemoryDedicated].(int)
		memorySwap := memoryBlock[mkMemorySwap].(int)

		updateBody.DedicatedMemory = &memoryDedicated
		updateBody.Swap = &memorySwap
	}

	devicePassthrough := d.Get(mkDevicePassthrough).([]interface{})

	passthroughDevices := make(
		containers.CustomPassthroughDevices,
		len(devicePassthrough),
	)

	for di, dv := range devicePassthrough {
		devicePassthroughMap := dv.(map[string]interface{})
		devicePassthroughObject := containers.CustomPassthroughDevice{}

		denyWrite := types.CustomBool(
			devicePassthroughMap[mkDevicePassthroughDenyWrite].(bool),
		)
		gid := devicePassthroughMap[mkDevicePassthroughGID].(int)
		mode := devicePassthroughMap[mkDevicePassthroughMode].(string)
		path := devicePassthroughMap[mkDevicePassthroughPath].(string)
		uid := devicePassthroughMap[mkDevicePassthroughUID].(int)

		devicePassthroughObject.DenyWrite = &denyWrite
		devicePassthroughObject.GID = &gid
		devicePassthroughObject.Mode = &mode
		devicePassthroughObject.Path = path
		devicePassthroughObject.UID = &uid

		passthroughDevices[fmt.Sprintf("dev%d", di)] = &devicePassthroughObject
	}

	updateBody.PassthroughDevices = passthroughDevices

	networkInterface := d.Get(mkNetworkInterface).([]interface{})

	if len(networkInterface) == 0 {
		networkInterface, err = containerGetExistingNetworkInterface(ctx, containerAPI)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	networkInterfaces := make(
		containers.CustomNetworkInterfaces,
		len(networkInterface),
	)

	for ni, nv := range networkInterface {
		networkInterfaceMap := nv.(map[string]interface{})
		networkInterfaceObject := containers.CustomNetworkInterface{}

		bridge := networkInterfaceMap[mkNetworkInterfaceBridge].(string)
		enabled := networkInterfaceMap[mkNetworkInterfaceEnabled].(bool)
		firewall := types.CustomBool(
			networkInterfaceMap[mkNetworkInterfaceFirewall].(bool),
		)
		macAddress := networkInterfaceMap[mkNetworkInterfaceMACAddress].(string)
		name := networkInterfaceMap[mkNetworkInterfaceName].(string)
		rateLimit := networkInterfaceMap[mkNetworkInterfaceRateLimit].(float64)
		vlanID := networkInterfaceMap[mkNetworkInterfaceVLANID].(int)
		mtu, _ := networkInterfaceMap[mkNetworkInterfaceMTU].(int)

		if bridge != "" {
			networkInterfaceObject.Bridge = &bridge
		}

		networkInterfaceObject.Enabled = enabled
		networkInterfaceObject.Firewall = &firewall

		if len(initializationIPConfigIPv4Address) > ni {
			if initializationIPConfigIPv4Address[ni] != "" {
				networkInterfaceObject.IPv4Address = &initializationIPConfigIPv4Address[ni]
			}

			if initializationIPConfigIPv4Gateway[ni] != "" {
				networkInterfaceObject.IPv4Gateway = &initializationIPConfigIPv4Gateway[ni]
			}

			if initializationIPConfigIPv6Address[ni] != "" {
				networkInterfaceObject.IPv6Address = &initializationIPConfigIPv6Address[ni]
			}

			if initializationIPConfigIPv6Gateway[ni] != "" {
				networkInterfaceObject.IPv6Gateway = &initializationIPConfigIPv6Gateway[ni]
			}
		}

		if macAddress != "" {
			networkInterfaceObject.MACAddress = &macAddress
		}

		networkInterfaceObject.Name = name

		if rateLimit != 0 {
			networkInterfaceObject.RateLimit = &rateLimit
		}

		if vlanID != 0 {
			networkInterfaceObject.Tag = &vlanID
		}

		if mtu != 0 {
			networkInterfaceObject.MTU = &mtu
		}

		networkInterfaces[fmt.Sprintf("net%d", ni)] = &networkInterfaceObject
	}

	updateBody.NetworkInterfaces = networkInterfaces

	for key, ni := range updateBody.NetworkInterfaces {
		if !ni.Enabled {
			updateBody.Delete = append(updateBody.Delete, key)
		}
	}

	for i := len(updateBody.NetworkInterfaces); i < maxNetworkInterfaces; i++ {
		updateBody.Delete = append(updateBody.Delete, fmt.Sprintf("net%d", i))
	}

	operatingSystem := d.Get(mkOperatingSystem).([]interface{})

	if len(operatingSystem) > 0 && operatingSystem[0] != nil {
		operatingSystemBlock := operatingSystem[0].(map[string]interface{})

		operatingSystemTemplateFileID := operatingSystemBlock[mkOperatingSystemTemplateFileID].(string)
		operatingSystemType := operatingSystemBlock[mkOperatingSystemType].(string)

		updateBody.OSTemplateFileVolume = &operatingSystemTemplateFileID
		updateBody.OSType = &operatingSystemType
	}

	if len(tags) > 0 {
		tagString := containerGetTagsString(d)
		updateBody.Tags = &tagString
	}

	template := types.CustomBool(d.Get(mkTemplate).(bool))

	if template {
		updateBody.Template = &template
	}

	err = containerAPI.UpdateContainer(ctx, updateBody)
	if err != nil {
		return diag.FromErr(err)
	}

	// Wait for the container's lock to be released.
	err = containerAPI.WaitForContainerConfigUnlock(ctx, true)
	if err != nil {
		return diag.FromErr(err)
	}

	return containerCreateStart(ctx, d, m)
}

func containerCreateCustom(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	createTimeoutSec := d.Get(mkTimeoutCreate).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(createTimeoutSec)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)
	container := Container()

	consoleBlock, err := structure.GetSchemaBlock(
		container,
		d,
		[]string{mkConsole},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	consoleEnabled := types.CustomBool(
		consoleBlock[mkConsoleEnabled].(bool),
	)
	consoleMode := consoleBlock[mkConsoleMode].(string)
	consoleTTYCount := consoleBlock[mkConsoleTTYCount].(int)

	cpuBlock, err := structure.GetSchemaBlock(
		container,
		d,
		[]string{mkCPU},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	cpuArchitecture := cpuBlock[mkCPUArchitecture].(string)
	cpuCores := cpuBlock[mkCPUCores].(int)
	cpuUnits := cpuBlock[mkCPUUnits].(int)

	description := d.Get(mkDescription).(string)

	diskBlock, err := structure.GetSchemaBlock(
		container,
		d,
		[]string{mkDisk},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	diskDatastoreID := diskBlock[mkDiskDatastoreID].(string)

	features, err := containerGetFeatures(container, d)
	if err != nil {
		return diag.FromErr(err)
	}

	hookScript := d.Get(mkHookScriptFileID).(string)

	initialization := d.Get(mkInitialization).([]interface{})
	initializationDNSDomain := dvInitializationDNSDomain
	initializationDNSServer := dvInitializationDNSServer
	initializationHostname := dvInitializationHostname

	var initializationIPConfigIPv4Address []string

	var initializationIPConfigIPv4Gateway []string

	var initializationIPConfigIPv6Address []string

	var initializationIPConfigIPv6Gateway []string

	initializationUserAccountKeys := containers.CustomSSHKeys{}
	initializationUserAccountPassword := dvInitializationUserAccountPassword

	if len(initialization) > 0 && initialization[0] != nil {
		initializationBlock := initialization[0].(map[string]interface{})
		initializationDNS := initializationBlock[mkInitializationDNS].([]interface{})

		if len(initializationDNS) > 0 && initializationDNS[0] != nil {
			initializationDNSBlock := initializationDNS[0].(map[string]interface{})
			initializationDNSDomain = initializationDNSBlock[mkInitializationDNSDomain].(string)

			servers := initializationDNSBlock[mkInitializationDNSServers].([]interface{})
			deprecatedServer := initializationDNSBlock[mkInitializationDNSServer].(string)

			if len(servers) > 0 {
				nameserver := strings.Join(utils.ConvertToStringSlice(servers), " ")

				initializationDNSServer = nameserver
			} else {
				initializationDNSServer = deprecatedServer
			}
		}

		initializationHostname = initializationBlock[mkInitializationHostname].(string)
		initializationIPConfig := initializationBlock[mkInitializationIPConfig].([]interface{})

		for _, c := range initializationIPConfig {
			if c == nil {
				continue
			}

			configBlock := c.(map[string]interface{})
			ipv4 := configBlock[mkInitializationIPConfigIPv4].([]interface{})

			if len(ipv4) > 0 && ipv4[0] != nil {
				ipv4Block := ipv4[0].(map[string]interface{})

				initializationIPConfigIPv4Address = append(
					initializationIPConfigIPv4Address,
					ipv4Block[mkInitializationIPConfigIPv4Address].(string),
				)

				initializationIPConfigIPv4Gateway = append(
					initializationIPConfigIPv4Gateway,
					ipv4Block[mkInitializationIPConfigIPv4Gateway].(string),
				)
			} else {
				initializationIPConfigIPv4Address = append(initializationIPConfigIPv4Address, "")
				initializationIPConfigIPv4Gateway = append(initializationIPConfigIPv4Gateway, "")
			}

			ipv6 := configBlock[mkInitializationIPConfigIPv6].([]interface{})

			if len(ipv6) > 0 && ipv6[0] != nil {
				ipv6Block := ipv6[0].(map[string]interface{})

				initializationIPConfigIPv6Address = append(
					initializationIPConfigIPv6Address,
					ipv6Block[mkInitializationIPConfigIPv6Address].(string),
				)

				initializationIPConfigIPv6Gateway = append(
					initializationIPConfigIPv6Gateway,
					ipv6Block[mkInitializationIPConfigIPv6Gateway].(string),
				)
			} else {
				initializationIPConfigIPv6Address = append(initializationIPConfigIPv6Address, "")
				initializationIPConfigIPv6Gateway = append(initializationIPConfigIPv6Gateway, "")
			}
		}

		initializationUserAccount := initializationBlock[mkInitializationUserAccount].([]interface{})

		if len(initializationUserAccount) > 0 && initializationUserAccount[0] != nil {
			initializationUserAccountBlock := initializationUserAccount[0].(map[string]interface{})

			keys := initializationUserAccountBlock[mkInitializationUserAccountKeys].([]interface{})
			initializationUserAccountKeys = make(
				containers.CustomSSHKeys,
				len(keys),
			)

			for ki, kv := range keys {
				initializationUserAccountKeys[ki] = kv.(string)
			}

			initializationUserAccountPassword = initializationUserAccountBlock[mkInitializationUserAccountPassword].(string)
		}
	}

	memoryBlock, err := structure.GetSchemaBlock(
		container,
		d,
		[]string{mkMemory},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	memoryDedicated := memoryBlock[mkMemoryDedicated].(int)
	memorySwap := memoryBlock[mkMemorySwap].(int)

	mountPoint := d.Get(mkMountPoint).([]interface{})
	mountPoints := make(containers.CustomMountPoints, len(mountPoint))

	// because of default bool values:

	for mi, mp := range mountPoint {
		mountPointMap := mp.(map[string]interface{})
		mountPointObject := containers.CustomMountPoint{}

		acl := types.CustomBool(mountPointMap[mkMountPointACL].(bool))
		backup := types.CustomBool(mountPointMap[mkMountPointBackup].(bool))
		mountOptions := mountPointMap[mkMountPointMountOptions].([]interface{})
		path := mountPointMap[mkMountPointPath].(string)
		quota := types.CustomBool(mountPointMap[mkMountPointQuota].(bool))
		readOnly := types.CustomBool(mountPointMap[mkMountPointReadOnly].(bool))
		replicate := types.CustomBool(mountPointMap[mkMountPointReplicate].(bool))
		shared := types.CustomBool(mountPointMap[mkMountPointShared].(bool))
		size := mountPointMap[mkMountPointSize].(string)
		volume := mountPointMap[mkMountPointVolume].(string)

		// we have to set only the values that are different from the provider's defaults,
		if acl {
			mountPointObject.ACL = &acl
		}

		if backup {
			mountPointObject.Backup = &backup
		}

		if path != dvMountPointPath {
			mountPointObject.MountPoint = path
		}

		if quota {
			mountPointObject.Quota = &quota
		}

		if readOnly {
			mountPointObject.ReadOnly = &readOnly
		}

		if !replicate {
			mountPointObject.Replicate = &replicate
		}

		if shared {
			mountPointObject.Shared = &shared
		}

		if len(size) > 0 {
			var ds types.DiskSize

			ds, err = types.ParseDiskSize(size)
			if err != nil {
				return diag.Errorf("invalid disk size: %s", err.Error())
			}

			mountPointObject.Volume = fmt.Sprintf("%s:%d", volume, ds.InGigabytes())
		} else {
			mountPointObject.Volume = volume
		}

		if len(mountOptions) > 0 {
			mountOptionsArray := make([]string, 0, len(mountPoint))

			for _, option := range mountOptions {
				mountOptionsArray = append(mountOptionsArray, option.(string))
			}

			mountPointObject.MountOptions = &mountOptionsArray
		}

		mountPoints[fmt.Sprintf("mp%d", mi)] = &mountPointObject
	}

	var rootFS *containers.CustomRootFS

	diskSize := diskBlock[mkDiskSize].(int)
	if diskDatastoreID != "" && (diskSize != dvDiskSize || len(mountPoints) > 0) {
		// This is a special case where the rootfs size is set to a non-default value at creation time.
		// see https://pve.proxmox.com/pve-docs/chapter-pct.html#_storage_backed_mount_points
		rootFS = &containers.CustomRootFS{
			Volume: fmt.Sprintf("%s:%d", diskDatastoreID, diskSize),
		}
	}

	networkInterface := d.Get(mkNetworkInterface).([]interface{})
	networkInterfaces := make(containers.CustomNetworkInterfaces, len(networkInterface))

	for ni, nv := range networkInterface {
		networkInterfaceMap := nv.(map[string]interface{})
		networkInterfaceObject := containers.CustomNetworkInterface{}

		bridge := networkInterfaceMap[mkNetworkInterfaceBridge].(string)
		enabled := networkInterfaceMap[mkNetworkInterfaceEnabled].(bool)
		macAddress := networkInterfaceMap[mkNetworkInterfaceMACAddress].(string)
		name := networkInterfaceMap[mkNetworkInterfaceName].(string)
		rateLimit := networkInterfaceMap[mkNetworkInterfaceRateLimit].(float64)
		vlanID := networkInterfaceMap[mkNetworkInterfaceVLANID].(int)
		mtu := networkInterfaceMap[mkNetworkInterfaceMTU].(int)
		firewall := networkInterfaceMap[mkNetworkInterfaceFirewall].(bool)

		if bridge != "" {
			networkInterfaceObject.Bridge = &bridge
		}

		networkInterfaceObject.Enabled = enabled
		networkInterfaceObject.Name = name

		if len(initializationIPConfigIPv4Address) > ni {
			if initializationIPConfigIPv4Address[ni] != "" {
				networkInterfaceObject.IPv4Address = &initializationIPConfigIPv4Address[ni]
			}

			if initializationIPConfigIPv4Gateway[ni] != "" {
				networkInterfaceObject.IPv4Gateway = &initializationIPConfigIPv4Gateway[ni]
			}

			if initializationIPConfigIPv6Address[ni] != "" {
				networkInterfaceObject.IPv6Address = &initializationIPConfigIPv6Address[ni]
			}

			if initializationIPConfigIPv6Gateway[ni] != "" {
				networkInterfaceObject.IPv6Gateway = &initializationIPConfigIPv6Gateway[ni]
			}
		}

		if firewall {
			networkInterfaceObject.Firewall = types.CustomBool(firewall).Pointer()
		}

		if macAddress != "" {
			networkInterfaceObject.MACAddress = &macAddress
		}

		if rateLimit != 0 {
			networkInterfaceObject.RateLimit = &rateLimit
		}

		if vlanID != 0 {
			networkInterfaceObject.Tag = &vlanID
		}

		if mtu != 0 {
			networkInterfaceObject.MTU = &mtu
		}

		networkInterfaces[fmt.Sprintf("net%d", ni)] = &networkInterfaceObject
	}

	devicePassthrough := d.Get(mkDevicePassthrough).([]interface{})

	passthroughDevices := make(
		containers.CustomPassthroughDevices,
		len(devicePassthrough),
	)

	for di, dv := range devicePassthrough {
		devicePassthroughMap := dv.(map[string]interface{})
		devicePassthroughObject := containers.CustomPassthroughDevice{}

		denyWrite := types.CustomBool(
			devicePassthroughMap[mkDevicePassthroughDenyWrite].(bool),
		)
		gid := devicePassthroughMap[mkDevicePassthroughGID].(int)
		mode := devicePassthroughMap[mkDevicePassthroughMode].(string)
		path := devicePassthroughMap[mkDevicePassthroughPath].(string)
		uid := devicePassthroughMap[mkDevicePassthroughUID].(int)

		devicePassthroughObject.DenyWrite = &denyWrite
		devicePassthroughObject.GID = &gid
		devicePassthroughObject.Mode = &mode
		devicePassthroughObject.Path = path
		devicePassthroughObject.UID = &uid

		passthroughDevices[fmt.Sprintf("dev%d", di)] = &devicePassthroughObject
	}

	operatingSystem := d.Get(mkOperatingSystem).([]interface{})

	if len(operatingSystem) == 0 || operatingSystem[0] == nil {
		return diag.Errorf(
			"\"%s\": required field is not set",
			mkOperatingSystem,
		)
	}

	operatingSystemBlock := operatingSystem[0].(map[string]interface{})
	operatingSystemTemplateFileID := operatingSystemBlock[mkOperatingSystemTemplateFileID].(string)
	operatingSystemType := operatingSystemBlock[mkOperatingSystemType].(string)

	poolID := d.Get(mkPoolID).(string)
	protection := types.CustomBool(d.Get(mkProtection).(bool))
	started := types.CustomBool(d.Get(mkStarted).(bool))
	startOnBoot := types.CustomBool(d.Get(mkStartOnBoot).(bool))
	startupBehavior := containerGetStartupBehavior(d)
	tags := d.Get(mkTags).([]interface{})
	template := types.CustomBool(d.Get(mkTemplate).(bool))
	unprivileged := types.CustomBool(d.Get(mkUnprivileged).(bool))
	vmIDUntyped, hasVMID := d.GetOk(mkVMID)
	vmID := vmIDUntyped.(int)

	if !hasVMID {
		vmIDNew, err := config.GetIDGenerator().NextID(ctx)
		if err != nil {
			return diag.FromErr(err)
		}

		vmID = vmIDNew

		err = d.Set(mkVMID, vmID)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	// Attempt to create the container using the retrieved values.
	createBody := containers.CreateRequestBody{
		ConsoleEnabled:       &consoleEnabled,
		ConsoleMode:          &consoleMode,
		CPUArchitecture:      &cpuArchitecture,
		CPUCores:             &cpuCores,
		CPUUnits:             &cpuUnits,
		DatastoreID:          &diskDatastoreID,
		DedicatedMemory:      &memoryDedicated,
		PassthroughDevices:   passthroughDevices,
		Features:             features,
		MountPoints:          mountPoints,
		NetworkInterfaces:    networkInterfaces,
		OSTemplateFileVolume: &operatingSystemTemplateFileID,
		OSType:               &operatingSystemType,
		Protection:           &protection,
		RootFS:               rootFS,
		Start:                &started,
		StartOnBoot:          &startOnBoot,
		StartupBehavior:      startupBehavior,
		Swap:                 &memorySwap,
		Template:             &template,
		TTY:                  &consoleTTYCount,
		Unprivileged:         &unprivileged,
		VMID:                 &vmID,
	}

	if description != "" {
		createBody.Description = &description
	}

	if hookScript != "" {
		createBody.HookScript = &hookScript
	}

	if initializationDNSDomain != "" {
		createBody.DNSDomain = &initializationDNSDomain
	}

	if initializationDNSServer != "" {
		createBody.DNSServer = &initializationDNSServer
	}

	if initializationHostname != "" {
		createBody.Hostname = &initializationHostname
	}

	if len(initializationUserAccountKeys) > 0 {
		createBody.SSHKeys = &initializationUserAccountKeys
	}

	if initializationUserAccountPassword != "" {
		createBody.Password = &initializationUserAccountPassword
	}

	if poolID != "" {
		createBody.PoolID = &poolID
	}

	if len(tags) > 0 {
		tagsString := containerGetTagsString(d)
		createBody.Tags = &tagsString
	}

	err = client.Node(nodeName).Container(0).CreateContainer(ctx, &createBody)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(strconv.Itoa(vmID))

	// Wait for the container's lock to be released.
	err = client.Node(nodeName).Container(vmID).WaitForContainerConfigUnlock(ctx, true)
	if err != nil {
		return diag.FromErr(err)
	}

	return containerCreateStart(ctx, d, m)
}

func containerCreateStart(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	started := d.Get(mkStarted).(bool)
	template := d.Get(mkTemplate).(bool)

	if !started || template {
		return containerRead(ctx, d, m)
	}

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)

	vmID, err := strconv.Atoi(d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	containerAPI := client.Node(nodeName).Container(vmID)

	// Start the container and wait for it to reach a running state before continuing.
	err = containerAPI.StartContainer(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	return containerRead(ctx, d, m)
}

// NOTE: this function is NOT used in `read`!
func containerGetExistingNetworkInterface(
	ctx context.Context,
	containerAPI *containers.Client,
) ([]interface{}, error) {
	containerInfo, err := containerAPI.GetContainer(ctx)
	if err != nil {
		return []interface{}{}, fmt.Errorf("error getting container information: %w", err)
	}

	networkInterfacesMap := make(map[string]interface{}, len(containerInfo.NetworkInterfaces))

	for key, nv := range containerInfo.NetworkInterfaces {
		networkInterface := map[string]interface{}{}

		networkInterface[mkNetworkInterfaceEnabled] = true
		networkInterface[mkNetworkInterfaceName] = nv.Name // "eth0", "eth1", etc, same as the `key`

		if nv.Bridge != nil {
			networkInterface[mkNetworkInterfaceBridge] = *nv.Bridge
		} else {
			networkInterface[mkNetworkInterfaceBridge] = ""
		}

		if nv.Firewall != nil && *nv.Firewall {
			networkInterface[mkNetworkInterfaceFirewall] = true
		} else {
			networkInterface[mkNetworkInterfaceFirewall] = false
		}

		if nv.MACAddress != nil {
			networkInterface[mkNetworkInterfaceMACAddress] = *nv.MACAddress
		} else {
			networkInterface[mkNetworkInterfaceMACAddress] = ""
		}

		if nv.RateLimit != nil {
			networkInterface[mkNetworkInterfaceRateLimit] = *nv.RateLimit
		} else {
			networkInterface[mkNetworkInterfaceRateLimit] = float64(0)
		}

		if nv.Tag != nil {
			networkInterface[mkNetworkInterfaceVLANID] = *nv.Tag
		} else {
			networkInterface[mkNetworkInterfaceVLANID] = 0
		}

		if nv.MTU != nil {
			networkInterface[mkNetworkInterfaceMTU] = *nv.MTU
		} else {
			networkInterface[mkNetworkInterfaceMTU] = 0
		}

		networkInterfacesMap[key] = networkInterface
	}

	return utils.OrderedListFromMap(networkInterfacesMap), nil
}

func containerGetTagsString(d *schema.ResourceData) string {
	var sanitizedTags []string

	tags := d.Get(mkTags).([]interface{})
	for _, tag := range tags {
		sanitizedTag := strings.TrimSpace(tag.(string))
		if len(sanitizedTag) > 0 {
			sanitizedTags = append(sanitizedTags, sanitizedTag)
		}
	}

	sort.Strings(sanitizedTags)

	return strings.Join(sanitizedTags, ";")
}

func containerGetStartupBehavior(d *schema.ResourceData) *containers.CustomStartupBehavior {
	startup := d.Get(mkStartup).([]interface{})
	if len(startup) > 0 && startup[0] != nil {
		startupBlock := startup[0].(map[string]interface{})
		startupOrder := startupBlock[mkStartupOrder].(int)
		startupUpDelay := startupBlock[mkStartupUpDelay].(int)
		startupDownDelay := startupBlock[mkStartupDownDelay].(int)

		order := containers.CustomStartupBehavior{}

		if startupUpDelay >= 0 {
			order.Up = &startupUpDelay
		}

		if startupDownDelay >= 0 {
			order.Down = &startupDownDelay
		}

		if startupOrder >= 0 {
			order.Order = &startupOrder
		}

		return &order
	}

	return nil
}

func containerGetFeatures(resource *schema.Resource, d *schema.ResourceData) (*containers.CustomFeatures, error) {
	featuresBlock, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkFeatures},
		0,
		true,
	)
	if err != nil {
		return nil, fmt.Errorf("error getting container features from schema: %w", err)
	}

	nesting := types.CustomBool(featuresBlock[mkFeaturesNesting].(bool))
	keyctl := types.CustomBool(featuresBlock[mkFeaturesKeyControl].(bool))
	fuse := types.CustomBool(featuresBlock[mkFeaturesFUSE].(bool))
	mountTypes := featuresBlock[mkFeaturesMountTypes].([]interface{})

	var mountTypesConverted []string
	if mountTypes != nil {
		mountTypesConverted = make([]string, len(mountTypes))
		for i, mountType := range mountTypes {
			mountTypesConverted[i] = mountType.(string)
		}
	} else {
		mountTypesConverted = []string{}
	}

	features := containers.CustomFeatures{
		MountTypes: &mountTypesConverted,
	}

	if nesting {
		features.Nesting = &nesting
	}

	if keyctl {
		features.KeyControl = &keyctl
	}

	if fuse {
		features.FUSE = &fuse
	}

	return &features, nil
}

func containerRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)

	client, e := config.GetClient()
	if e != nil {
		return diag.FromErr(e)
	}

	nodeName := d.Get(mkNodeName).(string)

	vmID, e := strconv.Atoi(d.Id())
	if e != nil {
		return diag.FromErr(e)
	}

	containerAPI := client.Node(nodeName).Container(vmID)

	// Retrieve the entire configuration in order to compare it to the state.
	containerConfig, e := containerAPI.GetContainer(ctx)
	if e != nil {
		if errors.Is(e, api.ErrResourceDoesNotExist) {
			d.SetId("")

			return nil
		}

		return diag.FromErr(e)
	}

	// Fix terraform.tfstate, by replacing '-1' (the old default value) with actual vm_id value
	if storedVMID := d.Get(mkVMID).(int); storedVMID == -1 {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Warning,
			Summary: fmt.Sprintf("VM %s has stored legacy vm_id %d, setting vm_id to its correct value %d.",
				d.Id(), storedVMID, vmID),
		})

		err := d.Set(mkVMID, vmID)
		diags = append(diags, diag.FromErr(err)...)
	}

	clone := d.Get(mkClone).([]interface{})

	// Compare the primitive values to those stored in the state.
	currentDescription := d.Get(mkDescription).(string)

	if len(clone) == 0 || currentDescription != dvDescription {
		if containerConfig.Description != nil {
			e = d.Set(mkDescription, *containerConfig.Description)
		} else {
			e = d.Set(mkDescription, "")
		}

		diags = append(diags, diag.FromErr(e)...)
	}

	// Compare the console configuration to the one stored in the state.
	console := map[string]interface{}{}

	if containerConfig.ConsoleEnabled != nil {
		console[mkConsoleEnabled] = *containerConfig.ConsoleEnabled
	} else {
		// Default value of "console" is "1" according to the API documentation.
		console[mkConsoleEnabled] = true
	}

	if containerConfig.ConsoleMode != nil {
		console[mkConsoleMode] = *containerConfig.ConsoleMode
	} else {
		// Default value of "cmode" is "tty" according to the API documentation.
		console[mkConsoleMode] = "tty"
	}

	if containerConfig.TTY != nil {
		console[mkConsoleTTYCount] = *containerConfig.TTY
	} else {
		// Default value of "tty" is "2" according to the API documentation.
		console[mkConsoleTTYCount] = 2
	}

	currentConsole := d.Get(mkConsole).([]interface{})

	if len(clone) > 0 {
		if len(currentConsole) > 0 {
			err := d.Set(mkConsole, []interface{}{console})
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentConsole) > 0 ||
		console[mkConsoleEnabled] != types.CustomBool(dvConsoleEnabled) ||
		console[mkConsoleMode] != dvConsoleMode ||
		console[mkConsoleTTYCount] != dvConsoleTTYCount {
		err := d.Set(mkConsole, []interface{}{console})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the CPU configuration to the one stored in the state.
	cpu := map[string]interface{}{}

	if containerConfig.CPUArchitecture != nil {
		cpu[mkCPUArchitecture] = *containerConfig.CPUArchitecture
	} else {
		// Default value of "arch" is "amd64" according to the API documentation.
		cpu[mkCPUArchitecture] = "amd64"
	}

	if containerConfig.CPUCores != nil {
		cpu[mkCPUCores] = *containerConfig.CPUCores
	} else {
		// Default value of "cores" is "1" according to the API documentation.
		cpu[mkCPUCores] = 1
	}

	if containerConfig.CPUUnits != nil {
		cpu[mkCPUUnits] = *containerConfig.CPUUnits
	} else {
		// Default value of "cpuunits" is "1024" according to the API documentation.
		cpu[mkCPUUnits] = 1024
	}

	currentCPU := d.Get(mkCPU).([]interface{})

	if len(clone) > 0 {
		if len(currentCPU) > 0 {
			err := d.Set(mkCPU, []interface{}{cpu})
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentCPU) > 0 ||
		cpu[mkCPUArchitecture] != dvCPUArchitecture ||
		cpu[mkCPUCores] != dvCPUCores ||
		cpu[mkCPUUnits] != dvCPUUnits {
		err := d.Set(mkCPU, []interface{}{cpu})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the disk configuration to the one stored in the state.
	disk := map[string]interface{}{}

	if containerConfig.RootFS != nil {
		volumeParts := strings.Split(containerConfig.RootFS.Volume, ":")
		disk[mkDiskDatastoreID] = volumeParts[0]
		disk[mkDiskSize] = containerConfig.RootFS.Size.InGigabytes()
	} else {
		// Default value of "storage" is "local" according to the API documentation.
		disk[mkDiskDatastoreID] = "local"
		disk[mkDiskSize] = dvDiskSize
	}

	currentDisk := d.Get(mkDisk).([]interface{})

	if len(clone) > 0 {
		if len(currentDisk) > 0 && currentDisk[0] != nil {
			// do not override the rootfs size if it was not changed during the clone operation
			if currentDisk[0].(map[string]interface{})[mkDiskSize] == dvDiskSize {
				disk[mkDiskSize] = dvDiskSize
			}

			err := d.Set(mkDisk, []interface{}{disk})
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentDisk) > 0 ||
		disk[mkDiskDatastoreID] != dvDiskDatastoreID ||
		disk[mkDiskSize] != dvDiskSize {
		err := d.Set(mkDisk, []interface{}{disk})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the memory configuration to the one stored in the state.
	memory := map[string]interface{}{}

	if containerConfig.DedicatedMemory != nil {
		memory[mkMemoryDedicated] = *containerConfig.DedicatedMemory
	} else {
		memory[mkMemoryDedicated] = 0
	}

	if containerConfig.Swap != nil {
		memory[mkMemorySwap] = *containerConfig.Swap
	} else {
		memory[mkMemorySwap] = 0
	}

	currentMemory := d.Get(mkMemory).([]interface{})

	if len(clone) > 0 {
		if len(currentMemory) > 0 {
			err := d.Set(mkMemory, []interface{}{memory})
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentMemory) > 0 ||
		memory[mkMemoryDedicated] != dvMemoryDedicated ||
		memory[mkMemorySwap] != dvMemorySwap {
		err := d.Set(mkMemory, []interface{}{memory})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the initialization and network interface configuration to the one stored in the state.
	initialization := map[string]interface{}{}

	if containerConfig.DNSDomain != nil || containerConfig.DNSServer != nil {
		initializationDNS := map[string]interface{}{}

		if containerConfig.DNSDomain != nil {
			initializationDNS[mkInitializationDNSDomain] = *containerConfig.DNSDomain
		} else {
			initializationDNS[mkInitializationDNSDomain] = ""
		}

		// check what we have in the plan
		currentInitializationDNSBlock := map[string]interface{}{}
		currentInitialization := d.Get(mkInitialization).([]interface{})

		if len(currentInitialization) > 0 && currentInitialization[0] != nil {
			currentInitializationBlock := currentInitialization[0].(map[string]interface{})
			currentInitializationDNS := currentInitializationBlock[mkInitializationDNS].([]interface{})

			if len(currentInitializationDNS) > 0 && currentInitializationDNS[0] != nil {
				currentInitializationDNSBlock = currentInitializationDNS[0].(map[string]interface{})
			}
		}

		currentInitializationDNSServer, ok := currentInitializationDNSBlock[mkInitializationDNSServer]
		if containerConfig.DNSServer != nil {
			if ok && currentInitializationDNSServer != "" {
				initializationDNS[mkInitializationDNSServer] = *containerConfig.DNSServer
			} else {
				dnsServer := strings.Split(*containerConfig.DNSServer, " ")
				initializationDNS[mkInitializationDNSServers] = dnsServer
			}
		} else {
			initializationDNS[mkInitializationDNSServer] = ""
			initializationDNS[mkInitializationDNSServers] = []string{}
		}

		initialization[mkInitializationDNS] = []interface{}{
			initializationDNS,
		}
	}

	if containerConfig.Hostname != nil {
		initialization[mkInitializationHostname] = *containerConfig.Hostname
	} else {
		initialization[mkInitializationHostname] = ""
	}

	passthroughDevicesMap := make(map[string]interface{}, len(containerConfig.PassthroughDevices))

	for key, dp := range containerConfig.PassthroughDevices {
		passthroughDevice := map[string]interface{}{}

		if dp.DenyWrite != nil {
			passthroughDevice[mkDevicePassthroughDenyWrite] = *dp.DenyWrite
		} else {
			passthroughDevice[mkDevicePassthroughDenyWrite] = false
		}

		if dp.GID != nil {
			passthroughDevice[mkDevicePassthroughGID] = *dp.GID
		} else {
			passthroughDevice[mkDevicePassthroughGID] = 0
		}

		if dp.Mode != nil {
			passthroughDevice[mkDevicePassthroughMode] = *dp.Mode
		} else {
			passthroughDevice[mkDevicePassthroughMode] = dvDevicePassthroughMode
		}

		passthroughDevice[mkDevicePassthroughPath] = dp.Path

		if dp.UID != nil {
			passthroughDevice[mkDevicePassthroughUID] = *dp.UID
		} else {
			passthroughDevice[mkDevicePassthroughUID] = 0
		}

		passthroughDevicesMap[key] = passthroughDevice
	}

	passthroughDevices := utils.OrderedListFromMap(passthroughDevicesMap)
	currentPassthroughDevices := d.Get(mkDevicePassthrough).([]interface{})

	if len(clone) > 0 {
		if len(currentPassthroughDevices) > 0 {
			err := d.Set(mkDevicePassthrough, passthroughDevices)
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(passthroughDevicesMap) > 0 {
		err := d.Set(mkDevicePassthrough, passthroughDevices)
		diags = append(diags, diag.FromErr(err)...)
	}

	mountPointsMap := make(map[string]interface{}, len(containerConfig.MountPoints))

	for key, mp := range containerConfig.MountPoints {
		mountPoint := map[string]interface{}{}

		if mp.ACL != nil {
			mountPoint[mkMountPointACL] = *mp.ACL
		} else {
			mountPoint[mkMountPointACL] = false
		}

		if mp.Backup != nil {
			mountPoint[mkMountPointBackup] = *mp.Backup
		} else {
			mountPoint[mkMountPointBackup] = dvMountPointBackup
		}

		if mp.MountOptions != nil {
			mountPoint[mkMountPointMountOptions] = *mp.MountOptions
		} else {
			mountPoint[mkMountPointMountOptions] = []string{}
		}

		mountPoint[mkMountPointPath] = mp.MountPoint

		if mp.Quota != nil {
			mountPoint[mkMountPointQuota] = *mp.Quota
		} else {
			mountPoint[mkMountPointQuota] = false
		}

		if mp.ReadOnly != nil {
			mountPoint[mkMountPointReadOnly] = *mp.ReadOnly
		} else {
			mountPoint[mkMountPointReadOnly] = false
		}

		if mp.Replicate != nil {
			mountPoint[mkMountPointReplicate] = *mp.Replicate
		} else {
			mountPoint[mkMountPointReplicate] = true
		}

		if mp.Shared != nil {
			mountPoint[mkMountPointShared] = *mp.Shared
		} else {
			mountPoint[mkMountPointShared] = false
		}

		if mp.DiskSize != nil {
			mountPoint[mkMountPointSize] = *mp.DiskSize
		} else {
			mountPoint[mkMountPointSize] = ""
		}

		mountPoint[mkMountPointVolume] = mp.Volume

		mountPointsMap[key] = mountPoint
	}

	mountPoints := utils.OrderedListFromMap(mountPointsMap)
	currentMountPoints := d.Get(mkMountPoint).([]interface{})

	if len(clone) > 0 {
		if len(currentMountPoints) > 0 {
			err := d.Set(mkMountPoint, mountPoints)
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(mountPointsMap) > 0 {
		err := d.Set(mkMountPoint, mountPoints)
		diags = append(diags, diag.FromErr(err)...)
	}

	ipConfigMap := make(map[string]interface{}, len(containerConfig.NetworkInterfaces))
	networkInterfacesMap := make(map[string]interface{}, len(containerConfig.NetworkInterfaces))

	for key, nv := range containerConfig.NetworkInterfaces {
		if nv.IPv4Address != nil || nv.IPv4Gateway != nil || nv.IPv6Address != nil ||
			nv.IPv6Gateway != nil {
			ipConfig := map[string]interface{}{}

			if nv.IPv4Address != nil || nv.IPv4Gateway != nil {
				ip := map[string]interface{}{}

				if nv.IPv4Address != nil {
					ip[mkInitializationIPConfigIPv4Address] = *nv.IPv4Address
				} else {
					ip[mkInitializationIPConfigIPv4Address] = ""
				}

				if nv.IPv4Gateway != nil {
					ip[mkInitializationIPConfigIPv4Gateway] = *nv.IPv4Gateway
				} else {
					ip[mkInitializationIPConfigIPv4Gateway] = ""
				}

				ipConfig[mkInitializationIPConfigIPv4] = []interface{}{ip}
			} else {
				ipConfig[mkInitializationIPConfigIPv4] = []interface{}{}
			}

			if nv.IPv6Address != nil || nv.IPv6Gateway != nil {
				ip := map[string]interface{}{}

				if nv.IPv6Address != nil {
					ip[mkInitializationIPConfigIPv6Address] = *nv.IPv6Address
				} else {
					ip[mkInitializationIPConfigIPv6Address] = ""
				}

				if nv.IPv6Gateway != nil {
					ip[mkInitializationIPConfigIPv6Gateway] = *nv.IPv6Gateway
				} else {
					ip[mkInitializationIPConfigIPv6Gateway] = ""
				}

				ipConfig[mkInitializationIPConfigIPv6] = []interface{}{ip}
			} else {
				ipConfig[mkInitializationIPConfigIPv6] = []interface{}{}
			}

			// there is only one set of IP addresses (IPv4 + IPv6)  per network interface
			ipConfigMap[key] = ipConfig
		}

		networkInterface := map[string]interface{}{}

		networkInterface[mkNetworkInterfaceEnabled] = true
		networkInterface[mkNetworkInterfaceName] = nv.Name

		if nv.Bridge != nil {
			networkInterface[mkNetworkInterfaceBridge] = *nv.Bridge
		} else {
			networkInterface[mkNetworkInterfaceBridge] = ""
		}

		if nv.Firewall != nil && *nv.Firewall {
			networkInterface[mkNetworkInterfaceFirewall] = true
		} else {
			networkInterface[mkNetworkInterfaceFirewall] = false
		}

		if nv.MACAddress != nil {
			networkInterface[mkNetworkInterfaceMACAddress] = *nv.MACAddress
		} else {
			networkInterface[mkNetworkInterfaceMACAddress] = ""
		}

		if nv.RateLimit != nil {
			networkInterface[mkNetworkInterfaceRateLimit] = *nv.RateLimit
		} else {
			networkInterface[mkNetworkInterfaceRateLimit] = 0
		}

		if nv.Tag != nil {
			networkInterface[mkNetworkInterfaceVLANID] = *nv.Tag
		} else {
			networkInterface[mkNetworkInterfaceVLANID] = 0
		}

		if nv.MTU != nil {
			networkInterface[mkNetworkInterfaceMTU] = *nv.MTU
		} else {
			networkInterface[mkNetworkInterfaceMTU] = 0
		}

		networkInterfacesMap[key] = networkInterface
	}

	networkInterfaces := utils.OrderedListFromMap(networkInterfacesMap)
	initialization[mkInitializationIPConfig] = utils.OrderedListFromMap(ipConfigMap)

	currentInitialization := d.Get(mkInitialization).([]interface{})

	if len(currentInitialization) > 0 && currentInitialization[0] != nil {
		currentInitializationMap := currentInitialization[0].(map[string]interface{})

		initialization[mkInitializationUserAccount] = currentInitializationMap[mkInitializationUserAccount].([]interface{})
	}

	if len(clone) > 0 {
		if len(currentInitialization) > 0 && currentInitialization[0] != nil {
			currentInitializationBlock := currentInitialization[0].(map[string]interface{})
			currentInitializationDNS := currentInitializationBlock[mkInitializationDNS].([]interface{})

			if len(currentInitializationDNS) == 0 {
				initialization[mkInitializationDNS] = []interface{}{}
			}

			currentInitializationIPConfig := currentInitializationBlock[mkInitializationIPConfig].([]interface{})

			if len(currentInitializationIPConfig) == 0 {
				initialization[mkInitializationIPConfig] = []interface{}{}
			}

			currentInitializationUserAccount := currentInitializationBlock[mkInitializationUserAccount].([]interface{})

			if len(currentInitializationUserAccount) == 0 {
				initialization[mkInitializationUserAccount] = []interface{}{}
			}

			if len(initialization) > 0 {
				e = d.Set(
					mkInitialization,
					[]interface{}{initialization},
				)
			} else {
				e = d.Set(mkInitialization, []interface{}{})
			}

			diags = append(diags, diag.FromErr(e)...)
		}

		currentNetworkInterface := d.Get(mkNetworkInterface).([]interface{})

		if len(currentNetworkInterface) > 0 {
			err := d.Set(mkNetworkInterface, networkInterfaces)
			diags = append(diags, diag.FromErr(err)...)
		}
	} else {
		if len(initialization) > 0 {
			e = d.Set(mkInitialization, []interface{}{initialization})
		} else {
			e = d.Set(mkInitialization, []interface{}{})
		}

		diags = append(diags, diag.FromErr(e)...)

		err := d.Set(mkNetworkInterface, networkInterfaces)
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the startup behavior to the one stored in the state.
	var startup map[string]interface{}

	if containerConfig.StartupBehavior != nil {
		startup = map[string]interface{}{}

		if containerConfig.StartupBehavior.Order != nil {
			startup[mkStartupOrder] = *containerConfig.StartupBehavior.Order
		} else {
			startup[mkStartupOrder] = dvStartupOrder
		}

		if containerConfig.StartupBehavior.Up != nil {
			startup[mkStartupUpDelay] = *containerConfig.StartupBehavior.Up
		} else {
			startup[mkStartupUpDelay] = dvStartupUpDelay
		}

		if containerConfig.StartupBehavior.Down != nil {
			startup[mkStartupDownDelay] = *containerConfig.StartupBehavior.Down
		} else {
			startup[mkStartupDownDelay] = dvStartupDownDelay
		}
	}

	currentStartup := d.Get(mkStartup).([]interface{})

	switch {
	case len(clone) > 0 && len(currentStartup) > 0:
		err := d.Set(mkStartup, []interface{}{startup})
		diags = append(diags, diag.FromErr(err)...)
	case len(startup) == 0:
		err := d.Set(mkStartup, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	case len(currentStartup) > 0 ||
		startup[mkStartupOrder] != mkStartupOrder ||
		startup[mkStartupUpDelay] != dvStartupUpDelay ||
		startup[mkStartupDownDelay] != dvStartupDownDelay:
		err := d.Set(mkStartup, []interface{}{startup})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the operating system configuration to the one stored in the state.
	operatingSystem := map[string]interface{}{}

	if containerConfig.OSType != nil {
		operatingSystem[mkOperatingSystemType] = *containerConfig.OSType
	} else {
		// Default value of "ostype" is "" according to the API documentation.
		operatingSystem[mkOperatingSystemType] = ""
	}

	currentOperatingSystem := d.Get(mkOperatingSystem).([]interface{})

	if len(currentOperatingSystem) > 0 && currentOperatingSystem[0] != nil {
		currentOperatingSystemMap := currentOperatingSystem[0].(map[string]interface{})

		operatingSystem[mkOperatingSystemTemplateFileID] = currentOperatingSystemMap[mkOperatingSystemTemplateFileID]
	}

	if len(clone) > 0 {
		if len(currentOperatingSystem) > 0 {
			err := d.Set(
				mkOperatingSystem,
				[]interface{}{operatingSystem},
			)
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentOperatingSystem) > 0 ||
		operatingSystem[mkOperatingSystemType] != dvOperatingSystemType {
		err := d.Set(mkOperatingSystem, []interface{}{operatingSystem})
		diags = append(diags, diag.FromErr(err)...)
	}

	currentUnprivileged := types.CustomBool(d.Get(mkUnprivileged).(bool))

	if len(clone) == 0 || currentUnprivileged {
		if containerConfig.Unprivileged != nil {
			e = d.Set(
				mkUnprivileged,
				bool(*containerConfig.Unprivileged),
			)
		} else {
			e = d.Set(mkUnprivileged, false)
		}

		diags = append(diags, diag.FromErr(e)...)
	}

	currentProtection := types.CustomBool(d.Get(mkProtection).(bool))

	if len(clone) == 0 || currentProtection {
		if containerConfig.Protection != nil {
			e = d.Set(
				mkProtection,
				bool(*containerConfig.Protection),
			)
		} else {
			e = d.Set(mkProtection, false)
		}

		diags = append(diags, diag.FromErr(e)...)
	}

	currentTags := d.Get(mkTags).([]interface{})

	if len(clone) == 0 || len(currentTags) > 0 {
		var tags []string

		if containerConfig.Tags != nil {
			for _, tag := range strings.Split(*containerConfig.Tags, ";") {
				t := strings.TrimSpace(tag)
				if len(t) > 0 {
					tags = append(tags, t)
				}
			}

			sort.Strings(tags)
		}

		e = d.Set(mkTags, tags)
		diags = append(diags, diag.FromErr(e)...)
	}

	currentTemplate := d.Get(mkTemplate).(bool)

	if len(clone) == 0 || currentTemplate {
		if containerConfig.Template != nil {
			e = d.Set(
				mkTemplate,
				bool(*containerConfig.Template),
			)
		} else {
			e = d.Set(mkTemplate, false)
		}

		diags = append(diags, diag.FromErr(e)...)
	}

	// Determine the state of the container in order to update the "started" argument.
	status, e := containerAPI.GetContainerStatus(ctx)
	if e != nil {
		return diag.FromErr(e)
	}

	e = d.Set(mkStarted, status.Status == "running")
	diags = append(diags, diag.FromErr(e)...)

	return diags
}

func containerUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	updateTimeoutSec := d.Get(mkTimeoutUpdate).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(updateTimeoutSec)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, e := config.GetClient()
	if e != nil {
		return diag.FromErr(e)
	}

	nodeName := d.Get(mkNodeName).(string)

	vmID, e := strconv.Atoi(d.Id())
	if e != nil {
		return diag.FromErr(e)
	}

	containerAPI := client.Node(nodeName).Container(vmID)

	// Prepare the new request object.
	updateBody := containers.UpdateRequestBody{
		Delete: []string{},
	}

	rebootRequired := false
	container := Container()

	// Retrieve the clone argument as the update logic varies for clones.
	clone := d.Get(mkClone).([]interface{})

	// Prepare the new primitive values.
	description := d.Get(mkDescription).(string)
	updateBody.Description = &description

	template := types.CustomBool(d.Get(mkTemplate).(bool))

	if d.HasChange(mkTemplate) {
		updateBody.Template = &template
	}

	// Prepare the new console configuration.
	if d.HasChange(mkConsole) {
		consoleBlock, err := structure.GetSchemaBlock(
			container,
			d,
			[]string{mkConsole},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		consoleEnabled := types.CustomBool(
			consoleBlock[mkConsoleEnabled].(bool),
		)
		consoleMode := consoleBlock[mkConsoleMode].(string)
		consoleTTYCount := consoleBlock[mkConsoleTTYCount].(int)

		updateBody.ConsoleEnabled = &consoleEnabled
		updateBody.ConsoleMode = &consoleMode
		updateBody.TTY = &consoleTTYCount

		rebootRequired = true
	}

	// Prepare the new CPU configuration.
	if d.HasChange(mkCPU) {
		cpuBlock, err := structure.GetSchemaBlock(
			container,
			d,
			[]string{mkCPU},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		cpuArchitecture := cpuBlock[mkCPUArchitecture].(string)
		cpuCores := cpuBlock[mkCPUCores].(int)
		cpuUnits := cpuBlock[mkCPUUnits].(int)

		updateBody.CPUArchitecture = &cpuArchitecture
		updateBody.CPUCores = &cpuCores
		updateBody.CPUUnits = &cpuUnits
	}

	if d.HasChange(mkFeatures) {
		features, err := containerGetFeatures(container, d)
		if err != nil {
			return diag.FromErr(err)
		}

		updateBody.Features = features
	}

	if d.HasChange(mkHookScriptFileID) {
		hookScript := d.Get(mkHookScriptFileID).(string)
		if hookScript != "" {
			updateBody.HookScript = &hookScript
		} else {
			updateBody.Delete = append(updateBody.Delete, "hookscript")
		}
	}

	// Prepare the new initialization configuration.
	initialization := d.Get(mkInitialization).([]interface{})
	initializationDNSDomain := dvInitializationDNSDomain
	initializationDNSServer := dvInitializationDNSServer
	initializationHostname := dvInitializationHostname

	var initializationIPConfigIPv4Address []string

	var initializationIPConfigIPv4Gateway []string

	var initializationIPConfigIPv6Address []string

	var initializationIPConfigIPv6Gateway []string

	if len(initialization) > 0 && initialization[0] != nil {
		initializationBlock := initialization[0].(map[string]interface{})
		initializationDNS := initializationBlock[mkInitializationDNS].([]interface{})

		if len(initializationDNS) > 0 {
			initializationDNSBlock := initializationDNS[0].(map[string]interface{})
			initializationDNSDomain = initializationDNSBlock[mkInitializationDNSDomain].(string)

			servers := initializationDNSBlock[mkInitializationDNSServers].([]interface{})
			deprecatedServer := initializationDNSBlock[mkInitializationDNSServer].(string)

			if len(servers) > 0 {
				initializationDNSServer = strings.Join(utils.ConvertToStringSlice(servers), " ")
			} else {
				initializationDNSServer = deprecatedServer
			}
		}

		initializationHostname = initializationBlock[mkInitializationHostname].(string)
		initializationIPConfig := initializationBlock[mkInitializationIPConfig].([]interface{})

		for _, c := range initializationIPConfig {
			if c == nil {
				continue
			}

			configBlock := c.(map[string]interface{})
			ipv4 := configBlock[mkInitializationIPConfigIPv4].([]interface{})

			if len(ipv4) > 0 && ipv4[0] != nil {
				ipv4Block := ipv4[0].(map[string]interface{})

				initializationIPConfigIPv4Address = append(
					initializationIPConfigIPv4Address,
					ipv4Block[mkInitializationIPConfigIPv4Address].(string),
				)

				initializationIPConfigIPv4Gateway = append(
					initializationIPConfigIPv4Gateway,
					ipv4Block[mkInitializationIPConfigIPv4Gateway].(string),
				)
			} else {
				initializationIPConfigIPv4Address = append(initializationIPConfigIPv4Address, "")
				initializationIPConfigIPv4Gateway = append(initializationIPConfigIPv4Gateway, "")
			}

			ipv6 := configBlock[mkInitializationIPConfigIPv6].([]interface{})

			if len(ipv6) > 0 && ipv6[0] != nil {
				ipv6Block := ipv6[0].(map[string]interface{})

				initializationIPConfigIPv6Address = append(
					initializationIPConfigIPv6Address,
					ipv6Block[mkInitializationIPConfigIPv6Address].(string),
				)

				initializationIPConfigIPv6Gateway = append(
					initializationIPConfigIPv6Gateway,
					ipv6Block[mkInitializationIPConfigIPv6Gateway].(string),
				)
			} else {
				initializationIPConfigIPv6Address = append(initializationIPConfigIPv6Address, "")
				initializationIPConfigIPv6Gateway = append(initializationIPConfigIPv6Gateway, "")
			}
		}
	}

	if d.HasChange(mkInitialization + "." + mkInitializationDNS) {
		updateBody.DNSDomain = &initializationDNSDomain
		updateBody.DNSServer = &initializationDNSServer
		rebootRequired = true
	}

	if d.HasChange(mkInitialization + "." + mkInitializationHostname) {
		updateBody.Hostname = &initializationHostname
		rebootRequired = true
	}

	// Prepare the new memory configuration.
	if d.HasChange(mkMemory) {
		memoryBlock, err := structure.GetSchemaBlock(
			container,
			d,
			[]string{mkMemory},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		memoryDedicated := memoryBlock[mkMemoryDedicated].(int)
		memorySwap := memoryBlock[mkMemorySwap].(int)

		updateBody.DedicatedMemory = &memoryDedicated
		updateBody.Swap = &memorySwap

		rebootRequired = true
	}

	// Prepare the new device passthrough configuration.
	if d.HasChange(mkDevicePassthrough) {
		_, newDevicePassthrough := d.GetChange(mkDevicePassthrough)

		devicePassthrough := newDevicePassthrough.([]interface{})
		passthroughDevices := make(
			containers.CustomPassthroughDevices,
			len(devicePassthrough),
		)

		for i, dp := range devicePassthrough {
			devicePassthroughMap := dp.(map[string]interface{})
			devicePassthroughObject := containers.CustomPassthroughDevice{}

			denyWrite := types.CustomBool(devicePassthroughMap[mkDevicePassthroughDenyWrite].(bool))
			gid := devicePassthroughMap[mkDevicePassthroughGID].(int)
			mode := devicePassthroughMap[mkDevicePassthroughMode].(string)
			path := devicePassthroughMap[mkDevicePassthroughPath].(string)
			uid := devicePassthroughMap[mkDevicePassthroughUID].(int)

			devicePassthroughObject.DenyWrite = &denyWrite
			devicePassthroughObject.GID = &gid
			devicePassthroughObject.Mode = &mode
			devicePassthroughObject.Path = path
			devicePassthroughObject.UID = &uid

			passthroughDevices[fmt.Sprintf("dev%d", i)] = &devicePassthroughObject
		}

		updateBody.PassthroughDevices = passthroughDevices

		rebootRequired = true
	}

	// Prepare the new mount point configuration.
	if d.HasChange(mkMountPoint) {
		_, newMountPoints := d.GetChange(mkMountPoint)

		mountPoints := newMountPoints.([]interface{})
		mountPointsMap := make(
			containers.CustomMountPoints,
			len(mountPoints),
		)

		for i, mp := range mountPoints {
			mountPointMap := mp.(map[string]interface{})
			mountPointObject := containers.CustomMountPoint{}

			acl := types.CustomBool(mountPointMap[mkMountPointACL].(bool))
			backup := types.CustomBool(mountPointMap[mkMountPointBackup].(bool))
			mountOptions := mountPointMap[mkMountPointMountOptions].([]interface{})
			path := mountPointMap[mkMountPointPath].(string)
			quota := types.CustomBool(mountPointMap[mkMountPointQuota].(bool))
			readOnly := types.CustomBool(mountPointMap[mkMountPointReadOnly].(bool))
			replicate := types.CustomBool(mountPointMap[mkMountPointReplicate].(bool))
			shared := types.CustomBool(mountPointMap[mkMountPointShared].(bool))
			size := mountPointMap[mkMountPointSize].(string)
			volume := mountPointMap[mkMountPointVolume].(string)

			mountPointObject.ACL = &acl
			mountPointObject.Backup = &backup
			mountPointObject.MountPoint = path
			mountPointObject.Quota = &quota
			mountPointObject.ReadOnly = &readOnly
			mountPointObject.Replicate = &replicate
			mountPointObject.Shared = &shared

			// this is a totally hackish way to determine if the mount point is new or not during the container update.
			// an attached storage-backed MP has volume in the format "storage:disk file", i.e. `local-lvm:vm-123-disk-1`
			// while a new storage-backed MP has just plain volume name, i.e. `local-lvm`
			// device or directory MPs won't have a colon in the volume name either, and we don't need to do the special
			// handling for them.
			createNewMP := !strings.Contains(volume, ":")

			if len(size) > 0 && createNewMP {
				var ds types.DiskSize

				ds, err := types.ParseDiskSize(size)
				if err != nil {
					return diag.Errorf("invalid disk size: %s", err.Error())
				}

				mountPointObject.Volume = fmt.Sprintf("%s:%d", volume, ds.InGigabytes())
			} else {
				mountPointObject.Volume = volume
			}

			if len(mountOptions) > 0 {
				mountOptionsArray := make([]string, 0, len(mountPoints))

				for _, option := range mountOptions {
					mountOptionsArray = append(mountOptionsArray, option.(string))
				}

				mountPointObject.MountOptions = &mountOptionsArray
			}

			mountPointsMap[fmt.Sprintf("mp%d", i)] = &mountPointObject
		}

		updateBody.MountPoints = mountPointsMap

		rebootRequired = true
	}

	// Prepare the new network interface configuration.
	networkInterface := d.Get(mkNetworkInterface).([]interface{})

	if len(networkInterface) == 0 && len(clone) > 0 {
		networkInterface, e = containerGetExistingNetworkInterface(ctx, containerAPI)
		if e != nil {
			return diag.FromErr(e)
		}
	}

	if d.HasChange(mkInitialization) ||
		d.HasChange(mkNetworkInterface) {
		networkInterfaces := make(
			containers.CustomNetworkInterfaces,
			len(networkInterface),
		)

		for ni, nv := range networkInterface {
			networkInterfaceMap := nv.(map[string]interface{})
			networkInterfaceObject := containers.CustomNetworkInterface{}

			bridge := networkInterfaceMap[mkNetworkInterfaceBridge].(string)
			enabled := networkInterfaceMap[mkNetworkInterfaceEnabled].(bool)
			firewall := types.CustomBool(
				networkInterfaceMap[mkNetworkInterfaceFirewall].(bool),
			)
			macAddress := networkInterfaceMap[mkNetworkInterfaceMACAddress].(string)
			name := networkInterfaceMap[mkNetworkInterfaceName].(string)
			rateLimit := networkInterfaceMap[mkNetworkInterfaceRateLimit].(float64)
			vlanID := networkInterfaceMap[mkNetworkInterfaceVLANID].(int)
			mtu := networkInterfaceMap[mkNetworkInterfaceMTU].(int)

			if bridge != "" {
				networkInterfaceObject.Bridge = &bridge
			}

			networkInterfaceObject.Enabled = enabled
			networkInterfaceObject.Firewall = &firewall

			if len(initializationIPConfigIPv4Address) > ni {
				if initializationIPConfigIPv4Address[ni] != "" {
					networkInterfaceObject.IPv4Address = &initializationIPConfigIPv4Address[ni]
				}

				if initializationIPConfigIPv4Gateway[ni] != "" {
					networkInterfaceObject.IPv4Gateway = &initializationIPConfigIPv4Gateway[ni]
				}

				if initializationIPConfigIPv6Address[ni] != "" {
					networkInterfaceObject.IPv6Address = &initializationIPConfigIPv6Address[ni]
				}

				if initializationIPConfigIPv6Gateway[ni] != "" {
					networkInterfaceObject.IPv6Gateway = &initializationIPConfigIPv6Gateway[ni]
				}
			}

			if macAddress != "" {
				networkInterfaceObject.MACAddress = &macAddress
			}

			networkInterfaceObject.Name = name

			if rateLimit != 0 {
				networkInterfaceObject.RateLimit = &rateLimit
			}

			if vlanID != 0 {
				networkInterfaceObject.Tag = &vlanID
			}

			if mtu != 0 {
				networkInterfaceObject.MTU = &mtu
			}

			networkInterfaces[fmt.Sprintf("net%d", ni)] = &networkInterfaceObject
		}

		updateBody.NetworkInterfaces = networkInterfaces

		for key, ni := range updateBody.NetworkInterfaces {
			if !ni.Enabled {
				updateBody.Delete = append(updateBody.Delete, key)
			}
		}

		for i := len(updateBody.NetworkInterfaces); i < maxNetworkInterfaces; i++ {
			updateBody.Delete = append(updateBody.Delete, fmt.Sprintf("net%d", i))
		}

		rebootRequired = true
	}

	if d.HasChange(mkStartup) {
		updateBody.StartupBehavior = containerGetStartupBehavior(d)
		if updateBody.StartupBehavior == nil {
			updateBody.Delete = append(updateBody.Delete, "startup")
		}
	}

	// Prepare the new operating system configuration.
	if d.HasChange(mkOperatingSystem) {
		operatingSystem, err := structure.GetSchemaBlock(
			container,
			d,
			[]string{mkOperatingSystem},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		operatingSystemType := operatingSystem[mkOperatingSystemType].(string)

		updateBody.OSType = &operatingSystemType

		rebootRequired = true
	}

	if d.HasChange(mkProtection) {
		protection := types.CustomBool(d.Get(mkProtection).(bool))
		updateBody.Protection = &protection
	}

	if d.HasChange(mkTags) {
		tagString := containerGetTagsString(d)
		updateBody.Tags = &tagString
	}

	// Update the configuration now that everything has been prepared.
	e = containerAPI.UpdateContainer(ctx, &updateBody)
	if e != nil {
		return diag.FromErr(e)
	}

	// Determine if the state of the container needs to be changed.
	started := d.Get(mkStarted).(bool)

	if d.HasChange(mkStarted) && !bool(template) {
		if started {
			e = containerAPI.StartContainer(ctx)
			if e != nil {
				return diag.FromErr(e)
			}
		} else {
			forceStop := types.CustomBool(true)
			// Using delete timeout here as we're in the similar situation
			// as in the delete function, where we need to wait for the container
			// to be stopped before we can proceed with the update.
			// see `containerDelete` function for more details about the logic here
			// Needs to be refactored to a common function
			shutdownTimeoutSec := max(1, d.Get(mkTimeoutDelete).(int)-5)

			e = containerAPI.ShutdownContainer(ctx, &containers.ShutdownRequestBody{
				ForceStop: &forceStop,
				Timeout:   &shutdownTimeoutSec,
			})
			if e != nil {
				return diag.FromErr(e)
			}

			e = containerAPI.WaitForContainerStatus(ctx, "stopped")
			if e != nil {
				return diag.FromErr(e)
			}

			rebootRequired = false
		}
	}

	// As a final step in the update procedure, we might need to reboot the container.
	if !bool(template) && started && rebootRequired {
		rebootTimeout := 300

		e = containerAPI.RebootContainer(
			ctx,
			&containers.RebootRequestBody{
				Timeout: &rebootTimeout,
			},
		)
		if e != nil {
			return diag.FromErr(e)
		}
	}

	return containerRead(ctx, d, m)
}

func containerDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	deleteTimeoutSec := d.Get(mkTimeoutDelete).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(deleteTimeoutSec)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)

	vmID, err := strconv.Atoi(d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	containerAPI := client.Node(nodeName).Container(vmID)

	// Shut down the container before deleting it.
	status, err := containerAPI.GetContainerStatus(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if status.Status != "stopped" {
		forceStop := types.CustomBool(true)

		err = containerAPI.ShutdownContainer(
			ctx,
			&containers.ShutdownRequestBody{
				ForceStop: &forceStop,
				// the timeout here must be less that the context timeout set above,
				// otherwise the context will be cancelled before PVE forcefully stops the container
				Timeout: ptr.Ptr(max(1, deleteTimeoutSec-5)),
			},
		)
		if err != nil {
			return diag.FromErr(err)
		}

		err = containerAPI.WaitForContainerStatus(ctx, "stopped")
		if err != nil {
			return diag.FromErr(err)
		}
	}

	err = containerAPI.DeleteContainer(ctx)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")

			return nil
		}

		return diag.FromErr(err)
	}

	// Wait for the state to become unavailable as that clearly indicates the destruction of the container.
	err = containerAPI.WaitForContainerStatus(ctx, "")
	if err == nil {
		return diag.Errorf("failed to delete container \"%d\"", vmID)
	}

	d.SetId("")

	return nil
}

func parseImportIDWithNodeName(id string) (string, string, error) {
	nodeName, id, found := strings.Cut(id, "/")

	if !found {
		return "", "", fmt.Errorf("unexpected format of ID (%s), expected node/id", id)
	}

	return nodeName, id, nil
}
`````

## File: proxmoxtf/resource/container/validators.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// MountTypeValidator returns a schema validation function for a mount type on a lxc container.
func MountTypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"cifs",
		"nfs",
	}, false))
}

// ConsoleModeValidator returns a schema validation function for a console mode on a lxc container.
func ConsoleModeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"console",
		"shell",
		"tty",
	}, false))
}

// CPUArchitectureValidator returns a schema validation function for a CPU architecture on a lxc container.
func CPUArchitectureValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"amd64",
		"arm64",
		"armhf",
		"i386",
	}, false))
}

// OperatingSystemTypeValidator returns a schema validation function for an operating system type on a lxc container.
func OperatingSystemTypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"alpine",
		"archlinux",
		"centos",
		"debian",
		"devuan",
		"fedora",
		"gentoo",
		"nixos",
		"opensuse",
		"ubuntu",
		"unmanaged",
	}, false))
}
`````

## File: proxmoxtf/resource/firewall/alias_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestAliasInstantiation tests whether the Alias instance can be instantiated.
func TestAliasInstantiation(t *testing.T) {
	t.Parallel()
	require.NotNilf(t, Alias(), "Cannot instantiate Alias")
}

// TestAliasSchema tests the Alias Schema.
func TestAliasSchema(t *testing.T) {
	t.Parallel()

	s := Alias().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkAliasName,
		mkAliasCIDR,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkSelectorVMID,
		mkSelectorNodeName,
		mkAliasComment,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkAliasName:    schema.TypeString,
		mkAliasCIDR:    schema.TypeString,
		mkAliasComment: schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/firewall/alias.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
)

const (
	mkAliasName    = "name"
	mkAliasCIDR    = "cidr"
	mkAliasComment = "comment"
)

// Alias returns a resource to manage aliases.
func Alias() *schema.Resource {
	s := map[string]*schema.Schema{
		mkAliasName: {
			Type:        schema.TypeString,
			Description: "Alias name",
			Required:    true,
		},
		mkAliasCIDR: {
			Type:        schema.TypeString,
			Description: "IP/CIDR block",
			Required:    true,
		},
		mkAliasComment: {
			Type:        schema.TypeString,
			Description: "Alias comment",
			Optional:    true,
			Default:     "",
		},
	}

	structure.MergeSchema(s, selectorSchema())

	return &schema.Resource{
		Schema:        s,
		CreateContext: selectFirewallAPI(aliasCreate),
		ReadContext:   selectFirewallAPI(aliasRead),
		UpdateContext: selectFirewallAPI(aliasUpdate),
		DeleteContext: selectFirewallAPI(aliasDelete),
	}
}

func aliasCreate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	comment := d.Get(mkAliasComment).(string)
	name := d.Get(mkAliasName).(string)
	cidr := d.Get(mkAliasCIDR).(string)

	body := &firewall.AliasCreateRequestBody{
		Comment: &comment,
		Name:    name,
		CIDR:    cidr,
	}

	err := api.CreateAlias(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(name)

	return aliasRead(ctx, api, d)
}

func aliasRead(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	name := d.Id()

	alias, err := api.GetAlias(ctx, name)
	if err != nil {
		if strings.Contains(err.Error(), "no such alias") {
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	aliasMap := map[string]interface{}{
		mkAliasComment: alias.Comment,
		mkAliasName:    alias.Name,
		mkAliasCIDR:    alias.CIDR,
	}

	for key, val := range aliasMap {
		err = d.Set(key, val)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return nil
}

func aliasUpdate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	comment := d.Get(mkAliasComment).(string)
	cidr := d.Get(mkAliasCIDR).(string)
	newName := d.Get(mkAliasName).(string)
	previousName := d.Id()

	body := &firewall.AliasUpdateRequestBody{
		ReName:  newName,
		CIDR:    cidr,
		Comment: &comment,
	}

	err := api.UpdateAlias(ctx, previousName, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(newName)

	return aliasRead(ctx, api, d)
}

func aliasDelete(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	name := d.Id()

	err := api.DeleteAlias(ctx, name)
	if err != nil {
		if strings.Contains(err.Error(), "no such alias") {
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/firewall/ipset_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestIPSetInstantiation tests whether the IPSet
// instance can be instantiated.
func TestIPSetInstantiation(t *testing.T) {
	t.Parallel()
	require.NotNilf(t, IPSet(), "Cannot instantiate IPSet")
}

// TestIPSetSchema tests the IPSet Schema.
func TestIPSetSchema(t *testing.T) {
	t.Parallel()

	s := IPSet().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkIPSetName,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkSelectorVMID,
		mkSelectorNodeName,
		mkIPSetCIDR,
		mkIPSetCIDRComment,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkIPSetName:        schema.TypeString,
		mkIPSetCIDR:        schema.TypeList,
		mkIPSetCIDRComment: schema.TypeString,
	})

	nested := test.AssertNestedSchemaExistence(t, s, mkIPSetCIDR)

	test.AssertRequiredArguments(t, nested, []string{
		mkIPSetCIDRName,
	})

	test.AssertOptionalArguments(t, nested, []string{
		mkIPSetCIDRComment,
		mkIPSetCIDRNoMatch,
	})

	test.AssertValueTypes(t, nested, map[string]schema.ValueType{
		mkIPSetCIDRName:    schema.TypeString,
		mkIPSetCIDRComment: schema.TypeString,
		mkIPSetCIDRNoMatch: schema.TypeBool,
	})
}
`````

## File: proxmoxtf/resource/firewall/ipset.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
)

const (
	dvIPSetCIDRComment = ""
	dvIPSetCIDRNoMatch = false

	mkIPSetName        = "name"
	mkIPSetCIDR        = "cidr"
	mkIPSetCIDRName    = "name"
	mkIPSetCIDRComment = "comment"
	mkIPSetCIDRNoMatch = "nomatch"
)

// IPSet returns a resource to manage IP sets.
func IPSet() *schema.Resource {
	s := map[string]*schema.Schema{
		mkIPSetName: {
			Type:        schema.TypeString,
			Description: "IPSet name",
			Required:    true,
			ForceNew:    false,
		},
		mkIPSetCIDRComment: {
			Type:        schema.TypeString,
			Description: "IPSet comment",
			Optional:    true,
			Default:     dvIPSetCIDRComment,
		},
		mkIPSetCIDR: {
			Type:        schema.TypeList,
			Description: "List of IP or Networks",
			Optional:    true,
			ForceNew:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			DiffSuppressFunc: structure.SuppressIfListsOfMapsAreEqualIgnoringOrderByKey(mkIPSetCIDRName),
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkIPSetCIDRName: {
						Type:        schema.TypeString,
						Description: "Network/IP specification in CIDR format",
						Required:    true,
						ForceNew:    true,
					},
					mkIPSetCIDRNoMatch: {
						Type:        schema.TypeBool,
						Description: "No match this IP/CIDR",
						Optional:    true,
						Default:     dvIPSetCIDRNoMatch,
						ForceNew:    true,
					},
					mkIPSetCIDRComment: {
						Type:        schema.TypeString,
						Description: "IP/CIDR comment",
						Optional:    true,
						Default:     dvIPSetCIDRComment,
						ForceNew:    true,
					},
				},
			},
		},
	}

	structure.MergeSchema(s, selectorSchema())

	return &schema.Resource{
		Schema:        s,
		CreateContext: selectFirewallAPI(ipSetCreate),
		ReadContext:   selectFirewallAPI(ipSetRead),
		UpdateContext: selectFirewallAPI(ipSetUpdate),
		DeleteContext: selectFirewallAPI(ipSetDelete),
	}
}

func ipSetCreate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	comment := d.Get(mkIPSetCIDRComment).(string)
	name := d.Get(mkIPSetName).(string)

	ipSets := d.Get(mkIPSetCIDR).([]interface{})
	ipSetsArray := make(firewall.IPSetContent, len(ipSets))

	for i, v := range ipSets {
		ipSetMap := v.(map[string]interface{})
		ipSetObject := firewall.IPSetGetResponseData{}

		cidr := ipSetMap[mkIPSetCIDRName].(string)
		noMatch := ipSetMap[mkIPSetCIDRNoMatch].(bool)

		comm := ipSetMap[mkIPSetCIDRComment].(string)
		if comm != "" {
			ipSetObject.Comment = &comm
		}

		ipSetObject.CIDR = cidr

		if noMatch {
			noMatchBool := types.CustomBool(true)
			ipSetObject.NoMatch = &noMatchBool
		}

		ipSetsArray[i] = ipSetObject
	}

	body := &firewall.IPSetCreateRequestBody{
		Comment: comment,
		Name:    name,
	}

	err := api.CreateIPSet(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	for _, v := range ipSetsArray {
		err = api.AddCIDRToIPSet(ctx, name, v)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	d.SetId(name)

	return ipSetRead(ctx, api, d)
}

func ipSetRead(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	var diags diag.Diagnostics

	name := d.Id()

	allIPSets, err := api.ListIPSets(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	for _, v := range allIPSets {
		if v.Name == name {
			err = d.Set(mkIPSetName, v.Name)
			diags = append(diags, diag.FromErr(err)...)
			err = d.Set(mkIPSetCIDRComment, v.Comment)
			diags = append(diags, diag.FromErr(err)...)

			break
		}
	}

	ipSet, err := api.GetIPSetContent(ctx, name)
	if err != nil {
		if strings.Contains(err.Error(), "no such IPSet") {
			d.SetId("")
			return nil
		}

		diags = append(diags, diag.FromErr(err)...)

		return diags
	}

	//nolint:prealloc
	var entries []interface{}

	for key := range ipSet {
		entry := map[string]interface{}{}

		entry[mkIPSetCIDRName] = ipSet[key].CIDR
		entry[mkIPSetCIDRNoMatch] = ipSet[key].NoMatch
		entry[mkIPSetCIDRComment] = ipSet[key].Comment

		entries = append(entries, entry)
	}

	err = d.Set(mkIPSetCIDR, entries)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func ipSetUpdate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	comment := d.Get(mkIPSetCIDRComment).(string)
	newName := d.Get(mkIPSetName).(string)
	previousName := d.Id()

	body := &firewall.IPSetUpdateRequestBody{
		ReName:  previousName,
		Name:    newName,
		Comment: &comment,
	}

	err := api.UpdateIPSet(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(newName)

	return ipSetRead(ctx, api, d)
}

func ipSetDelete(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	diags := diag.Diagnostics{}

	name := d.Id()

	IPSetContent, err := api.GetIPSetContent(ctx, name)
	if err != nil {
		return diag.FromErr(err)
	}

	// PVE requires content of IPSet be cleared before removal
	if len(IPSetContent) > 0 {
		for _, ipSet := range IPSetContent {
			err = api.DeleteIPSetContent(ctx, name, ipSet.CIDR)
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	if diags.HasError() {
		return diags
	}

	err = api.DeleteIPSet(ctx, name)
	if err != nil {
		if strings.Contains(err.Error(), "no such IPSet") {
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/firewall/options_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestOptionsInstantiation tests whether the Options instance can be instantiated.
func TestOptionsInstantiation(t *testing.T) {
	t.Parallel()
	require.NotNilf(t, Options(), "Cannot instantiate Options")
}

// TestOptionsSchema tests the Options Schema.
func TestOptionsSchema(t *testing.T) {
	t.Parallel()

	s := Options().Schema

	test.AssertOptionalArguments(t, s, []string{
		mkDHCP,
		mkEnabled,
		mkIPFilter,
		mkLogLevelIN,
		mkLogLevelOUT,
		mkMACFilter,
		mkNDP,
		mkPolicyIn,
		mkPolicyOut,
		mkRadv,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkDHCP:        schema.TypeBool,
		mkEnabled:     schema.TypeBool,
		mkIPFilter:    schema.TypeBool,
		mkLogLevelIN:  schema.TypeString,
		mkLogLevelOUT: schema.TypeString,
		mkMACFilter:   schema.TypeBool,
		mkNDP:         schema.TypeBool,
		mkPolicyIn:    schema.TypeString,
		mkPolicyOut:   schema.TypeString,
		mkRadv:        schema.TypeBool,
	})
}
`````

## File: proxmoxtf/resource/firewall/options.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
)

const (
	dvDHCP        = false
	dvEnabled     = false
	dvLogLevelIN  = "nolog"
	dvLogLevelOUT = "nolog"
	dvMACFilter   = true
	dvNDP         = false
	dvPolicyIn    = "DROP"
	dvPolicyOut   = "ACCEPT"
	dvReadv       = true

	mkDHCP        = "dhcp"
	mkEnabled     = "enabled"
	mkIPFilter    = "ipfilter"
	mkLogLevelIN  = "log_level_in"
	mkLogLevelOUT = "log_level_out"
	mkMACFilter   = "macfilter"
	mkNDP         = "ndp"
	mkPolicyIn    = "input_policy"
	mkPolicyOut   = "output_policy"
	mkRadv        = "radv"
)

// Options returns a resource to manage firewall options.
func Options() *schema.Resource {
	s := map[string]*schema.Schema{
		mkDHCP: {
			Type:        schema.TypeBool,
			Description: "Enable DHCP",
			Optional:    true,
			Default:     dvDHCP,
		},
		mkEnabled: {
			Type:        schema.TypeBool,
			Description: "Enable or disable the firewall",
			Optional:    true,
			Default:     dvEnabled,
		},
		mkIPFilter: {
			Type: schema.TypeBool,
			Description: "Enable default IP filters. This is equivalent to adding an empty ipfilter-net<id> ipset " +
				"for every interface. Such ipsets implicitly contain sane default restrictions such as restricting " +
				"IPv6 link local addresses to the one derived from the interface's MAC address. " +
				"For containers the configured IP addresses will be implicitly added.",
			Optional: true,
		},
		mkLogLevelIN: {
			Type:             schema.TypeString,
			Description:      "Log level for incoming traffic.",
			Optional:         true,
			Default:          dvLogLevelIN,
			ValidateDiagFunc: validators.FirewallLogLevel(),
		},
		mkLogLevelOUT: {
			Type:             schema.TypeString,
			Description:      "Log level for outgoing traffic.",
			Optional:         true,
			Default:          dvLogLevelOUT,
			ValidateDiagFunc: validators.FirewallLogLevel(),
		},
		mkMACFilter: {
			Type:        schema.TypeBool,
			Description: "Enable MAC address filtering",
			Optional:    true,
			Default:     dvMACFilter,
		},
		mkNDP: {
			Type:        schema.TypeBool,
			Description: "Enable NDP (Neighbor Discovery Protocol)",
			Optional:    true,
			Default:     dvNDP,
		},
		mkPolicyIn: {
			Type:             schema.TypeString,
			Description:      "Default policy for incoming traffic",
			Optional:         true,
			Default:          dvPolicyIn,
			ValidateDiagFunc: validators.FirewallPolicy(),
		},
		mkPolicyOut: {
			Type:             schema.TypeString,
			Description:      "Default policy for outgoing traffic",
			Optional:         true,
			Default:          dvPolicyOut,
			ValidateDiagFunc: validators.FirewallPolicy(),
		},
		mkRadv: {
			Type:        schema.TypeBool,
			Description: "Allow sending Router Advertisement",
			Optional:    true,
			Default:     dvReadv,
		},
	}

	structure.MergeSchema(s, selectorSchemaMandatory())

	return &schema.Resource{
		Schema:        s,
		CreateContext: selectFirewallAPI(optionsSet),
		ReadContext:   selectFirewallAPI(optionsRead),
		UpdateContext: selectFirewallAPI(optionsUpdate),
		DeleteContext: selectFirewallAPI(optionsDelete),
	}
}

func optionsSet(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	dhcp := types.CustomBool(d.Get(mkDHCP).(bool))
	enabled := types.CustomBool(d.Get(mkEnabled).(bool))
	ipFilter := types.CustomBool(d.Get(mkIPFilter).(bool))
	logLevelIn := d.Get(mkLogLevelIN).(string)
	logLevelOut := d.Get(mkLogLevelOUT).(string)
	macFilter := types.CustomBool(d.Get(mkMACFilter).(bool))
	ndp := types.CustomBool(d.Get(mkNDP).(bool))
	policyIn := d.Get(mkPolicyIn).(string)
	policyOut := d.Get(mkPolicyOut).(string)
	radv := types.CustomBool(d.Get(mkRadv).(bool))

	body := &firewall.OptionsPutRequestBody{
		DHCP:        &dhcp,
		Enable:      &enabled,
		IPFilter:    &ipFilter,
		LogLevelIN:  &logLevelIn,
		LogLevelOUT: &logLevelOut,
		MACFilter:   &macFilter,
		NDP:         &ndp,
		PolicyIn:    &policyIn,
		PolicyOut:   &policyOut,
		RAdv:        &radv,
	}

	err := api.SetOptions(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(api.GetOptionsID())

	return optionsRead(ctx, api, d)
}

func optionsRead(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	var diags diag.Diagnostics

	options, err := api.GetOptions(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if options.DHCP != nil {
		err = d.Set(mkDHCP, *options.DHCP)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.Enable != nil {
		err = d.Set(mkEnabled, *options.Enable)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.IPFilter != nil {
		err = d.Set(mkIPFilter, *options.IPFilter)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.LogLevelIN != nil {
		err = d.Set(mkLogLevelIN, *options.LogLevelIN)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.LogLevelOUT != nil {
		err = d.Set(mkLogLevelOUT, *options.LogLevelOUT)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.MACFilter != nil {
		err = d.Set(mkMACFilter, *options.MACFilter)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.NDP != nil {
		err = d.Set(mkNDP, *options.NDP)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.PolicyIn != nil {
		err = d.Set(mkPolicyIn, *options.PolicyIn)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.PolicyOut != nil {
		err = d.Set(mkPolicyOut, *options.PolicyOut)
		diags = append(diags, diag.FromErr(err)...)
	}

	if options.RAdv != nil {
		err = d.Set(mkRadv, *options.RAdv)
		diags = append(diags, diag.FromErr(err)...)
	}

	return diags
}

func optionsUpdate(ctx context.Context, api firewall.API, d *schema.ResourceData) diag.Diagnostics {
	diags := optionsSet(ctx, api, d)
	if diags.HasError() {
		return diags
	}

	return optionsRead(ctx, api, d)
}

func optionsDelete(_ context.Context, _ firewall.API, d *schema.ResourceData) diag.Diagnostics {
	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/firewall/rules_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestRuleInstantiation tests whether the Rules instance can be instantiated.
func TestRuleInstantiation(t *testing.T) {
	t.Parallel()
	require.NotNilf(t, Rules(), "Cannot instantiate Rules")
}

// TestRuleSchema tests the Rules Schema.
func TestRuleSchema(t *testing.T) {
	t.Parallel()

	rules := Rules().Schema

	test.AssertRequiredArguments(t, rules, []string{
		MkRule,
	})

	test.AssertOptionalArguments(t, rules, []string{
		mkSelectorVMID,
		mkSelectorNodeName,
	})

	nested := test.AssertNestedSchemaExistence(t, rules, MkRule)

	test.AssertOptionalArguments(t, nested, []string{
		mkSecurityGroup,
		mkRuleAction,
		mkRuleType,
		mkRuleComment,
		mkRuleDest,
		mkRuleDPort,
		mkRuleEnabled,
		mkRuleIFace,
		mkRuleLog,
		mkRuleMacro,
		mkRuleProto,
		mkRuleSource,
		mkRuleSPort,
	})

	test.AssertValueTypes(t, nested, map[string]schema.ValueType{
		mkRulePos:     schema.TypeInt,
		mkRuleAction:  schema.TypeString,
		mkRuleType:    schema.TypeString,
		mkRuleComment: schema.TypeString,
		mkRuleDest:    schema.TypeString,
		mkRuleDPort:   schema.TypeString,
		mkRuleEnabled: schema.TypeBool,
		mkRuleIFace:   schema.TypeString,
		mkRuleLog:     schema.TypeString,
		mkRuleMacro:   schema.TypeString,
		mkRuleProto:   schema.TypeString,
		mkRuleSource:  schema.TypeString,
		mkRuleSPort:   schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/firewall/rules.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
)

const (
	dvSecurityGroup = ""
	dvRuleComment   = ""
	dvRuleDPort     = ""
	dvRuleDest      = ""
	dvRuleEnabled   = true
	dvRuleIface     = ""
	dvRuleLog       = ""
	dvRuleMacro     = ""
	dvRuleProto     = ""
	dvRuleSPort     = ""
	dvRuleSource    = ""

	// MkRule defines the name of the rule resource in the schema.
	MkRule = "rule"

	mkSecurityGroup = "security_group"

	mkRuleAction  = "action"
	mkRuleComment = "comment"
	mkRuleDPort   = "dport"
	mkRuleDest    = "dest"
	mkRuleEnabled = "enabled"
	mkRuleIFace   = "iface"
	mkRuleLog     = "log"
	mkRuleMacro   = "macro"
	mkRulePos     = "pos"
	mkRuleProto   = "proto"
	mkRuleSource  = "source"
	mkRuleSPort   = "sport"
	mkRuleType    = "type"
)

// Rules returns a resource that manages firewall rules.
func Rules() *schema.Resource {
	rule := map[string]*schema.Schema{
		mkRulePos: {
			Type:        schema.TypeInt,
			Description: "Rules position",
			Computed:    true,
		},
		mkSecurityGroup: {
			Type:        schema.TypeString,
			Description: "Security group name",
			Optional:    true,
			ForceNew:    true,
			Default:     dvSecurityGroup,
		},
		mkRuleAction: {
			Type:             schema.TypeString,
			Description:      "Rules action ('ACCEPT', 'DROP', 'REJECT')",
			Optional:         true,
			ValidateDiagFunc: validators.FirewallPolicy(),
		},
		mkRuleType: {
			Type:             schema.TypeString,
			Description:      "Rules type ('in', 'out')",
			Optional:         true,
			ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{"in", "out"}, true)),
		},
		mkRuleComment: {
			Type:        schema.TypeString,
			Description: "Rules comment",
			Optional:    true,
			Default:     dvRuleComment,
		},
		mkRuleDest: {
			Type: schema.TypeString,
			Description: "Restrict packet destination address. This can refer to a single IP address, an" +
				" IP set ('+ipsetname') or an IP alias definition. You can also specify an address range " +
				"like '20.34.101.207-201.3.9.99', or a list of IP addresses and networks (entries are " +
				"separated by comma). Please do not mix IPv4 and IPv6 addresses inside such lists.",
			Optional: true,
			Default:  dvRuleDest,
		},
		mkRuleDPort: {
			Type: schema.TypeString,
			Description: "Restrict TCP/UDP destination port. You can use service names or simple numbers " +
				"(0-65535), as defined in '/etc/services'. Port ranges can be specified with '\\d+:\\d+'," +
				" for example '80:85', and you can use comma separated list to match several ports or ranges.",
			Optional: true,
			Default:  dvRuleDPort,
		},
		mkRuleEnabled: {
			Type:        schema.TypeBool,
			Description: "Enable rule",
			Optional:    true,
			Default:     dvRuleEnabled,
		},
		mkRuleIFace: {
			Type: schema.TypeString,
			Description: "Network interface name. You have to use network configuration key names for VMs" +
				" and containers ('net\\d+'). Host related rules can use arbitrary strings.",
			Optional: true,
			Default:  dvRuleIface,
		},
		mkRuleLog: {
			Type: schema.TypeString,
			Description: "Log level for this rule ('emerg', 'alert', 'crit', 'err', 'warning', 'notice'," +
				" 'info', 'debug', 'nolog')",
			Optional: true,
			Default:  dvRuleLog,
		},
		mkRuleMacro: {
			Type:        schema.TypeString,
			Description: "Use predefined standard macro",
			Optional:    true,
			Default:     dvRuleMacro,
		},
		mkRuleProto: {
			Type: schema.TypeString,
			Description: "Restrict packet protocol. You can use protocol names or simple numbers " +
				"(0-255), as defined in '/etc/protocols'.",
			Optional: true,
			Default:  dvRuleProto,
		},
		mkRuleSource: {
			Type: schema.TypeString,
			Description: "Restrict packet source address. This can refer to a single IP address, an" +
				" IP set ('+ipsetname') or an IP alias definition. You can also specify an address range " +
				"like '20.34.101.207-201.3.9.99', or a list of IP addresses and networks (entries are " +
				"separated by comma). Please do not mix IPv4 and IPv6 addresses inside such lists.",
			Optional: true,
			Default:  dvRuleSource,
		},
		mkRuleSPort: {
			Type: schema.TypeString,
			Description: "Restrict TCP/UDP source port. You can use service names or simple numbers " +
				"(0-65535), as defined in '/etc/services'. Port ranges can be specified with '\\d+:\\d+'," +
				" for example '80:85', and you can use comma separated list to match several ports or ranges.",
			Optional: true,
			Default:  dvRuleSPort,
		},
	}

	s := map[string]*schema.Schema{
		MkRule: {
			Type:        schema.TypeList,
			Description: "List of rules",
			Required:    true,
			ForceNew:    true,
			Elem:        &schema.Resource{Schema: rule},
		},
	}

	structure.MergeSchema(s, selectorSchema())

	return &schema.Resource{
		Schema:        s,
		CreateContext: invokeRuleAPI(RulesCreate),
		ReadContext:   invokeRuleAPI(RulesRead),
		UpdateContext: invokeRuleAPI(RulesUpdate),
		DeleteContext: invokeRuleAPI(RulesDelete),
	}
}

// RulesCreate creates new firewall rules.
func RulesCreate(ctx context.Context, api firewall.Rule, d *schema.ResourceData) diag.Diagnostics {
	diags := diag.Diagnostics{}

	rules := d.Get(MkRule).([]interface{})

	for i := len(rules) - 1; i >= 0; i-- {
		var ruleBody firewall.RuleCreateRequestBody

		rule := rules[i].(map[string]interface{})

		sg := rule[mkSecurityGroup].(string)
		if sg != "" {
			// this is a special case of security group insertion
			ruleBody = firewall.RuleCreateRequestBody{
				Action:   sg,
				Type:     "group",
				BaseRule: *mapToSecurityGroupBaseRule(rule),
			}
		} else {
			a := rule[mkRuleAction].(string)
			t := rule[mkRuleType].(string)

			if a == "" || t == "" {
				diags = append(diags, diag.Errorf("Either '%s' OR both '%s' and '%s' must be defined for the rule #%d",
					mkSecurityGroup, mkRuleAction, mkRuleType, i)...)
				continue
			}

			ruleBody = firewall.RuleCreateRequestBody{
				Action:   a,
				Type:     t,
				BaseRule: *mapToBaseRule(rule),
			}
		}

		err := api.CreateRule(ctx, &ruleBody)
		diags = append(diags, diag.FromErr(err)...)
	}

	if diags.HasError() {
		return diags
	}

	// reset rules, we re-read them (with proper positions) from the API
	err := d.Set(MkRule, nil)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(api.GetRulesID())

	return RulesRead(ctx, api, d)
}

// RulesRead reads rules from the API and updates the state.
func RulesRead(ctx context.Context, api firewall.Rule, d *schema.ResourceData) diag.Diagnostics {
	diags := diag.Diagnostics{}

	readRule := func(pos int, ruleMap map[string]interface{}) error {
		rule, err := api.GetRule(ctx, pos)
		if err != nil {
			if strings.Contains(err.Error(), "no rule at position") {
				// this is not an error, the rule does not exist
				return nil
			}

			return fmt.Errorf("error reading rule %d : %w", pos, err)
		}

		// pos in the map should be int!
		ruleMap[mkRulePos] = pos

		if rule.Type == "group" {
			// this is a special case of security group insertion
			ruleMap[mkSecurityGroup] = rule.Action
			securityGroupBaseRuleToMap(&rule.BaseRule, ruleMap)
		} else {
			ruleMap[mkRuleAction] = rule.Action
			ruleMap[mkRuleType] = rule.Type
			baseRuleToMap(&rule.BaseRule, ruleMap)
		}

		return nil
	}

	rules := d.Get(MkRule).([]interface{})
	if len(rules) > 0 {
		// We have rules in the state, so we need to read them from the API
		for _, v := range rules {
			ruleMap := v.(map[string]interface{})
			pos := ruleMap[mkRulePos].(int)

			err := readRule(pos, ruleMap)
			diags = append(diags, diag.FromErr(err)...)
		}
	} else {
		ruleIDs, err := api.ListRules(ctx)
		if err != nil {
			return diag.FromErr(err)
		}

		for _, id := range ruleIDs {
			ruleMap := map[string]interface{}{}

			err = readRule(id.Pos, ruleMap)
			if err != nil {
				diags = append(diags, diag.FromErr(err)...)
			} else if len(ruleMap) > 0 {
				rules = append(rules, ruleMap)
			}
		}
	}

	if diags.HasError() {
		return diags
	}

	err := d.Set(MkRule, rules)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

// RulesUpdate updates rules.
func RulesUpdate(ctx context.Context, api firewall.Rule, d *schema.ResourceData) diag.Diagnostics {
	diags := diag.Diagnostics{}

	rules := d.Get(MkRule).([]interface{})
	for i := len(rules) - 1; i >= 0; i-- {
		rule := rules[i].(map[string]interface{})

		ruleBody := firewall.RuleUpdateRequestBody{
			BaseRule: *mapToBaseRule(rule),
		}

		pos := rule[mkRulePos].(int)
		if pos >= 0 {
			ruleBody.Pos = &pos
		}

		action := rule[mkRuleAction].(string)
		if action != "" {
			ruleBody.Action = &action
		}

		rType := rule[mkRuleType].(string)
		if rType != "" {
			ruleBody.Type = &rType
		}

		err := api.UpdateRule(ctx, pos, &ruleBody)
		if err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	if diags.HasError() {
		return diags
	}

	return RulesRead(ctx, api, d)
}

// RulesDelete deletes all rules.
func RulesDelete(ctx context.Context, api firewall.Rule, d *schema.ResourceData) diag.Diagnostics {
	var diags diag.Diagnostics

	rules := d.Get(MkRule).([]interface{})
	sort.Slice(rules, func(i, j int) bool {
		ruleI := rules[i].(map[string]interface{})
		ruleJ := rules[j].(map[string]interface{})

		return ruleI[mkRulePos].(int) > ruleJ[mkRulePos].(int)
	})

	for _, v := range rules {
		rule := v.(map[string]interface{})
		pos := rule[mkRulePos].(int)

		_, err := api.GetRule(ctx, pos)
		if err != nil {
			// if the rule is not found / can't be retrieved, we can safely ignore it
			continue
		}

		err = api.DeleteRule(ctx, pos)
		diags = append(diags, diag.FromErr(err)...)
	}

	return diags
}

func mapToBaseRule(rule map[string]interface{}) *firewall.BaseRule {
	baseRule := &firewall.BaseRule{}

	comment := rule[mkRuleComment].(string)
	if comment != "" {
		baseRule.Comment = &comment
	}

	dest := rule[mkRuleDest].(string)
	if dest != "" {
		baseRule.Dest = &dest
	}

	dport := rule[mkRuleDPort].(string)
	if dport != "" {
		baseRule.DPort = &dport
	}

	enableBool := types.CustomBool(rule[mkRuleEnabled].(bool))
	baseRule.Enable = &enableBool

	iface := rule[mkRuleIFace].(string)
	if iface != "" {
		baseRule.IFace = &iface
	}

	log := rule[mkRuleLog].(string)
	if log != "" {
		baseRule.Log = &log
	}

	macro := rule[mkRuleMacro].(string)
	if macro != "" {
		baseRule.Macro = &macro
	}

	proto := rule[mkRuleProto].(string)
	if proto != "" {
		baseRule.Proto = &proto
	}

	source := rule[mkRuleSource].(string)
	if source != "" {
		baseRule.Source = &source
	}

	sport := rule[mkRuleSPort].(string)
	if sport != "" {
		baseRule.SPort = &sport
	}

	return baseRule
}

func mapToSecurityGroupBaseRule(rule map[string]interface{}) *firewall.BaseRule {
	baseRule := &firewall.BaseRule{}

	comment := rule[mkRuleComment].(string)
	if comment != "" {
		baseRule.Comment = &comment
	}

	enableBool := types.CustomBool(rule[mkRuleEnabled].(bool))
	baseRule.Enable = &enableBool

	iface := rule[mkRuleIFace].(string)
	if iface != "" {
		baseRule.IFace = &iface
	}

	return baseRule
}

func baseRuleToMap(baseRule *firewall.BaseRule, rule map[string]interface{}) {
	if baseRule.Comment != nil {
		rule[mkRuleComment] = *baseRule.Comment
	}

	if baseRule.Dest != nil {
		rule[mkRuleDest] = *baseRule.Dest
	}

	if baseRule.DPort != nil {
		rule[mkRuleDPort] = *baseRule.DPort
	}

	if baseRule.Enable != nil {
		rule[mkRuleEnabled] = *baseRule.Enable
	}

	if baseRule.IFace != nil {
		rule[mkRuleIFace] = *baseRule.IFace
	}

	if baseRule.Log != nil {
		rule[mkRuleLog] = *baseRule.Log
	}

	if baseRule.Macro != nil {
		rule[mkRuleMacro] = *baseRule.Macro
	}

	if baseRule.Proto != nil {
		rule[mkRuleProto] = *baseRule.Proto
	}

	if baseRule.Source != nil {
		rule[mkRuleSource] = *baseRule.Source
	}

	if baseRule.SPort != nil {
		rule[mkRuleSPort] = *baseRule.SPort
	}
}

func securityGroupBaseRuleToMap(baseRule *firewall.BaseRule, rule map[string]interface{}) {
	if baseRule.Comment != nil {
		rule[mkRuleComment] = *baseRule.Comment
	}

	if baseRule.Enable != nil {
		rule[mkRuleEnabled] = *baseRule.Enable
	}

	if baseRule.IFace != nil {
		rule[mkRuleIFace] = *baseRule.IFace
	}
}

func invokeRuleAPI(
	f func(context.Context, firewall.Rule, *schema.ResourceData) diag.Diagnostics,
) func(context.Context, *schema.ResourceData, interface{}) diag.Diagnostics {
	return func(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		return selectFirewallAPI(func(ctx context.Context, api firewall.API, data *schema.ResourceData) diag.Diagnostics {
			return f(ctx, api, data)
		})(ctx, d, m)
	}
}
`````

## File: proxmoxtf/resource/firewall/selector.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package firewall

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/firewall"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
	resource "github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm"
)

const (
	mkSelectorNodeName    = "node_name"
	mkSelectorVMID        = "vm_id"
	mkSelectorContainerID = "container_id"
)

func selectorSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		mkSelectorNodeName: {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "The name of the node.",
		},
		mkSelectorVMID: {
			Type:             schema.TypeInt,
			Optional:         true,
			Description:      "The ID of the VM to manage the firewall for.",
			RequiredWith:     []string{mkSelectorNodeName},
			ValidateDiagFunc: resource.VMIDValidator(),
		},
		mkSelectorContainerID: {
			Type:             schema.TypeInt,
			Optional:         true,
			Description:      "The ID of the container to manage the firewall for.",
			RequiredWith:     []string{mkSelectorNodeName},
			ValidateDiagFunc: resource.VMIDValidator(),
		},
	}
}

func selectorSchemaMandatory() map[string]*schema.Schema {
	s := selectorSchema()
	s[mkSelectorNodeName].Optional = false
	s[mkSelectorNodeName].Required = true
	// required attributes can't be included in RequiredWith
	s[mkSelectorVMID].RequiredWith = nil
	s[mkSelectorContainerID].RequiredWith = nil

	return s
}

func selectFirewallAPI(
	f func(context.Context, firewall.API, *schema.ResourceData) diag.Diagnostics,
) func(context.Context, *schema.ResourceData, interface{}) diag.Diagnostics {
	return func(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		config := m.(proxmoxtf.ProviderConfiguration)

		api, err := config.GetClient()
		if err != nil {
			return diag.FromErr(err)
		}

		var fwAPI firewall.API = api.Cluster().Firewall()

		if nn, ok := d.GetOk(mkSelectorNodeName); ok {
			nodeName := nn.(string)
			nodeAPI := api.Node(nodeName)

			if v, ok := d.GetOk(mkSelectorVMID); ok {
				fwAPI = nodeAPI.VM(v.(int)).Firewall()
			} else if v, ok := d.GetOk(mkSelectorContainerID); ok {
				fwAPI = nodeAPI.Container(v.(int)).Firewall()
			}
		}

		return f(ctx, fwAPI, d)
	}
}
`````

## File: proxmoxtf/resource/validators/file_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestFileID(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		value string
		valid bool
	}{
		{"empty", "", true},
		{"invalid", "invalid", false},
		{"valid", "local:vztmpl/zen-dns-0.1.tar.zst", true},
		{"valid when datastore name has dots", "terraform.proxmox.storage.compute.zen:vztmpl/zen-dns-0.1.tar.zst", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			f := FileID()
			res := f(tt.value, nil)

			if tt.valid {
				require.Empty(t, res, "validate: '%s'", tt.value)
			} else {
				require.NotEmpty(t, res, "validate: '%s'", tt.value)
			}
		})
	}
}

func TestFileMode(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		value string
		valid bool
	}{
		{"valid", "0700", true},
		{"invalid", "invalid", false},
		// Even though Go supports octal prefixes, we should not allow them in the string value to reduce the complexity.
		{"invalid", "0o700", false},
		{"invalid", "0x700", false},
		// Maximum value for uint32, incremented by one.
		{"too large", "4294967296", false},
		{"too small", "0", false},
		{"negative", "-1", false},
		{"empty", "", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			f := FileMode()
			res := f(tt.value, nil)

			if tt.valid {
				require.Empty(t, res, "validate: '%s'", tt.value)
			} else {
				require.NotEmpty(t, res, "validate: '%s'", tt.value)
			}
		})
	}
}
`````

## File: proxmoxtf/resource/validators/file.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"fmt"
	"regexp"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// ContentType returns a schema validation function for a content type on a storage device.
func ContentType() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"backup",
		"iso",
		"snippets",
		"vztmpl",
	}, false))
}

// FileFormat returns a schema validation function for a file format.
func FileFormat() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"qcow2",
		"raw",
		"vmdk",
	}, false))
}

// FileID returns a schema validation function for a file identifier.
func FileID() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(func(i interface{}, k string) ([]string, []error) {
		v, ok := i.(string)

		var ws []string

		var es []error

		if !ok {
			es = append(es, fmt.Errorf("expected type of %s to be string", k))
			return ws, es
		}

		if v != "" {
			r := regexp.MustCompile(`^(?i)[a-z\d\-_.]+:([a-z\d\-_]+/)?.+$`)
			ok := r.MatchString(v)

			if !ok {
				es = append(es, fmt.Errorf(
					"expected %s to be a valid file identifier (datastore-name:iso/some-file.img), got %s", k, v,
				))

				return ws, es
			}
		}

		return ws, es
	})
}

// FileMode is a schema validation function for file mode.
func FileMode() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(
		func(i interface{}, k string) ([]string, []error) {
			var errs []error

			v, ok := i.(string)
			if !ok {
				errs = append(errs, fmt.Errorf(
					`expected string in octal format (e.g. "0o700" or "0700"") for %q, but got %v of type %T`, k, v, i))
				return nil, errs
			}

			mode, err := strconv.ParseInt(v, 10, 64)
			if err != nil {
				errs = append(errs, fmt.Errorf("failed to parse file mode %q: %w", v, err))
				return nil, errs
			}

			if mode < 1 || mode > int64(^uint32(0)) {
				errs = append(errs, fmt.Errorf("%q must be in the range (%d - %d), got %d", v, 1, ^uint32(0), mode))
				return nil, errs
			}

			return []string{}, errs
		},
	)
}

// FileSize is a schema validation function for file size.
func FileSize() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(func(i interface{}, k string) ([]string, []error) {
		v, ok := i.(string)

		var es []error

		if !ok {
			es = append(es, fmt.Errorf("expected type of %s to be string", k))
			return nil, es
		}

		if v != "" {
			_, err := types.ParseDiskSize(v)
			if err != nil {
				es = append(es, fmt.Errorf("expected %s to be a valid file size (100, 1M, 1G), got %s", k, v))
				return nil, es
			}
		}

		return []string{}, es
	})
}
`````

## File: proxmoxtf/resource/validators/firewall.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"regexp"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

var rateExpression = regexp.MustCompile(`[1-9][0-9]*/(second|minute|hour|day)`)

// FirewallRate returns a schema validation function for a firewall rate.
func FirewallRate() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringMatch(
		rateExpression,
		"Must be a valid rate expression, e.g. '1/second'",
	))
}

// FirewallPolicy returns a schema validation function for a firewall policy.
func FirewallPolicy() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice(
		[]string{"ACCEPT", "REJECT", "DROP"},
		false,
	))
}

// FirewallLogLevel returns a schema validation function for a firewall log level.
func FirewallLogLevel() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice(
		[]string{"emerg", "alert", "crit", "err", "warning", "notice", "info", "debug", "nolog"},
		false,
	))
}
`````

## File: proxmoxtf/resource/validators/network_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestMACAddress(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		value string
		valid bool
	}{
		{"empty", "", true},
		{"invalid", "invalid", false},
		{"invalid: no dashes", "38-f9-d3-4b-f5-51", false},
		{"valid", "38:f9:d3:4b:f5:51", true},
		{"valid", "38:F9:D3:4B:F5:51", true},
		{"valid", "00:15:5d:00:09:03", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			f := MACAddress()
			res := f(tt.value, nil)

			if tt.valid {
				require.Empty(t, res, "validate: '%s'", tt.value)
			} else {
				require.NotEmpty(t, res, "validate: '%s'", tt.value)
			}
		})
	}
}
`````

## File: proxmoxtf/resource/validators/network.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package validators

import (
	"fmt"
	"regexp"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// MACAddress is a schema validation function for MAC address.
func MACAddress() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(func(i interface{}, path string) ([]string, []error) {
		v, ok := i.(string)

		var ws []string

		var es []error

		if !ok {
			es = append(es, fmt.Errorf("expected type of %q to be string", path))
			return ws, es
		}

		if v != "" {
			r := regexp.MustCompile(`^[A-Fa-f0-9]{2}(:[A-Fa-f0-9]{2}){5}$`)
			ok := r.MatchString(v)

			if !ok {
				es = append(es, fmt.Errorf("expected %q to be a valid MAC address (A0:B1:C2:D3:E4:F5), got %q", path, v))
				return ws, es
			}
		}

		return ws, es
	})
}
`````

## File: proxmoxtf/resource/vm/disk/disk.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package disk

import (
	"context"
	"errors"
	"fmt"
	"regexp"
	"slices"
	"strings"
	"unicode"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

// GetInfo returns the disk information for a VM.
// Deprecated: use vms.MapCustomStorageDevices from proxmox/nodes/vms instead.
func GetInfo(resp *vms.GetResponseData, d *schema.ResourceData) vms.CustomStorageDevices {
	storageDevices := resp.StorageDevices

	currentDisk := d.Get(MkDisk)

	diskMap := utils.MapResourcesByAttribute(currentDisk.([]interface{}), mkDiskInterface)

	for k, v := range storageDevices {
		if v != nil && diskMap[k] != nil {
			if disk, ok := diskMap[k].(map[string]interface{}); ok {
				if fileID, ok := disk[mkDiskFileID].(string); ok && fileID != "" {
					v.FileID = &fileID
				}
			}

			if v.Size == nil {
				v.Size = new(types.DiskSize)
			}
		}
	}

	return storageDevices
}

// UpdateClone updates disks in a cloned VM.
func UpdateClone(
	ctx context.Context,
	planDisks vms.CustomStorageDevices,
	allDiskInfo vms.CustomStorageDevices,
	vmAPI *vms.Client,
) error {
	for diskInterface, planDisk := range planDisks {
		currentDisk := allDiskInfo[diskInterface]

		if currentDisk == nil {
			diskUpdateBody := &vms.UpdateRequestBody{}
			diskUpdateBody.AddCustomStorageDevice(diskInterface, *planDisk)

			if err := vmAPI.UpdateVM(ctx, diskUpdateBody); err != nil {
				return fmt.Errorf("disk update fails: %w", err)
			}

			continue
		}

		if planDisk.Size.InMegabytes() < currentDisk.Size.InMegabytes() {
			return fmt.Errorf("disk resize failure: requested size (%s) is lower than current size (%s)",
				planDisk.Size.String(),
				currentDisk.Size.String(),
			)
		}

		// update other disk parameters
		// we have to do it before moving the disk, because the disk volume and location may change
		if currentDisk.MergeWith(*planDisk) {
			diskUpdateBody := &vms.UpdateRequestBody{}
			diskUpdateBody.AddCustomStorageDevice(diskInterface, *currentDisk)

			if err := vmAPI.UpdateVM(ctx, diskUpdateBody); err != nil {
				return fmt.Errorf("disk update fails: %w", err)
			}
		}

		moveDisk := false

		if *planDisk.DatastoreID != "" {
			fileIDParts := strings.Split(currentDisk.FileVolume, ":")
			moveDisk = *planDisk.DatastoreID != fileIDParts[0]
		}

		if moveDisk {
			deleteOriginalDisk := types.CustomBool(true)

			diskMoveBody := &vms.MoveDiskRequestBody{
				DeleteOriginalDisk: &deleteOriginalDisk,
				Disk:               diskInterface,
				TargetStorage:      *planDisk.DatastoreID,
			}

			// Note: after disk move, the actual disk volume ID will be different: both datastore id *and*
			// path in datastore will change.
			err := vmAPI.MoveVMDisk(ctx, diskMoveBody)
			if err != nil {
				return fmt.Errorf("disk move fails: %w", err)
			}
		}

		if planDisk.Size.InMegabytes() > currentDisk.Size.InMegabytes() {
			diskResizeBody := &vms.ResizeDiskRequestBody{
				Disk: diskInterface,
				Size: *planDisk.Size,
			}

			err := vmAPI.ResizeVMDisk(ctx, diskResizeBody)
			if err != nil {
				return fmt.Errorf("disk resize fails: %w", err)
			}
		}
	}

	return nil
}

// DigitPrefix returns the prefix of a string that is not a digit.
func DigitPrefix(s string) string {
	for i, r := range s {
		if unicode.IsDigit(r) {
			return s[:i]
		}
	}

	return s
}

// GetDiskDeviceObjects returns a map of disk devices for a VM.
func GetDiskDeviceObjects(
	d *schema.ResourceData,
	resource *schema.Resource,
	disks []interface{},
) (vms.CustomStorageDevices, error) {
	var diskDevices []interface{}

	if disks != nil {
		diskDevices = disks
	} else {
		diskDevices = d.Get(MkDisk).([]interface{})
	}

	diskDeviceObjects := vms.CustomStorageDevices{}

	for _, diskEntry := range diskDevices {
		diskDevice := &vms.CustomStorageDevice{}

		block := diskEntry.(map[string]interface{})
		datastoreID, _ := block[mkDiskDatastoreID].(string)
		pathInDatastore := ""

		if untyped, hasPathInDatastore := block[mkDiskPathInDatastore]; hasPathInDatastore {
			pathInDatastore = untyped.(string)
		}

		aio := block[mkDiskAIO].(string)
		backup := types.CustomBool(block[mkDiskBackup].(bool))
		cache := block[mkDiskCache].(string)
		discard := block[mkDiskDiscard].(string)
		diskInterface, _ := block[mkDiskInterface].(string)
		fileFormat, _ := block[mkDiskFileFormat].(string)
		fileID, _ := block[mkDiskFileID].(string)
		ioThread := types.CustomBool(block[mkDiskIOThread].(bool))
		replicate := types.CustomBool(block[mkDiskReplicate].(bool))
		serial := block[mkDiskSerial].(string)
		size, _ := block[mkDiskSize].(int)
		ssd := types.CustomBool(block[mkDiskSSD].(bool))

		speedBlock, err := structure.GetSchemaBlock(
			resource,
			d,
			[]string{MkDisk, mkDiskSpeed},
			0,
			false,
		)
		if err != nil {
			return diskDeviceObjects, fmt.Errorf("error getting disk speed block: %w", err)
		}

		if pathInDatastore != "" {
			if datastoreID != "" {
				diskDevice.FileVolume = fmt.Sprintf("%s:%s", datastoreID, pathInDatastore)
			} else {
				// FileVolume is the absolute path in the host filesystem
				diskDevice.FileVolume = pathInDatastore
			}
		} else {
			diskDevice.FileVolume = fmt.Sprintf("%s:%d", datastoreID, size)
		}

		diskDevice.AIO = &aio
		diskDevice.Backup = &backup
		diskDevice.Cache = &cache
		diskDevice.DatastoreID = &datastoreID
		diskDevice.Discard = &discard
		diskDevice.FileID = &fileID
		diskDevice.Replicate = &replicate
		diskDevice.Serial = &serial
		diskDevice.Size = types.DiskSizeFromGigabytes(int64(size))

		if fileFormat != "" {
			diskDevice.Format = &fileFormat
		}

		if !strings.HasPrefix(diskInterface, "virtio") {
			diskDevice.SSD = &ssd
		}

		if !strings.HasPrefix(diskInterface, "sata") && !strings.HasPrefix(diskInterface, "ide") {
			diskDevice.IOThread = &ioThread
		}

		if len(speedBlock) > 0 {
			iopsRead := speedBlock[mkDiskIopsRead].(int)
			iopsReadBurstable := speedBlock[mkDiskIopsReadBurstable].(int)
			iopsWrite := speedBlock[mkDiskIopsWrite].(int)
			iopsWriteBurstable := speedBlock[mkDiskIopsWriteBurstable].(int)
			speedLimitRead := speedBlock[mkDiskSpeedRead].(int)
			speedLimitReadBurstable := speedBlock[mkDiskSpeedReadBurstable].(int)
			speedLimitWrite := speedBlock[mkDiskSpeedWrite].(int)
			speedLimitWriteBurstable := speedBlock[mkDiskSpeedWriteBurstable].(int)

			if iopsRead > 0 {
				diskDevice.IopsRead = &iopsRead
			}

			if iopsReadBurstable > 0 {
				diskDevice.MaxIopsRead = &iopsReadBurstable
			}

			if iopsWrite > 0 {
				diskDevice.IopsWrite = &iopsWrite
			}

			if iopsWriteBurstable > 0 {
				diskDevice.MaxIopsWrite = &iopsWriteBurstable
			}

			if speedLimitRead > 0 {
				diskDevice.MaxReadSpeedMbps = &speedLimitRead
			}

			if speedLimitReadBurstable > 0 {
				diskDevice.BurstableReadSpeedMbps = &speedLimitReadBurstable
			}

			if speedLimitWrite > 0 {
				diskDevice.MaxWriteSpeedMbps = &speedLimitWrite
			}

			if speedLimitWriteBurstable > 0 {
				diskDevice.BurstableWriteSpeedMbps = &speedLimitWriteBurstable
			}
		}

		if !slices.Contains(vms.StorageInterfaces, DigitPrefix(diskInterface)) {
			errorMsg := fmt.Sprintf(
				"Defined disk interface not supported. Interface was %s, but only %v are supported",
				diskInterface, vms.StorageInterfaces,
			)

			return diskDeviceObjects, errors.New(errorMsg)
		}

		diskDeviceObjects[diskInterface] = diskDevice
	}

	return diskDeviceObjects, nil
}

// CreateCustomDisks creates custom disks for a VM.
func CreateCustomDisks(
	ctx context.Context,
	client proxmox.Client,
	nodeName string,
	vmID int,
	storageDevices vms.CustomStorageDevices,
) diag.Diagnostics {
	for iface, disk := range storageDevices {
		if disk != nil && disk.FileID != nil && *disk.FileID != "" {
			// only custom disks with defined file ID
			err := createCustomDisk(ctx, client, nodeName, vmID, iface, *disk)
			if err != nil {
				return diag.FromErr(err)
			}
		}
	}

	return nil
}

func createCustomDisk(
	ctx context.Context,
	client proxmox.Client,
	nodeName string,
	vmID int,
	iface string,
	disk vms.CustomStorageDevice,
) error {
	// use "old default" specifically here.
	fileFormat := "qcow2"
	if disk.Format != nil && *disk.Format != "" {
		fileFormat = *disk.Format
	}

	//nolint:lll
	commands := []string{
		`set -e`,
		ssh.TrySudo,
		fmt.Sprintf(`file_id="%s"`, *disk.FileID),
		fmt.Sprintf(`file_format="%s"`, fileFormat),
		fmt.Sprintf(`datastore_id_target="%s"`, *disk.DatastoreID),
		fmt.Sprintf(`vm_id="%d"`, vmID),
		fmt.Sprintf(`disk_options="%s"`, disk.EncodeOptions()),
		fmt.Sprintf(`disk_interface="%s"`, iface),
		`source_image=$(try_sudo "pvesm path $file_id")`,
		`imported_disk="$(try_sudo "qm disk import $vm_id $source_image $datastore_id_target -format $file_format" | grep "unused0" | cut -d ":" -f 3 | cut -d "'" -f 1)"`,
		`disk_id="${datastore_id_target}:$imported_disk,${disk_options}"`,
		`try_sudo "qm set $vm_id -${disk_interface} $disk_id"`,
	}

	out, err := client.SSH().ExecuteNodeCommands(ctx, nodeName, commands)
	if err != nil {
		if matches, e := regexp.Match(`pvesm: .* not found`, out); e == nil && matches {
			err = ssh.NewErrUserHasNoPermission(client.SSH().Username())
		}

		return fmt.Errorf("creating custom disk: %w", err)
	}

	tflog.Debug(ctx, "vmCreateCustomDisks: commands", map[string]interface{}{
		"output": string(out),
	})

	err = client.Node(nodeName).VM(vmID).ResizeVMDisk(ctx, &vms.ResizeDiskRequestBody{
		Disk: iface,
		Size: *disk.Size,
	})
	if err != nil {
		return fmt.Errorf("resizing disk: %w", err)
	}

	return nil
}

// Read reads the disk configuration of a VM.
func Read(
	ctx context.Context,
	d *schema.ResourceData,
	diskObjects vms.CustomStorageDevices,
	vmID int,
	client proxmox.Client,
	nodeName string,
	isClone bool,
) diag.Diagnostics {
	currentDiskList := d.Get(MkDisk).([]interface{})
	diskMap := map[string]interface{}{}

	var diags diag.Diagnostics

	for di, dd := range diskObjects {
		if dd == nil || dd.FileVolume == "none" {
			continue
		}

		if dd.IsCloudInitDrive(vmID) {
			continue
		}

		disk := map[string]interface{}{}

		datastoreID, pathInDatastore, hasDatastoreID := strings.Cut(dd.FileVolume, ":")
		if !hasDatastoreID {
			// when no ':' separator is found, 'Cut' places the whole string to 'datastoreID',
			// we want it in 'pathInDatastore' (it is absolute filesystem path)
			pathInDatastore = datastoreID
			datastoreID = ""
		}

		disk[mkDiskDatastoreID] = datastoreID
		disk[mkDiskPathInDatastore] = pathInDatastore

		if dd.Format == nil {
			if datastoreID != "" {
				// disk format may not be returned by config API if it is default for the storage, and that may be different
				// from the default qcow2, so we need to read it from the storage API to make sure we have the correct value
				volume, e := client.Node(nodeName).Storage(datastoreID).GetDatastoreFile(ctx, dd.FileVolume)
				if e != nil {
					diags = append(diags, diag.FromErr(e)...)
					continue
				}

				disk[mkDiskFileFormat] = volume.FileFormat
			}
		} else {
			disk[mkDiskFileFormat] = dd.Format
		}

		if dd.FileID != nil {
			disk[mkDiskFileID] = dd.FileID
		}

		disk[mkDiskInterface] = di
		disk[mkDiskSize] = dd.Size.InGigabytes()

		if dd.AIO != nil {
			disk[mkDiskAIO] = *dd.AIO
		} else {
			disk[mkDiskAIO] = dvDiskAIO
		}

		if dd.Backup != nil {
			disk[mkDiskBackup] = *dd.Backup
		} else {
			disk[mkDiskBackup] = true
		}

		if dd.IOThread != nil {
			disk[mkDiskIOThread] = *dd.IOThread
		} else {
			disk[mkDiskIOThread] = false
		}

		if dd.Replicate != nil {
			disk[mkDiskReplicate] = *dd.Replicate
		} else {
			disk[mkDiskReplicate] = true
		}

		if dd.Serial != nil {
			disk[mkDiskSerial] = *dd.Serial
		} else {
			disk[mkDiskSerial] = ""
		}

		if dd.SSD != nil {
			disk[mkDiskSSD] = *dd.SSD
		} else {
			disk[mkDiskSSD] = false
		}

		if dd.Discard != nil {
			disk[mkDiskDiscard] = *dd.Discard
		} else {
			disk[mkDiskDiscard] = dvDiskDiscard
		}

		if dd.Cache != nil {
			disk[mkDiskCache] = *dd.Cache
		} else {
			disk[mkDiskCache] = dvDiskCache
		}

		if dd.IopsRead != nil ||
			dd.MaxIopsRead != nil ||
			dd.IopsWrite != nil ||
			dd.MaxIopsWrite != nil ||
			dd.BurstableReadSpeedMbps != nil ||
			dd.BurstableWriteSpeedMbps != nil ||
			dd.MaxReadSpeedMbps != nil ||
			dd.MaxWriteSpeedMbps != nil {
			speed := map[string]interface{}{}

			if dd.IopsRead != nil {
				speed[mkDiskIopsRead] = *dd.IopsRead
			} else {
				speed[mkDiskIopsRead] = 0
			}

			if dd.MaxIopsRead != nil {
				speed[mkDiskIopsReadBurstable] = *dd.MaxIopsRead
			} else {
				speed[mkDiskIopsReadBurstable] = 0
			}

			if dd.IopsWrite != nil {
				speed[mkDiskIopsWrite] = *dd.IopsWrite
			} else {
				speed[mkDiskIopsWrite] = 0
			}

			if dd.MaxIopsWrite != nil {
				speed[mkDiskIopsWriteBurstable] = *dd.MaxIopsWrite
			} else {
				speed[mkDiskIopsWriteBurstable] = 0
			}

			if dd.MaxReadSpeedMbps != nil {
				speed[mkDiskSpeedRead] = *dd.MaxReadSpeedMbps
			} else {
				speed[mkDiskSpeedRead] = 0
			}

			if dd.BurstableReadSpeedMbps != nil {
				speed[mkDiskSpeedReadBurstable] = *dd.BurstableReadSpeedMbps
			} else {
				speed[mkDiskSpeedReadBurstable] = 0
			}

			if dd.MaxWriteSpeedMbps != nil {
				speed[mkDiskSpeedWrite] = *dd.MaxWriteSpeedMbps
			} else {
				speed[mkDiskSpeedWrite] = 0
			}

			if dd.BurstableWriteSpeedMbps != nil {
				speed[mkDiskSpeedWriteBurstable] = *dd.BurstableWriteSpeedMbps
			} else {
				speed[mkDiskSpeedWriteBurstable] = 0
			}

			disk[mkDiskSpeed] = []interface{}{speed}
		} else {
			disk[mkDiskSpeed] = []interface{}{}
		}

		diskMap[di] = disk
	}

	if !isClone || len(currentDiskList) > 0 {
		var diskList []interface{}

		if len(currentDiskList) > 0 {
			interfaces := utils.ListResourcesAttributeValue(currentDiskList, mkDiskInterface)
			diskList = utils.OrderedListFromMapByKeyValues(diskMap, interfaces)
		} else {
			diskList = utils.OrderedListFromMap(diskMap)
		}

		err := d.Set(MkDisk, diskList)
		diags = append(diags, diag.FromErr(err)...)
	}

	return diags
}

// Update updates the disk configuration of a VM.
func Update(
	ctx context.Context,
	client proxmox.Client,
	nodeName string,
	vmID int,
	d *schema.ResourceData,
	planDisks vms.CustomStorageDevices,
	currentDisks vms.CustomStorageDevices,
	updateBody *vms.UpdateRequestBody,
) (bool, error) {
	rebootRequired := false

	if d.HasChange(MkDisk) {
		for iface, disk := range planDisks {
			var tmp *vms.CustomStorageDevice

			switch {
			case currentDisks[iface] == nil && disk != nil:
				if disk.FileID != nil && *disk.FileID != "" {
					// only disks with defined file ID are custom image disks that need to be created via import.
					err := createCustomDisk(ctx, client, nodeName, vmID, iface, *disk)
					if err != nil {
						return false, fmt.Errorf("creating custom disk: %w", err)
					}
				} else {
					// otherwise this is a blank disk that can be added directly via update API
					tmp = disk
				}
			case currentDisks[iface] != nil:
				// update existing disk
				tmp = currentDisks[iface]
			default:
				// something went wrong
				return false, fmt.Errorf("missing device %s", iface)
			}

			if tmp == nil || disk == nil {
				continue
			}

			if !ptr.Eq(tmp.AIO, disk.AIO) {
				rebootRequired = true
				tmp.AIO = disk.AIO
			}

			tmp.Backup = disk.Backup
			tmp.BurstableReadSpeedMbps = disk.BurstableReadSpeedMbps
			tmp.BurstableWriteSpeedMbps = disk.BurstableWriteSpeedMbps
			tmp.Cache = disk.Cache
			tmp.Discard = disk.Discard
			tmp.IOThread = disk.IOThread
			tmp.IopsRead = disk.IopsRead
			tmp.IopsWrite = disk.IopsWrite
			tmp.MaxIopsRead = disk.MaxIopsRead
			tmp.MaxIopsWrite = disk.MaxIopsWrite
			tmp.MaxReadSpeedMbps = disk.MaxReadSpeedMbps
			tmp.MaxWriteSpeedMbps = disk.MaxWriteSpeedMbps
			tmp.Replicate = disk.Replicate
			tmp.Serial = disk.Serial
			tmp.SSD = disk.SSD

			updateBody.AddCustomStorageDevice(iface, *tmp)
		}
	}

	return rebootRequired, nil
}
`````

## File: proxmoxtf/resource/vm/disk/schema_test.go
`````go
package disk

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

func TestVMSchema(t *testing.T) {
	t.Parallel()

	s := Schema()

	diskSchema := test.AssertNestedSchemaExistence(t, s, MkDisk)

	test.AssertOptionalArguments(t, diskSchema, []string{
		mkDiskDatastoreID,
		mkDiskPathInDatastore,
		mkDiskFileFormat,
		mkDiskFileID,
		mkDiskSize,
	})

	test.AssertValueTypes(t, diskSchema, map[string]schema.ValueType{
		mkDiskDatastoreID:     schema.TypeString,
		mkDiskPathInDatastore: schema.TypeString,
		mkDiskFileFormat:      schema.TypeString,
		mkDiskFileID:          schema.TypeString,
		mkDiskSize:            schema.TypeInt,
	})

	diskSpeedSchema := test.AssertNestedSchemaExistence(
		t,
		diskSchema,
		mkDiskSpeed,
	)

	test.AssertOptionalArguments(t, diskSpeedSchema, []string{
		mkDiskSpeedRead,
		mkDiskSpeedReadBurstable,
		mkDiskSpeedWrite,
		mkDiskSpeedWriteBurstable,
	})

	test.AssertValueTypes(t, diskSpeedSchema, map[string]schema.ValueType{
		mkDiskSpeedRead:           schema.TypeInt,
		mkDiskSpeedReadBurstable:  schema.TypeInt,
		mkDiskSpeedWrite:          schema.TypeInt,
		mkDiskSpeedWriteBurstable: schema.TypeInt,
	})
}
`````

## File: proxmoxtf/resource/vm/disk/schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package disk

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
)

const (
	dvDiskInterface   = "scsi0"
	dvDiskDatastoreID = "local-lvm"
	dvDiskSize        = 8
	dvDiskAIO         = "io_uring"
	dvDiskDiscard     = "ignore"
	dvDiskCache       = "none"

	// MkDisk is the name of the disk resource.
	MkDisk                    = "disk"
	mkDiskAIO                 = "aio"
	mkDiskBackup              = "backup"
	mkDiskCache               = "cache"
	mkDiskDatastoreID         = "datastore_id"
	mkDiskDiscard             = "discard"
	mkDiskFileFormat          = "file_format"
	mkDiskFileID              = "file_id"
	mkDiskInterface           = "interface"
	mkDiskIopsRead            = "iops_read"
	mkDiskIopsReadBurstable   = "iops_read_burstable"
	mkDiskIopsWrite           = "iops_write"
	mkDiskIopsWriteBurstable  = "iops_write_burstable"
	mkDiskIOThread            = "iothread"
	mkDiskPathInDatastore     = "path_in_datastore"
	mkDiskReplicate           = "replicate"
	mkDiskSerial              = "serial"
	mkDiskSize                = "size"
	mkDiskSpeed               = "speed"
	mkDiskSpeedRead           = "read"
	mkDiskSpeedReadBurstable  = "read_burstable"
	mkDiskSpeedWrite          = "write"
	mkDiskSpeedWriteBurstable = "write_burstable"
	mkDiskSSD                 = "ssd"
)

// Schema returns the schema for the disk resource.
func Schema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		MkDisk: {
			Type:        schema.TypeList,
			Description: "The disk devices",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkDiskAIO:             dvDiskAIO,
						mkDiskBackup:          true,
						mkDiskCache:           dvDiskCache,
						mkDiskDatastoreID:     dvDiskDatastoreID,
						mkDiskDiscard:         dvDiskDiscard,
						mkDiskFileID:          "",
						mkDiskInterface:       dvDiskInterface,
						mkDiskIOThread:        false,
						mkDiskPathInDatastore: nil,
						mkDiskReplicate:       true,
						mkDiskSerial:          "",
						mkDiskSize:            dvDiskSize,
						mkDiskSSD:             false,
					},
				}, nil
			},
			DiffSuppressFunc: structure.SuppressIfListsOfMapsAreEqualIgnoringOrderByKey(
				mkDiskInterface, mkDiskPathInDatastore,
			),
			DiffSuppressOnRefresh: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkDiskInterface: {
						Type:        schema.TypeString,
						Description: "The datastore name",
						Required:    true,
					},
					mkDiskDatastoreID: {
						Type:        schema.TypeString,
						Description: "The datastore id",
						Optional:    true,
						Default:     dvDiskDatastoreID,
					},
					mkDiskPathInDatastore: {
						Type:        schema.TypeString,
						Description: "The in-datastore path to disk image",
						Computed:    true,
						Optional:    true,
						Default:     nil,
					},
					mkDiskFileFormat: {
						Type:             schema.TypeString,
						Description:      "The file format",
						Optional:         true,
						Computed:         true,
						ValidateDiagFunc: validators.FileFormat(),
					},
					mkDiskAIO: {
						Type:        schema.TypeString,
						Description: "The disk AIO mode",
						Optional:    true,
						Default:     dvDiskAIO,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.StringInSlice([]string{
								"io_uring",
								"native",
								"threads",
							}, false),
						),
					},
					mkDiskBackup: {
						Type:        schema.TypeBool,
						Description: "Whether the drive should be included when making backups",
						Optional:    true,
						Default:     true,
					},
					mkDiskFileID: {
						Type:             schema.TypeString,
						Description:      "The file id for a disk image",
						Optional:         true,
						ForceNew:         true,
						Default:          "",
						ValidateDiagFunc: validators.FileID(),
					},
					mkDiskSerial: {
						Type:             schema.TypeString,
						Description:      "The drive‚Äôs reported serial number",
						Optional:         true,
						Default:          "",
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringLenBetween(0, 20)),
					},
					mkDiskSize: {
						Type:             schema.TypeInt,
						Description:      "The disk size in gigabytes",
						Optional:         true,
						Default:          dvDiskSize,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(1)),
					},
					mkDiskIOThread: {
						Type:        schema.TypeBool,
						Description: "Whether to use iothreads for this disk drive",
						Optional:    true,
						Default:     false,
					},
					mkDiskReplicate: {
						Type:        schema.TypeBool,
						Description: "Whether the drive should be considered for replication jobs",
						Optional:    true,
						Default:     true,
					},
					mkDiskSSD: {
						Type:        schema.TypeBool,
						Description: "Whether to use ssd for this disk drive",
						Optional:    true,
						Default:     false,
					},
					mkDiskDiscard: {
						Type:        schema.TypeString,
						Description: "Whether to pass discard/trim requests to the underlying storage.",
						Optional:    true,
						Default:     dvDiskDiscard,
					},
					mkDiskCache: {
						Type:        schema.TypeString,
						Description: "The drive‚Äôs cache mode",
						Optional:    true,
						Default:     dvDiskCache,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.StringInSlice([]string{
								"none",
								"writethrough",
								"writeback",
								"unsafe",
								"directsync",
							}, false),
						),
					},
					mkDiskSpeed: {
						Type:        schema.TypeList,
						Description: "The speed limits",
						Optional:    true,
						DefaultFunc: func() (interface{}, error) {
							return []interface{}{
								map[string]interface{}{
									mkDiskIopsRead:            0,
									mkDiskIopsWrite:           0,
									mkDiskIopsReadBurstable:   0,
									mkDiskIopsWriteBurstable:  0,
									mkDiskSpeedRead:           0,
									mkDiskSpeedReadBurstable:  0,
									mkDiskSpeedWrite:          0,
									mkDiskSpeedWriteBurstable: 0,
								},
							}, nil
						},
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								mkDiskIopsRead: {
									Type:        schema.TypeInt,
									Description: "The maximum read I/O in operations per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskIopsWrite: {
									Type:        schema.TypeInt,
									Description: "The maximum write I/O in operations per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskIopsReadBurstable: {
									Type:        schema.TypeInt,
									Description: "The maximum unthrottled read I/O pool in operations per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskIopsWriteBurstable: {
									Type:        schema.TypeInt,
									Description: "The maximum unthrottled write I/O pool in operations per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskSpeedRead: {
									Type:        schema.TypeInt,
									Description: "The maximum read speed in megabytes per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskSpeedReadBurstable: {
									Type:        schema.TypeInt,
									Description: "The maximum burstable read speed in megabytes per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskSpeedWrite: {
									Type:        schema.TypeInt,
									Description: "The maximum write speed in megabytes per second",
									Optional:    true,
									Default:     0,
								},
								mkDiskSpeedWriteBurstable: {
									Type:        schema.TypeInt,
									Description: "The maximum burstable write speed in megabytes per second",
									Optional:    true,
									Default:     0,
								},
							},
						},
						MaxItems: 1,
						MinItems: 0,
					},
				},
			},
			MaxItems: 14,
			MinItems: 0,
		},
	}
}
`````

## File: proxmoxtf/resource/vm/network/network.go
`````go
package network

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
)

// GetNetworkDeviceObjects returns a list of network devices from the resource data.
func GetNetworkDeviceObjects(d *schema.ResourceData) (vms.CustomNetworkDevices, error) {
	networkDevice := d.Get(MkNetworkDevice).([]interface{})
	networkDeviceObjects := make(vms.CustomNetworkDevices, len(networkDevice))

	for i, networkDeviceEntry := range networkDevice {
		block := networkDeviceEntry.(map[string]interface{})

		bridge := block[mkNetworkDeviceBridge].(string)
		disconnected := types.CustomBool(block[mkNetworkDeviceDisconnected].(bool))
		enabled := block[mkNetworkDeviceEnabled].(bool)
		firewall := types.CustomBool(block[mkNetworkDeviceFirewall].(bool))
		macAddress := block[mkNetworkDeviceMACAddress].(string)
		model := block[mkNetworkDeviceModel].(string)
		mtu := block[mkNetworkDeviceMTU].(int)
		queues := block[mkNetworkDeviceQueues].(int)
		rateLimit := block[mkNetworkDeviceRateLimit].(float64)
		trunks := block[mkNetworkDeviceTrunks].(string)
		vlanID := block[mkNetworkDeviceVLANID].(int)

		device := vms.CustomNetworkDevice{
			Enabled:  enabled,
			Firewall: &firewall,
			Model:    model,
		}

		if bridge != "" {
			device.Bridge = &bridge
		}

		if disconnected {
			device.LinkDown = &disconnected
		}

		if macAddress != "" {
			device.MACAddress = &macAddress
		}

		if queues != 0 {
			device.Queues = &queues
		}

		if rateLimit != 0 {
			device.RateLimit = &rateLimit
		}

		if vlanID != 0 {
			device.Tag = &vlanID
		}

		if trunks != "" {
			splitTrunks := strings.Split(trunks, ";")

			var trunksAsInt []int

			for _, numStr := range splitTrunks {
				num, err := strconv.Atoi(numStr)
				if err != nil {
					return nil, fmt.Errorf("error parsing trunks: %w", err)
				}

				trunksAsInt = append(trunksAsInt, num)
			}

			device.Trunks = trunksAsInt
		}

		if mtu != 0 {
			device.MTU = &mtu
		}

		networkDeviceObjects[i] = device
	}

	return networkDeviceObjects, nil
}

// ReadNetworkDeviceObjects reads the network device objects from the resource data.
func ReadNetworkDeviceObjects(d *schema.ResourceData, vmConfig *vms.GetResponseData) diag.Diagnostics {
	var diags diag.Diagnostics

	// Compare the network devices to those stored in the state.
	currentNetworkDeviceList := d.Get(MkNetworkDevice).([]interface{})

	macAddresses := make([]interface{}, MaxNetworkDevices)
	networkDeviceLast := -1
	networkDeviceList := make([]interface{}, MaxNetworkDevices)
	networkDeviceObjects := []*vms.CustomNetworkDevice{
		vmConfig.NetworkDevice0,
		vmConfig.NetworkDevice1,
		vmConfig.NetworkDevice2,
		vmConfig.NetworkDevice3,
		vmConfig.NetworkDevice4,
		vmConfig.NetworkDevice5,
		vmConfig.NetworkDevice6,
		vmConfig.NetworkDevice7,
		vmConfig.NetworkDevice8,
		vmConfig.NetworkDevice9,
		vmConfig.NetworkDevice10,
		vmConfig.NetworkDevice11,
		vmConfig.NetworkDevice12,
		vmConfig.NetworkDevice13,
		vmConfig.NetworkDevice14,
		vmConfig.NetworkDevice15,
		vmConfig.NetworkDevice16,
		vmConfig.NetworkDevice17,
		vmConfig.NetworkDevice18,
		vmConfig.NetworkDevice19,
		vmConfig.NetworkDevice20,
		vmConfig.NetworkDevice21,
		vmConfig.NetworkDevice22,
		vmConfig.NetworkDevice23,
		vmConfig.NetworkDevice24,
		vmConfig.NetworkDevice25,
		vmConfig.NetworkDevice26,
		vmConfig.NetworkDevice27,
		vmConfig.NetworkDevice28,
		vmConfig.NetworkDevice29,
		vmConfig.NetworkDevice30,
		vmConfig.NetworkDevice31,
	}

	for ni, nd := range networkDeviceObjects {
		networkDevice := map[string]interface{}{}

		if nd != nil {
			networkDeviceLast = ni

			if nd.Bridge != nil {
				networkDevice[mkNetworkDeviceBridge] = *nd.Bridge
			} else {
				networkDevice[mkNetworkDeviceBridge] = ""
			}

			networkDevice[mkNetworkDeviceEnabled] = nd.Enabled

			if nd.LinkDown != nil {
				networkDevice[mkNetworkDeviceDisconnected] = *nd.LinkDown
			} else {
				networkDevice[mkNetworkDeviceDisconnected] = false
			}

			if nd.Firewall != nil {
				networkDevice[mkNetworkDeviceFirewall] = *nd.Firewall
			} else {
				networkDevice[mkNetworkDeviceFirewall] = false
			}

			if nd.MACAddress != nil {
				macAddresses[ni] = *nd.MACAddress
			} else {
				macAddresses[ni] = ""
			}

			networkDevice[mkNetworkDeviceMACAddress] = macAddresses[ni]
			networkDevice[mkNetworkDeviceModel] = nd.Model

			if nd.Queues != nil {
				networkDevice[mkNetworkDeviceQueues] = *nd.Queues
			} else {
				networkDevice[mkNetworkDeviceQueues] = 0
			}

			if nd.RateLimit != nil {
				networkDevice[mkNetworkDeviceRateLimit] = *nd.RateLimit
			} else {
				networkDevice[mkNetworkDeviceRateLimit] = 0
			}

			if nd.Tag != nil {
				networkDevice[mkNetworkDeviceVLANID] = nd.Tag
			} else {
				networkDevice[mkNetworkDeviceVLANID] = 0
			}

			if nd.Trunks != nil {
				networkDevice[mkNetworkDeviceTrunks] = strings.Trim(
					strings.Join(strings.Fields(fmt.Sprint(nd.Trunks)), ";"), "[]")
			} else {
				networkDevice[mkNetworkDeviceTrunks] = ""
			}

			if nd.MTU != nil {
				networkDevice[mkNetworkDeviceMTU] = nd.MTU
			} else {
				networkDevice[mkNetworkDeviceMTU] = 0
			}
		} else {
			macAddresses[ni] = ""
			networkDevice[mkNetworkDeviceEnabled] = false
		}

		networkDeviceList[ni] = networkDevice
	}

	if len(currentNetworkDeviceList) > 0 || networkDeviceLast > -1 {
		err := d.Set(MkNetworkDevice, networkDeviceList[:networkDeviceLast+1])
		diags = append(diags, diag.FromErr(err)...)
	}

	err := d.Set(mkMACAddresses, macAddresses[0:len(currentNetworkDeviceList)])
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

// ReadNetworkValues reads the network values from the resource data.
func ReadNetworkValues(
	ctx context.Context,
	d *schema.ResourceData,
	vmAPI *vms.Client,
	started bool,
	vmConfig *vms.GetResponseData,
	agentTimeout time.Duration,
) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4Addresses []interface{}

	var ipv6Addresses []interface{}

	var networkInterfaceNames []interface{}

	if started {
		if vmConfig.Agent != nil && vmConfig.Agent.Enabled != nil && *vmConfig.Agent.Enabled {
			var macAddresses []interface{}

			networkInterfaces, err := vmAPI.WaitForNetworkInterfacesFromVMAgent(ctx, int(agentTimeout.Seconds()), 5, true)
			if err == nil && networkInterfaces.Result != nil {
				ipv4Addresses = make([]interface{}, len(*networkInterfaces.Result))
				ipv6Addresses = make([]interface{}, len(*networkInterfaces.Result))
				macAddresses = make([]interface{}, len(*networkInterfaces.Result))
				networkInterfaceNames = make([]interface{}, len(*networkInterfaces.Result))

				for ri, rv := range *networkInterfaces.Result {
					var rvIPv4Addresses []interface{}

					var rvIPv6Addresses []interface{}

					if rv.IPAddresses != nil {
						for _, ip := range *rv.IPAddresses {
							switch ip.Type {
							case "ipv4":
								rvIPv4Addresses = append(rvIPv4Addresses, ip.Address)
							case "ipv6":
								rvIPv6Addresses = append(rvIPv6Addresses, ip.Address)
							}
						}
					}

					ipv4Addresses[ri] = rvIPv4Addresses
					ipv6Addresses[ri] = rvIPv6Addresses
					macAddresses[ri] = strings.ToUpper(rv.MACAddress)
					networkInterfaceNames[ri] = rv.Name
				}
			}

			err = d.Set(mkMACAddresses, macAddresses)
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	e := d.Set(mkIPv4Addresses, ipv4Addresses)
	diags = append(diags, diag.FromErr(e)...)
	e = d.Set(mkIPv6Addresses, ipv6Addresses)
	diags = append(diags, diag.FromErr(e)...)
	e = d.Set(mkNetworkInterfaceNames, networkInterfaceNames)
	diags = append(diags, diag.FromErr(e)...)

	return diags
}
`````

## File: proxmoxtf/resource/vm/network/schema_test.go
`````go
package network

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

func TestNetworkSchema(t *testing.T) {
	t.Parallel()

	s := Schema()

	test.AssertComputedAttributes(t, s, []string{
		mkIPv4Addresses,
		mkIPv6Addresses,
		mkMACAddresses,
		mkNetworkInterfaceNames,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkIPv4Addresses:         schema.TypeList,
		mkIPv6Addresses:         schema.TypeList,
		mkMACAddresses:          schema.TypeList,
		mkNetworkInterfaceNames: schema.TypeList,
	})

	deviceSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		MkNetworkDevice,
	)

	test.AssertOptionalArguments(t, deviceSchema, []string{
		mkNetworkDeviceBridge,
		mkNetworkDeviceEnabled,
		mkNetworkDeviceMACAddress,
		mkNetworkDeviceModel,
		mkNetworkDeviceRateLimit,
		mkNetworkDeviceVLANID,
		mkNetworkDeviceMTU,
	})

	test.AssertValueTypes(t, deviceSchema, map[string]schema.ValueType{
		mkNetworkDeviceBridge:     schema.TypeString,
		mkNetworkDeviceEnabled:    schema.TypeBool,
		mkNetworkDeviceMACAddress: schema.TypeString,
		mkNetworkDeviceModel:      schema.TypeString,
		mkNetworkDeviceRateLimit:  schema.TypeFloat,
		mkNetworkDeviceVLANID:     schema.TypeInt,
		mkNetworkDeviceMTU:        schema.TypeInt,
	})
}
`````

## File: proxmoxtf/resource/vm/network/schema.go
`````go
package network

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
)

const (
	// MaxNetworkDevices is the maximum number of network devices supported by the resource.
	MaxNetworkDevices = 32

	dvNetworkDeviceBridge    = "vmbr0"
	dvNetworkDeviceEnabled   = true
	dvNetworkDeviceFirewall  = false
	dvNetworkDeviceMTU       = 0
	dvNetworkDeviceModel     = "virtio"
	dvNetworkDeviceQueues    = 0
	dvNetworkDeviceRateLimit = 0
	dvNetworkDeviceVLANID    = 0

	mkIPv4Addresses = "ipv4_addresses"
	mkIPv6Addresses = "ipv6_addresses"
	mkMACAddresses  = "mac_addresses"

	// MkNetworkDevice is the name of the network device.
	MkNetworkDevice             = "network_device"
	mkNetworkDeviceBridge       = "bridge"
	mkNetworkDeviceDisconnected = "disconnected"
	mkNetworkDeviceEnabled      = "enabled"
	mkNetworkDeviceFirewall     = "firewall"
	mkNetworkDeviceMACAddress   = "mac_address"
	mkNetworkDeviceMTU          = "mtu"
	mkNetworkDeviceModel        = "model"
	mkNetworkDeviceQueues       = "queues"
	mkNetworkDeviceRateLimit    = "rate_limit"
	mkNetworkDeviceTrunks       = "trunks"
	mkNetworkDeviceVLANID       = "vlan_id"
	mkNetworkInterfaceNames     = "network_interface_names"
)

// Schema returns the schema for the network resource.
func Schema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		mkIPv4Addresses: {
			Type:        schema.TypeList,
			Description: "The IPv4 addresses published by the QEMU agent",
			Computed:    true,
			Elem: &schema.Schema{
				Type: schema.TypeList,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
		},
		mkIPv6Addresses: {
			Type:        schema.TypeList,
			Description: "The IPv6 addresses published by the QEMU agent",
			Computed:    true,
			Elem: &schema.Schema{
				Type: schema.TypeList,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
		},
		mkMACAddresses: {
			Type:        schema.TypeList,
			Description: "The MAC addresses for the network interfaces",
			Computed:    true,
			Optional:    true,
			Elem:        &schema.Schema{Type: schema.TypeString},
		},
		MkNetworkDevice: {
			Type:        schema.TypeList,
			Description: "The network devices",
			Optional:    true,
			Computed:    true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkNetworkDeviceBridge: {
						Type:        schema.TypeString,
						Description: "The bridge",
						Optional:    true,
						Default:     dvNetworkDeviceBridge,
					},
					mkNetworkDeviceDisconnected: {
						Type:        schema.TypeBool,
						Description: "Whether the network device should be disconnected from the network",
						Optional:    true,
					},
					mkNetworkDeviceEnabled: {
						Type:        schema.TypeBool,
						Description: "Whether to enable the network device",
						Optional:    true,
						Default:     dvNetworkDeviceEnabled,
					},
					mkNetworkDeviceFirewall: {
						Type:        schema.TypeBool,
						Description: "Whether this interface's firewall rules should be used",
						Optional:    true,
						Default:     dvNetworkDeviceFirewall,
					},
					mkNetworkDeviceMACAddress: {
						Type:             schema.TypeString,
						Description:      "The MAC address",
						Optional:         true,
						Computed:         true,
						ValidateDiagFunc: validators.MACAddress(),
					},
					mkNetworkDeviceModel: {
						Type:        schema.TypeString,
						Description: "The model",
						Optional:    true,
						Default:     dvNetworkDeviceModel,
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"e1000",
							"e1000e",
							"rtl8139",
							"virtio",
							"vmxnet3",
						}, false)),
					},
					mkNetworkDeviceQueues: {
						Type:             schema.TypeInt,
						Description:      "Number of packet queues to be used on the device",
						Optional:         true,
						Default:          dvNetworkDeviceQueues,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntBetween(0, 64)),
					},
					mkNetworkDeviceRateLimit: {
						Type:        schema.TypeFloat,
						Description: "The rate limit in megabytes per second",
						Optional:    true,
						Default:     dvNetworkDeviceRateLimit,
					},
					mkNetworkDeviceVLANID: {
						Type:        schema.TypeInt,
						Description: "The VLAN identifier",
						Optional:    true,
						Default:     dvNetworkDeviceVLANID,
					},
					mkNetworkDeviceTrunks: {
						Type:        schema.TypeString,
						Optional:    true,
						Description: "List of VLAN trunks for the network interface",
					},
					mkNetworkDeviceMTU: {
						Type:        schema.TypeInt,
						Description: "Maximum transmission unit (MTU)",
						Optional:    true,
						Default:     dvNetworkDeviceMTU,
					},
				},
			},
			MaxItems: MaxNetworkDevices,
			MinItems: 0,
		},
		mkNetworkInterfaceNames: {
			Type:        schema.TypeList,
			Description: "The network interface names published by the QEMU agent",
			Computed:    true,
			Elem:        &schema.Schema{Type: schema.TypeString},
		},
	}
}

// CustomizeDiff returns the custom diff functions for the network resource.
func CustomizeDiff() []schema.CustomizeDiffFunc {
	return []schema.CustomizeDiffFunc{
		customdiff.ComputedIf(
			mkIPv4Addresses,
			func(_ context.Context, d *schema.ResourceDiff, _ interface{}) bool {
				return d.HasChange("started") ||
					d.HasChange(MkNetworkDevice)
			},
		),
		customdiff.ComputedIf(
			mkIPv6Addresses,
			func(_ context.Context, d *schema.ResourceDiff, _ interface{}) bool {
				return d.HasChange("started") ||
					d.HasChange(MkNetworkDevice)
			},
		),
		customdiff.ComputedIf(
			mkNetworkInterfaceNames,
			func(_ context.Context, d *schema.ResourceDiff, _ interface{}) bool {
				return d.HasChange("started") ||
					d.HasChange(MkNetworkDevice)
			},
		),
	}
}
`````

## File: proxmoxtf/resource/vm/validators_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCPUType(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		value string
		valid bool
	}{
		{"empty", "", false},
		{"invalid", "invalid", false},
		{"valid", "host", true},
		{"valid", "qemu64", true},
		{"valid", "custom-abc", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			f := CPUTypeValidator()
			res := f(tt.value, nil)

			if tt.valid {
				require.Empty(t, res, "validate: '%s'", tt.value)
			} else {
				require.NotEmpty(t, res, "validate: '%s'", tt.value)
			}
		})
	}
}

func TestMachineType(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name  string
		value string
		valid bool
	}{
		{"empty is valid", "", true},
		{"invalid", "invalid", false},
		{"valid q35", "q35", true},
		{"valid q35 with viommu", "q35,viommu=virtio", true},
		{"invalid q35 with viommu", "q35,viommu=invalid", false},
		{"valid pc-q35", "pc-q35-2.3", true},
		{"valid i440fx", "pc-i440fx-3.1+pve0", true},
		{"valid virt", "virt", true},
		{"invalid i440fx", "i440fx", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			f := MachineTypeValidator()
			res := f(tt.value, nil)

			if tt.valid {
				require.Empty(t, res, "validate: '%s'", tt.value)
			} else {
				require.NotEmpty(t, res, "validate: '%s'", tt.value)
			}
		})
	}
}
`````

## File: proxmoxtf/resource/vm/validators.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// VMIDValidator returns a schema validation function for a VM ID.
func VMIDValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(func(i interface{}, k string) ([]string, []error) {
		minID := 100
		maxID := 2147483647

		var ws []string

		var es []error

		v, ok := i.(int)

		if !ok {
			es = append(es, fmt.Errorf("expected type of %s to be int", k))
			return ws, es
		}

		if v != -1 {
			if v < minID || v > maxID {
				es = append(es, fmt.Errorf("expected %s to be in the range (%d - %d), got %d", k, minID, maxID, v))
				return ws, es
			}
		}

		return ws, es
	})
}

// BIOSValidator returns a schema validation function for a BIOSValidator type.
func BIOSValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"ovmf",
		"seabios",
	}, false))
}

// CPUArchitectureValidator returns a schema validation function for a CPU architecture.
func CPUArchitectureValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"",
		"aarch64",
		"x86_64",
	}, false))
}

// CPUTypeValidator returns a schema validation function for a CPU type.
func CPUTypeValidator() schema.SchemaValidateDiagFunc {
	standardTypes := []string{
		"486",
		"Broadwell",
		"Broadwell-IBRS",
		"Broadwell-noTSX",
		"Broadwell-noTSX-IBRS",
		"Cascadelake-Server",
		"Cascadelake-Server-noTSX",
		"Cascadelake-Server-v2",
		"Cascadelake-Server-v4",
		"Cascadelake-Server-v5",
		"Conroe",
		"Cooperlake",
		"Cooperlake-v2",
		"EPYC",
		"EPYC-IBPB",
		"EPYC-Milan",
		"EPYC-Rome",
		"EPYC-Rome-v2",
		"EPYC-v3",
		"EPYC-v4",
		"Haswell",
		"Haswell-IBRS",
		"Haswell-noTSX",
		"Haswell-noTSX-IBRS",
		"Icelake-Client",
		"Icelake-Client-noTSX",
		"Icelake-Server",
		"Icelake-Server-noTSX",
		"Icelake-Server-v3",
		"Icelake-Server-v4",
		"Icelake-Server-v5",
		"Icelake-Server-v6",
		"IvyBridge",
		"IvyBridge-IBRS",
		"KnightsMill",
		"Nehalem",
		"Nehalem-IBRS",
		"Opteron_G1",
		"Opteron_G2",
		"Opteron_G3",
		"Opteron_G4",
		"Opteron_G5",
		"Penryn",
		"SandyBridge",
		"SandyBridge-IBRS",
		"SapphireRapids",
		"Skylake-Client",
		"Skylake-Client-IBRS",
		"Skylake-Client-noTSX-IBRS",
		"Skylake-Client-v4",
		"Skylake-Server",
		"Skylake-Server-IBRS",
		"Skylake-Server-noTSX-IBRS",
		"Skylake-Server-v4",
		"Skylake-Server-v5",
		"Westmere",
		"Westmere-IBRS",
		"athlon",
		"core2duo",
		"coreduo",
		"host",
		"kvm32",
		"kvm64",
		"max",
		"pentium",
		"pentium2",
		"pentium3",
		"phenom",
		"qemu32",
		"qemu64",
		"x86-64-v2",
		"x86-64-v2-AES",
		"x86-64-v3",
		"x86-64-v4",
	}

	return validation.ToDiagFunc(validation.Any(
		validation.StringInSlice(standardTypes, false),
		validation.StringMatch(regexp.MustCompile(`^custom-.+$`), "must be a valid custom CPU type"),
	))
}

// CPUAffinityValidator returns a schema validation function for a CPU affinity.
func CPUAffinityValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(
		validation.StringMatch(regexp.MustCompile(`^\d+[\d-,]*$`), "must contain numbers or number ranges separated by ','"),
	)
}

// QEMUAgentTypeValidator is a schema validation function for QEMU agent types.
func QEMUAgentTypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{"isa", "virtio"}, false))
}

// AMDSEVTypeValidator is a schema validation function for AMDSEV types.
func AMDSEVTypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{"std", "es", "snp"}, false))
}

// KeyboardLayoutValidator is a schema validation function for keyboard layouts.
func KeyboardLayoutValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"da",
		"de",
		"de-ch",
		"en-gb",
		"en-us",
		"es",
		"fi",
		"fr",
		"fr-be",
		"fr-ca",
		"fr-ch",
		"hu",
		"is",
		"it",
		"ja",
		"lt",
		"mk",
		"nl",
		"no",
		"pl",
		"pt",
		"pt-br",
		"sl",
		"sv",
		"tr",
	}, false))
}

// MachineTypeValidator is a schema validation function for machine types.
func MachineTypeValidator() schema.SchemaValidateDiagFunc {
	//nolint:lll
	r := regexp.MustCompile(`^$|^(pc|pc(-i440fx)?-\d+(\.\d+)+(\+pve\d+)?(\.pxe)?|q35(,viommu=(intel|virtio))?|pc-q35-\d+(\.\d+)+(\+pve\d+)?(\.pxe)?|virt(?:-\d+(\.\d+)+)?(\+pve\d+)?)$`)

	return validation.ToDiagFunc(validation.StringMatch(r, "must be a valid machine type"))
}

// TimeoutValidator is a schema validation function for timeouts.
func TimeoutValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(func(i interface{}, k string) ([]string, []error) {
		v, ok := i.(string)

		var ws []string

		var es []error

		if !ok {
			es = append(es, fmt.Errorf("expected type of %s to be string", k))
			return ws, es
		}

		_, err := time.ParseDuration(v)
		if err != nil {
			es = append(es, fmt.Errorf("expected value of %s to be a duration - got: %s", k, v))
			return ws, es
		}

		return ws, es
	})
}

// VGAMemoryValidator is a schema validation function for VGA memory sizes.
func VGAMemoryValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.IntBetween(4, 512))
}

// VGATypeValidator is a schema validation function for VGA device types.
func VGATypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"cirrus",
		"none",
		"qxl",
		"qxl2",
		"qxl3",
		"qxl4",
		"serial0",
		"serial1",
		"serial2",
		"serial3",
		"std",
		"virtio",
		"virtio-gl",
		"vmware",
	}, false))
}

// SCSIHardwareValidator is a schema validation function for SCSI hardware.
func SCSIHardwareValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"lsi",
		"lsi53c810",
		"virtio-scsi-pci",
		"virtio-scsi-single",
		"megasas",
		"pvscsi",
	}, false))
}

// CDROMInterfaceValidator is a schema validation function for IDE interfaces.
func CDROMInterfaceValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringMatch(
		regexp.MustCompile(`^(ide[0-3]|sata[0-5]|scsi([0-9]|1[0-3]))$`),
		"must be one of `ide[0-3]`, `sata[0-5]`, `scsi[0-13]`",
	))
}

// VirtiofsCacheValidator is a schema validation function for virtiofs cache configs.
func VirtiofsCacheValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"auto",
		"always",
		"metadata",
		"never",
	}, false))
}

// CloudInitInterfaceValidator is a schema validation function that accepts either an IDE interface identifier or an
// empty string, which is used as the default and means "detect which interface should be used automatically".
func CloudInitInterfaceValidator() schema.SchemaValidateDiagFunc {
	r := regexp.MustCompile(`^ide[0-3]|sata[0-5]|scsi(?:30|[12][0-9]|[0-9])$`)

	return validation.ToDiagFunc(validation.Any(
		validation.StringIsEmpty,
		validation.StringMatch(r, "one of ide0..3|sata0..5|scsi0..30"),
	))
}

// CloudInitTypeValidator is a schema validation function for cloud-init types.
func CloudInitTypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"configdrive2",
		"nocloud",
	}, false))
}

// AudioDeviceValidator is a schema validation function for audio devices.
func AudioDeviceValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"AC97",
		"ich9-intel-hda",
		"intel-hda",
	}, false))
}

// AudioDriverValidator is a schema validation function for audio drivers.
func AudioDriverValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"spice",
	}, false))
}

// OperatingSystemTypeValidator is a schema validation function for operating system types.
func OperatingSystemTypeValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(validation.StringInSlice([]string{
		"l24",
		"l26",
		"other",
		"solaris",
		"w2k",
		"w2k3",
		"w2k8",
		"win7",
		"win8",
		"win10",
		"win11",
		"wvista",
		"wxp",
	}, false))
}

// SerialDeviceValidator is a schema validation function for serial devices.
func SerialDeviceValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(func(i interface{}, k string) ([]string, []error) {
		v, ok := i.(string)

		var es []error

		if !ok {
			es = append(es, fmt.Errorf("expected type of %s to be string", k))
			return nil, es
		}

		if !strings.HasPrefix(v, "/dev/") && v != "socket" {
			es = append(es, fmt.Errorf("expected %s to be '/dev/*' or 'socket'", k))
			return nil, es
		}

		return nil, es
	})
}

// RangeSemicolonValidator is a proxmox list validation function for ranges with semicolon.
func RangeSemicolonValidator() schema.SchemaValidateDiagFunc {
	return validation.ToDiagFunc(
		validation.StringMatch(
			regexp.MustCompile(`^\d+(?:-\d+)?(?:;\d+(?:-\d+)?)*$`),
			"must contain numbers or number ranges separated by ';'",
		),
	)
}
`````

## File: proxmoxtf/resource/vm/vm_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/require"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm/disk"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm/network"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestVMInstantiation tests whether the VM instance can be instantiated.
func TestVMInstantiation(t *testing.T) {
	t.Parallel()

	r := VM()
	if r == nil {
		t.Fatalf("Cannot instantiate VM")
	}
}

// TestVMSchema tests the VM schema.
func TestVMSchema(t *testing.T) {
	t.Parallel()

	s := VM().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkNodeName,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkACPI,
		mkAgent,
		mkAudioDevice,
		mkBIOS,
		mkBootOrder,
		mkCDROM,
		mkClone,
		mkCPU,
		mkDescription,
		disk.MkDisk,
		mkEFIDisk,
		mkInitialization,
		mkHostPCI,
		mkHostUSB,
		mkKeyboardLayout,
		mkKVMArguments,
		mkMachine,
		mkMemory,
		mkName,
		network.MkNetworkDevice,
		mkOperatingSystem,
		mkPoolID,
		mkSerialDevice,
		mkStarted,
		mkTabletDevice,
		mkTemplate,
		mkVirtiofs,
		mkVMID,
		mkSCSIHardware,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkACPI:            schema.TypeBool,
		mkAgent:           schema.TypeList,
		mkAudioDevice:     schema.TypeList,
		mkBIOS:            schema.TypeString,
		mkBootOrder:       schema.TypeList,
		mkCDROM:           schema.TypeList,
		mkCPU:             schema.TypeList,
		mkDescription:     schema.TypeString,
		disk.MkDisk:       schema.TypeList,
		mkEFIDisk:         schema.TypeList,
		mkHostPCI:         schema.TypeList,
		mkHostUSB:         schema.TypeList,
		mkInitialization:  schema.TypeList,
		mkKeyboardLayout:  schema.TypeString,
		mkKVMArguments:    schema.TypeString,
		mkMachine:         schema.TypeString,
		mkMemory:          schema.TypeList,
		mkName:            schema.TypeString,
		mkOperatingSystem: schema.TypeList,
		mkPoolID:          schema.TypeString,
		mkSerialDevice:    schema.TypeList,
		mkStarted:         schema.TypeBool,
		mkTabletDevice:    schema.TypeBool,
		mkTemplate:        schema.TypeBool,
		mkVirtiofs:        schema.TypeList,
		mkVMID:            schema.TypeInt,
		mkSCSIHardware:    schema.TypeString,
	})

	agentSchema := test.AssertNestedSchemaExistence(t, s, mkAgent)

	test.AssertOptionalArguments(t, agentSchema, []string{
		mkAgentEnabled,
		mkAgentTimeout,
		mkAgentTrim,
		mkAgentType,
	})

	test.AssertValueTypes(t, agentSchema, map[string]schema.ValueType{
		mkAgentEnabled: schema.TypeBool,
		mkAgentTrim:    schema.TypeBool,
		mkAgentType:    schema.TypeString,
	})

	audioDeviceSchema := test.AssertNestedSchemaExistence(t, s, mkAudioDevice)

	test.AssertOptionalArguments(t, audioDeviceSchema, []string{
		mkAudioDeviceDevice,
		mkAudioDeviceDriver,
	})

	test.AssertValueTypes(t, audioDeviceSchema, map[string]schema.ValueType{
		mkAudioDeviceDevice: schema.TypeString,
		mkAudioDeviceDriver: schema.TypeString,
	})

	cdromSchema := test.AssertNestedSchemaExistence(t, s, mkCDROM)

	test.AssertOptionalArguments(t, cdromSchema, []string{
		mkCDROMEnabled,
		mkCDROMFileID,
	})

	test.AssertValueTypes(t, cdromSchema, map[string]schema.ValueType{
		mkCDROMEnabled: schema.TypeBool,
		mkCDROMFileID:  schema.TypeString,
	})

	cloneSchema := test.AssertNestedSchemaExistence(t, s, mkClone)

	test.AssertRequiredArguments(t, cloneSchema, []string{
		mkCloneVMID,
	})

	test.AssertOptionalArguments(t, cloneSchema, []string{
		mkCloneDatastoreID,
		mkCloneNodeName,
	})

	test.AssertValueTypes(t, cloneSchema, map[string]schema.ValueType{
		mkCloneDatastoreID: schema.TypeString,
		mkCloneNodeName:    schema.TypeString,
		mkCloneVMID:        schema.TypeInt,
	})

	cpuSchema := test.AssertNestedSchemaExistence(t, s, mkCPU)

	test.AssertOptionalArguments(t, cpuSchema, []string{
		mkCPUArchitecture,
		mkCPUCores,
		mkCPUFlags,
		mkCPUHotplugged,
		mkCPUNUMA,
		mkCPUSockets,
		mkCPUType,
		mkCPUUnits,
	})

	test.AssertValueTypes(t, cpuSchema, map[string]schema.ValueType{
		mkCPUArchitecture: schema.TypeString,
		mkCPUCores:        schema.TypeInt,
		mkCPUFlags:        schema.TypeList,
		mkCPUHotplugged:   schema.TypeInt,
		mkCPUNUMA:         schema.TypeBool,
		mkCPUSockets:      schema.TypeInt,
		mkCPUType:         schema.TypeString,
		mkCPUUnits:        schema.TypeInt,
	})

	efiDiskSchema := test.AssertNestedSchemaExistence(t, s, mkEFIDisk)

	test.AssertOptionalArguments(t, efiDiskSchema, []string{
		mkEFIDiskDatastoreID,
		mkEFIDiskFileFormat,
		mkEFIDiskType,
	})

	test.AssertValueTypes(t, efiDiskSchema, map[string]schema.ValueType{
		mkEFIDiskDatastoreID: schema.TypeString,
		mkEFIDiskFileFormat:  schema.TypeString,
		mkEFIDiskType:        schema.TypeString,
	})

	initializationSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		mkInitialization,
	)

	test.AssertOptionalArguments(t, initializationSchema, []string{
		mkInitializationDatastoreID,
		mkInitializationInterface,
		mkInitializationDNS,
		mkInitializationIPConfig,
		mkInitializationUserAccount,
	})

	test.AssertValueTypes(t, initializationSchema, map[string]schema.ValueType{
		mkInitializationDatastoreID: schema.TypeString,
		mkInitializationInterface:   schema.TypeString,
		mkInitializationDNS:         schema.TypeList,
		mkInitializationIPConfig:    schema.TypeList,
		mkInitializationUserAccount: schema.TypeList,
	})

	hostPCISchema := test.AssertNestedSchemaExistence(t, s, mkHostPCI)

	test.AssertOptionalArguments(t, hostPCISchema, []string{
		mkHostPCIDeviceMDev,
		mkHostPCIDevicePCIE,
		mkHostPCIDeviceROMBAR,
		mkHostPCIDeviceROMFile,
		mkHostPCIDeviceXVGA,
	})

	test.AssertValueTypes(t, hostPCISchema, map[string]schema.ValueType{
		mkHostPCIDevice:        schema.TypeString,
		mkHostPCIDeviceMDev:    schema.TypeString,
		mkHostPCIDevicePCIE:    schema.TypeBool,
		mkHostPCIDeviceROMBAR:  schema.TypeBool,
		mkHostPCIDeviceROMFile: schema.TypeString,
		mkHostPCIDeviceXVGA:    schema.TypeBool,
	})

	hostUSBSchema := test.AssertNestedSchemaExistence(t, s, mkHostUSB)

	test.AssertOptionalArguments(t, hostUSBSchema, []string{
		mkHostUSBDeviceMapping,
	})

	test.AssertValueTypes(t, hostUSBSchema, map[string]schema.ValueType{
		mkHostUSBDevice:     schema.TypeString,
		mkHostUSBDeviceUSB3: schema.TypeBool,
	})

	initializationDNSSchema := test.AssertNestedSchemaExistence(
		t,
		initializationSchema,
		mkInitializationDNS,
	)

	test.AssertOptionalArguments(t, initializationDNSSchema, []string{
		mkInitializationDNSDomain,
		mkInitializationDNSServers,
	})

	test.AssertValueTypes(t, initializationDNSSchema, map[string]schema.ValueType{
		mkInitializationDNSDomain:  schema.TypeString,
		mkInitializationDNSServers: schema.TypeList,
	})

	initializationIPConfigSchema := test.AssertNestedSchemaExistence(
		t,
		initializationSchema,
		mkInitializationIPConfig,
	)

	test.AssertOptionalArguments(t, initializationIPConfigSchema, []string{
		mkInitializationIPConfigIPv4,
		mkInitializationIPConfigIPv6,
	})

	test.AssertValueTypes(t, initializationIPConfigSchema, map[string]schema.ValueType{
		mkInitializationIPConfigIPv4: schema.TypeList,
		mkInitializationIPConfigIPv6: schema.TypeList,
	})

	initializationIPConfigIPv4Schema := test.AssertNestedSchemaExistence(
		t,
		initializationIPConfigSchema,
		mkInitializationIPConfigIPv4,
	)

	test.AssertOptionalArguments(t, initializationIPConfigIPv4Schema, []string{
		mkInitializationIPConfigIPv4Address,
		mkInitializationIPConfigIPv4Gateway,
	})

	test.AssertValueTypes(t, initializationIPConfigIPv4Schema, map[string]schema.ValueType{
		mkInitializationIPConfigIPv4Address: schema.TypeString,
		mkInitializationIPConfigIPv4Gateway: schema.TypeString,
	})

	initializationIPConfigIPv6Schema := test.AssertNestedSchemaExistence(
		t,
		initializationIPConfigSchema,
		mkInitializationIPConfigIPv6,
	)

	test.AssertOptionalArguments(t, initializationIPConfigIPv6Schema, []string{
		mkInitializationIPConfigIPv6Address,
		mkInitializationIPConfigIPv6Gateway,
	})

	test.AssertValueTypes(t, initializationIPConfigIPv6Schema, map[string]schema.ValueType{
		mkInitializationIPConfigIPv6Address: schema.TypeString,
		mkInitializationIPConfigIPv6Gateway: schema.TypeString,
	})

	initializationUserAccountSchema := test.AssertNestedSchemaExistence(
		t,
		initializationSchema,
		mkInitializationUserAccount,
	)

	test.AssertOptionalArguments(t, initializationUserAccountSchema, []string{
		mkInitializationUserAccountKeys,
		mkInitializationUserAccountPassword,
		mkInitializationUserAccountUsername,
	})

	test.AssertValueTypes(t, initializationUserAccountSchema, map[string]schema.ValueType{
		mkInitializationUserAccountKeys:     schema.TypeList,
		mkInitializationUserAccountPassword: schema.TypeString,
		mkInitializationUserAccountUsername: schema.TypeString,
	})

	memorySchema := test.AssertNestedSchemaExistence(t, s, mkMemory)

	test.AssertOptionalArguments(t, memorySchema, []string{
		mkMemoryDedicated,
		mkMemoryFloating,
		mkMemoryShared,
	})

	test.AssertValueTypes(t, memorySchema, map[string]schema.ValueType{
		mkMemoryDedicated: schema.TypeInt,
		mkMemoryFloating:  schema.TypeInt,
		mkMemoryShared:    schema.TypeInt,
	})

	numaSchema := test.AssertNestedSchemaExistence(t, s, mkNUMA)

	test.AssertOptionalArguments(t, numaSchema, []string{
		mkNUMAHostNodeNames,
		mkNUMAPolicy,
	})

	test.AssertValueTypes(t, numaSchema, map[string]schema.ValueType{
		mkNUMADevice:        schema.TypeString,
		mkNUMACPUIDs:        schema.TypeString,
		mkNUMAMemory:        schema.TypeInt,
		mkNUMAHostNodeNames: schema.TypeString,
		mkNUMAPolicy:        schema.TypeString,
	})

	operatingSystemSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		mkOperatingSystem,
	)

	test.AssertOptionalArguments(t, operatingSystemSchema, []string{
		mkOperatingSystemType,
	})

	test.AssertValueTypes(t, operatingSystemSchema, map[string]schema.ValueType{
		mkOperatingSystemType: schema.TypeString,
	})

	serialDeviceSchema := test.AssertNestedSchemaExistence(
		t,
		s,
		mkSerialDevice,
	)

	test.AssertOptionalArguments(t, serialDeviceSchema, []string{
		mkSerialDeviceDevice,
	})

	test.AssertValueTypes(t, serialDeviceSchema, map[string]schema.ValueType{
		mkSerialDeviceDevice: schema.TypeString,
	})

	virtiofsSchema := test.AssertNestedSchemaExistence(t, s, mkVirtiofs)

	test.AssertOptionalArguments(t, virtiofsSchema, []string{
		mkVirtiofsCache,
		mkVirtiofsDirectIO,
		mkVirtiofsExposeACL,
		mkVirtiofsExposeXAttr,
	})

	test.AssertValueTypes(t, virtiofsSchema, map[string]schema.ValueType{
		mkVirtiofsMapping:     schema.TypeString,
		mkVirtiofsCache:       schema.TypeString,
		mkVirtiofsDirectIO:    schema.TypeBool,
		mkVirtiofsExposeACL:   schema.TypeBool,
		mkVirtiofsExposeXAttr: schema.TypeBool,
	})

	vgaSchema := test.AssertNestedSchemaExistence(t, s, mkVGA)

	test.AssertOptionalArguments(t, vgaSchema, []string{
		mkVGAMemory,
		mkVGAType,
	})

	test.AssertValueTypes(t, vgaSchema, map[string]schema.ValueType{
		mkVGAMemory: schema.TypeInt,
		mkVGAType:   schema.TypeString,
	})
}

func Test_parseImportIDWIthNodeName(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name             string
		value            string
		valid            bool
		expectedNodeName string
		expectedID       string
	}{
		{"empty", "", false, "", ""},
		{"missing slash", "invalid", false, "", ""},
		{"valid", "host/id", true, "host", "id"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			nodeName, id, err := parseImportIDWithNodeName(tt.value)

			if !tt.valid {
				require.Error(t, err)
				return
			}

			require.NoError(t, err)
			require.Equal(t, tt.expectedNodeName, nodeName)
			require.Equal(t, tt.expectedID, id)
		})
	}
}
`````

## File: proxmoxtf/resource/vm/vm.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/helpers/ptr"
	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes/vms"
	"github.com/bpg/terraform-provider-proxmox/proxmox/pools"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm/disk"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/vm/network"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/structure"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

const (
	dvRebootAfterCreation = false
	dvRebootAfterUpdate   = true
	dvOnBoot              = true
	dvACPI                = true
	dvAgentEnabled        = false
	dvAgentTimeout        = "15m"
	dvAgentTrim           = false
	dvAgentType           = "virtio"
	dvAMDSEVType          = "std"
	dvAMDSEVAllowSMT      = true
	dvAMDSEVKernelHashes  = false
	dvAMDSEVNoDebug       = false
	dvAMDSEVNoKeySharing  = false
	dvAudioDeviceDevice   = "intel-hda"
	dvAudioDeviceDriver   = "spice"
	dvAudioDeviceEnabled  = true
	dvBIOS                = "seabios"
	dvCDROMEnabled        = false
	dvCDROMFileID         = ""
	dvCDROMInterface      = "ide3"
	dvCloneDatastoreID    = ""
	dvCloneNodeName       = ""
	dvCloneFull           = true
	dvCloneRetries        = 1
	dvCPUArchitecture     = ""
	dvCPUCores            = 1
	dvCPUHotplugged       = 0
	dvCPULimit            = 0
	dvCPUNUMA             = false
	dvCPUSockets          = 1
	dvCPUType             = "qemu64"
	dvCPUUnits            = 1024
	dvCPUAffinity         = ""
	dvDescription         = ""

	dvEFIDiskDatastoreID                = "local-lvm"
	dvEFIDiskFileFormat                 = "raw"
	dvEFIDiskType                       = "2m"
	dvEFIDiskPreEnrolledKeys            = false
	dvTPMStateDatastoreID               = "local-lvm"
	dvTPMStateVersion                   = "v2.0"
	dvInitializationDatastoreID         = "local-lvm"
	dvInitializationInterface           = ""
	dvInitializationDNSDomain           = ""
	dvInitializationIPConfigIPv4Address = ""
	dvInitializationIPConfigIPv4Gateway = ""
	dvInitializationIPConfigIPv6Address = ""
	dvInitializationIPConfigIPv6Gateway = ""
	dvInitializationUserAccountPassword = ""
	dvKeyboardLayout                    = "en-us"
	dvKVMArguments                      = ""
	dvMachineType                       = ""
	dvMemoryDedicated                   = 512
	dvMemoryFloating                    = 0
	dvMemoryShared                      = 0
	dvMemoryHugepages                   = ""
	dvMemoryKeepHugepages               = false
	dvMigrate                           = false
	dvName                              = ""

	dvOperatingSystemType = "other"
	dvPoolID              = ""
	dvProtection          = false
	dvRNGMaxBytes         = 1024
	dvRNGPeriod           = 1000
	dvSerialDeviceDevice  = "socket"
	dvSMBIOSFamily        = ""
	dvSMBIOSManufacturer  = ""
	dvSMBIOSProduct       = ""
	dvSMBIOSSKU           = ""
	dvSMBIOSSerial        = ""
	dvSMBIOSVersion       = ""
	dvStarted             = true
	dvStartupOrder        = -1
	dvStartupUpDelay      = -1
	dvStartupDownDelay    = -1
	dvTabletDevice        = true
	dvTemplate            = false
	dvTimeoutClone        = 1800
	dvTimeoutCreate       = 1800
	dvTimeoutMigrate      = 1800
	dvTimeoutReboot       = 1800
	dvTimeoutShutdownVM   = 1800
	dvTimeoutStartVM      = 1800
	dvTimeoutStopVM       = 300
	dvVGAClipboard        = ""
	dvVGAMemory           = 16
	dvVGAType             = "std"
	dvVirtiofsCache       = "auto"
	dvVirtiofsDirectIo    = false
	dvVirtiofsExposeAcl   = false
	dvVirtiofsExposeXattr = false
	dvSCSIHardware        = "virtio-scsi-pci"
	dvStopOnDestroy       = false
	dvHookScript          = ""
	dvWatchdogModel       = "i6300esb"
	dvWatchdogAction      = "none"

	maxResourceVirtualEnvironmentVMAudioDevices  = 1
	maxResourceVirtualEnvironmentVMSerialDevices = 4
	// see /usr/share/perl5/PVE/QemuServer/PCI.pm.
	maxResourceVirtualEnvironmentVMHostPCIDevices = 16
	maxResourceVirtualEnvironmentVMHostUSBDevices = 4
	// hardcoded /usr/share/perl5/PVE/QemuServer/Memory.pm: "our $MAX_NUMA = 8".
	maxResourceVirtualEnvironmentVMNUMADevices  = 8
	maxResourceVirtualEnvironmentVirtiofsShares = 8

	mkRebootAfterCreation = "reboot"
	mkRebootAfterUpdate   = "reboot_after_update"
	mkOnBoot              = "on_boot"
	mkBootOrder           = "boot_order"
	mkACPI                = "acpi"
	mkAgent               = "agent"
	mkAgentEnabled        = "enabled"
	mkAgentTimeout        = "timeout"
	mkAgentTrim           = "trim"
	mkAgentType           = "type"
	mkAMDSEV              = "amd_sev"
	mkAMDSEVType          = "type"
	mkAMDSEVAllowSMT      = "allow_smt"
	mkAMDSEVKernelHashes  = "kernel_hashes"
	mkAMDSEVNoDebug       = "no_debug"
	mkAMDSEVNoKeySharing  = "no_key_sharing"
	mkAudioDevice         = "audio_device"
	mkAudioDeviceDevice   = "device"
	mkAudioDeviceDriver   = "driver"
	mkAudioDeviceEnabled  = "enabled"
	mkBIOS                = "bios"
	mkCDROM               = "cdrom"
	mkCDROMEnabled        = "enabled"
	mkCDROMFileID         = "file_id"
	mkCDROMInterface      = "interface"
	mkClone               = "clone"
	mkCloneRetries        = "retries"
	mkCloneDatastoreID    = "datastore_id"
	mkCloneNodeName       = "node_name"
	mkCloneVMID           = "vm_id"
	mkCloneFull           = "full"
	mkCPU                 = "cpu"
	mkCPUArchitecture     = "architecture"
	mkCPUCores            = "cores"
	mkCPUFlags            = "flags"
	mkCPUHotplugged       = "hotplugged"
	mkCPULimit            = "limit"
	mkCPUNUMA             = "numa"
	mkCPUSockets          = "sockets"
	mkCPUType             = "type"
	mkCPUUnits            = "units"
	mkCPUAffinity         = "affinity"
	mkDescription         = "description"

	mkNUMA              = "numa"
	mkNUMADevice        = "device"
	mkNUMACPUIDs        = "cpus"
	mkNUMAHostNodeNames = "hostnodes"
	mkNUMAMemory        = "memory"
	mkNUMAPolicy        = "policy"

	mkEFIDisk                           = "efi_disk"
	mkEFIDiskDatastoreID                = "datastore_id"
	mkEFIDiskFileFormat                 = "file_format"
	mkEFIDiskType                       = "type"
	mkEFIDiskPreEnrolledKeys            = "pre_enrolled_keys"
	mkTPMState                          = "tpm_state"
	mkTPMStateDatastoreID               = "datastore_id"
	mkTPMStateVersion                   = "version"
	mkHostPCI                           = "hostpci"
	mkHostPCIDevice                     = "device"
	mkHostPCIDeviceID                   = "id"
	mkHostPCIDeviceMapping              = "mapping"
	mkHostPCIDeviceMDev                 = "mdev"
	mkHostPCIDevicePCIE                 = "pcie"
	mkHostPCIDeviceROMBAR               = "rombar"
	mkHostPCIDeviceROMFile              = "rom_file"
	mkHostPCIDeviceXVGA                 = "xvga"
	mkInitialization                    = "initialization"
	mkInitializationDatastoreID         = "datastore_id"
	mkInitializationInterface           = "interface"
	mkInitializationDNS                 = "dns"
	mkInitializationDNSDomain           = "domain"
	mkInitializationDNSServers          = "servers"
	mkInitializationIPConfig            = "ip_config"
	mkInitializationIPConfigIPv4        = "ipv4"
	mkInitializationIPConfigIPv4Address = "address"
	mkInitializationIPConfigIPv4Gateway = "gateway"
	mkInitializationIPConfigIPv6        = "ipv6"
	mkInitializationIPConfigIPv6Address = "address"
	mkInitializationIPConfigIPv6Gateway = "gateway"
	mkInitializationType                = "type"
	mkInitializationUserAccount         = "user_account"
	mkInitializationUserAccountKeys     = "keys"
	mkInitializationUserAccountPassword = "password"
	mkInitializationUserAccountUsername = "username"
	mkInitializationUserDataFileID      = "user_data_file_id"
	mkInitializationVendorDataFileID    = "vendor_data_file_id"
	mkInitializationNetworkDataFileID   = "network_data_file_id"
	mkInitializationMetaDataFileID      = "meta_data_file_id"

	mkKeyboardLayout      = "keyboard_layout"
	mkKVMArguments        = "kvm_arguments"
	mkMachine             = "machine"
	mkMemory              = "memory"
	mkMemoryDedicated     = "dedicated"
	mkMemoryFloating      = "floating"
	mkMemoryShared        = "shared"
	mkMemoryHugepages     = "hugepages"
	mkMemoryKeepHugepages = "keep_hugepages"
	mkMigrate             = "migrate"
	mkName                = "name"

	mkNodeName             = "node_name"
	mkOperatingSystem      = "operating_system"
	mkOperatingSystemType  = "type"
	mkPoolID               = "pool_id"
	mkProtection           = "protection"
	mkRNG                  = "rng"
	mkRNGSource            = "source"
	mkRNGMaxBytes          = "max_bytes"
	mkRNGPeriod            = "period"
	mkSerialDevice         = "serial_device"
	mkSerialDeviceDevice   = "device"
	mkSMBIOS               = "smbios"
	mkSMBIOSFamily         = "family"
	mkSMBIOSManufacturer   = "manufacturer"
	mkSMBIOSProduct        = "product"
	mkSMBIOSSKU            = "sku"
	mkSMBIOSSerial         = "serial"
	mkSMBIOSUUID           = "uuid"
	mkSMBIOSVersion        = "version"
	mkStarted              = "started"
	mkStartup              = "startup"
	mkStartupOrder         = "order"
	mkStartupUpDelay       = "up_delay"
	mkStartupDownDelay     = "down_delay"
	mkTabletDevice         = "tablet_device"
	mkTags                 = "tags"
	mkTemplate             = "template"
	mkTimeoutClone         = "timeout_clone"
	mkTimeoutCreate        = "timeout_create"
	mkTimeoutMigrate       = "timeout_migrate" // this is essentially a "timeout_update", needs to be refactored
	mkTimeoutReboot        = "timeout_reboot"
	mkTimeoutShutdownVM    = "timeout_shutdown_vm"
	mkTimeoutStartVM       = "timeout_start_vm"
	mkTimeoutStopVM        = "timeout_stop_vm"
	mkHostUSB              = "usb"
	mkHostUSBDevice        = "host"
	mkHostUSBDeviceMapping = "mapping"
	mkHostUSBDeviceUSB3    = "usb3"
	mkVGA                  = "vga"
	mkVGAClipboard         = "clipboard"
	mkVGAMemory            = "memory"
	mkVGAType              = "type"
	mkVMID                 = "vm_id"
	mkSCSIHardware         = "scsi_hardware"
	mkHookScriptFileID     = "hook_script_file_id"
	mkStopOnDestroy        = "stop_on_destroy"
	mkVirtiofs             = "virtiofs"
	mkVirtiofsMapping      = "mapping"
	mkVirtiofsCache        = "cache"
	mkVirtiofsDirectIO     = "direct_io"
	mkVirtiofsExposeACL    = "expose_acl"
	mkVirtiofsExposeXAttr  = "expose_xattr"
	mkWatchdog             = "watchdog"
	// a workaround for the lack of proper support of default and undefined values in SDK.
	mkWatchdogEnabled = "enabled"
	mkWatchdogModel   = "model"
	mkWatchdogAction  = "action"
)

// MaskedPassword represents a value that PVE returns instead of the configured ciuser password when we read the
// VM config back, and we store this value in the state.
// I don't want to change this "security feature" at the moment to avoid breaking change, but
// the provider should avoid overriding config / state in general. Instead, the state encryption feature should
// be used for data protection.
const MaskedPassword = "**********"

// VM returns a resource that manages VMs.
func VM() *schema.Resource {
	s := map[string]*schema.Schema{
		mkRebootAfterCreation: {
			Type:        schema.TypeBool,
			Description: "Whether to reboot VM after creation",
			Optional:    true,
			Default:     dvRebootAfterCreation,
		},
		mkRebootAfterUpdate: {
			Type:        schema.TypeBool,
			Description: "Whether to reboot VM after update if needed",
			Optional:    true,
			Default:     dvRebootAfterUpdate,
		},
		mkOnBoot: {
			Type:        schema.TypeBool,
			Description: "Start VM on Node boot",
			Optional:    true,
			Default:     dvOnBoot,
		},
		mkBootOrder: {
			Type:        schema.TypeList,
			Description: "The guest will attempt to boot from devices in the order they appear here",
			Optional:    true,
			Elem:        &schema.Schema{Type: schema.TypeString},
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
		},
		mkACPI: {
			Type:        schema.TypeBool,
			Description: "Whether to enable ACPI",
			Optional:    true,
			Default:     dvACPI,
		},
		mkAgent: {
			Type:        schema.TypeList,
			Description: "The QEMU agent configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkAgentEnabled: dvAgentEnabled,
						mkAgentTimeout: dvAgentTimeout,
						mkAgentTrim:    dvAgentTrim,
						mkAgentType:    dvAgentType,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkAgentEnabled: {
						Type:        schema.TypeBool,
						Description: "Whether to enable the QEMU agent",
						Optional:    true,
						Default:     dvAgentEnabled,
					},
					mkAgentTimeout: {
						Type:             schema.TypeString,
						Description:      "The maximum amount of time to wait for data from the QEMU agent to become available",
						Optional:         true,
						Default:          dvAgentTimeout,
						ValidateDiagFunc: TimeoutValidator(),
					},
					mkAgentTrim: {
						Type:        schema.TypeBool,
						Description: "Whether to enable the FSTRIM feature in the QEMU agent",
						Optional:    true,
						Default:     dvAgentTrim,
					},
					mkAgentType: {
						Type:             schema.TypeString,
						Description:      "The QEMU agent interface type",
						Optional:         true,
						Default:          dvAgentType,
						ValidateDiagFunc: QEMUAgentTypeValidator(),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkAMDSEV: {
			Type:        schema.TypeList,
			Description: "Secure Encrypted Virtualization (SEV) features by AMD CPUs",
			Optional:    true,
			ForceNew:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkAMDSEVType: {
						Type: schema.TypeString,
						Description: "Enable standard SEV with type=std or enable experimental SEV-ES with the es option" +
							"or enable experimental SEV-SNP with the snp option.",
						Optional:         true,
						Default:          dvAMDSEVType,
						ValidateDiagFunc: AMDSEVTypeValidator(),
					},
					mkAMDSEVAllowSMT: {
						Type:        schema.TypeBool,
						Description: "Sets policy bit to allow Simultaneous Multi Threading (SMT) (Ignored unless for SEV-SNP)",
						Optional:    true,
						Default:     dvAMDSEVAllowSMT,
					},
					mkAMDSEVKernelHashes: {
						Type:        schema.TypeBool,
						Description: "Add kernel hashes to guest firmware for measured linux kernel launch",
						Optional:    true,
						Default:     dvAMDSEVKernelHashes,
					},
					mkAMDSEVNoDebug: {
						Type:        schema.TypeBool,
						Description: "Sets policy bit to disallow debugging of guest",
						Optional:    true,
						Default:     dvAMDSEVNoDebug,
					},
					mkAMDSEVNoKeySharing: {
						Type:        schema.TypeBool,
						Description: "Sets policy bit to disallow key sharing with other guests (Ignored for SEV-SNP)",
						Optional:    true,
						Default:     dvAMDSEVNoKeySharing,
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkKVMArguments: {
			Type:        schema.TypeString,
			Description: "The args implementation",
			Optional:    true,
			Default:     dvKVMArguments,
		},
		mkAudioDevice: {
			Type:        schema.TypeList,
			Description: "The audio devices",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkAudioDeviceDevice: {
						Type:             schema.TypeString,
						Description:      "The device",
						Optional:         true,
						Default:          dvAudioDeviceDevice,
						ValidateDiagFunc: AudioDeviceValidator(),
					},
					mkAudioDeviceDriver: {
						Type:             schema.TypeString,
						Description:      "The driver",
						Optional:         true,
						Default:          dvAudioDeviceDriver,
						ValidateDiagFunc: AudioDriverValidator(),
					},
					mkAudioDeviceEnabled: {
						Type:        schema.TypeBool,
						Description: "Whether to enable the audio device",
						Optional:    true,
						Default:     dvAudioDeviceEnabled,
					},
				},
			},
			MaxItems: maxResourceVirtualEnvironmentVMAudioDevices,
			MinItems: 0,
		},
		mkBIOS: {
			Type:             schema.TypeString,
			Description:      "The BIOS implementation",
			Optional:         true,
			Default:          dvBIOS,
			ValidateDiagFunc: BIOSValidator(),
		},
		mkCDROM: {
			Type:        schema.TypeList,
			Description: "The CDROM drive",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkCDROMFileID:    dvCDROMFileID,
						mkCDROMInterface: dvCDROMInterface,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkCDROMEnabled: {
						Type:        schema.TypeBool,
						Description: "Whether to enable the CDROM drive",
						Optional:    true,
						Default:     dvCDROMEnabled,
						Deprecated: "Remove this attribute's configuration as it is no longer used and the attribute will " +
							"be removed in the next version of the provider. Set `file_id` to `none` to leave the CDROM drive empty.",
					},
					mkCDROMFileID: {
						Type:        schema.TypeString,
						Description: "The file id",
						Optional:    true,
						Default:     dvCDROMFileID,
						ValidateDiagFunc: validation.AnyDiag(
							validation.ToDiagFunc(validation.StringInSlice([]string{"none", "cdrom"}, false)),
							validators.FileID(),
						),
					},
					mkCDROMInterface: {
						Type:             schema.TypeString,
						Description:      "The CDROM interface",
						Optional:         true,
						Default:          dvCDROMInterface,
						ValidateDiagFunc: CDROMInterfaceValidator(),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkClone: {
			Type:        schema.TypeList,
			Description: "The cloning configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkCloneRetries: {
						Type:        schema.TypeInt,
						Description: "The number of Retries to create a clone",
						Optional:    true,
						ForceNew:    true,
						Default:     dvCloneRetries,
					},
					mkCloneDatastoreID: {
						Type:        schema.TypeString,
						Description: "The ID of the target datastore",
						Optional:    true,
						ForceNew:    true,
						Default:     dvCloneDatastoreID,
					},
					mkCloneNodeName: {
						Type:        schema.TypeString,
						Description: "The name of the source node",
						Optional:    true,
						ForceNew:    true,
						Default:     dvCloneNodeName,
					},
					mkCloneVMID: {
						Type:             schema.TypeInt,
						Description:      "The ID of the source VM",
						Required:         true,
						ForceNew:         true,
						ValidateDiagFunc: VMIDValidator(),
					},
					mkCloneFull: {
						Type:        schema.TypeBool,
						Description: "The Clone Type, create a Full Clone (true) or a linked Clone (false)",
						Optional:    true,
						ForceNew:    true,
						Default:     dvCloneFull,
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkCPU: {
			Type:        schema.TypeList,
			Description: "The CPU allocation",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkCPUArchitecture: dvCPUArchitecture,
						mkCPUCores:        dvCPUCores,
						mkCPUFlags:        []interface{}{},
						mkCPUHotplugged:   dvCPUHotplugged,
						mkCPULimit:        dvCPULimit,
						mkCPUNUMA:         dvCPUNUMA,
						mkCPUSockets:      dvCPUSockets,
						mkCPUType:         dvCPUType,
						mkCPUUnits:        dvCPUUnits,
						mkCPUAffinity:     dvCPUAffinity,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkCPUArchitecture: {
						Type:             schema.TypeString,
						Description:      "The CPU architecture",
						Optional:         true,
						Default:          dvCPUArchitecture,
						ValidateDiagFunc: CPUArchitectureValidator(),
					},
					mkCPUCores: {
						Type:             schema.TypeInt,
						Description:      "The number of CPU cores",
						Optional:         true,
						Default:          dvCPUCores,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntBetween(1, 2304)),
					},
					mkCPUFlags: {
						Type:        schema.TypeList,
						Description: "The CPU flags",
						Optional:    true,
						DefaultFunc: func() (interface{}, error) {
							return []interface{}{}, nil
						},
						Elem: &schema.Schema{Type: schema.TypeString},
					},
					mkCPUHotplugged: {
						Type:             schema.TypeInt,
						Description:      "The number of hotplugged vCPUs",
						Optional:         true,
						Default:          dvCPUHotplugged,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntBetween(0, 2304)),
					},
					mkCPULimit: {
						Type:        schema.TypeInt,
						Description: "Limit of CPU usage",
						Optional:    true,
						Default:     dvCPULimit,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.IntBetween(0, 128),
						),
					},
					mkCPUNUMA: {
						Type:        schema.TypeBool,
						Description: "Enable/disable NUMA.",
						Optional:    true,
						Default:     dvCPUNUMA,
					},
					mkCPUSockets: {
						Type:             schema.TypeInt,
						Description:      "The number of CPU sockets",
						Optional:         true,
						Default:          dvCPUSockets,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntBetween(1, 16)),
					},
					mkCPUType: {
						Type:             schema.TypeString,
						Description:      "The emulated CPU type",
						Optional:         true,
						Default:          dvCPUType,
						ValidateDiagFunc: CPUTypeValidator(),
					},
					mkCPUUnits: {
						Type:        schema.TypeInt,
						Description: "The CPU units",
						Optional:    true,
						Default:     dvCPUUnits,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.IntBetween(2, 262144),
						),
					},
					mkCPUAffinity: {
						Type:             schema.TypeString,
						Description:      "The CPU affinity",
						Optional:         true,
						Default:          dvCPUAffinity,
						ValidateDiagFunc: CPUAffinityValidator(),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkDescription: {
			Type:        schema.TypeString,
			Description: "The description",
			Optional:    true,
			Default:     dvDescription,
			StateFunc: func(i interface{}) string {
				// PVE always adds a newline to the description, so we have to do the same,
				// also taking in account the CLRF case (Windows)
				// Unlike container, VM description does not have trailing "\n"
				if i.(string) != "" {
					return strings.ReplaceAll(strings.TrimSpace(i.(string)), "\r\n", "\n")
				}

				return ""
			},
		},
		mkEFIDisk: {
			Type:        schema.TypeList,
			Description: "The efidisk device",
			Optional:    true,
			ForceNew:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkEFIDiskDatastoreID: {
						Type:        schema.TypeString,
						Description: "The datastore id",
						Optional:    true,
						Default:     dvEFIDiskDatastoreID,
					},
					mkEFIDiskFileFormat: {
						Type:             schema.TypeString,
						Description:      "The file format",
						Optional:         true,
						ForceNew:         true,
						Computed:         true,
						ValidateDiagFunc: validators.FileFormat(),
					},
					mkEFIDiskType: {
						Type:        schema.TypeString,
						Description: "Size and type of the OVMF EFI disk",
						Optional:    true,
						ForceNew:    true,
						Default:     dvEFIDiskType,
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"2m",
							"4m",
						}, true)),
					},
					mkEFIDiskPreEnrolledKeys: {
						Type: schema.TypeBool,
						Description: "Use an EFI vars template with distribution-specific and Microsoft Standard " +
							"keys enrolled, if used with efi type=`4m`.",
						Optional: true,
						ForceNew: true,
						Default:  dvEFIDiskPreEnrolledKeys,
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkTPMState: {
			Type:        schema.TypeList,
			Description: "The tpmstate device",
			Optional:    true,
			ForceNew:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkTPMStateDatastoreID: {
						Type:        schema.TypeString,
						Description: "Datastore ID",
						Optional:    true,
						Default:     dvTPMStateDatastoreID,
					},
					mkTPMStateVersion: {
						Type:        schema.TypeString,
						Description: "TPM version",
						Optional:    true,
						ForceNew:    true,
						Default:     dvTPMStateVersion,
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"v1.2",
							"v2.0",
						}, true)),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkInitialization: {
			Type:        schema.TypeList,
			Description: "The cloud-init configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkInitializationDatastoreID: {
						Type:        schema.TypeString,
						Description: "The datastore id",
						Optional:    true,
						Default:     dvInitializationDatastoreID,
					},
					mkInitializationInterface: {
						Type:             schema.TypeString,
						Description:      "The IDE interface on which the CloudInit drive will be added",
						Optional:         true,
						Default:          dvInitializationInterface,
						ValidateDiagFunc: CloudInitInterfaceValidator(),
						DiffSuppressFunc: func(_, _, newValue string, _ *schema.ResourceData) bool {
							return newValue == ""
						},
					},
					mkInitializationDNS: {
						Type:        schema.TypeList,
						Description: "The DNS configuration",
						Optional:    true,
						DefaultFunc: func() (interface{}, error) {
							return []interface{}{}, nil
						},
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								mkInitializationDNSDomain: {
									Type:        schema.TypeString,
									Description: "The DNS search domain",
									Optional:    true,
									Default:     dvInitializationDNSDomain,
								},
								mkInitializationDNSServers: {
									Type:        schema.TypeList,
									Description: "The list of DNS servers",
									Optional:    true,
									Elem:        &schema.Schema{Type: schema.TypeString, ValidateFunc: validation.IsIPAddress},
									MinItems:    0,
								},
							},
						},
						MaxItems: 1,
						MinItems: 0,
					},
					mkInitializationIPConfig: {
						Type:        schema.TypeList,
						Description: "The IP configuration",
						Optional:    true,
						DefaultFunc: func() (interface{}, error) {
							return []interface{}{}, nil
						},
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								mkInitializationIPConfigIPv4: {
									Type:        schema.TypeList,
									Description: "The IPv4 configuration",
									Optional:    true,
									DefaultFunc: func() (interface{}, error) {
										return []interface{}{}, nil
									},
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											mkInitializationIPConfigIPv4Address: {
												Type:        schema.TypeString,
												Description: "The IPv4 address",
												Optional:    true,
												Default:     dvInitializationIPConfigIPv4Address,
											},
											mkInitializationIPConfigIPv4Gateway: {
												Type:        schema.TypeString,
												Description: "The IPv4 gateway",
												Optional:    true,
												Default:     dvInitializationIPConfigIPv4Gateway,
											},
										},
									},
									MaxItems: 1,
									MinItems: 0,
								},
								mkInitializationIPConfigIPv6: {
									Type:        schema.TypeList,
									Description: "The IPv6 configuration",
									Optional:    true,
									DefaultFunc: func() (interface{}, error) {
										return []interface{}{}, nil
									},
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											mkInitializationIPConfigIPv6Address: {
												Type:        schema.TypeString,
												Description: "The IPv6 address",
												Optional:    true,
												Default:     dvInitializationIPConfigIPv6Address,
											},
											mkInitializationIPConfigIPv6Gateway: {
												Type:        schema.TypeString,
												Description: "The IPv6 gateway",
												Optional:    true,
												Default:     dvInitializationIPConfigIPv6Gateway,
											},
										},
									},
									MaxItems: 1,
									MinItems: 0,
								},
							},
						},
						MaxItems: 8,
						MinItems: 0,
					},
					mkInitializationUserAccount: {
						Type:        schema.TypeList,
						Description: "The user account configuration",
						Optional:    true,
						DefaultFunc: func() (interface{}, error) {
							return []interface{}{}, nil
						},
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								mkInitializationUserAccountKeys: {
									Type:        schema.TypeList,
									Description: "The SSH keys",
									Optional:    true,
									Elem:        &schema.Schema{Type: schema.TypeString},
								},
								mkInitializationUserAccountPassword: {
									Type:        schema.TypeString,
									Description: "The SSH password",
									Optional:    true,
									Sensitive:   true,
									Default:     dvInitializationUserAccountPassword,
									DiffSuppressFunc: func(_, oldVal, _ string, _ *schema.ResourceData) bool {
										return len(oldVal) > 0 &&
											strings.ReplaceAll(oldVal, "*", "") == ""
									},
								},
								mkInitializationUserAccountUsername: {
									Type:        schema.TypeString,
									Description: "The SSH username",
									Optional:    true,
								},
							},
						},
						MaxItems: 1,
						MinItems: 0,
					},
					mkInitializationUserDataFileID: {
						Type:             schema.TypeString,
						Description:      "The ID of a file containing custom user data",
						Optional:         true,
						Computed:         true,
						ForceNew:         true,
						ValidateDiagFunc: validators.FileID(),
					},
					mkInitializationVendorDataFileID: {
						Type:             schema.TypeString,
						Description:      "The ID of a file containing vendor data",
						Optional:         true,
						Computed:         true,
						ForceNew:         true,
						ValidateDiagFunc: validators.FileID(),
					},
					mkInitializationNetworkDataFileID: {
						Type:             schema.TypeString,
						Description:      "The ID of a file containing network config",
						Optional:         true,
						Computed:         true,
						ForceNew:         true,
						ValidateDiagFunc: validators.FileID(),
					},
					mkInitializationMetaDataFileID: {
						Type:             schema.TypeString,
						Description:      "The ID of a file containing meta data config",
						Optional:         true,
						Computed:         true,
						ForceNew:         true,
						ValidateDiagFunc: validators.FileID(),
					},
					mkInitializationType: {
						Type:             schema.TypeString,
						Description:      "The cloud-init configuration format",
						Optional:         true,
						Computed:         true,
						ForceNew:         true,
						ValidateDiagFunc: CloudInitTypeValidator(),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkHostPCI: {
			Type:        schema.TypeList,
			Description: "The Host PCI devices mapped to the VM",
			Optional:    true,
			ForceNew:    false,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkHostPCIDevice: {
						Type:        schema.TypeString,
						Description: "The PCI device name for Proxmox, in form of 'hostpciX' where X is a sequential number from 0 to 3",
						Required:    true,
					},
					mkHostPCIDeviceID: {
						Type: schema.TypeString,
						Description: "The PCI ID of the device, for example 0000:00:1f.0 (or 0000:00:1f.0;0000:00:1f.1 for multiple " +
							"device functions, or 0000:00:1f for all functions). Use either this or mapping.",
						Optional: true,
					},
					mkHostPCIDeviceMapping: {
						Type:        schema.TypeString,
						Description: "The resource mapping name of the device, for example gpu. Use either this or id.",
						Optional:    true,
					},
					mkHostPCIDeviceMDev: {
						Type:        schema.TypeString,
						Description: "The the mediated device to use",
						Optional:    true,
					},
					mkHostPCIDevicePCIE: {
						Type: schema.TypeBool,
						Description: "Tells Proxmox VE to use a PCIe or PCI port. Some guests/device combination require PCIe rather " +
							"than PCI. PCIe is only available for q35 machine types.",
						Optional: true,
					},
					mkHostPCIDeviceROMBAR: {
						Type:        schema.TypeBool,
						Description: "Makes the firmware ROM visible for the guest. Default is true",
						Optional:    true,
					},
					mkHostPCIDeviceROMFile: {
						Type:        schema.TypeString,
						Description: "A path to a ROM file for the device to use. This is a relative path under /usr/share/kvm/",
						Optional:    true,
					},
					mkHostPCIDeviceXVGA: {
						Type: schema.TypeBool,
						Description: "Marks the PCI(e) device as the primary GPU of the VM. With this enabled, " +
							"the vga configuration argument will be ignored.",
						Optional: true,
					},
				},
			},
			MaxItems: maxResourceVirtualEnvironmentVMHostPCIDevices,
		},
		mkHostUSB: {
			Type:        schema.TypeList,
			Description: "The Host USB devices mapped to the VM",
			Optional:    true,
			ForceNew:    false,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkHostUSBDevice: {
						Type:        schema.TypeString,
						Description: "The USB device ID for Proxmox, in form of '<MANUFACTURER>:<ID>'",
						Optional:    true,
					},
					mkHostUSBDeviceMapping: {
						Type:        schema.TypeString,
						Description: "The resource mapping name of the device, for example usbdisk. Use either this or id.",
						Optional:    true,
					},
					mkHostUSBDeviceUSB3: {
						Type:        schema.TypeBool,
						Description: "Makes the USB device a USB3 device for the machine. Default is false",
						Optional:    true,
					},
				},
			},
		},
		mkKeyboardLayout: {
			Type:             schema.TypeString,
			Description:      "The keyboard layout",
			Optional:         true,
			Default:          dvKeyboardLayout,
			ValidateDiagFunc: KeyboardLayoutValidator(),
		},
		mkMachine: {
			Type:             schema.TypeString,
			Description:      "The VM machine type, either default `pc` or `q35`",
			Optional:         true,
			Default:          dvMachineType,
			ValidateDiagFunc: MachineTypeValidator(),
		},
		mkMemory: {
			Type:        schema.TypeList,
			Description: "The memory allocation",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkMemoryDedicated:     dvMemoryDedicated,
						mkMemoryFloating:      dvMemoryFloating,
						mkMemoryShared:        dvMemoryShared,
						mkMemoryHugepages:     dvMemoryHugepages,
						mkMemoryKeepHugepages: dvMemoryKeepHugepages,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkMemoryDedicated: {
						Type:        schema.TypeInt,
						Description: "The dedicated memory in megabytes",
						Optional:    true,
						Default:     dvMemoryDedicated,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.IntBetween(64, 268435456),
						),
					},
					mkMemoryFloating: {
						Type:        schema.TypeInt,
						Description: "The floating memory in megabytes (balloon)",
						Optional:    true,
						Default:     dvMemoryFloating,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.IntBetween(0, 268435456),
						),
					},
					mkMemoryShared: {
						Type:        schema.TypeInt,
						Description: "The shared memory in megabytes",
						Optional:    true,
						Default:     dvMemoryShared,
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.IntBetween(0, 268435456),
						),
					},
					mkMemoryHugepages: {
						Type:         schema.TypeString,
						Description:  "Enable/disable hugepages memory",
						Optional:     true,
						Default:      dvMemoryHugepages,
						RequiredWith: []string{"cpu.0.numa"},
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"1024",
							"2",
							"any",
						}, true)),
					},
					mkMemoryKeepHugepages: {
						Type:         schema.TypeBool,
						Description:  "Hugepages will not be deleted after VM shutdown and can be used for subsequent starts",
						Optional:     true,
						Default:      dvMemoryKeepHugepages,
						RequiredWith: []string{"cpu.0.numa"},
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkName: {
			Type:        schema.TypeString,
			Description: "The name",
			Optional:    true,
			Default:     dvName,
		},
		mkNodeName: {
			Type:         schema.TypeString,
			Description:  "The node name",
			Required:     true,
			ValidateFunc: validation.StringIsNotEmpty,
		},
		mkNUMA: {
			Type:        schema.TypeList,
			Description: "The NUMA topology",
			Optional:    true,
			ForceNew:    false,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			DiffSuppressFunc:      structure.SuppressIfListsOfMapsAreEqualIgnoringOrderByKey(mkNUMADevice),
			DiffSuppressOnRefresh: true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkNUMADevice: {
						Type:         schema.TypeString,
						Description:  "Numa node device ID",
						Optional:     false,
						Required:     true,
						RequiredWith: []string{"cpu.0.numa"},
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringMatch(
							regexp.MustCompile(`^numa\d+$`),
							"numa node device ID must be in the format 'numaX' where X is a number",
						)),
					},
					mkNUMACPUIDs: {
						Type:             schema.TypeString,
						Description:      "CPUs accessing this NUMA node",
						Optional:         false,
						Required:         true,
						RequiredWith:     []string{"cpu.0.numa"},
						ValidateDiagFunc: RangeSemicolonValidator(),
					},
					mkNUMAMemory: {
						Type:         schema.TypeInt,
						Description:  "Amount of memory this NUMA node provides",
						Optional:     false,
						Required:     true,
						RequiredWith: []string{"cpu.0.numa"},
						ValidateDiagFunc: validation.ToDiagFunc(
							validation.IntBetween(64, 268435456),
						),
					},
					mkNUMAHostNodeNames: {
						Type:             schema.TypeString,
						Description:      "Host NUMA nodes to use",
						Optional:         true,
						RequiredWith:     []string{"cpu.0.numa"},
						ValidateDiagFunc: RangeSemicolonValidator(),
					},
					mkNUMAPolicy: {
						Type:        schema.TypeString,
						Description: "NUMA policy",
						Optional:    true,
						Default:     "preferred",
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"bind",
							"interleave",
							"preferred",
						}, true)),
					},
				},
			},
		},
		mkMigrate: {
			Type:        schema.TypeBool,
			Description: "Whether to migrate the VM on node change instead of re-creating it",
			Optional:    true,
			Default:     dvMigrate,
		},
		mkOperatingSystem: {
			Type:        schema.TypeList,
			Description: "The operating system configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkOperatingSystemType: dvOperatingSystemType,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkOperatingSystemType: {
						Type:             schema.TypeString,
						Description:      "The type",
						Optional:         true,
						Default:          dvOperatingSystemType,
						ValidateDiagFunc: OperatingSystemTypeValidator(),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkPoolID: {
			Type:        schema.TypeString,
			Description: "The ID of the pool to assign the virtual machine to",
			Optional:    true,
			Default:     dvPoolID,
		},
		mkProtection: {
			Type:        schema.TypeBool,
			Description: "Sets the protection flag of the VM. This will disable the remove VM and remove disk operations",
			Optional:    true,
			Default:     dvProtection,
		},
		mkRNG: {
			Type:        schema.TypeList,
			Description: "The RNG configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkRNGSource: {
						Type: schema.TypeString,
						Description: "The file on the host to gather entropy from. " +
							"In most cases, `/dev/urandom` should be preferred over `/dev/random` " +
							"to avoid entropy-starvation issues on the host.",
						ValidateFunc: validation.StringIsNotEmpty,
						Required:     true,
					},
					mkRNGMaxBytes: {
						Type: schema.TypeInt,
						Description: "Maximum bytes of entropy allowed to get injected into the guest every `period` " +
							"milliseconds. Prefer a lower value when using `/dev/random` as source.",
						Optional:         true,
						Computed:         true,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(1)),
					},
					mkRNGPeriod: {
						Type: schema.TypeInt,
						Description: "Every `period` milliseconds the entropy-injection quota is reset, " +
							"allowing the guest to retrieve another `max_bytes` of entropy.",
						Optional:         true,
						Computed:         true,
						ValidateDiagFunc: validation.ToDiagFunc(validation.IntAtLeast(1)),
					},
				},
			},
		},
		mkSerialDevice: {
			Type:        schema.TypeList,
			Description: "The serial devices",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkSerialDeviceDevice: dvSerialDeviceDevice,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkSerialDeviceDevice: {
						Type:             schema.TypeString,
						Description:      "The device",
						Optional:         true,
						Default:          dvSerialDeviceDevice,
						ValidateDiagFunc: SerialDeviceValidator(),
					},
				},
			},
			MaxItems: maxResourceVirtualEnvironmentVMSerialDevices,
			MinItems: 0,
		},
		mkSMBIOS: {
			Type:        schema.TypeList,
			Description: "Specifies SMBIOS (type1) settings for the VM",
			Optional:    true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkSMBIOSFamily: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS family string",
						Optional:    true,
						Default:     dvSMBIOSFamily,
					},
					mkSMBIOSManufacturer: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS manufacturer",
						Optional:    true,
						Default:     dvSMBIOSManufacturer,
					},
					mkSMBIOSProduct: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS product ID",
						Optional:    true,
						Default:     dvSMBIOSProduct,
					},
					mkSMBIOSSerial: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS serial number",
						Optional:    true,
						Default:     dvSMBIOSSerial,
					},
					mkSMBIOSSKU: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS SKU",
						Optional:    true,
						Default:     dvSMBIOSSKU,
					},
					mkSMBIOSUUID: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS UUID",
						Optional:    true,
						Computed:    true,
					},
					mkSMBIOSVersion: {
						Type:        schema.TypeString,
						Description: "Sets SMBIOS version",
						Optional:    true,
						Default:     dvSMBIOSVersion,
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkStarted: {
			Type:        schema.TypeBool,
			Description: "Whether to start the virtual machine",
			Optional:    true,
			Default:     dvStarted,
			DiffSuppressFunc: func(_, _, _ string, d *schema.ResourceData) bool {
				return d.Get(mkTemplate).(bool)
			},
		},
		mkStartup: {
			Type:        schema.TypeList,
			Description: "Defines startup and shutdown behavior of the VM",
			Optional:    true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkStartupOrder: {
						Type:        schema.TypeInt,
						Description: "A non-negative number defining the general startup order",
						Optional:    true,
						Default:     dvStartupOrder,
					},
					mkStartupUpDelay: {
						Type:        schema.TypeInt,
						Description: "A non-negative number defining the delay in seconds before the next VM is started",
						Optional:    true,
						Default:     dvStartupUpDelay,
					},
					mkStartupDownDelay: {
						Type:        schema.TypeInt,
						Description: "A non-negative number defining the delay in seconds before the next VM is shut down",
						Optional:    true,
						Default:     dvStartupDownDelay,
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkTabletDevice: {
			Type:        schema.TypeBool,
			Description: "Whether to enable the USB tablet device",
			Optional:    true,
			Default:     dvTabletDevice,
		},
		mkTags: {
			Type:        schema.TypeList,
			Description: "Tags of the virtual machine. This is only meta information.",
			Optional:    true,
			Elem: &schema.Schema{
				Type:         schema.TypeString,
				ValidateFunc: validation.StringIsNotEmpty,
			},
			DiffSuppressFunc:      structure.SuppressIfListsAreEqualIgnoringOrder,
			DiffSuppressOnRefresh: true,
		},
		mkTemplate: {
			Type:        schema.TypeBool,
			Description: "Whether to create a template",
			Optional:    true,
			ForceNew:    true,
			Default:     dvTemplate,
		},
		mkTimeoutClone: {
			Type:        schema.TypeInt,
			Description: "Clone VM timeout",
			Optional:    true,
			Default:     dvTimeoutClone,
		},
		mkTimeoutCreate: {
			Type:        schema.TypeInt,
			Description: "Create VM timeout",
			Optional:    true,
			Default:     dvTimeoutCreate,
		},
		"timeout_move_disk": {
			Type:        schema.TypeInt,
			Description: "MoveDisk timeout",
			Optional:    true,
			Default:     1800,
			Deprecated: "This field is deprecated and will be removed in a future release. " +
				"An overall operation timeout (timeout_create / timeout_clone / timeout_migrate) is used instead.",
		},
		mkTimeoutMigrate: {
			Type:        schema.TypeInt,
			Description: "Migrate VM timeout",
			Optional:    true,
			Default:     dvTimeoutMigrate,
		},
		mkTimeoutReboot: {
			Type:        schema.TypeInt,
			Description: "Reboot timeout",
			Optional:    true,
			Default:     dvTimeoutReboot,
		},
		mkTimeoutShutdownVM: {
			Type:        schema.TypeInt,
			Description: "Shutdown timeout",
			Optional:    true,
			Default:     dvTimeoutShutdownVM,
		},
		mkTimeoutStartVM: {
			Type:        schema.TypeInt,
			Description: "Start VM timeout",
			Optional:    true,
			Default:     dvTimeoutStartVM,
		},
		mkTimeoutStopVM: {
			Type:        schema.TypeInt,
			Description: "Stop VM timeout",
			Optional:    true,
			Default:     dvTimeoutStopVM,
		},
		mkVGA: {
			Type:        schema.TypeList,
			Description: "The VGA configuration",
			Optional:    true,
			Computed:    true,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkVGAClipboard: {
						Type:        schema.TypeString,
						Description: "Enable clipboard support. Set to `vnc` to enable clipboard support for VNC.",
						Optional:    true,
						Default:     dvVGAClipboard,
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"",
							"vnc",
						}, true)),
					},
					mkVGAMemory: {
						Type:             schema.TypeInt,
						Description:      "The VGA memory in megabytes (4-512 MB)",
						Optional:         true,
						Default:          dvVGAMemory,
						ValidateDiagFunc: VGAMemoryValidator(),
					},
					mkVGAType: {
						Type:             schema.TypeString,
						Description:      "The VGA type",
						Optional:         true,
						Default:          dvVGAType,
						ValidateDiagFunc: VGATypeValidator(),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
		mkVirtiofs: {
			Type:        schema.TypeList,
			Description: "Virtiofs share configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkVirtiofsMapping: {
						Type:         schema.TypeString,
						Description:  "Directory mapping identifier",
						Required:     true,
						ValidateFunc: validation.StringIsNotEmpty,
					},
					mkVirtiofsCache: {
						Type:             schema.TypeString,
						Description:      "The caching mode",
						Optional:         true,
						Default:          dvVirtiofsCache,
						ValidateDiagFunc: VirtiofsCacheValidator(),
					},
					mkVirtiofsDirectIO: {
						Type:        schema.TypeBool,
						Description: "Whether to allow direct io",
						Optional:    true,
						Default:     dvVirtiofsDirectIo,
					},
					mkVirtiofsExposeACL: {
						Type:        schema.TypeBool,
						Description: "Enable POSIX ACLs, implies xattr support",
						Optional:    true,
						Default:     dvVirtiofsExposeAcl,
					},
					mkVirtiofsExposeXAttr: {
						Type:        schema.TypeBool,
						Description: "Enable support for extended attributes",
						Optional:    true,
						Default:     dvVirtiofsExposeXattr,
					},
				},
			},
			MaxItems: maxResourceVirtualEnvironmentVirtiofsShares,
			MinItems: 0,
		},
		mkVMID: {
			Type:        schema.TypeInt,
			Description: "The VM identifier",
			Optional:    true,
			Computed:    true,
			// "ForceNew: true" handled in CustomizeDiff, making sure VMs with legacy configs with vm_id = -1
			// do not require re-creation.
			ValidateDiagFunc: VMIDValidator(),
		},
		mkSCSIHardware: {
			Type:             schema.TypeString,
			Description:      "The SCSI hardware type",
			Optional:         true,
			Default:          dvSCSIHardware,
			ValidateDiagFunc: SCSIHardwareValidator(),
		},
		mkHookScriptFileID: {
			Type:        schema.TypeString,
			Description: "A hook script",
			Optional:    true,
			Default:     dvHookScript,
		},
		mkStopOnDestroy: {
			Type:        schema.TypeBool,
			Description: "Whether to stop rather than shutdown on VM destroy",
			Optional:    true,
			Default:     dvStopOnDestroy,
		},
		mkWatchdog: {
			Type:        schema.TypeList,
			Description: "The watchdog configuration",
			Optional:    true,
			DefaultFunc: func() (interface{}, error) {
				return []interface{}{
					map[string]interface{}{
						mkWatchdogAction:  dvWatchdogAction,
						mkWatchdogEnabled: false,
						mkWatchdogModel:   dvWatchdogModel,
					},
				}, nil
			},
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					mkWatchdogAction: {
						Type:        schema.TypeString,
						Description: "The watchdog action",
						Optional:    true,
						Default:     dvWatchdogAction,
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"debug",
							"none",
							"pause",
							"poweroff",
							"reset",
							"shutdown",
						}, true)),
					},
					mkWatchdogEnabled: {
						Type:        schema.TypeBool,
						Description: "Whether the watchdog is enabled",
						Optional:    true,
						Default:     false,
					},
					mkWatchdogModel: {
						Type:        schema.TypeString,
						Description: "The watchdog model",
						Optional:    true,
						Default:     dvWatchdogModel,
						ValidateDiagFunc: validation.ToDiagFunc(validation.StringInSlice([]string{
							"i6300esb",
							"ib700",
						}, true)),
					},
				},
			},
			MaxItems: 1,
			MinItems: 0,
		},
	}

	structure.MergeSchema(s, disk.Schema())
	structure.MergeSchema(s, network.Schema())

	return &schema.Resource{
		Schema:        s,
		CreateContext: vmCreate,
		ReadContext:   vmRead,
		UpdateContext: vmUpdate,
		DeleteContext: vmDelete,
		CustomizeDiff: customdiff.All(
			customdiff.All(network.CustomizeDiff()...),
			customdiff.ForceNewIf(
				mkVMID,
				func(_ context.Context, d *schema.ResourceDiff, _ interface{}) bool {
					if !d.HasChange(mkVMID) {
						return false
					}

					newValue := d.Get(mkVMID)

					// 'vm_id' is ForceNew, except when changing 'vm_id' to existing correct id
					// (automatic fix from -1 to actual vm_id must not re-create VM)
					return strconv.Itoa(newValue.(int)) != d.Id()
				},
			),
			customdiff.ForceNewIf(
				mkNodeName,
				func(_ context.Context, d *schema.ResourceDiff, _ interface{}) bool {
					if !d.HasChange(mkNodeName) {
						return false
					}

					return !d.Get(mkMigrate).(bool)
				},
			),
		),
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				node, id, err := parseImportIDWithNodeName(d.Id())
				if err != nil {
					return nil, err
				}

				d.SetId(id)
				err = d.Set(mkNodeName, node)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func vmCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	clone := d.Get(mkClone).([]interface{})

	// reset the default timeout for the create operation
	ctx = context.WithoutCancel(ctx)

	if len(clone) > 0 {
		return vmCreateClone(ctx, d, m)
	}

	return vmCreateCustom(ctx, d, m)
}

// Check for an existing CloudInit IDE drive. If no such drive is found, return the specified `defaultValue`.
func findExistingCloudInitDrive(vmConfig *vms.GetResponseData, vmID int, defaultValue string) string {
	devs := vmConfig.StorageDevices.Filter(func(device *vms.CustomStorageDevice) bool {
		return device.IsCloudInitDrive(vmID)
	})

	for iface := range devs {
		return iface
	}

	return defaultValue
}

// Return a pointer to the storage device configuration based on a name. The device name is assumed to be a
// valid ide, sata, or scsi interface name.
func getStorageDevice(vmConfig *vms.GetResponseData, deviceName string) *vms.CustomStorageDevice {
	if dev, ok := vmConfig.StorageDevices[deviceName]; ok {
		return dev
	}

	return nil
}

// Delete IDE interfaces that can then be used for CloudInit. The first interface will always
// be deleted. The second will be deleted only if it isn't empty and isn't the same as the
// first.
func deleteIdeDrives(ctx context.Context, vmAPI *vms.Client, itf1 string, itf2 string) diag.Diagnostics {
	ddUpdateBody := &vms.UpdateRequestBody{}
	ddUpdateBody.Delete = append(ddUpdateBody.Delete, itf1)
	tflog.Debug(ctx, fmt.Sprintf("Deleting IDE interface '%s'", itf1))

	if itf2 != "" && itf2 != itf1 {
		ddUpdateBody.Delete = append(ddUpdateBody.Delete, itf2)
		tflog.Debug(ctx, fmt.Sprintf("Deleting IDE interface '%s'", itf2))
	}

	e := vmAPI.UpdateVM(ctx, ddUpdateBody)
	if e != nil {
		return diag.FromErr(e)
	}

	return nil
}

// Start the VM, then wait for it to actually start; it may not be started immediately if running in HA mode.
func vmStart(ctx context.Context, vmAPI *vms.Client, d *schema.ResourceData) diag.Diagnostics {
	tflog.Debug(ctx, "Starting VM")

	startTimeoutSec := d.Get(mkTimeoutStartVM).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(startTimeoutSec)*time.Second)
	defer cancel()

	var diags diag.Diagnostics

	log, e := vmAPI.StartVM(ctx, startTimeoutSec)
	if e != nil {
		return diag.FromErr(e)
	}

	if len(log) > 0 {
		lines := "\n\t| " + strings.Join(log, "\n\t| ")
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Warning,
			Summary:  fmt.Sprintf("the VM startup task finished with a warning, task log:\n%s", lines),
		})
	}

	return append(diags, diag.FromErr(vmAPI.WaitForVMStatus(ctx, "running"))...)
}

// Shutdown the VM, then wait for it to actually shut down (it may not be shut down immediately if
// running in HA mode).
func vmShutdown(ctx context.Context, vmAPI *vms.Client, d *schema.ResourceData) diag.Diagnostics {
	tflog.Debug(ctx, "Shutting down VM")

	forceStop := types.CustomBool(true)
	shutdownTimeoutSec := d.Get(mkTimeoutShutdownVM).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(shutdownTimeoutSec)*time.Second)
	defer cancel()

	e := vmAPI.ShutdownVM(ctx, &vms.ShutdownRequestBody{
		ForceStop: &forceStop,
		Timeout:   &shutdownTimeoutSec,
	})
	if e != nil {
		return diag.FromErr(e)
	}

	return diag.FromErr(vmAPI.WaitForVMStatus(ctx, "stopped"))
}

// Forcefully stop the VM, then wait for it to actually stop.
func vmStop(ctx context.Context, vmAPI *vms.Client, d *schema.ResourceData) diag.Diagnostics {
	tflog.Debug(ctx, "Stopping VM")

	stopTimeout := d.Get(mkTimeoutStopVM).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(stopTimeout)*time.Second)
	defer cancel()

	e := vmAPI.StopVM(ctx)
	if e != nil {
		return diag.FromErr(e)
	}

	return diag.FromErr(vmAPI.WaitForVMStatus(ctx, "stopped"))
}

func vmCreateClone(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	cloneTimeoutSec := d.Get(mkTimeoutClone).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(cloneTimeoutSec)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, e := config.GetClient()
	if e != nil {
		return diag.FromErr(e)
	}

	clone := d.Get(mkClone).([]interface{})
	cloneBlock := clone[0].(map[string]interface{})
	cloneRetries := cloneBlock[mkCloneRetries].(int)
	cloneDatastoreID := cloneBlock[mkCloneDatastoreID].(string)
	cloneNodeName := cloneBlock[mkCloneNodeName].(string)
	cloneVMID := cloneBlock[mkCloneVMID].(int)
	cloneFull := cloneBlock[mkCloneFull].(bool)

	description := d.Get(mkDescription).(string)
	name := d.Get(mkName).(string)
	tags := d.Get(mkTags).([]interface{})
	nodeName := d.Get(mkNodeName).(string)
	poolID := d.Get(mkPoolID).(string)
	vmIDUntyped, hasVMID := d.GetOk(mkVMID)
	vmID := vmIDUntyped.(int)

	if !hasVMID {
		vmIDNew, err := config.GetIDGenerator().NextID(ctx)
		if err != nil {
			return diag.FromErr(err)
		}

		vmID = vmIDNew

		err = d.Set(mkVMID, vmID)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	fullCopy := types.CustomBool(cloneFull)

	cloneBody := &vms.CloneRequestBody{
		FullCopy: &fullCopy,
		VMIDNew:  vmID,
	}

	if cloneDatastoreID != "" {
		cloneBody.TargetStorage = &cloneDatastoreID
	}

	if description != "" {
		cloneBody.Description = &description
	}

	if name != "" {
		cloneBody.Name = &name
	}

	if poolID != "" {
		cloneBody.PoolID = &poolID
	}

	if cloneNodeName != "" && cloneNodeName != nodeName {
		// Check if any used datastores of the source VM are not shared
		vmConfig, err := client.Node(cloneNodeName).VM(cloneVMID).GetVM(ctx)
		if err != nil {
			return diag.FromErr(err)
		}

		datastores := getDiskDatastores(vmConfig, d)

		onlySharedDatastores := true

		for _, datastore := range datastores {
			datastoreStatus, err2 := client.Node(cloneNodeName).Storage(datastore).GetDatastoreStatus(ctx)
			if err2 != nil {
				return diag.FromErr(err2)
			}

			if datastoreStatus.Shared != nil && !*datastoreStatus.Shared {
				onlySharedDatastores = false
				break
			}
		}

		if onlySharedDatastores {
			// If the source and the target node are not the same, only clone directly to the target node if
			//  all used datastores in the source VM are shared. Directly cloning to non-shared storage
			//  on a different node is currently not supported by proxmox.
			cloneBody.TargetNodeName = &nodeName

			err = client.Node(cloneNodeName).VM(cloneVMID).CloneVM(ctx, cloneRetries, cloneBody)
			if err != nil {
				return diag.FromErr(err)
			}
		} else { //nolint:wsl
			// If the source and the target node are not the same and any used datastore in the source VM is
			//  not shared, clone to the source node and then migrate to the target node. This is a workaround
			//  for missing functionality in the proxmox api as recommended per
			//  https://forum.proxmox.com/threads/500-cant-clone-to-non-shared-storage-local.49078/#post-229727

			// Temporarily clone to local node
			err = client.Node(cloneNodeName).VM(cloneVMID).CloneVM(ctx, cloneRetries, cloneBody)
			if err != nil {
				return diag.FromErr(err)
			}

			// Wait for the virtual machine to be created and its configuration lock to be released before migrating.

			err = client.Node(cloneNodeName).VM(vmID).WaitForVMConfigUnlock(ctx, true)
			if err != nil {
				return diag.FromErr(err)
			}

			// Migrate to target node
			withLocalDisks := types.CustomBool(true)
			migrateBody := &vms.MigrateRequestBody{
				TargetNode:     nodeName,
				WithLocalDisks: &withLocalDisks,
			}

			if cloneDatastoreID != "" {
				migrateBody.TargetStorage = &cloneDatastoreID
			}

			err = client.Node(cloneNodeName).VM(vmID).MigrateVM(ctx, migrateBody)
			if err != nil {
				return diag.FromErr(err)
			}
		}
	} else {
		e = client.Node(nodeName).VM(cloneVMID).CloneVM(ctx, cloneRetries, cloneBody)
	}

	if e != nil {
		return diag.FromErr(e)
	}

	d.SetId(strconv.Itoa(vmID))

	vmAPI := client.Node(nodeName).VM(vmID)

	// Wait for the virtual machine to be created and its configuration lock to be released.
	e = vmAPI.WaitForVMConfigUnlock(ctx, true)
	if e != nil {
		return diag.FromErr(e)
	}

	// Now that the virtual machine has been cloned, we need to perform some modifications.
	audioDevices := vmGetAudioDeviceList(d)

	acpi := types.CustomBool(d.Get(mkACPI).(bool))
	agent := d.Get(mkAgent).([]interface{})
	amdsev := d.Get(mkAMDSEV).([]interface{})
	bios := d.Get(mkBIOS).(string)
	cdrom := d.Get(mkCDROM).([]interface{})
	cpu := d.Get(mkCPU).([]interface{})
	hostPCI := d.Get(mkHostPCI).([]interface{})
	hostUSB := d.Get(mkHostUSB).([]interface{})
	initialization := d.Get(mkInitialization).([]interface{})
	keyboardLayout := d.Get(mkKeyboardLayout).(string)
	kvmArguments := d.Get(mkKVMArguments).(string)
	machine := d.Get(mkMachine).(string)
	memory := d.Get(mkMemory).([]interface{})
	numa := d.Get(mkNUMA).([]interface{})
	onBoot := types.CustomBool(d.Get(mkOnBoot).(bool))
	operatingSystem := d.Get(mkOperatingSystem).([]interface{})
	protection := types.CustomBool(d.Get(mkProtection).(bool))
	scsiHardware := d.Get(mkSCSIHardware).(string)
	serialDevice := d.Get(mkSerialDevice).([]interface{})
	tabletDevice := types.CustomBool(d.Get(mkTabletDevice).(bool))
	template := types.CustomBool(d.Get(mkTemplate).(bool))
	vga := d.Get(mkVGA).([]interface{})
	virtiofs := d.Get(mkVirtiofs).([]interface{})
	watchdog := d.Get(mkWatchdog).([]interface{})

	updateBody := &vms.UpdateRequestBody{
		AudioDevices: audioDevices,
	}

	ideDevices := vms.CustomStorageDevices{}

	var del []string

	if !acpi {
		updateBody.ACPI = &acpi
	}

	if len(agent) > 0 && agent[0] != nil {
		agentBlock := agent[0].(map[string]interface{})

		agentEnabled := types.CustomBool(
			agentBlock[mkAgentEnabled].(bool),
		)
		agentTrim := types.CustomBool(agentBlock[mkAgentTrim].(bool))
		agentType := agentBlock[mkAgentType].(string)

		updateBody.Agent = &vms.CustomAgent{
			Enabled:         &agentEnabled,
			TrimClonedDisks: &agentTrim,
			Type:            &agentType,
		}
	}

	if len(amdsev) > 0 && amdsev[0] != nil {
		amdsevBlock := amdsev[0].(map[string]interface{})

		amdsevType := amdsevBlock[mkAMDSEVType].(string)
		amdsevAllowSMT := types.CustomBool(
			amdsevBlock[mkAMDSEVAllowSMT].(bool),
		)
		amdsevKernelHashes := types.CustomBool(
			amdsevBlock[mkAMDSEVKernelHashes].(bool),
		)
		amdsevNoDebug := types.CustomBool(
			amdsevBlock[mkAMDSEVNoDebug].(bool),
		)
		amdsevNoKeySharing := types.CustomBool(
			amdsevBlock[mkAMDSEVNoKeySharing].(bool),
		)

		updateBody.AMDSEV = &vms.CustomAMDSEV{
			Type:         amdsevType,
			AllowSMT:     &amdsevAllowSMT,
			KernelHashes: &amdsevKernelHashes,
			NoDebug:      &amdsevNoDebug,
			NoKeySharing: &amdsevNoKeySharing,
		}
	}

	if kvmArguments != dvKVMArguments {
		updateBody.KVMArguments = &kvmArguments
	}

	if bios != dvBIOS {
		updateBody.BIOS = &bios
	}

	if machine != dvMachineType {
		updateBody.Machine = &machine
	}

	if scsiHardware != dvSCSIHardware {
		updateBody.SCSIHardware = &scsiHardware
	}

	if len(cdrom) > 0 && cdrom[0] != nil {
		cdromBlock := cdrom[0].(map[string]interface{})

		cdromFileID := cdromBlock[mkCDROMFileID].(string)
		cdromInterface := cdromBlock[mkCDROMInterface].(string)

		if cdromFileID == "" {
			cdromFileID = "cdrom"
		}

		cdromMedia := "cdrom"

		ideDevices[cdromInterface] = &vms.CustomStorageDevice{
			FileVolume: cdromFileID,
			Media:      &cdromMedia,
		}
	}

	if len(cpu) > 0 && cpu[0] != nil {
		cpuBlock := cpu[0].(map[string]interface{})

		cpuArchitecture := cpuBlock[mkCPUArchitecture].(string)
		cpuCores := cpuBlock[mkCPUCores].(int)
		cpuFlags := cpuBlock[mkCPUFlags].([]interface{})
		cpuHotplugged := cpuBlock[mkCPUHotplugged].(int)
		cpuLimit := cpuBlock[mkCPULimit].(int)
		cpuNUMA := types.CustomBool(cpuBlock[mkCPUNUMA].(bool))
		cpuSockets := cpuBlock[mkCPUSockets].(int)
		cpuType := cpuBlock[mkCPUType].(string)
		cpuUnits := cpuBlock[mkCPUUnits].(int)
		cpuAffinity := cpuBlock[mkCPUAffinity].(string)

		cpuFlagsConverted := make([]string, len(cpuFlags))

		for fi, flag := range cpuFlags {
			cpuFlagsConverted[fi] = flag.(string)
		}

		if err := setCPUArchitecture(ctx, cpuArchitecture, client, updateBody); err != nil {
			return diag.FromErr(err)
		}

		updateBody.CPUCores = ptr.Ptr(int64(cpuCores))
		updateBody.CPUEmulation = &vms.CustomCPUEmulation{
			Flags: &cpuFlagsConverted,
			Type:  cpuType,
		}
		updateBody.NUMAEnabled = &cpuNUMA
		updateBody.CPUSockets = ptr.Ptr(int64(cpuSockets))
		updateBody.CPUUnits = ptr.Ptr(int64(cpuUnits))

		if cpuAffinity != "" {
			updateBody.CPUAffinity = &cpuAffinity
		}

		if cpuHotplugged > 0 {
			updateBody.VirtualCPUCount = ptr.Ptr(int64(cpuHotplugged))
		}

		if cpuLimit > 0 {
			updateBody.CPULimit = ptr.Ptr(int64(cpuLimit))
		}
	}

	vmConfig, err := vmAPI.GetVM(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if len(initialization) > 0 && initialization[0] != nil {
		tflog.Trace(ctx, "Preparing the CloudInit configuration")

		initializationBlock := initialization[0].(map[string]interface{})
		initializationDatastoreID := initializationBlock[mkInitializationDatastoreID].(string)
		initializationInterface := initializationBlock[mkInitializationInterface].(string)

		existingInterface := findExistingCloudInitDrive(vmConfig, vmID, "ide2")
		if initializationInterface == "" {
			initializationInterface = existingInterface
		}

		tflog.Trace(ctx, fmt.Sprintf("CloudInit IDE interface is '%s'", initializationInterface))

		cdromCloudInitFileID := fmt.Sprintf("%s:cloudinit", initializationDatastoreID)
		cdromCloudInitMedia := "cdrom"
		ideDevices[initializationInterface] = &vms.CustomStorageDevice{
			FileVolume: cdromCloudInitFileID,
			Media:      &cdromCloudInitMedia,
		}

		if err := deleteIdeDrives(ctx, vmAPI, initializationInterface, existingInterface); err != nil {
			return err
		}

		updateBody.CloudInitConfig = vmGetCloudInitConfig(d)
	}

	if len(hostPCI) > 0 {
		updateBody.PCIDevices = vmGetHostPCIDeviceObjects(d)
	}

	if len(numa) > 0 {
		updateBody.NUMADevices = vmGetNumaDeviceObjects(d)
	}

	if len(hostUSB) > 0 {
		updateBody.USBDevices = vmGetHostUSBDeviceObjects(d)
	}

	if len(cdrom) > 0 || len(initialization) > 0 {
		for iface, dev := range ideDevices {
			updateBody.AddCustomStorageDevice(iface, *dev)
		}
	}

	if keyboardLayout != dvKeyboardLayout {
		updateBody.KeyboardLayout = &keyboardLayout
	}

	if len(memory) > 0 && memory[0] != nil {
		memoryBlock := memory[0].(map[string]interface{})

		memoryDedicated := memoryBlock[mkMemoryDedicated].(int)
		memoryFloating := memoryBlock[mkMemoryFloating].(int)
		memoryShared := memoryBlock[mkMemoryShared].(int)
		hugepages := memoryBlock[mkMemoryHugepages].(string)
		keepHugepages := types.CustomBool(memoryBlock[mkMemoryKeepHugepages].(bool))

		updateBody.DedicatedMemory = &memoryDedicated
		updateBody.FloatingMemory = &memoryFloating

		if memoryShared > 0 {
			memorySharedName := fmt.Sprintf("vm-%d-ivshmem", vmID)

			updateBody.SharedMemory = &vms.CustomSharedMemory{
				Name: &memorySharedName,
				Size: memoryShared,
			}
		}

		if hugepages != "" {
			updateBody.Hugepages = &hugepages
		}

		if keepHugepages {
			updateBody.KeepHugepages = &keepHugepages
		}
	}

	networkDevice := d.Get(network.MkNetworkDevice).([]interface{})
	if len(networkDevice) > 0 {
		updateBody.NetworkDevices, err = network.GetNetworkDeviceObjects(d)
		if err != nil {
			return diag.FromErr(err)
		}

		for i, ni := range updateBody.NetworkDevices {
			if !ni.Enabled {
				del = append(del, fmt.Sprintf("net%d", i))
			}
		}

		for i := len(updateBody.NetworkDevices); i < network.MaxNetworkDevices; i++ {
			del = append(del, fmt.Sprintf("net%d", i))
		}
	}

	if len(operatingSystem) > 0 && operatingSystem[0] != nil {
		operatingSystemBlock := operatingSystem[0].(map[string]interface{})
		operatingSystemType := operatingSystemBlock[mkOperatingSystemType].(string)

		updateBody.OSType = &operatingSystemType
	}

	if len(serialDevice) > 0 {
		updateBody.SerialDevices = vmGetSerialDeviceList(d)

		for i := len(updateBody.SerialDevices); i < maxResourceVirtualEnvironmentVMSerialDevices; i++ {
			del = append(del, fmt.Sprintf("serial%d", i))
		}
	}

	updateBody.StartOnBoot = &onBoot

	updateBody.SMBIOS = vmGetSMBIOS(d)

	updateBody.StartupOrder = vmGetStartupOrder(d)

	if !tabletDevice {
		updateBody.TabletDeviceEnabled = &tabletDevice
	}

	if protection {
		updateBody.DeletionProtection = &protection
	}

	if len(tags) > 0 {
		tagString := vmGetTagsString(d)
		updateBody.Tags = &tagString
	}

	if template {
		updateBody.Template = &template
	}

	if len(vga) > 0 {
		vgaDevice := vmGetVGADeviceObject(d)
		updateBody.VGADevice = vgaDevice
	}

	if len(virtiofs) > 0 {
		virtiofsShares := vmGetVirtiofsShares(d)
		updateBody.VirtiofsShares = virtiofsShares
	}

	hookScript := d.Get(mkHookScriptFileID).(string)
	currentHookScript := vmConfig.HookScript

	if len(hookScript) > 0 {
		updateBody.HookScript = &hookScript
	} else if currentHookScript != nil {
		del = append(del, "hookscript")
	}

	if len(watchdog) > 0 && watchdog[0] != nil {
		watchdogBlock := watchdog[0].(map[string]interface{})

		watchdogEnabled := types.CustomBool(
			watchdogBlock[mkWatchdogEnabled].(bool),
		)
		if watchdogEnabled {
			watchdogAction := watchdogBlock[mkWatchdogAction].(string)
			watchdogModel := watchdogBlock[mkWatchdogModel].(string)

			updateBody.WatchdogDevice = &vms.CustomWatchdogDevice{
				Action: &watchdogAction,
				Model:  &watchdogModel,
			}
		}
	}

	updateBody.Delete = del

	e = vmAPI.UpdateVM(ctx, updateBody)
	if e != nil {
		return diag.FromErr(e)
	}

	vmConfig, e = vmAPI.GetVM(ctx)
	if e != nil {
		if errors.Is(e, api.ErrResourceDoesNotExist) {
			d.SetId("")
			return nil
		}

		return diag.FromErr(e)
	}

	clonedDiskInfo := disk.GetInfo(vmConfig, d) // from the cloned VM

	planDisks, e := disk.GetDiskDeviceObjects(d, VM(), nil) // from the resource config
	if e != nil {
		return diag.FromErr(e)
	}

	e = disk.UpdateClone(ctx, planDisks, clonedDiskInfo, vmAPI)
	if e != nil {
		return diag.FromErr(e)
	}

	efiDisk := d.Get(mkEFIDisk).([]interface{})
	efiDiskInfo := vmGetEfiDisk(d, nil) // from the resource config

	for i := range efiDisk {
		diskBlock := efiDisk[i].(map[string]interface{})
		diskInterface := "efidisk0"
		dataStoreID := diskBlock[mkEFIDiskDatastoreID].(string)
		efiType := diskBlock[mkEFIDiskType].(string)

		currentDiskInfo := vmConfig.EFIDisk
		configuredDiskInfo := efiDiskInfo

		if currentDiskInfo == nil {
			diskUpdateBody := &vms.UpdateRequestBody{}

			diskUpdateBody.EFIDisk = configuredDiskInfo

			e = vmAPI.UpdateVM(ctx, diskUpdateBody)
			if e != nil {
				return diag.FromErr(e)
			}

			continue
		}

		// the efitype is either "2m" or "4m"
		// so it's kinda resizing, but with 2 fixed sizes it treated as a "type" by PVE
		// default is "2m", hence this elaborated check.
		if (currentDiskInfo.Type != nil && efiType != *currentDiskInfo.Type) ||
			(currentDiskInfo.Type == nil && efiType != dvEFIDiskType) {
			return diag.Errorf(
				"changing the EFI disk type (4m / 2m) is not supported",
			)
		}

		deleteOriginalDisk := types.CustomBool(true)

		diskMoveBody := &vms.MoveDiskRequestBody{
			DeleteOriginalDisk: &deleteOriginalDisk,
			Disk:               diskInterface,
			TargetStorage:      dataStoreID,
		}

		moveDisk := false

		if dataStoreID != "" {
			moveDisk = true

			if clonedDiskInfo[diskInterface] != nil {
				fileIDParts := strings.Split(clonedDiskInfo[diskInterface].FileVolume, ":")
				moveDisk = dataStoreID != fileIDParts[0]
			}
		}

		if moveDisk {
			e = vmAPI.MoveVMDisk(ctx, diskMoveBody)
			if e != nil {
				return diag.FromErr(e)
			}
		}
	}

	tpmState := d.Get(mkTPMState).([]interface{})
	tpmStateInfo := vmGetTPMState(d, nil) // from the resource config

	for i := range tpmState {
		diskBlock := tpmState[i].(map[string]interface{})
		diskInterface := "tpmstate0"
		dataStoreID := diskBlock[mkTPMStateDatastoreID].(string)

		currentTPMState := vmConfig.TPMState
		configuredTPMStateInfo := tpmStateInfo

		if currentTPMState == nil {
			diskUpdateBody := &vms.UpdateRequestBody{}

			diskUpdateBody.TPMState = configuredTPMStateInfo

			e = vmAPI.UpdateVM(ctx, diskUpdateBody)
			if e != nil {
				return diag.FromErr(e)
			}

			continue
		}

		deleteOriginalDisk := types.CustomBool(true)

		diskMoveBody := &vms.MoveDiskRequestBody{
			DeleteOriginalDisk: &deleteOriginalDisk,
			Disk:               diskInterface,
			TargetStorage:      dataStoreID,
		}

		moveDisk := false

		if dataStoreID != "" {
			moveDisk = true

			if clonedDiskInfo[diskInterface] != nil {
				fileIDParts := strings.Split(clonedDiskInfo[diskInterface].FileVolume, ":")
				moveDisk = dataStoreID != fileIDParts[0]
			}
		}

		if moveDisk {
			e = vmAPI.MoveVMDisk(ctx, diskMoveBody)
			if e != nil {
				return diag.FromErr(e)
			}
		}
	}

	return vmCreateStart(ctx, d, m)
}

func setCPUArchitecture(
	ctx context.Context,
	cpuArchitecture string,
	client proxmox.Client,
	updateBody *vms.UpdateRequestBody,
) error {
	// Only the root account is allowed to change the CPU architecture.
	if cpuArchitecture != "" {
		if client.API().IsRootTicket(ctx) {
			updateBody.CPUArchitecture = &cpuArchitecture
		} else {
			return errors.New("the `cpu.architecture` can only be set by the root account. " +
				"Please switch to the root account or remove the `cpu.architecture` from the VM configuration")
		}
	}

	return nil
}

func vmCreateCustom(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	createTimeoutSec := d.Get(mkTimeoutCreate).(int)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(createTimeoutSec)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	resource := VM()

	acpi := types.CustomBool(d.Get(mkACPI).(bool))

	agentBlock, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkAgent},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	agentEnabled := types.CustomBool(
		agentBlock[mkAgentEnabled].(bool),
	)
	agentTrim := types.CustomBool(agentBlock[mkAgentTrim].(bool))
	agentType := agentBlock[mkAgentType].(string)

	amdsev := vmGetAMDSEVObject(d)

	kvmArguments := d.Get(mkKVMArguments).(string)

	audioDevices := vmGetAudioDeviceList(d)

	bios := d.Get(mkBIOS).(string)

	cdromFileID := ""
	cdromInterface := ""

	cdrom := d.Get(mkCDROM).([]interface{})
	if len(cdrom) > 0 {
		cdromBlock := cdrom[0].(map[string]interface{})
		cdromFileID = cdromBlock[mkCDROMFileID].(string)
		cdromInterface = cdromBlock[mkCDROMInterface].(string)

		if cdromFileID == "" {
			cdromFileID = "cdrom"
		}
	}

	cdromCloudInitFileID := ""
	cdromCloudInitInterface := ""

	cpuBlock, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkCPU},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	cpuArchitecture := cpuBlock[mkCPUArchitecture].(string)
	cpuCores := cpuBlock[mkCPUCores].(int)
	cpuFlags := cpuBlock[mkCPUFlags].([]interface{})
	cpuHotplugged := cpuBlock[mkCPUHotplugged].(int)
	cpuLimit := cpuBlock[mkCPULimit].(int)
	cpuSockets := cpuBlock[mkCPUSockets].(int)
	cpuNUMA := types.CustomBool(cpuBlock[mkCPUNUMA].(bool))
	cpuType := cpuBlock[mkCPUType].(string)
	cpuUnits := cpuBlock[mkCPUUnits].(int)
	cpuAffinity := cpuBlock[mkCPUAffinity].(string)

	description := d.Get(mkDescription).(string)

	var efiDisk *vms.CustomEFIDisk

	efiDiskBlock := d.Get(mkEFIDisk).([]interface{})
	if len(efiDiskBlock) > 0 && efiDiskBlock[0] != nil {
		block := efiDiskBlock[0].(map[string]interface{})

		datastoreID, _ := block[mkEFIDiskDatastoreID].(string)
		fileFormat, _ := block[mkEFIDiskFileFormat].(string)
		efiType, _ := block[mkEFIDiskType].(string)
		preEnrolledKeys := types.CustomBool(block[mkEFIDiskPreEnrolledKeys].(bool))

		if fileFormat == "" {
			fileFormat = dvEFIDiskFileFormat
		}

		efiDisk = &vms.CustomEFIDisk{
			Type:            &efiType,
			FileVolume:      fmt.Sprintf("%s:1", datastoreID),
			Format:          &fileFormat,
			PreEnrolledKeys: &preEnrolledKeys,
		}
	}

	tpmState := vmGetTPMState(d, nil)
	if tpmState != nil && (tpmState.Version == nil || *tpmState.Version == "") {
		tpmState.Version = ptr.Ptr(dvTPMStateVersion)
	}

	rng := vmGetRNGDevice(d)

	initializationConfig := vmGetCloudInitConfig(d)
	initializationAttr := d.Get(mkInitialization)

	if initializationConfig != nil && initializationAttr != nil {
		initialization := initializationAttr.([]interface{})

		initializationBlock := initialization[0].(map[string]interface{})
		initializationDatastoreID := initializationBlock[mkInitializationDatastoreID].(string)

		cdromCloudInitFileID = fmt.Sprintf("%s:cloudinit", initializationDatastoreID)

		cdromCloudInitInterface = initializationBlock[mkInitializationInterface].(string)
		if cdromCloudInitInterface == "" {
			cdromCloudInitInterface = "ide2"
		}
	}

	pciDeviceObjects := vmGetHostPCIDeviceObjects(d)

	numaDeviceObjects := vmGetNumaDeviceObjects(d)

	usbDeviceObjects := vmGetHostUSBDeviceObjects(d)

	keyboardLayout := d.Get(mkKeyboardLayout).(string)

	memoryBlock, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkMemory},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	memoryDedicated := memoryBlock[mkMemoryDedicated].(int)
	memoryFloating := memoryBlock[mkMemoryFloating].(int)
	memoryShared := memoryBlock[mkMemoryShared].(int)
	memoryHugepages := memoryBlock[mkMemoryHugepages].(string)
	memoryKeepHugepages := types.CustomBool(memoryBlock[mkMemoryKeepHugepages].(bool))

	machine := d.Get(mkMachine).(string)
	name := d.Get(mkName).(string)
	tags := d.Get(mkTags).([]interface{})

	networkDeviceObjects, err := network.GetNetworkDeviceObjects(d)
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)

	operatingSystem, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkOperatingSystem},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	operatingSystemType := operatingSystem[mkOperatingSystemType].(string)

	poolID := d.Get(mkPoolID).(string)
	protection := types.CustomBool(d.Get(mkProtection).(bool))

	serialDevices := vmGetSerialDeviceList(d)

	smbios := vmGetSMBIOS(d)

	startupOrder := vmGetStartupOrder(d)

	onBoot := types.CustomBool(d.Get(mkOnBoot).(bool))
	tabletDevice := types.CustomBool(d.Get(mkTabletDevice).(bool))
	template := types.CustomBool(d.Get(mkTemplate).(bool))

	virtiofsShares := vmGetVirtiofsShares(d)
	vgaDevice := vmGetVGADeviceObject(d)

	vmIDUntyped, hasVMID := d.GetOk(mkVMID)
	vmID := vmIDUntyped.(int)

	if !hasVMID {
		vmIDNew, e := config.GetIDGenerator().NextID(ctx)
		if e != nil {
			return diag.FromErr(e)
		}

		vmID = vmIDNew
		e = d.Set(mkVMID, vmID)

		if e != nil {
			return diag.FromErr(e)
		}
	}

	diskDeviceObjects, err := disk.GetDiskDeviceObjects(d, resource, nil)
	if err != nil {
		return diag.FromErr(err)
	}

	var bootOrderConverted []string
	if cdromInterface != "" {
		bootOrderConverted = []string{cdromInterface}
	}

	bootOrder := d.Get(mkBootOrder).([]interface{})

	if len(bootOrder) == 0 {
		if _, ok := diskDeviceObjects["ide0"]; ok {
			bootOrderConverted = append(bootOrderConverted, "ide0")
		}

		if _, ok := diskDeviceObjects["sata0"]; ok {
			bootOrderConverted = append(bootOrderConverted, "sata0")
		}

		if _, ok := diskDeviceObjects["scsi0"]; ok {
			bootOrderConverted = append(bootOrderConverted, "scsi0")
		}

		if _, ok := diskDeviceObjects["virtio0"]; ok {
			bootOrderConverted = append(bootOrderConverted, "virtio0")
		}

		if networkDeviceObjects != nil {
			bootOrderConverted = append(bootOrderConverted, "net0")
		}
	} else {
		bootOrderConverted = make([]string, len(bootOrder))
		for i, device := range bootOrder {
			bootOrderConverted[i] = device.(string)
		}
	}

	cpuFlagsConverted := make([]string, len(cpuFlags))
	for fi, flag := range cpuFlags {
		cpuFlagsConverted[fi] = flag.(string)
	}

	ideDevice2Media := "cdrom"

	if cdromCloudInitInterface != "" {
		diskDeviceObjects[cdromCloudInitInterface] = &vms.CustomStorageDevice{
			FileVolume: cdromCloudInitFileID,
			Media:      &ideDevice2Media,
		}
	}

	if cdromInterface != "" {
		diskDeviceObjects[cdromInterface] = &vms.CustomStorageDevice{
			FileVolume: cdromFileID,
			Media:      &ideDevice2Media,
		}
	}

	var memorySharedObject *vms.CustomSharedMemory

	if memoryShared > 0 {
		memorySharedName := fmt.Sprintf("vm-%d-ivshmem", vmID)
		memorySharedObject = &vms.CustomSharedMemory{
			Name: &memorySharedName,
			Size: memoryShared,
		}
	}

	scsiHardware := d.Get(mkSCSIHardware).(string)

	var watchdogObject *vms.CustomWatchdogDevice

	watchdogBlock, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkWatchdog},
		0,
		true,
	)
	if err != nil {
		return diag.FromErr(err)
	}

	watchdogEnabled := types.CustomBool(
		watchdogBlock[mkWatchdogEnabled].(bool),
	)
	if watchdogEnabled {
		watchdogAction := watchdogBlock[mkWatchdogAction].(string)
		watchdogModel := watchdogBlock[mkWatchdogModel].(string)

		watchdogObject = &vms.CustomWatchdogDevice{
			Action: &watchdogAction,
			Model:  &watchdogModel,
		}
	}

	createBody := &vms.CreateRequestBody{
		ACPI: &acpi,
		Agent: &vms.CustomAgent{
			Enabled:         &agentEnabled,
			TrimClonedDisks: &agentTrim,
			Type:            &agentType,
		},
		AMDSEV:       amdsev,
		AudioDevices: audioDevices,
		BIOS:         &bios,
		Boot: &vms.CustomBoot{
			Order: &bootOrderConverted,
		},
		CloudInitConfig: initializationConfig,
		CPUCores:        ptr.Ptr(int64(cpuCores)),
		CPUEmulation: &vms.CustomCPUEmulation{
			Flags: &cpuFlagsConverted,
			Type:  cpuType,
		},
		CPUSockets:           ptr.Ptr(int64(cpuSockets)),
		CPUUnits:             ptr.Ptr(int64(cpuUnits)),
		DedicatedMemory:      &memoryDedicated,
		DeletionProtection:   &protection,
		EFIDisk:              efiDisk,
		TPMState:             tpmState,
		FloatingMemory:       &memoryFloating,
		KeyboardLayout:       &keyboardLayout,
		NetworkDevices:       networkDeviceObjects,
		NUMAEnabled:          &cpuNUMA,
		NUMADevices:          numaDeviceObjects,
		OSType:               &operatingSystemType,
		PCIDevices:           pciDeviceObjects,
		RNGDevice:            rng,
		SCSIHardware:         &scsiHardware,
		SerialDevices:        serialDevices,
		SharedMemory:         memorySharedObject,
		StartOnBoot:          &onBoot,
		SMBIOS:               smbios,
		StartupOrder:         startupOrder,
		TabletDeviceEnabled:  &tabletDevice,
		Template:             &template,
		USBDevices:           usbDeviceObjects,
		VirtiofsShares:       virtiofsShares,
		VGADevice:            vgaDevice,
		VMID:                 vmID,
		WatchdogDevice:       watchdogObject,
		CustomStorageDevices: diskDeviceObjects,
	}

	if err = setCPUArchitecture(ctx, cpuArchitecture, client, createBody); err != nil {
		return diag.FromErr(err)
	}

	if cpuHotplugged > 0 {
		createBody.VirtualCPUCount = ptr.Ptr(int64(cpuHotplugged))
	}

	if cpuLimit > 0 {
		createBody.CPULimit = ptr.Ptr(int64(cpuLimit))
	}

	if cpuAffinity != "" {
		createBody.CPUAffinity = &cpuAffinity
	}

	if description != "" {
		createBody.Description = &description
	}

	if len(tags) > 0 {
		tagsString := vmGetTagsString(d)
		createBody.Tags = &tagsString
	}

	if kvmArguments != "" {
		createBody.KVMArguments = &kvmArguments
	}

	if machine != "" {
		createBody.Machine = &machine
	}

	if memoryHugepages != "" {
		createBody.Hugepages = &memoryHugepages
	}

	if memoryKeepHugepages {
		createBody.KeepHugepages = &memoryKeepHugepages
	}

	if name != "" {
		createBody.Name = &name
	}

	if poolID != "" {
		createBody.PoolID = &poolID
	}

	hookScript := d.Get(mkHookScriptFileID).(string)
	if len(hookScript) > 0 {
		createBody.HookScript = &hookScript
	}

	err = client.Node(nodeName).VM(0).CreateVM(ctx, createBody)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(strconv.Itoa(vmID))

	diags := disk.CreateCustomDisks(ctx, client, nodeName, vmID, diskDeviceObjects)
	if diags.HasError() {
		return diags
	}

	return vmCreateStart(ctx, d, m)
}

func vmCreateStart(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	started := d.Get(mkStarted).(bool)
	template := d.Get(mkTemplate).(bool)
	reboot := d.Get(mkRebootAfterCreation).(bool)

	if !started || template {
		return vmRead(ctx, d, m)
	}

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)

	vmID, err := strconv.Atoi(d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	vmAPI := client.Node(nodeName).VM(vmID)

	// Start the virtual machine and wait for it to reach a running state before continuing.
	if diags := vmStart(ctx, vmAPI, d); diags != nil {
		return diags
	}

	if reboot {
		rebootTimeoutSec := d.Get(mkTimeoutReboot).(int)

		if e := vmAPI.RebootVMAndWaitForRunning(ctx, rebootTimeoutSec); e != nil {
			return diag.FromErr(e)
		}
	}

	return vmRead(ctx, d, m)
}

func vmGetAMDSEVObject(d *schema.ResourceData) *vms.CustomAMDSEV {
	var amdsev *vms.CustomAMDSEV

	amdsevBlock := d.Get(mkAMDSEV).([]interface{})
	if len(amdsevBlock) > 0 && amdsevBlock[0] != nil {
		block := amdsevBlock[0].(map[string]interface{})

		amdsevType := block[mkAMDSEVType].(string)
		amdsevAllowSMT := types.CustomBool(
			block[mkAMDSEVAllowSMT].(bool),
		)
		amdsevKernelHashes := types.CustomBool(
			block[mkAMDSEVKernelHashes].(bool),
		)
		amdsevNoDebug := types.CustomBool(
			block[mkAMDSEVNoDebug].(bool),
		)
		amdsevNoKeySharing := types.CustomBool(
			block[mkAMDSEVNoKeySharing].(bool),
		)

		amdsev = &vms.CustomAMDSEV{
			Type:         amdsevType,
			AllowSMT:     &amdsevAllowSMT,
			KernelHashes: &amdsevKernelHashes,
			NoDebug:      &amdsevNoDebug,
			NoKeySharing: &amdsevNoKeySharing,
		}
	}

	return amdsev
}

func vmGetAudioDeviceList(d *schema.ResourceData) vms.CustomAudioDevices {
	devices := d.Get(mkAudioDevice).([]interface{})
	list := make(vms.CustomAudioDevices, len(devices))

	for i, v := range devices {
		block := v.(map[string]interface{})

		device, _ := block[mkAudioDeviceDevice].(string)
		driver, _ := block[mkAudioDeviceDriver].(string)
		enabled, _ := block[mkAudioDeviceEnabled].(bool)

		list[i].Device = device
		list[i].Driver = &driver
		list[i].Enabled = enabled
	}

	return list
}

func vmGetCloudInitConfig(d *schema.ResourceData) *vms.CustomCloudInitConfig {
	initialization := d.Get(mkInitialization).([]interface{})

	if len(initialization) == 0 || initialization[0] == nil {
		return nil
	}

	var initializationConfig *vms.CustomCloudInitConfig

	initializationBlock := initialization[0].(map[string]interface{})
	initializationConfig = &vms.CustomCloudInitConfig{}
	initializationDNS := initializationBlock[mkInitializationDNS].([]interface{})

	if len(initializationDNS) > 0 && initializationDNS[0] != nil {
		initializationDNSBlock := initializationDNS[0].(map[string]interface{})
		domain := initializationDNSBlock[mkInitializationDNSDomain].(string)

		if domain != "" {
			initializationConfig.SearchDomain = &domain
		}

		servers := initializationDNSBlock[mkInitializationDNSServers].([]interface{})

		if len(servers) > 0 {
			nameserver := strings.Join(utils.ConvertToStringSlice(servers), " ")

			initializationConfig.Nameserver = &nameserver
		}
	}

	initializationIPConfig := initializationBlock[mkInitializationIPConfig].([]interface{})
	initializationConfig.IPConfig = make([]vms.CustomCloudInitIPConfig, len(initializationIPConfig))

	for i, c := range initializationIPConfig {
		configBlock := c.(map[string]interface{})
		ipv4 := configBlock[mkInitializationIPConfigIPv4].([]interface{})

		if len(ipv4) > 0 && ipv4[0] != nil {
			ipv4Block := ipv4[0].(map[string]interface{})
			ipv4Address := ipv4Block[mkInitializationIPConfigIPv4Address].(string)

			if ipv4Address != "" {
				initializationConfig.IPConfig[i].IPv4 = &ipv4Address
			}

			ipv4Gateway := ipv4Block[mkInitializationIPConfigIPv4Gateway].(string)

			if ipv4Gateway != "" {
				initializationConfig.IPConfig[i].GatewayIPv4 = &ipv4Gateway
			}
		}

		ipv6 := configBlock[mkInitializationIPConfigIPv6].([]interface{})

		if len(ipv6) > 0 && ipv6[0] != nil {
			ipv6Block := ipv6[0].(map[string]interface{})
			ipv6Address := ipv6Block[mkInitializationIPConfigIPv6Address].(string)

			if ipv6Address != "" {
				initializationConfig.IPConfig[i].IPv6 = &ipv6Address
			}

			ipv6Gateway := ipv6Block[mkInitializationIPConfigIPv6Gateway].(string)

			if ipv6Gateway != "" {
				initializationConfig.IPConfig[i].GatewayIPv6 = &ipv6Gateway
			}
		}
	}

	initializationUserAccount := initializationBlock[mkInitializationUserAccount].([]interface{})

	if len(initializationUserAccount) > 0 && initializationUserAccount[0] != nil {
		initializationUserAccountBlock := initializationUserAccount[0].(map[string]interface{})
		keys := initializationUserAccountBlock[mkInitializationUserAccountKeys].([]interface{})

		if len(keys) > 0 {
			sshKeys := make(vms.CustomCloudInitSSHKeys, len(keys))

			for i, k := range keys {
				if k != nil {
					sshKeys[i] = k.(string)
				}
			}

			initializationConfig.SSHKeys = &sshKeys
		}

		password := initializationUserAccountBlock[mkInitializationUserAccountPassword].(string)
		if password != "" && password != MaskedPassword {
			initializationConfig.Password = &password
		}

		username := initializationUserAccountBlock[mkInitializationUserAccountUsername].(string)
		if username != "" {
			initializationConfig.Username = &username
		}
	}

	initializationUserDataFileID := initializationBlock[mkInitializationUserDataFileID].(string)
	if initializationUserDataFileID != "" {
		initializationConfig.Files = &vms.CustomCloudInitFiles{
			UserVolume: &initializationUserDataFileID,
		}
	}

	initializationVendorDataFileID := initializationBlock[mkInitializationVendorDataFileID].(string)
	if initializationVendorDataFileID != "" {
		if initializationConfig.Files == nil {
			initializationConfig.Files = &vms.CustomCloudInitFiles{}
		}

		initializationConfig.Files.VendorVolume = &initializationVendorDataFileID
	}

	initializationNetworkDataFileID := initializationBlock[mkInitializationNetworkDataFileID].(string)
	if initializationNetworkDataFileID != "" {
		if initializationConfig.Files == nil {
			initializationConfig.Files = &vms.CustomCloudInitFiles{}
		}

		initializationConfig.Files.NetworkVolume = &initializationNetworkDataFileID
	}

	initializationMetaDataFileID := initializationBlock[mkInitializationMetaDataFileID].(string)
	if initializationMetaDataFileID != "" {
		if initializationConfig.Files == nil {
			initializationConfig.Files = &vms.CustomCloudInitFiles{}
		}

		initializationConfig.Files.MetaVolume = &initializationMetaDataFileID
	}

	initializationType := initializationBlock[mkInitializationType].(string)
	if initializationType != "" {
		initializationConfig.Type = &initializationType
	}

	return initializationConfig
}

func vmGetEfiDisk(d *schema.ResourceData, disk []interface{}) *vms.CustomEFIDisk {
	var efiDisk []interface{}

	if disk != nil {
		efiDisk = disk
	} else {
		efiDisk = d.Get(mkEFIDisk).([]interface{})
	}

	var efiDiskConfig *vms.CustomEFIDisk

	if len(efiDisk) > 0 && efiDisk[0] != nil {
		efiDiskConfig = &vms.CustomEFIDisk{}

		block := efiDisk[0].(map[string]interface{})
		datastoreID, _ := block[mkEFIDiskDatastoreID].(string)
		fileFormat, _ := block[mkEFIDiskFileFormat].(string)
		efiType, _ := block[mkEFIDiskType].(string)
		preEnrolledKeys := types.CustomBool(block[mkEFIDiskPreEnrolledKeys].(bool))

		// use the special syntax STORAGE_ID:SIZE_IN_GiB to allocate a new volume.
		// NB SIZE_IN_GiB is ignored, see docs for more info.
		efiDiskConfig.FileVolume = fmt.Sprintf("%s:1", datastoreID)
		efiDiskConfig.Format = &fileFormat
		efiDiskConfig.Type = &efiType
		efiDiskConfig.PreEnrolledKeys = &preEnrolledKeys
	}

	return efiDiskConfig
}

func vmGetEfiDiskAsStorageDevice(d *schema.ResourceData, disk []interface{}) (*vms.CustomStorageDevice, error) {
	efiDisk := vmGetEfiDisk(d, disk)

	var storageDevice *vms.CustomStorageDevice

	if efiDisk != nil {
		id := "0"

		storageDevice = &vms.CustomStorageDevice{
			FileVolume:  efiDisk.FileVolume,
			Format:      efiDisk.Format,
			DatastoreID: &id,
		}

		if efiDisk.Type != nil {
			ds, err := types.ParseDiskSize(*efiDisk.Type)
			if err != nil {
				return nil, fmt.Errorf("invalid efi disk type: %s", err.Error())
			}

			storageDevice.Size = &ds
		}
	}

	return storageDevice, nil
}

func vmGetTPMState(d *schema.ResourceData, disk []interface{}) *vms.CustomTPMState {
	var tpmState []interface{}

	if disk != nil {
		tpmState = disk
	} else {
		tpmState = d.Get(mkTPMState).([]interface{})
	}

	var tpmStateConfig *vms.CustomTPMState

	if len(tpmState) > 0 && tpmState[0] != nil {
		tpmStateConfig = &vms.CustomTPMState{}

		block := tpmState[0].(map[string]interface{})
		datastoreID, _ := block[mkTPMStateDatastoreID].(string)
		version, _ := block[mkTPMStateVersion].(string)

		// use the special syntax STORAGE_ID:SIZE_IN_GiB to allocate a new volume.
		// NB SIZE_IN_GiB is ignored, see docs for more info.
		tpmStateConfig.FileVolume = fmt.Sprintf("%s:1", datastoreID)
		tpmStateConfig.Version = &version
	}

	return tpmStateConfig
}

func vmGetTPMStateAsStorageDevice(d *schema.ResourceData, disk []interface{}) *vms.CustomStorageDevice {
	tpmState := vmGetTPMState(d, disk)

	var storageDevice *vms.CustomStorageDevice

	if tpmState != nil {
		id := "0"
		storageDevice = &vms.CustomStorageDevice{
			FileVolume:  tpmState.FileVolume,
			DatastoreID: &id,
		}
	}

	return storageDevice
}

func vmGetRNGDevice(d *schema.ResourceData) *vms.CustomRNGDevice {
	rngBlock := d.Get(mkRNG).([]interface{})

	var rng *vms.CustomRNGDevice

	if len(rngBlock) > 0 && rngBlock[0] != nil {
		block := rngBlock[0].(map[string]interface{})

		source, _ := block[mkRNGSource].(string)

		maxBytes, _ := block[mkRNGMaxBytes].(int)
		if maxBytes == 0 {
			maxBytes = dvRNGMaxBytes
		}

		period, _ := block[mkRNGPeriod].(int)
		if period == 0 {
			period = dvRNGPeriod
		}

		rng = &vms.CustomRNGDevice{
			Source:   source,
			MaxBytes: &maxBytes,
			Period:   &period,
		}
	}

	return rng
}

func vmGetHostPCIDeviceObjects(d *schema.ResourceData) vms.CustomPCIDevices {
	pciDevice := d.Get(mkHostPCI).([]interface{})
	pciDeviceObjects := make(vms.CustomPCIDevices, len(pciDevice))

	for _, pciDeviceEntry := range pciDevice {
		block := pciDeviceEntry.(map[string]interface{})

		deviceName := block[mkHostPCIDevice].(string)
		ids, _ := block[mkHostPCIDeviceID].(string)
		mdev, _ := block[mkHostPCIDeviceMDev].(string)
		pcie := types.CustomBool(block[mkHostPCIDevicePCIE].(bool))
		rombar := types.CustomBool(
			block[mkHostPCIDeviceROMBAR].(bool),
		)
		romfile, _ := block[mkHostPCIDeviceROMFile].(string)
		xvga := types.CustomBool(block[mkHostPCIDeviceXVGA].(bool))
		mapping, _ := block[mkHostPCIDeviceMapping].(string)

		device := vms.CustomPCIDevice{
			PCIExpress: &pcie,
			ROMBAR:     &rombar,
			XVGA:       &xvga,
		}

		if ids != "" {
			dIDs := strings.Split(ids, ";")
			device.DeviceIDs = &dIDs
		}

		if mdev != "" {
			device.MDev = &mdev
		}

		if romfile != "" {
			device.ROMFile = &romfile
		}

		if mapping != "" {
			device.Mapping = &mapping
		}

		pciDeviceObjects[deviceName] = &device
	}

	return pciDeviceObjects
}

func vmGetNumaDeviceObjects(d *schema.ResourceData) vms.CustomNUMADevices {
	numaNode := d.Get(mkNUMA).([]interface{})
	numaNodeObjects := make(vms.CustomNUMADevices, len(numaNode))

	for i, numaNodeEntry := range numaNode {
		block := numaNodeEntry.(map[string]interface{})

		deviceName := block[mkNUMADevice].(string)
		ids := block[mkNUMACPUIDs].(string)
		hostNodes, _ := block[mkNUMAHostNodeNames].(string)
		memory, _ := block[mkNUMAMemory].(int)
		policy, _ := block[mkNUMAPolicy].(string)

		device := vms.CustomNUMADevice{
			Memory: &memory,
			Policy: &policy,
		}

		if ids != "" {
			dIDs := strings.Split(ids, ";")
			device.CPUIDs = dIDs
		}

		if hostNodes != "" {
			dHostNodes := strings.Split(hostNodes, ";")
			device.HostNodeNames = &dHostNodes
		}

		if strings.HasPrefix(deviceName, "numa") {
			deviceID, err := strconv.Atoi(deviceName[4:])
			if err == nil {
				numaNodeObjects[deviceID] = device

				continue
			}
		}

		numaNodeObjects[i] = device
	}

	return numaNodeObjects
}

func vmGetHostUSBDeviceObjects(d *schema.ResourceData) vms.CustomUSBDevices {
	usbDevice := d.Get(mkHostUSB).([]interface{})
	usbDeviceObjects := make(vms.CustomUSBDevices, len(usbDevice))

	for i, usbDeviceEntry := range usbDevice {
		block := usbDeviceEntry.(map[string]interface{})

		host, _ := block[mkHostUSBDevice].(string)
		usb3 := types.CustomBool(block[mkHostUSBDeviceUSB3].(bool))
		mapping, _ := block[mkHostUSBDeviceMapping].(string)

		device := vms.CustomUSBDevice{
			USB3: &usb3,
		}

		if host != "" {
			device.HostDevice = &host
		}

		if mapping != "" {
			device.Mapping = &mapping
		}

		usbDeviceObjects[i] = device
	}

	return usbDeviceObjects
}

func vmGetSerialDeviceList(d *schema.ResourceData) vms.CustomSerialDevices {
	device := d.Get(mkSerialDevice).([]interface{})
	list := make(vms.CustomSerialDevices, len(device))

	for i, v := range device {
		block := v.(map[string]interface{})

		device, _ := block[mkSerialDeviceDevice].(string)

		list[i] = device
	}

	return list
}

func vmGetSMBIOS(d *schema.ResourceData) *vms.CustomSMBIOS {
	smbiosSections := d.Get(mkSMBIOS).([]interface{})

	if len(smbiosSections) > 0 && smbiosSections[0] != nil {
		smbiosBlock := smbiosSections[0].(map[string]interface{})
		b64 := types.CustomBool(true)
		family, _ := smbiosBlock[mkSMBIOSFamily].(string)
		manufacturer, _ := smbiosBlock[mkSMBIOSManufacturer].(string)
		product, _ := smbiosBlock[mkSMBIOSProduct].(string)
		serial, _ := smbiosBlock[mkSMBIOSSerial].(string)
		sku, _ := smbiosBlock[mkSMBIOS].(string)
		version, _ := smbiosBlock[mkSMBIOSVersion].(string)
		uid, _ := smbiosBlock[mkSMBIOSUUID].(string)

		smbios := vms.CustomSMBIOS{
			Base64: &b64,
		}

		if family != "" {
			v := base64.StdEncoding.EncodeToString([]byte(family))
			smbios.Family = &v
		}

		if manufacturer != "" {
			v := base64.StdEncoding.EncodeToString([]byte(manufacturer))
			smbios.Manufacturer = &v
		}

		if product != "" {
			v := base64.StdEncoding.EncodeToString([]byte(product))
			smbios.Product = &v
		}

		if serial != "" {
			v := base64.StdEncoding.EncodeToString([]byte(serial))
			smbios.Serial = &v
		}

		if sku != "" {
			v := base64.StdEncoding.EncodeToString([]byte(sku))
			smbios.SKU = &v
		}

		if version != "" {
			v := base64.StdEncoding.EncodeToString([]byte(version))
			smbios.Version = &v
		}

		if uid != "" {
			smbios.UUID = &uid
		}

		if smbios.UUID == nil || *smbios.UUID == "" {
			smbios.UUID = ptr.Ptr(uuid.New().String())
		}

		return &smbios
	}

	return nil
}

func vmGetStartupOrder(d *schema.ResourceData) *vms.CustomStartupOrder {
	startup := d.Get(mkStartup).([]interface{})

	if len(startup) > 0 && startup[0] != nil {
		startupBlock := startup[0].(map[string]interface{})
		startupOrder := startupBlock[mkStartupOrder].(int)
		startupUpDelay := startupBlock[mkStartupUpDelay].(int)
		startupDownDelay := startupBlock[mkStartupDownDelay].(int)

		order := vms.CustomStartupOrder{}

		if startupUpDelay >= 0 {
			order.Up = &startupUpDelay
		}

		if startupDownDelay >= 0 {
			order.Down = &startupDownDelay
		}

		if startupOrder >= 0 {
			order.Order = &startupOrder
		}

		return &order
	}

	return nil
}

func vmGetTagsString(d *schema.ResourceData) string {
	var sanitizedTags []string

	tags := d.Get(mkTags).([]interface{})
	for _, tag := range tags {
		sanitizedTag := strings.TrimSpace(tag.(string))
		if len(sanitizedTag) > 0 {
			sanitizedTags = append(sanitizedTags, sanitizedTag)
		}
	}

	sort.Strings(sanitizedTags)

	return strings.Join(sanitizedTags, ";")
}

func vmGetVirtiofsShares(d *schema.ResourceData) vms.CustomVirtiofsShares {
	virtiofs := d.Get(mkVirtiofs).([]interface{})
	virtiofsShares := make(vms.CustomVirtiofsShares, len(virtiofs))

	for i, virtiofsShare := range virtiofs {
		block := virtiofsShare.(map[string]interface{})

		mapping, _ := block[mkVirtiofsMapping].(string)
		cache, _ := block[mkVirtiofsCache].(string)
		directIO := types.CustomBool(block[mkVirtiofsDirectIO].(bool))
		exposeACL := types.CustomBool(block[mkVirtiofsExposeACL].(bool))
		exposeXAttr := types.CustomBool(block[mkVirtiofsExposeXAttr].(bool))

		share := vms.CustomVirtiofsShare{
			DirId:       mapping,
			DirectIo:    &directIO,
			ExposeAcl:   &exposeACL,
			ExposeXattr: &exposeXAttr,
		}

		if cache != "" {
			share.Cache = &cache
		}

		if share.ExposeAcl != nil && *share.ExposeAcl && share.ExposeXattr == nil {
			bv := types.CustomBool(true)
			share.ExposeXattr = &bv
		}

		virtiofsShares[fmt.Sprintf("virtiofs%d", i)] = &share
	}

	return virtiofsShares
}

func vmGetVGADeviceObject(d *schema.ResourceData) *vms.CustomVGADevice {
	vga := d.Get(mkVGA).([]interface{})
	if len(vga) > 0 && vga[0] != nil {
		vgaBlock := vga[0].(map[string]interface{})
		vgaClipboard := vgaBlock[mkVGAClipboard].(string)
		vgaMemory := vgaBlock[mkVGAMemory].(int)

		vgaType := vgaBlock[mkVGAType].(string)

		vgaDevice := &vms.CustomVGADevice{}

		if vgaClipboard != "" {
			vgaDevice.Clipboard = &vgaClipboard
		}

		if vgaMemory > 0 {
			vgaDevice.Memory = ptr.Ptr(int64(vgaMemory))
		}

		if vgaType != "" {
			vgaDevice.Type = &vgaType
		}

		return vgaDevice
	}

	return nil
}

func vmRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	vmID, err := strconv.Atoi(d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	vmNodeName, err := client.Cluster().GetVMNodeName(ctx, vmID)
	if err != nil {
		if errors.Is(err, cluster.ErrVMDoesNotExist) {
			d.SetId("")

			return nil
		}

		return diag.FromErr(err)
	}

	if vmNodeName != d.Get(mkNodeName) {
		err = d.Set(mkNodeName, vmNodeName)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	nodeName := d.Get(mkNodeName).(string)

	vmAPI := client.Node(nodeName).VM(vmID)

	// Retrieve the entire configuration in order to compare it to the state.
	vmConfig, err := vmAPI.GetVM(ctx)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	vmStatus, err := vmAPI.GetVMStatus(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	return vmReadCustom(ctx, d, m, vmID, vmConfig, vmStatus)
}

func vmReadCustom(
	ctx context.Context,
	d *schema.ResourceData,
	m interface{},
	vmID int,
	vmConfig *vms.GetResponseData,
	vmStatus *vms.GetStatusResponseData,
) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, e := config.GetClient()
	if e != nil {
		return diag.FromErr(e)
	}

	var diags diag.Diagnostics

	if !d.Get(mkTemplate).(bool) {
		// we shouldn't be updating this attribute at read. Instead, the current status should be captured
		// in a separate computed attribute. To be addressed in v1.0
		err := d.Set(mkStarted, vmStatus.Status == "running")
		diags = append(diags, diag.FromErr(err)...)
	}

	diags = append(diags, vmReadPrimitiveValues(d, vmConfig)...)
	if diags.HasError() {
		return diags
	}

	// Fix terraform.tfstate, by replacing '-1' (the old default value) with actual vm_id value
	if storedVMID := d.Get(mkVMID).(int); storedVMID == -1 {
		diags = append(diags, diag.Diagnostic{
			Severity: diag.Warning,
			Summary: fmt.Sprintf("VM %s has stored legacy vm_id %d, setting vm_id to its correct value %d.",
				d.Id(), storedVMID, vmID),
		})

		err := d.Set(mkVMID, vmID)
		diags = append(diags, diag.FromErr(err)...)
	}

	nodeName := d.Get(mkNodeName).(string)
	clone := d.Get(mkClone).([]interface{})

	// Compare the agent configuration to the one stored in the state.
	currentAgent := d.Get(mkAgent).([]interface{})

	//nolint:gocritic
	if len(clone) == 0 || len(currentAgent) > 0 {
		if vmConfig.Agent != nil {
			agent := map[string]interface{}{}

			if vmConfig.Agent.Enabled != nil {
				agent[mkAgentEnabled] = bool(*vmConfig.Agent.Enabled)
			} else {
				agent[mkAgentEnabled] = false
			}

			if vmConfig.Agent.TrimClonedDisks != nil {
				agent[mkAgentTrim] = bool(
					*vmConfig.Agent.TrimClonedDisks,
				)
			} else {
				agent[mkAgentTrim] = false
			}

			if len(currentAgent) > 0 && currentAgent[0] != nil {
				currentAgentBlock := currentAgent[0].(map[string]interface{})
				currentAgentTimeout := currentAgentBlock[mkAgentTimeout].(string)

				if currentAgentTimeout != "" {
					agent[mkAgentTimeout] = currentAgentTimeout
				} else {
					agent[mkAgentTimeout] = dvAgentTimeout
				}
			} else {
				agent[mkAgentTimeout] = dvAgentTimeout
			}

			if vmConfig.Agent.Type != nil {
				agent[mkAgentType] = *vmConfig.Agent.Type
			} else {
				agent[mkAgentType] = ""
			}

			if len(clone) > 0 {
				if len(currentAgent) > 0 {
					err := d.Set(mkAgent, []interface{}{agent})
					diags = append(diags, diag.FromErr(err)...)
				}
			} else if len(currentAgent) > 0 ||
				agent[mkAgentEnabled] != dvAgentEnabled ||
				agent[mkAgentTimeout] != dvAgentTimeout ||
				agent[mkAgentTrim] != dvAgentTrim ||
				agent[mkAgentType] != dvAgentType {
				err := d.Set(mkAgent, []interface{}{agent})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else if len(clone) > 0 {
			if len(currentAgent) > 0 {
				err := d.Set(mkAgent, []interface{}{})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else {
			err := d.Set(mkAgent, []interface{}{})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Compare the amdsev configuration to the one stored in the state.
	currentAMDSEV := d.Get(mkAMDSEV).([]interface{})

	//nolint:gocritic
	if len(clone) == 0 || len(currentAMDSEV) > 0 {
		if vmConfig.AMDSEV != nil {
			amdsev := map[string]interface{}{}

			amdsev[mkAMDSEVType] = vmConfig.AMDSEV.Type

			if vmConfig.AMDSEV.AllowSMT != nil {
				amdsev[mkAMDSEVAllowSMT] = bool(*vmConfig.AMDSEV.AllowSMT)
			} else {
				amdsev[mkAMDSEVAllowSMT] = false
			}

			if vmConfig.AMDSEV.KernelHashes != nil {
				amdsev[mkAMDSEVKernelHashes] = bool(*vmConfig.AMDSEV.KernelHashes)
			} else {
				amdsev[mkAMDSEVKernelHashes] = false
			}

			if vmConfig.AMDSEV.NoDebug != nil {
				amdsev[mkAMDSEVNoDebug] = bool(*vmConfig.AMDSEV.NoDebug)
			} else {
				amdsev[mkAMDSEVNoDebug] = false
			}

			if vmConfig.AMDSEV.NoKeySharing != nil {
				amdsev[mkAMDSEVNoKeySharing] = bool(*vmConfig.AMDSEV.NoKeySharing)
			} else {
				amdsev[mkAMDSEVNoKeySharing] = false
			}

			if len(clone) > 0 {
				if len(currentAMDSEV) > 0 {
					err := d.Set(mkAMDSEV, []interface{}{amdsev})
					diags = append(diags, diag.FromErr(err)...)
				}
			} else if len(currentAMDSEV) > 0 ||
				amdsev[mkAMDSEVType] != dvAMDSEVType ||
				amdsev[mkAMDSEVAllowSMT] != dvAMDSEVAllowSMT ||
				amdsev[mkAMDSEVKernelHashes] != dvAMDSEVKernelHashes ||
				amdsev[mkAMDSEVNoDebug] != dvAMDSEVNoDebug ||
				amdsev[mkAMDSEVNoKeySharing] != dvAMDSEVNoKeySharing {
				err := d.Set(mkAMDSEV, []interface{}{amdsev})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else if len(clone) > 0 {
			if len(currentAMDSEV) > 0 {
				err := d.Set(mkAMDSEV, []interface{}{})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else {
			err := d.Set(mkAMDSEV, []interface{}{})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Compare the audio devices to those stored in the state.
	currentAudioDevice := d.Get(mkAudioDevice).([]interface{})

	audioDevices := make([]interface{}, 1)
	audioDevicesArray := []*vms.CustomAudioDevice{
		vmConfig.AudioDevice,
	}
	audioDevicesCount := 0

	for adi, ad := range audioDevicesArray {
		m := map[string]interface{}{}

		if ad != nil {
			m[mkAudioDeviceDevice] = ad.Device

			if ad.Driver != nil {
				m[mkAudioDeviceDriver] = *ad.Driver
			} else {
				m[mkAudioDeviceDriver] = ""
			}

			m[mkAudioDeviceEnabled] = true

			audioDevicesCount = adi + 1
		} else {
			m[mkAudioDeviceDevice] = ""
			m[mkAudioDeviceDriver] = ""
			m[mkAudioDeviceEnabled] = false
		}

		audioDevices[adi] = m
	}

	if len(clone) == 0 || len(currentAudioDevice) > 0 {
		err := d.Set(mkAudioDevice, audioDevices[:audioDevicesCount])
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the IDE devices to the CD-ROM configurations stored in the state.
	currentInterface := dvCDROMInterface

	currentCDROM := d.Get(mkCDROM).([]interface{})
	if len(currentCDROM) > 0 && currentCDROM[0] != nil {
		currentBlock := currentCDROM[0].(map[string]interface{})
		currentInterface = currentBlock[mkCDROMInterface].(string)
	}

	cdromIDEDevice := getStorageDevice(vmConfig, currentInterface)

	if cdromIDEDevice != nil {
		cdrom := make([]interface{}, 1)
		cdromBlock := map[string]interface{}{}

		if len(clone) == 0 || len(currentCDROM) > 0 {
			cdromBlock[mkCDROMFileID] = cdromIDEDevice.FileVolume
			cdromBlock[mkCDROMInterface] = currentInterface

			if len(currentCDROM) > 0 && currentCDROM[0] != nil {
				currentBlock := currentCDROM[0].(map[string]interface{})

				if currentBlock[mkCDROMFileID] == "" {
					cdromBlock[mkCDROMFileID] = ""
				}
			}

			cdrom[0] = cdromBlock

			err := d.Set(mkCDROM, cdrom)
			diags = append(diags, diag.FromErr(err)...)
		}
	} else {
		err := d.Set(mkCDROM, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the CPU configuration to the one stored in the state.
	cpu := map[string]interface{}{}

	if vmConfig.CPUArchitecture != nil {
		cpu[mkCPUArchitecture] = *vmConfig.CPUArchitecture
	} else {
		// Default value of "arch" is "" according to the API documentation.
		cpu[mkCPUArchitecture] = ""
	}

	if vmConfig.CPUCores != nil {
		cpu[mkCPUCores] = int(*vmConfig.CPUCores)
	} else {
		// Default value of "cores" is "1" according to the API documentation.
		cpu[mkCPUCores] = 1
	}

	if vmConfig.VirtualCPUCount != nil {
		cpu[mkCPUHotplugged] = int(*vmConfig.VirtualCPUCount)
	} else {
		// Default value of "vcpus" is "1" according to the API documentation.
		cpu[mkCPUHotplugged] = 0
	}

	if vmConfig.CPULimit != nil {
		cpu[mkCPULimit] = int(*vmConfig.CPULimit)
	} else {
		// Default value of "cpulimit" is "0" according to the API documentation.
		cpu[mkCPULimit] = 0
	}

	if vmConfig.NUMAEnabled != nil {
		cpu[mkCPUNUMA] = *vmConfig.NUMAEnabled
	} else {
		// Default value of "numa" is "false" according to the API documentation.
		cpu[mkCPUNUMA] = false
	}

	currentNUMAList := d.Get(mkNUMA).([]interface{})
	numaMap := map[string]interface{}{}

	numaDevices := getNUMAInfo(vmConfig, d)
	for ni, np := range numaDevices {
		if np == nil || np.CPUIDs == nil || np.HostNodeNames == nil {
			continue
		}

		numaNode := map[string]interface{}{}
		numaNode[mkNUMADevice] = ni

		if len(np.CPUIDs) > 0 {
			numaNode[mkNUMACPUIDs] = strings.Join(np.CPUIDs, ";")
		}

		numaNode[mkNUMAHostNodeNames] = strings.Join(*np.HostNodeNames, ";")
		numaNode[mkNUMAMemory] = np.Memory
		numaNode[mkNUMAPolicy] = np.Policy

		numaMap[ni] = numaNode
	}

	if len(clone) == 0 || len(currentNUMAList) > 0 {
		var numaList []interface{}

		if len(currentNUMAList) > 0 {
			devices := utils.ListResourcesAttributeValue(currentNUMAList, mkNUMADevice)
			numaList = utils.OrderedListFromMapByKeyValues(numaMap, devices)
		} else {
			numaList = utils.OrderedListFromMap(numaMap)
		}

		err := d.Set(mkNUMA, numaList)
		diags = append(diags, diag.FromErr(err)...)
	}

	if vmConfig.CPUSockets != nil {
		cpu[mkCPUSockets] = int(*vmConfig.CPUSockets)
	} else {
		// Default value of "sockets" is "1" according to the API documentation.
		cpu[mkCPUSockets] = 1
	}

	if vmConfig.CPUEmulation != nil {
		if vmConfig.CPUEmulation.Flags != nil {
			convertedFlags := make([]interface{}, len(*vmConfig.CPUEmulation.Flags))

			for fi, fv := range *vmConfig.CPUEmulation.Flags {
				convertedFlags[fi] = fv
			}

			cpu[mkCPUFlags] = convertedFlags
		} else {
			cpu[mkCPUFlags] = []interface{}{}
		}

		cpu[mkCPUType] = vmConfig.CPUEmulation.Type
	} else {
		cpu[mkCPUFlags] = []interface{}{}
		// Default value of "cputype" is "qemu64" according to the QEMU documentation.
		cpu[mkCPUType] = "qemu64"
	}

	if vmConfig.CPUUnits != nil {
		cpu[mkCPUUnits] = int(*vmConfig.CPUUnits)
	} else {
		// Default value of "cpuunits" is "1024" according to the API documentation.
		cpu[mkCPUUnits] = 1024
	}

	if vmConfig.CPUAffinity != nil {
		cpu[mkCPUAffinity] = *vmConfig.CPUAffinity
	} else {
		cpu[mkCPUAffinity] = ""
	}

	currentCPU := d.Get(mkCPU).([]interface{})

	if len(clone) > 0 {
		if len(currentCPU) > 0 {
			err := d.Set(mkCPU, []interface{}{cpu})
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentCPU) > 0 ||
		cpu[mkCPUArchitecture] != dvCPUArchitecture ||
		cpu[mkCPUCores] != dvCPUCores ||
		len(cpu[mkCPUFlags].([]interface{})) > 0 ||
		cpu[mkCPUHotplugged] != dvCPUHotplugged ||
		cpu[mkCPULimit] != dvCPULimit ||
		cpu[mkCPUSockets] != dvCPUSockets ||
		cpu[mkCPUType] != dvCPUType ||
		cpu[mkCPUUnits] != dvCPUUnits {
		err := d.Set(mkCPU, []interface{}{cpu})
		diags = append(diags, diag.FromErr(err)...)
	}

	allDiskInfo := disk.GetInfo(vmConfig, d)

	diags = append(diags, disk.Read(ctx, d, allDiskInfo, vmID, client, nodeName, len(clone) > 0)...)

	if vmConfig.EFIDisk != nil {
		efiDisk := map[string]interface{}{}

		fileIDParts := strings.Split(vmConfig.EFIDisk.FileVolume, ":")

		efiDisk[mkEFIDiskDatastoreID] = fileIDParts[0]

		if vmConfig.EFIDisk.Format != nil {
			efiDisk[mkEFIDiskFileFormat] = *vmConfig.EFIDisk.Format
		} else {
			// disk format may not be returned by config API if it is default for the storage, and that may be different
			// from the default qcow2, so we need to read it from the storage API to make sure we have the correct value
			volume, err := client.Node(nodeName).Storage(fileIDParts[0]).GetDatastoreFile(ctx, vmConfig.EFIDisk.FileVolume)
			if err != nil {
				diags = append(diags, diag.FromErr(err)...)
			} else {
				efiDisk[mkEFIDiskFileFormat] = volume.FileFormat
			}
		}

		if vmConfig.EFIDisk.Type != nil {
			efiDisk[mkEFIDiskType] = *vmConfig.EFIDisk.Type
		} else {
			efiDisk[mkEFIDiskType] = dvEFIDiskType
		}

		if vmConfig.EFIDisk.PreEnrolledKeys != nil {
			efiDisk[mkEFIDiskPreEnrolledKeys] = *vmConfig.EFIDisk.PreEnrolledKeys
		} else {
			efiDisk[mkEFIDiskPreEnrolledKeys] = false
		}

		currentEfiDisk := d.Get(mkEFIDisk).([]interface{})

		if len(clone) > 0 {
			if len(currentEfiDisk) > 0 {
				err := d.Set(mkEFIDisk, []interface{}{efiDisk})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else if len(currentEfiDisk) > 0 ||
			efiDisk[mkEFIDiskDatastoreID] != dvEFIDiskDatastoreID ||
			efiDisk[mkEFIDiskType] != dvEFIDiskType ||
			efiDisk[mkEFIDiskPreEnrolledKeys] != dvEFIDiskPreEnrolledKeys ||
			efiDisk[mkEFIDiskFileFormat] != dvEFIDiskFileFormat {
			err := d.Set(mkEFIDisk, []interface{}{efiDisk})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	if vmConfig.TPMState != nil {
		tpmState := map[string]interface{}{}

		fileIDParts := strings.Split(vmConfig.TPMState.FileVolume, ":")

		tpmState[mkTPMStateDatastoreID] = fileIDParts[0]
		tpmState[mkTPMStateVersion] = dvTPMStateVersion

		currentTPMState := d.Get(mkTPMState).([]interface{})

		if len(clone) > 0 {
			if len(currentTPMState) > 0 {
				err := d.Set(mkTPMState, []interface{}{tpmState})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else if len(currentTPMState) > 0 ||
			tpmState[mkTPMStateDatastoreID] != dvTPMStateDatastoreID ||
			tpmState[mkTPMStateVersion] != dvTPMStateVersion {
			err := d.Set(mkTPMState, []interface{}{tpmState})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	if vmConfig.RNGDevice != nil {
		rng := map[string]interface{}{}

		rng[mkRNGSource] = vmConfig.RNGDevice.Source

		if vmConfig.RNGDevice.MaxBytes != nil {
			rng[mkRNGMaxBytes] = *vmConfig.RNGDevice.MaxBytes
		}

		if vmConfig.RNGDevice.Period != nil {
			rng[mkRNGPeriod] = *vmConfig.RNGDevice.Period
		}

		currentRNG := d.Get(mkRNG).([]interface{})

		if len(clone) > 0 {
			if len(currentRNG) > 0 {
				err := d.Set(mkRNG, []interface{}{rng})
				diags = append(diags, diag.FromErr(err)...)
			}
		} else if len(currentRNG) > 0 ||
			rng[mkRNGSource] != "" ||
			rng[mkRNGMaxBytes] != dvRNGMaxBytes || // or != 0?
			rng[mkRNGPeriod] != dvRNGPeriod {
			err := d.Set(mkRNG, []interface{}{rng})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	currentPCIList := d.Get(mkHostPCI).([]interface{})
	pciMap := map[string]interface{}{}

	for pi, pp := range vmConfig.PCIDevices {
		if (pp == nil) || (pp.DeviceIDs == nil && pp.Mapping == nil) {
			continue
		}

		pci := map[string]interface{}{}

		pci[mkHostPCIDevice] = pi
		if pp.DeviceIDs != nil {
			pci[mkHostPCIDeviceID] = strings.Join(*pp.DeviceIDs, ";")
		} else {
			pci[mkHostPCIDeviceID] = ""
		}

		if pp.MDev != nil {
			pci[mkHostPCIDeviceMDev] = *pp.MDev
		} else {
			pci[mkHostPCIDeviceMDev] = ""
		}

		if pp.PCIExpress != nil {
			pci[mkHostPCIDevicePCIE] = *pp.PCIExpress
		} else {
			pci[mkHostPCIDevicePCIE] = false
		}

		if pp.ROMBAR != nil {
			pci[mkHostPCIDeviceROMBAR] = *pp.ROMBAR
		} else {
			pci[mkHostPCIDeviceROMBAR] = true
		}

		if pp.ROMFile != nil {
			pci[mkHostPCIDeviceROMFile] = *pp.ROMFile
		} else {
			pci[mkHostPCIDeviceROMFile] = ""
		}

		if pp.XVGA != nil {
			pci[mkHostPCIDeviceXVGA] = *pp.XVGA
		} else {
			pci[mkHostPCIDeviceXVGA] = false
		}

		if pp.Mapping != nil {
			pci[mkHostPCIDeviceMapping] = *pp.Mapping
		} else {
			pci[mkHostPCIDeviceMapping] = ""
		}

		pciMap[pi] = pci
	}

	if len(clone) == 0 || len(currentPCIList) > 0 {
		orderedPCIList := utils.OrderedListFromMap(pciMap)
		err := d.Set(mkHostPCI, orderedPCIList)
		diags = append(diags, diag.FromErr(err)...)
	}

	currentUSBList := d.Get(mkHostUSB).([]interface{})
	usbMap := map[string]interface{}{}

	usbDevices := getUSBInfo(vmConfig, d)
	for pi, pp := range usbDevices {
		if (pp == nil) || (pp.HostDevice == nil && pp.Mapping == nil) {
			continue
		}

		usb := map[string]interface{}{}

		if pp.HostDevice != nil {
			usb[mkHostUSBDevice] = *pp.HostDevice
		} else {
			usb[mkHostUSBDevice] = ""
		}

		if pp.USB3 != nil {
			usb[mkHostUSBDeviceUSB3] = *pp.USB3
		} else {
			usb[mkHostUSBDeviceUSB3] = false
		}

		if pp.Mapping != nil {
			usb[mkHostUSBDeviceMapping] = *pp.Mapping
		} else {
			usb[mkHostUSBDeviceMapping] = ""
		}

		usbMap[pi] = usb
	}

	if len(clone) == 0 || len(currentUSBList) > 0 {
		// NOTE: reordering of devices by PVE may cause an issue here
		orderedUSBList := utils.OrderedListFromMap(usbMap)
		err := d.Set(mkHostUSB, orderedUSBList)
		diags = append(diags, diag.FromErr(err)...)
	}

	currentVirtiofsList := d.Get(mkVirtiofs).([]interface{})
	virtiofsMap := map[string]interface{}{}

	for pi, pp := range vmConfig.VirtiofsShares {
		if pp == nil {
			continue
		}

		share := map[string]interface{}{}

		share[mkVirtiofsMapping] = pp.DirId

		if pp.Cache != nil {
			share[mkVirtiofsCache] = *pp.Cache
		} else {
			share[mkVirtiofsCache] = dvVirtiofsCache
		}

		if pp.DirectIo != nil {
			share[mkVirtiofsDirectIO] = *pp.DirectIo
		} else {
			share[mkVirtiofsDirectIO] = dvVirtiofsDirectIo
		}

		if pp.ExposeAcl != nil {
			share[mkVirtiofsExposeACL] = *pp.ExposeAcl
		} else {
			share[mkVirtiofsExposeACL] = dvVirtiofsExposeAcl
		}

		switch {
		case pp.ExposeXattr != nil:
			share[mkVirtiofsExposeXAttr] = *pp.ExposeXattr
		case pp.ExposeAcl != nil && bool(*pp.ExposeAcl):
			// expose-xattr implies expose-acl
			share[mkVirtiofsExposeXAttr] = true
		default:
			share[mkVirtiofsExposeXAttr] = dvVirtiofsExposeXattr
		}

		virtiofsMap[pi] = share
	}

	if len(clone) == 0 || len(currentVirtiofsList) > 0 {
		orderedVirtiofsList := utils.OrderedListFromMap(virtiofsMap)
		err := d.Set(mkVirtiofs, orderedVirtiofsList)
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the initialization configuration to the one stored in the state.
	initialization := map[string]interface{}{}

	initializationInterface := findExistingCloudInitDrive(vmConfig, vmID, "")
	if initializationInterface != "" {
		initializationDevice := getStorageDevice(vmConfig, initializationInterface)
		fileVolumeParts := strings.Split(initializationDevice.FileVolume, ":")

		initialization[mkInitializationInterface] = initializationInterface
		initialization[mkInitializationDatastoreID] = fileVolumeParts[0]
	}

	if vmConfig.CloudInitDNSDomain != nil || vmConfig.CloudInitDNSServer != nil {
		initializationDNS := map[string]interface{}{}

		if vmConfig.CloudInitDNSDomain != nil {
			initializationDNS[mkInitializationDNSDomain] = *vmConfig.CloudInitDNSDomain
		} else {
			initializationDNS[mkInitializationDNSDomain] = ""
		}

		if vmConfig.CloudInitDNSServer != nil {
			dnsServer := strings.Split(*vmConfig.CloudInitDNSServer, " ")
			initializationDNS[mkInitializationDNSServers] = dnsServer
		} else {
			initializationDNS[mkInitializationDNSServers] = []string{}
		}

		initialization[mkInitializationDNS] = []interface{}{
			initializationDNS,
		}
	}

	ipConfigLast := -1
	ipConfigObjects := []*vms.CustomCloudInitIPConfig{
		vmConfig.IPConfig0,
		vmConfig.IPConfig1,
		vmConfig.IPConfig2,
		vmConfig.IPConfig3,
		vmConfig.IPConfig4,
		vmConfig.IPConfig5,
		vmConfig.IPConfig6,
		vmConfig.IPConfig7,
		vmConfig.IPConfig7,
		vmConfig.IPConfig8,
		vmConfig.IPConfig9,
		vmConfig.IPConfig10,
		vmConfig.IPConfig11,
		vmConfig.IPConfig12,
		vmConfig.IPConfig13,
		vmConfig.IPConfig14,
		vmConfig.IPConfig15,
		vmConfig.IPConfig16,
		vmConfig.IPConfig17,
		vmConfig.IPConfig18,
		vmConfig.IPConfig19,
		vmConfig.IPConfig20,
		vmConfig.IPConfig21,
		vmConfig.IPConfig22,
		vmConfig.IPConfig23,
		vmConfig.IPConfig24,
		vmConfig.IPConfig25,
		vmConfig.IPConfig26,
		vmConfig.IPConfig27,
		vmConfig.IPConfig28,
		vmConfig.IPConfig29,
		vmConfig.IPConfig30,
		vmConfig.IPConfig31,
	}
	ipConfigList := make([]interface{}, len(ipConfigObjects))

	for ipConfigIndex, ipConfig := range ipConfigObjects {
		ipConfigItem := map[string]interface{}{}

		if ipConfig != nil {
			ipConfigLast = ipConfigIndex

			if ipConfig.GatewayIPv4 != nil || ipConfig.IPv4 != nil {
				ipv4 := map[string]interface{}{}

				if ipConfig.IPv4 != nil {
					ipv4[mkInitializationIPConfigIPv4Address] = *ipConfig.IPv4
				} else {
					ipv4[mkInitializationIPConfigIPv4Address] = ""
				}

				if ipConfig.GatewayIPv4 != nil {
					ipv4[mkInitializationIPConfigIPv4Gateway] = *ipConfig.GatewayIPv4
				} else {
					ipv4[mkInitializationIPConfigIPv4Gateway] = ""
				}

				ipConfigItem[mkInitializationIPConfigIPv4] = []interface{}{
					ipv4,
				}
			} else {
				ipConfigItem[mkInitializationIPConfigIPv4] = []interface{}{}
			}

			if ipConfig.GatewayIPv6 != nil || ipConfig.IPv6 != nil {
				ipv6 := map[string]interface{}{}

				if ipConfig.IPv6 != nil {
					ipv6[mkInitializationIPConfigIPv6Address] = *ipConfig.IPv6
				} else {
					ipv6[mkInitializationIPConfigIPv6Address] = ""
				}

				if ipConfig.GatewayIPv6 != nil {
					ipv6[mkInitializationIPConfigIPv6Gateway] = *ipConfig.GatewayIPv6
				} else {
					ipv6[mkInitializationIPConfigIPv6Gateway] = ""
				}

				ipConfigItem[mkInitializationIPConfigIPv6] = []interface{}{
					ipv6,
				}
			} else {
				ipConfigItem[mkInitializationIPConfigIPv6] = []interface{}{}
			}
		} else {
			ipConfigItem[mkInitializationIPConfigIPv4] = []interface{}{}
			ipConfigItem[mkInitializationIPConfigIPv6] = []interface{}{}
		}

		ipConfigList[ipConfigIndex] = ipConfigItem
	}

	if ipConfigLast >= 0 {
		initialization[mkInitializationIPConfig] = ipConfigList[:ipConfigLast+1]
	}

	if vmConfig.CloudInitPassword != nil || vmConfig.CloudInitSSHKeys != nil ||
		vmConfig.CloudInitUsername != nil {
		initializationUserAccount := map[string]interface{}{}

		if vmConfig.CloudInitSSHKeys != nil {
			initializationUserAccount[mkInitializationUserAccountKeys] = []string(
				*vmConfig.CloudInitSSHKeys,
			)
		} else {
			initializationUserAccount[mkInitializationUserAccountKeys] = []string{}
		}

		if vmConfig.CloudInitPassword != nil {
			initializationUserAccount[mkInitializationUserAccountPassword] = *vmConfig.CloudInitPassword
		} else {
			initializationUserAccount[mkInitializationUserAccountPassword] = ""
		}

		if vmConfig.CloudInitUsername != nil {
			initializationUserAccount[mkInitializationUserAccountUsername] = *vmConfig.CloudInitUsername
		} else {
			initializationUserAccount[mkInitializationUserAccountUsername] = ""
		}

		initialization[mkInitializationUserAccount] = []interface{}{
			initializationUserAccount,
		}
	}

	if vmConfig.CloudInitFiles != nil {
		if vmConfig.CloudInitFiles.UserVolume != nil {
			initialization[mkInitializationUserDataFileID] = *vmConfig.CloudInitFiles.UserVolume
		} else {
			initialization[mkInitializationUserDataFileID] = ""
		}

		if vmConfig.CloudInitFiles.VendorVolume != nil {
			initialization[mkInitializationVendorDataFileID] = *vmConfig.CloudInitFiles.VendorVolume
		} else {
			initialization[mkInitializationVendorDataFileID] = ""
		}

		if vmConfig.CloudInitFiles.NetworkVolume != nil {
			initialization[mkInitializationNetworkDataFileID] = *vmConfig.CloudInitFiles.NetworkVolume
		} else {
			initialization[mkInitializationNetworkDataFileID] = ""
		}

		if vmConfig.CloudInitFiles.MetaVolume != nil {
			initialization[mkInitializationMetaDataFileID] = *vmConfig.CloudInitFiles.MetaVolume
		} else {
			initialization[mkInitializationMetaDataFileID] = ""
		}
	} else if len(initialization) > 0 {
		initialization[mkInitializationUserDataFileID] = ""
		initialization[mkInitializationVendorDataFileID] = ""
		initialization[mkInitializationNetworkDataFileID] = ""
		initialization[mkInitializationMetaDataFileID] = ""
	}

	if vmConfig.CloudInitType != nil {
		initialization[mkInitializationType] = *vmConfig.CloudInitType
	} else if len(initialization) > 0 {
		initialization[mkInitializationType] = ""
	}

	currentInitialization := d.Get(mkInitialization).([]interface{})

	//nolint:gocritic
	if len(clone) > 0 {
		if len(currentInitialization) > 0 {
			if len(initialization) > 0 {
				err := d.Set(mkInitialization, []interface{}{initialization})
				diags = append(diags, diag.FromErr(err)...)
			} else {
				err := d.Set(mkInitialization, []interface{}{})
				diags = append(diags, diag.FromErr(err)...)
			}
		}
	} else if len(initialization) > 0 {
		err := d.Set(mkInitialization, []interface{}{initialization})
		diags = append(diags, diag.FromErr(err)...)
	} else {
		err := d.Set(mkInitialization, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the operating system configuration to the one stored in the state.
	kvmArguments := map[string]interface{}{}

	if vmConfig.KVMArguments != nil {
		kvmArguments[mkKVMArguments] = *vmConfig.KVMArguments
	} else {
		kvmArguments[mkKVMArguments] = ""
	}

	// Compare the memory configuration to the one stored in the state.
	memory := map[string]interface{}{}

	if vmConfig.DedicatedMemory != nil {
		memory[mkMemoryDedicated] = int(*vmConfig.DedicatedMemory)
	} else {
		memory[mkMemoryDedicated] = 0
	}

	if vmConfig.FloatingMemory != nil {
		memory[mkMemoryFloating] = int(*vmConfig.FloatingMemory)
	} else {
		memory[mkMemoryFloating] = 0
	}

	if vmConfig.SharedMemory != nil {
		memory[mkMemoryShared] = vmConfig.SharedMemory.Size
	} else {
		memory[mkMemoryShared] = 0
	}

	if vmConfig.Hugepages != nil {
		memory[mkMemoryHugepages] = *vmConfig.Hugepages
	} else {
		memory[mkMemoryHugepages] = ""
	}

	if vmConfig.KeepHugepages != nil {
		memory[mkMemoryKeepHugepages] = *vmConfig.KeepHugepages
	} else {
		memory[mkMemoryKeepHugepages] = false
	}

	currentMemory := d.Get(mkMemory).([]interface{})

	if len(clone) > 0 {
		if len(currentMemory) > 0 {
			err := d.Set(mkMemory, []interface{}{memory})
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if len(currentMemory) > 0 ||
		memory[mkMemoryDedicated] != dvMemoryDedicated ||
		memory[mkMemoryFloating] != dvMemoryFloating ||
		memory[mkMemoryShared] != dvMemoryShared ||
		memory[mkMemoryHugepages] != dvMemoryHugepages ||
		memory[mkMemoryKeepHugepages] != dvMemoryKeepHugepages {
		err := d.Set(mkMemory, []interface{}{memory})
		diags = append(diags, diag.FromErr(err)...)
	}

	diags = append(diags, network.ReadNetworkDeviceObjects(d, vmConfig)...)

	// Compare the operating system configuration to the one stored in the state.
	operatingSystem := map[string]interface{}{}

	if vmConfig.OSType != nil {
		operatingSystem[mkOperatingSystemType] = *vmConfig.OSType
	} else {
		operatingSystem[mkOperatingSystemType] = ""
	}

	currentOperatingSystem := d.Get(mkOperatingSystem).([]interface{})

	switch {
	case len(clone) > 0:
		if len(currentOperatingSystem) > 0 {
			err := d.Set(
				mkOperatingSystem,
				[]interface{}{operatingSystem},
			)
			diags = append(diags, diag.FromErr(err)...)
		}
	case len(currentOperatingSystem) > 0 || operatingSystem[mkOperatingSystemType] != dvOperatingSystemType:
		err := d.Set(mkOperatingSystem, []interface{}{operatingSystem})
		diags = append(diags, diag.FromErr(err)...)
	default:
		err := d.Set(mkOperatingSystem, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the pool ID to the value stored in the state.
	currentPoolID := d.Get(mkPoolID).(string)

	if len(clone) == 0 || currentPoolID != dvPoolID {
		if vmConfig.PoolID != nil {
			err := d.Set(mkPoolID, *vmConfig.PoolID)
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Compare the serial devices to those stored in the state.
	serialDevices := make([]interface{}, 4)
	serialDevicesArray := []*string{
		vmConfig.SerialDevice0,
		vmConfig.SerialDevice1,
		vmConfig.SerialDevice2,
		vmConfig.SerialDevice3,
	}
	serialDevicesCount := 0

	for sdi, sd := range serialDevicesArray {
		m := map[string]interface{}{}

		if sd != nil {
			m[mkSerialDeviceDevice] = *sd
			serialDevicesCount = sdi + 1
		} else {
			m[mkSerialDeviceDevice] = ""
		}

		serialDevices[sdi] = m
	}

	currentSerialDevice := d.Get(mkSerialDevice).([]interface{})

	if len(clone) == 0 || len(currentSerialDevice) > 0 {
		err := d.Set(mkSerialDevice, serialDevices[:serialDevicesCount])
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare the SMBIOS to the one stored in the state.
	var smbios map[string]interface{}

	if vmConfig.SMBIOS != nil {
		smbios = map[string]interface{}{}

		if vmConfig.SMBIOS.Family != nil {
			b, err := base64.StdEncoding.DecodeString(*vmConfig.SMBIOS.Family)
			diags = append(diags, diag.FromErr(err)...)
			smbios[mkSMBIOSFamily] = string(b)
		} else {
			smbios[mkSMBIOSFamily] = dvSMBIOSFamily
		}

		if vmConfig.SMBIOS.Manufacturer != nil {
			b, err := base64.StdEncoding.DecodeString(*vmConfig.SMBIOS.Manufacturer)
			diags = append(diags, diag.FromErr(err)...)
			smbios[mkSMBIOSManufacturer] = string(b)
		} else {
			smbios[mkSMBIOSManufacturer] = dvSMBIOSManufacturer
		}

		if vmConfig.SMBIOS.Product != nil {
			b, err := base64.StdEncoding.DecodeString(*vmConfig.SMBIOS.Product)
			diags = append(diags, diag.FromErr(err)...)
			smbios[mkSMBIOSProduct] = string(b)
		} else {
			smbios[mkSMBIOSProduct] = dvSMBIOSProduct
		}

		if vmConfig.SMBIOS.Serial != nil {
			b, err := base64.StdEncoding.DecodeString(*vmConfig.SMBIOS.Serial)
			diags = append(diags, diag.FromErr(err)...)
			smbios[mkSMBIOSSerial] = string(b)
		} else {
			smbios[mkSMBIOSSerial] = dvSMBIOSSerial
		}

		if vmConfig.SMBIOS.SKU != nil {
			b, err := base64.StdEncoding.DecodeString(*vmConfig.SMBIOS.SKU)
			diags = append(diags, diag.FromErr(err)...)
			smbios[mkSMBIOSSKU] = string(b)
		} else {
			smbios[mkSMBIOSSKU] = dvSMBIOSSKU
		}

		if vmConfig.SMBIOS.Version != nil {
			b, err := base64.StdEncoding.DecodeString(*vmConfig.SMBIOS.Version)
			diags = append(diags, diag.FromErr(err)...)
			smbios[mkSMBIOSVersion] = string(b)
		} else {
			smbios[mkSMBIOSVersion] = dvSMBIOSVersion
		}

		if vmConfig.SMBIOS.UUID != nil {
			smbios[mkSMBIOSUUID] = *vmConfig.SMBIOS.UUID
		} else {
			smbios[mkSMBIOSUUID] = nil
		}
	}

	currentSMBIOS := d.Get(mkSMBIOS).([]interface{})

	switch {
	case len(clone) > 0:
		if len(currentSMBIOS) > 0 {
			err := d.Set(mkSMBIOS, currentSMBIOS)
			diags = append(diags, diag.FromErr(err)...)
		}
	case len(smbios) == 0:
		err := d.Set(mkSMBIOS, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	default:
		if len(currentSMBIOS) > 0 ||
			smbios[mkSMBIOSFamily] != dvSMBIOSFamily ||
			smbios[mkSMBIOSManufacturer] != dvSMBIOSManufacturer ||
			smbios[mkSMBIOSProduct] != dvSMBIOSProduct ||
			smbios[mkSMBIOSSerial] != dvSMBIOSSerial ||
			smbios[mkSMBIOSSKU] != dvSMBIOSSKU ||
			smbios[mkSMBIOSVersion] != dvSMBIOSVersion {
			err := d.Set(mkSMBIOS, []interface{}{smbios})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Compare the startup order to the one stored in the state.
	var startup map[string]interface{}

	if vmConfig.StartupOrder != nil {
		startup = map[string]interface{}{}

		if vmConfig.StartupOrder.Order != nil {
			startup[mkStartupOrder] = *vmConfig.StartupOrder.Order
		} else {
			startup[mkStartupOrder] = dvStartupOrder
		}

		if vmConfig.StartupOrder.Up != nil {
			startup[mkStartupUpDelay] = *vmConfig.StartupOrder.Up
		} else {
			startup[mkStartupUpDelay] = dvStartupUpDelay
		}

		if vmConfig.StartupOrder.Down != nil {
			startup[mkStartupDownDelay] = *vmConfig.StartupOrder.Down
		} else {
			startup[mkStartupDownDelay] = dvStartupDownDelay
		}
	}

	currentStartup := d.Get(mkStartup).([]interface{})

	switch {
	case len(clone) > 0:
		if len(currentStartup) > 0 {
			err := d.Set(mkStartup, []interface{}{startup})
			diags = append(diags, diag.FromErr(err)...)
		}
	case len(startup) == 0:
		err := d.Set(mkStartup, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	default:
		if len(currentStartup) > 0 ||
			startup[mkStartupOrder] != mkStartupOrder ||
			startup[mkStartupUpDelay] != dvStartupUpDelay ||
			startup[mkStartupDownDelay] != dvStartupDownDelay {
			err := d.Set(mkStartup, []interface{}{startup})
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Compare the VGA configuration to the one stored in the state.
	vga := map[string]interface{}{}

	if vmConfig.VGADevice != nil {
		if vmConfig.VGADevice.Clipboard != nil {
			vga[mkVGAClipboard] = *vmConfig.VGADevice.Clipboard
		} else {
			vga[mkVGAClipboard] = dvVGAClipboard
		}

		if vmConfig.VGADevice.Memory != nil {
			vga[mkVGAMemory] = int(*vmConfig.VGADevice.Memory)
		} else {
			vga[mkVGAMemory] = dvVGAMemory
		}

		if vmConfig.VGADevice.Type != nil {
			vga[mkVGAType] = *vmConfig.VGADevice.Type
		}
	} else {
		vga[mkVGAClipboard] = dvVGAClipboard
		vga[mkVGAMemory] = dvVGAMemory
		vga[mkVGAType] = dvVGAType
	}

	currentVGA := d.Get(mkVGA).([]interface{})

	switch {
	case len(clone) > 0 && len(currentVGA) > 0:
		err := d.Set(mkVGA, []interface{}{vga})
		diags = append(diags, diag.FromErr(err)...)
	case len(currentVGA) > 0 ||
		vga[mkVGAClipboard] != dvVGAClipboard ||
		vga[mkVGAMemory] != dvVGAMemory ||
		vga[mkVGAType] != dvVGAType:
		err := d.Set(mkVGA, []interface{}{vga})
		diags = append(diags, diag.FromErr(err)...)
	default:
		err := d.Set(mkVGA, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	}

	// Compare SCSI hardware type
	scsiHardware := d.Get(mkSCSIHardware).(string)

	if len(clone) == 0 || scsiHardware != dvSCSIHardware {
		if vmConfig.SCSIHardware != nil {
			err := d.Set(mkSCSIHardware, *vmConfig.SCSIHardware)
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	watchdog := map[string]interface{}{}

	if vmConfig.WatchdogDevice != nil {
		watchdog[mkWatchdogEnabled] = true

		if vmConfig.WatchdogDevice.Action != nil {
			watchdog[mkWatchdogAction] = *vmConfig.WatchdogDevice.Action
		} else {
			watchdog[mkWatchdogAction] = dvWatchdogAction
		}

		if vmConfig.WatchdogDevice.Model != nil {
			watchdog[mkWatchdogModel] = *vmConfig.WatchdogDevice.Model
		} else {
			watchdog[mkWatchdogModel] = dvWatchdogModel
		}
	} else {
		watchdog[mkWatchdogEnabled] = false
		watchdog[mkWatchdogAction] = dvWatchdogAction
		watchdog[mkWatchdogModel] = dvWatchdogModel
	}

	currentWatchdog := d.Get(mkWatchdog).([]interface{})
	currentWatchdogEnabled := len(currentWatchdog) > 0 &&
		currentWatchdog[0] != nil && currentWatchdog[0].(map[string]interface{})[mkWatchdogEnabled].(bool)
	currentWatchdogDisabled := len(currentWatchdog) > 0 &&
		currentWatchdog[0] != nil && !currentWatchdog[0].(map[string]interface{})[mkWatchdogEnabled].(bool)

	switch {
	case len(clone) > 0 && len(currentWatchdog) > 0:
		err := d.Set(mkWatchdog, []interface{}{watchdog})
		diags = append(diags, diag.FromErr(err)...)
	case currentWatchdogEnabled ||
		watchdog[mkWatchdogEnabled] != false ||
		watchdog[mkWatchdogAction] != dvWatchdogAction ||
		watchdog[mkWatchdogModel] != dvWatchdogModel:
		err := d.Set(mkWatchdog, []interface{}{watchdog})
		diags = append(diags, diag.FromErr(err)...)
	case currentWatchdogDisabled && vmConfig.WatchdogDevice == nil:
		// do nothing
	default:
		err := d.Set(mkWatchdog, []interface{}{})
		diags = append(diags, diag.FromErr(err)...)
	}

	vmAPI := client.Node(nodeName).VM(vmID)
	started := d.Get(mkStarted).(bool)

	agentTimeout, e := getAgentTimeout(d)
	if e != nil {
		return diag.FromErr(e)
	}

	diags = append(
		diags,
		network.ReadNetworkValues(ctx, d, vmAPI, started, vmConfig, agentTimeout)...)

	// during import these core attributes might not be set, so set them explicitly here
	d.SetId(strconv.Itoa(vmID))
	e = d.Set(mkVMID, vmID)
	diags = append(diags, diag.FromErr(e)...)
	e = d.Set(mkNodeName, nodeName)
	diags = append(diags, diag.FromErr(e)...)

	return diags
}

func vmReadPrimitiveValues(
	d *schema.ResourceData,
	vmConfig *vms.GetResponseData,
) diag.Diagnostics {
	var diags diag.Diagnostics

	var err error

	clone := d.Get(mkClone).([]interface{})
	currentACPI := d.Get(mkACPI).(bool)

	if len(clone) == 0 || !currentACPI {
		if vmConfig.ACPI != nil {
			err = d.Set(mkACPI, bool(*vmConfig.ACPI))
		} else {
			// Default value of "acpi" is "1" according to the API documentation.
			err = d.Set(mkACPI, true)
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentKVMArguments := d.Get(mkKVMArguments).(string)

	if len(clone) == 0 || currentKVMArguments != dvKVMArguments {
		// PVE API returns "args" as " " if it is set to empty.
		if vmConfig.KVMArguments != nil && len(strings.TrimSpace(*vmConfig.KVMArguments)) > 0 {
			err = d.Set(mkKVMArguments, *vmConfig.KVMArguments)
		} else {
			// Default value of "args" is "" according to the API documentation.
			err = d.Set(mkKVMArguments, "")
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentBIOS := d.Get(mkBIOS).(string)

	if len(clone) == 0 || currentBIOS != dvBIOS {
		if vmConfig.BIOS != nil {
			err = d.Set(mkBIOS, *vmConfig.BIOS)
		} else {
			// Default value of "bios" is "seabios" according to the API documentation.
			err = d.Set(mkBIOS, "seabios")
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentDescription := d.Get(mkDescription).(string)

	if len(clone) == 0 || currentDescription != dvDescription {
		if vmConfig.Description != nil {
			err = d.Set(mkDescription, *vmConfig.Description)
		} else {
			// Default value of "description" is "" according to the API documentation.
			err = d.Set(mkDescription, "")
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentTags := d.Get(mkTags).([]interface{})

	if len(clone) == 0 || len(currentTags) > 0 {
		var tags []string

		if vmConfig.Tags != nil {
			for _, tag := range strings.Split(*vmConfig.Tags, ";") {
				t := strings.TrimSpace(tag)
				if len(t) > 0 {
					tags = append(tags, t)
				}
			}

			sort.Strings(tags)
		}

		err = d.Set(mkTags, tags)
		diags = append(diags, diag.FromErr(err)...)
	}

	currentKeyboardLayout := d.Get(mkKeyboardLayout).(string)

	if len(clone) == 0 || currentKeyboardLayout != dvKeyboardLayout {
		if vmConfig.KeyboardLayout != nil {
			err = d.Set(mkKeyboardLayout, *vmConfig.KeyboardLayout)
		} else {
			// Default value of "keyboard" is "" according to the API documentation.
			err = d.Set(mkKeyboardLayout, "")
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentMachine := d.Get(mkMachine).(string)

	if len(clone) == 0 || currentMachine != dvMachineType {
		if vmConfig.Machine != nil {
			err = d.Set(mkMachine, *vmConfig.Machine)
		} else {
			err = d.Set(mkMachine, "")
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentName := d.Get(mkName).(string)

	if len(clone) == 0 || currentName != dvName {
		if vmConfig.Name != nil {
			err = d.Set(mkName, *vmConfig.Name)
		} else {
			// Default value of "name" is "" according to the API documentation.
			err = d.Set(mkName, "")
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentProtection := d.Get(mkProtection).(bool)

	if len(clone) == 0 || currentProtection {
		if vmConfig.DeletionProtection != nil {
			err = d.Set(
				mkProtection,
				bool(*vmConfig.DeletionProtection),
			)
		} else {
			// Default value of "protection" is "0" according to the API documentation.
			err = d.Set(mkProtection, false)
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentTabletDevice := d.Get(mkTabletDevice).(bool)

	if len(clone) == 0 || !currentTabletDevice {
		if vmConfig.TabletDeviceEnabled != nil {
			err = d.Set(
				mkTabletDevice,
				bool(*vmConfig.TabletDeviceEnabled),
			)
		} else {
			// Default value of "tablet" is "1" according to the API documentation.
			err = d.Set(mkTabletDevice, true)
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	currentTemplate := d.Get(mkTemplate).(bool)

	if len(clone) == 0 || currentTemplate {
		if vmConfig.Template != nil {
			err = d.Set(mkTemplate, bool(*vmConfig.Template))
		} else {
			// Default value of "template" is "0" according to the API documentation.
			err = d.Set(mkTemplate, false)
		}

		diags = append(diags, diag.FromErr(err)...)
	}

	return diags
}

// vmUpdatePool moves the VM to the pool it is supposed to be in if the pool ID changed.
func vmUpdatePool(
	ctx context.Context,
	d *schema.ResourceData,
	api *pools.Client,
	vmID int,
) error {
	oldPoolValue, newPoolValue := d.GetChange(mkPoolID)
	if cmp.Equal(newPoolValue, oldPoolValue) {
		return nil
	}

	oldPool := oldPoolValue.(string)
	newPool := newPoolValue.(string)
	vmList := (types.CustomCommaSeparatedList)([]string{strconv.Itoa(vmID)})

	tflog.Debug(ctx, fmt.Sprintf("Moving VM %d from pool '%s' to pool '%s'", vmID, oldPool, newPool))

	if oldPool != "" {
		trueValue := types.CustomBool(true)
		poolUpdate := &pools.PoolUpdateRequestBody{
			VMs:    &vmList,
			Delete: &trueValue,
		}

		err := api.UpdatePool(ctx, oldPool, poolUpdate)
		if err != nil {
			return fmt.Errorf("while removing VM %d from pool %s: %w", vmID, oldPool, err)
		}
	}

	if newPool != "" {
		poolUpdate := &pools.PoolUpdateRequestBody{VMs: &vmList}

		err := api.UpdatePool(ctx, newPool, poolUpdate)
		if err != nil {
			return fmt.Errorf("while adding VM %d to pool %s: %w", vmID, newPool, err)
		}
	}

	return nil
}

func vmUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, e := config.GetClient()
	if e != nil {
		return diag.FromErr(e)
	}

	nodeName := d.Get(mkNodeName).(string)
	rebootRequired := false

	vmID, e := strconv.Atoi(d.Id())
	if e != nil {
		return diag.FromErr(e)
	}

	e = vmUpdatePool(ctx, d, client.Pool(), vmID)
	if e != nil {
		return diag.FromErr(e)
	}

	// If the node name has changed we need to migrate the VM to the new node before we do anything else.
	if d.HasChange(mkNodeName) {
		migrateTimeoutSec := d.Get(mkTimeoutMigrate).(int)

		migrateCtx, cancel := context.WithTimeout(ctx, time.Duration(migrateTimeoutSec)*time.Second)
		defer cancel()

		oldNodeNameValue, _ := d.GetChange(mkNodeName)
		oldNodeName := oldNodeNameValue.(string)
		vmAPI := client.Node(oldNodeName).VM(vmID)

		trueValue := types.CustomBool(true)
		migrateBody := &vms.MigrateRequestBody{
			TargetNode:      nodeName,
			WithLocalDisks:  &trueValue,
			OnlineMigration: &trueValue,
		}

		err := vmAPI.MigrateVM(migrateCtx, migrateBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	vmAPI := client.Node(nodeName).VM(vmID)

	updateBody := &vms.UpdateRequestBody{}

	var del []string

	resource := VM()

	// Retrieve the entire configuration as we need to process certain values.
	vmConfig, e := vmAPI.GetVM(ctx)
	if e != nil {
		return diag.FromErr(e)
	}

	// Prepare the new primitive configuration values.
	if d.HasChange(mkACPI) {
		acpi := types.CustomBool(d.Get(mkACPI).(bool))
		updateBody.ACPI = &acpi
		rebootRequired = true
	}

	if d.HasChange(mkKVMArguments) {
		kvmArguments := d.Get(mkKVMArguments).(string)
		updateBody.KVMArguments = &kvmArguments
		rebootRequired = true
	}

	if d.HasChange(mkBIOS) {
		bios := d.Get(mkBIOS).(string)
		updateBody.BIOS = &bios
		rebootRequired = true
	}

	if d.HasChange(mkDescription) {
		description := d.Get(mkDescription).(string)
		updateBody.Description = &description
	}

	if d.HasChange(mkOnBoot) {
		startOnBoot := types.CustomBool(d.Get(mkOnBoot).(bool))
		updateBody.StartOnBoot = &startOnBoot
	}

	if d.HasChange(mkTags) {
		tagString := vmGetTagsString(d)
		updateBody.Tags = &tagString
	}

	if d.HasChange(mkKeyboardLayout) {
		keyboardLayout := d.Get(mkKeyboardLayout).(string)
		updateBody.KeyboardLayout = &keyboardLayout
		rebootRequired = true
	}

	if d.HasChange(mkMachine) {
		machine := d.Get(mkMachine).(string)
		updateBody.Machine = &machine
		rebootRequired = true
	}

	name := d.Get(mkName).(string)

	if name == "" {
		del = append(del, "name")
	} else {
		updateBody.Name = &name
	}

	if d.HasChange(mkProtection) {
		protection := types.CustomBool(d.Get(mkProtection).(bool))
		updateBody.DeletionProtection = &protection
	}

	if d.HasChange(mkTabletDevice) {
		tabletDevice := types.CustomBool(d.Get(mkTabletDevice).(bool))
		updateBody.TabletDeviceEnabled = &tabletDevice
		rebootRequired = true
	}

	template := types.CustomBool(d.Get(mkTemplate).(bool))

	if d.HasChange(mkTemplate) {
		updateBody.Template = &template
		rebootRequired = true
	}

	// Prepare the new agent configuration.
	if d.HasChange(mkAgent) {
		agentBlock, err := structure.GetSchemaBlock(
			resource,
			d,
			[]string{mkAgent},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		agentEnabled := types.CustomBool(
			agentBlock[mkAgentEnabled].(bool),
		)
		agentTrim := types.CustomBool(agentBlock[mkAgentTrim].(bool))
		agentType := agentBlock[mkAgentType].(string)

		updateBody.Agent = &vms.CustomAgent{
			Enabled:         &agentEnabled,
			TrimClonedDisks: &agentTrim,
			Type:            &agentType,
		}

		rebootRequired = true
	}

	// Prepare the new amdsev configuration.
	if d.HasChange(mkAMDSEV) {
		amdsev := vmGetAMDSEVObject(d)

		updateBody.AMDSEV = amdsev

		rebootRequired = true
	}

	// Prepare the new audio devices.
	if d.HasChange(mkAudioDevice) {
		updateBody.AudioDevices = vmGetAudioDeviceList(d)

		for i, ad := range updateBody.AudioDevices {
			if !ad.Enabled {
				del = append(del, fmt.Sprintf("audio%d", i))
			}
		}

		for i := len(updateBody.AudioDevices); i < maxResourceVirtualEnvironmentVMAudioDevices; i++ {
			del = append(del, fmt.Sprintf("audio%d", i))
		}

		rebootRequired = true
	}

	// Prepare the new boot configuration.
	if d.HasChange(mkBootOrder) {
		bootOrder := d.Get(mkBootOrder).([]interface{})
		bootOrderConverted := make([]string, len(bootOrder))

		for i, device := range bootOrder {
			bootOrderConverted[i] = device.(string)
		}

		updateBody.Boot = &vms.CustomBoot{
			Order: &bootOrderConverted,
		}
		rebootRequired = true
	}

	// Prepare the new CD-ROM configuration.

	if d.HasChange(mkCDROM) {
		cdromBlock, err := structure.GetSchemaBlock(
			resource,
			d,
			[]string{mkCDROM},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		cdromFileID := cdromBlock[mkCDROMFileID].(string)
		cdromInterface := cdromBlock[mkCDROMInterface].(string)

		old, _ := d.GetChange(mkCDROM)

		if len(old.([]interface{})) > 0 && old.([]interface{})[0] != nil {
			oldList := old.([]interface{})[0]
			oldBlock := oldList.(map[string]interface{})

			// If the interface is not set, use the default, for backward compatibility.
			oldInterface, ok := oldBlock[mkCDROMInterface].(string)
			if !ok || oldInterface == "" {
				oldInterface = dvCDROMInterface
			}

			if oldInterface != cdromInterface {
				del = append(del, oldInterface)
			}
		}

		if cdromFileID == "" {
			cdromFileID = "cdrom"
		}

		cdromMedia := "cdrom"

		updateBody.AddCustomStorageDevice(cdromInterface, vms.CustomStorageDevice{
			FileVolume: cdromFileID,
			Media:      &cdromMedia,
		})
	}

	// Prepare the new CPU configuration.

	if d.HasChange(mkCPU) {
		cpuBlock, err := structure.GetSchemaBlock(
			resource,
			d,
			[]string{mkCPU},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		cpuArchitecture := cpuBlock[mkCPUArchitecture].(string)
		cpuCores := cpuBlock[mkCPUCores].(int)
		cpuFlags := cpuBlock[mkCPUFlags].([]interface{})
		cpuHotplugged := cpuBlock[mkCPUHotplugged].(int)
		cpuLimit := cpuBlock[mkCPULimit].(int)
		cpuNUMA := types.CustomBool(cpuBlock[mkCPUNUMA].(bool))
		cpuSockets := cpuBlock[mkCPUSockets].(int)
		cpuType := cpuBlock[mkCPUType].(string)
		cpuUnits := cpuBlock[mkCPUUnits].(int)
		cpuAffinity := cpuBlock[mkCPUAffinity].(string)

		if err = setCPUArchitecture(ctx, cpuArchitecture, client, updateBody); err != nil {
			return diag.FromErr(err)
		}

		updateBody.CPUCores = ptr.Ptr(int64(cpuCores))
		updateBody.CPUSockets = ptr.Ptr(int64(cpuSockets))
		updateBody.CPUUnits = ptr.Ptr(int64(cpuUnits))
		updateBody.NUMAEnabled = &cpuNUMA

		// CPU affinity is a special case, only root can change it.
		// we can't even have it in the delete list, as PVE will return an error for non-root.
		// Hence, checking explicitly if it has changed.
		if d.HasChange(mkCPU + ".0." + mkCPUAffinity) {
			if cpuAffinity != "" {
				updateBody.CPUAffinity = &cpuAffinity
			} else {
				del = append(del, "affinity")
			}
		}

		if cpuHotplugged > 0 {
			updateBody.VirtualCPUCount = ptr.Ptr(int64(cpuHotplugged))
		} else {
			del = append(del, "vcpus")
		}

		if cpuLimit > 0 {
			updateBody.CPULimit = ptr.Ptr(int64(cpuLimit))
		} else {
			del = append(del, "cpulimit")
		}

		cpuFlagsConverted := make([]string, len(cpuFlags))

		for fi, flag := range cpuFlags {
			cpuFlagsConverted[fi] = flag.(string)
		}

		updateBody.CPUEmulation = &vms.CustomCPUEmulation{
			Flags: &cpuFlagsConverted,
			Type:  cpuType,
		}

		rebootRequired = true
	}

	// Prepare the new disk device configuration.
	allDiskInfo := disk.GetInfo(vmConfig, d)

	planDisks, err := disk.GetDiskDeviceObjects(d, resource, nil)
	if err != nil {
		return diag.FromErr(err)
	}

	rr, err := disk.Update(ctx, client, nodeName, vmID, d, planDisks, allDiskInfo, updateBody)
	if err != nil {
		return diag.FromErr(err)
	}

	rebootRequired = rebootRequired || rr

	// Prepare the new efi disk configuration.
	if d.HasChange(mkEFIDisk) {
		efiDisk := vmGetEfiDisk(d, nil)

		updateBody.EFIDisk = efiDisk

		rebootRequired = true
	}

	// Prepare the new tpm state configuration.
	if d.HasChange(mkTPMState) {
		tpmState := vmGetTPMState(d, nil)

		updateBody.TPMState = tpmState

		rebootRequired = true
	}

	// Prepare the new RNG configuration.
	if d.HasChange(mkRNG) {
		rngDevice := vmGetRNGDevice(d)

		updateBody.RNGDevice = rngDevice

		rebootRequired = true
	}

	// Prepare the new cloud-init configuration.
	stoppedBeforeUpdate := false
	cloudInitRebuildRequired := false

	if d.HasChange(mkInitialization) {
		cloudInitConfig := vmGetCloudInitConfig(d)

		updateBody.CloudInitConfig = cloudInitConfig

		initialization := d.Get(mkInitialization).([]interface{})

		if updateBody.CloudInitConfig != nil && len(initialization) > 0 && initialization[0] != nil {
			var fileVolume string

			initializationBlock := initialization[0].(map[string]interface{})
			initializationDatastoreID := initializationBlock[mkInitializationDatastoreID].(string)
			initializationInterface := initializationBlock[mkInitializationInterface].(string)
			cdromMedia := "cdrom"

			existingInterface := findExistingCloudInitDrive(vmConfig, vmID, "")
			if initializationInterface == "" && existingInterface == "" {
				initializationInterface = "ide2"
			} else if initializationInterface == "" {
				initializationInterface = existingInterface
			}

			mustMove := existingInterface != "" && initializationInterface != existingInterface
			if mustMove {
				tflog.Debug(ctx, fmt.Sprintf("CloudInit must be moved from %s to %s", existingInterface, initializationInterface))
			}

			mustChangeDatastore := false

			oldInit, _ := d.GetChange(mkInitialization)
			if len(oldInit.([]interface{})) > 0 {
				oldInitBlock := oldInit.([]interface{})[0].(map[string]interface{})
				prevDatastoreID := oldInitBlock[mkInitializationDatastoreID].(string)

				mustChangeDatastore = prevDatastoreID != initializationDatastoreID
				if mustChangeDatastore {
					tflog.Debug(ctx, fmt.Sprintf("CloudInit must be moved from datastore %s to datastore %s",
						prevDatastoreID, initializationDatastoreID))
				}
			}

			if mustMove || mustChangeDatastore || existingInterface == "" {
				// CloudInit must be moved, either from a device to another or from a datastore
				// to another (or both). This requires the VM to be stopped.
				if er := vmShutdown(ctx, vmAPI, d); er != nil {
					return er
				}

				if er := deleteIdeDrives(ctx, vmAPI, initializationInterface, existingInterface); er != nil {
					return er
				}

				stoppedBeforeUpdate = true
				fileVolume = fmt.Sprintf("%s:cloudinit", initializationDatastoreID)
			} else {
				ideDevice := getStorageDevice(vmConfig, existingInterface)
				fileVolume = ideDevice.FileVolume
			}

			updateBody.AddCustomStorageDevice(initializationInterface, vms.CustomStorageDevice{
				FileVolume: fileVolume,
				Media:      &cdromMedia,
			})
		}

		cloudInitRebuildRequired = true
		rebootRequired = true
	}

	// Prepare the new hostpci devices configuration.
	if d.HasChange(mkHostPCI) {
		updateBody.PCIDevices = vmGetHostPCIDeviceObjects(d)

		for i := len(updateBody.PCIDevices); i < maxResourceVirtualEnvironmentVMHostPCIDevices; i++ {
			del = append(del, fmt.Sprintf("hostpci%d", i))
		}

		rebootRequired = true
	}

	// Prepare the new numa devices configuration.
	if d.HasChange(mkNUMA) {
		updateBody.NUMADevices = vmGetNumaDeviceObjects(d)

		for i := len(updateBody.NUMADevices); i < maxResourceVirtualEnvironmentVMNUMADevices; i++ {
			del = append(del, fmt.Sprintf("numa%d", i))
		}

		rebootRequired = true
	}

	// Prepare the new usb devices configuration.
	if d.HasChange(mkHostUSB) {
		updateBody.USBDevices = vmGetHostUSBDeviceObjects(d)

		for i := len(updateBody.USBDevices); i < maxResourceVirtualEnvironmentVMHostUSBDevices; i++ {
			del = append(del, fmt.Sprintf("usb%d", i))
		}

		rebootRequired = true
	}

	// Prepare the new memory configuration.
	if d.HasChange(mkMemory) {
		memoryBlock, er := structure.GetSchemaBlock(
			resource,
			d,
			[]string{mkMemory},
			0,
			true,
		)
		if er != nil {
			return diag.FromErr(er)
		}

		memoryDedicated := memoryBlock[mkMemoryDedicated].(int)
		memoryFloating := memoryBlock[mkMemoryFloating].(int)
		memoryShared := memoryBlock[mkMemoryShared].(int)
		memoryHugepages := memoryBlock[mkMemoryHugepages].(string)
		memoryKeepHugepages := types.CustomBool(memoryBlock[mkMemoryKeepHugepages].(bool))

		updateBody.DedicatedMemory = &memoryDedicated
		updateBody.FloatingMemory = &memoryFloating

		if memoryShared > 0 {
			memorySharedName := fmt.Sprintf("vm-%d-ivshmem", vmID)

			updateBody.SharedMemory = &vms.CustomSharedMemory{
				Name: &memorySharedName,
				Size: memoryShared,
			}
		}

		if d.HasChange(mkMemory + ".0." + mkMemoryHugepages) {
			if memoryHugepages != "" {
				updateBody.Hugepages = &memoryHugepages
			} else {
				del = append(del, "hugepages")
			}
		}

		if d.HasChange(mkMemory + ".0." + mkMemoryKeepHugepages) {
			if memoryHugepages != "" {
				updateBody.KeepHugepages = &memoryKeepHugepages
			} else {
				del = append(del, "keephugepages")
			}
		}

		rebootRequired = true
	}

	// Prepare the new network device configuration.

	if d.HasChange(network.MkNetworkDevice) {
		updateBody.NetworkDevices, err = network.GetNetworkDeviceObjects(d)
		if err != nil {
			return diag.FromErr(err)
		}

		for i, nd := range updateBody.NetworkDevices {
			if !nd.Enabled {
				del = append(del, fmt.Sprintf("net%d", i))
			}
		}

		for i := len(updateBody.NetworkDevices); i < network.MaxNetworkDevices; i++ {
			del = append(del, fmt.Sprintf("net%d", i))
		}

		rebootRequired = true
	}

	// Prepare the new operating system configuration.
	if d.HasChange(mkOperatingSystem) {
		operatingSystem, err := structure.GetSchemaBlock(
			resource,
			d,
			[]string{mkOperatingSystem},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		operatingSystemType := operatingSystem[mkOperatingSystemType].(string)

		updateBody.OSType = &operatingSystemType

		rebootRequired = true
	}

	// Prepare the new serial devices.
	if d.HasChange(mkSerialDevice) {
		updateBody.SerialDevices = vmGetSerialDeviceList(d)

		for i := len(updateBody.SerialDevices); i < maxResourceVirtualEnvironmentVMSerialDevices; i++ {
			del = append(del, fmt.Sprintf("serial%d", i))
		}

		rebootRequired = true
	}

	if d.HasChange(mkSMBIOS) {
		updateBody.SMBIOS = vmGetSMBIOS(d)
		if updateBody.SMBIOS == nil {
			del = append(del, "smbios1")
		}
	}

	if d.HasChange(mkStartup) {
		updateBody.StartupOrder = vmGetStartupOrder(d)
		if updateBody.StartupOrder == nil {
			del = append(del, "startup")
		}
	}

	// Prepare the new VGA configuration.
	if d.HasChange(mkVGA) {
		updateBody.VGADevice = vmGetVGADeviceObject(d)
		rebootRequired = true
	}

	// Prepare the new Virtiofs shares configuration.
	if d.HasChange(mkVirtiofs) {
		updateBody.VirtiofsShares = vmGetVirtiofsShares(d)

		for i := len(updateBody.VirtiofsShares); i < maxResourceVirtualEnvironmentVirtiofsShares; i++ {
			del = append(del, fmt.Sprintf("virtiofs%d", i))
		}

		rebootRequired = true
	}

	// Prepare the new SCSI hardware type
	if d.HasChange(mkSCSIHardware) {
		scsiHardware := d.Get(mkSCSIHardware).(string)
		updateBody.SCSIHardware = &scsiHardware

		rebootRequired = true
	}

	if d.HasChanges(mkHookScriptFileID) {
		hookScript := d.Get(mkHookScriptFileID).(string)
		if len(hookScript) > 0 {
			updateBody.HookScript = &hookScript
		} else {
			del = append(del, "hookscript")
		}
	}

	// Prepare the new watchdog configuration.
	if d.HasChange(mkWatchdog) {
		watchdogBlock, err := structure.GetSchemaBlock(
			resource,
			d,
			[]string{mkWatchdog},
			0,
			true,
		)
		if err != nil {
			return diag.FromErr(err)
		}

		watchdogEnabled := types.CustomBool(
			watchdogBlock[mkWatchdogEnabled].(bool),
		)
		if watchdogEnabled {
			watchdogAction := watchdogBlock[mkWatchdogAction].(string)
			watchdogModel := watchdogBlock[mkWatchdogModel].(string)

			updateBody.WatchdogDevice = &vms.CustomWatchdogDevice{
				Action: &watchdogAction,
				Model:  &watchdogModel,
			}
		} else {
			del = append(del, "watchdog")
		}

		rebootRequired = true
	}

	// Update the configuration now that everything has been prepared.
	updateBody.Delete = del

	e = vmAPI.UpdateVM(ctx, updateBody)
	if e != nil {
		return diag.FromErr(e)
	}

	// Determine if the state of the virtual machine state needs to be changed.
	//nolint: nestif
	if (d.HasChange(mkStarted) || stoppedBeforeUpdate) && !bool(template) {
		started := d.Get(mkStarted).(bool)
		if started {
			if diags := vmStart(ctx, vmAPI, d); diags != nil {
				return diags
			}
		} else {
			if er := vmShutdown(ctx, vmAPI, d); er != nil {
				return er
			}

			rebootRequired = false
		}
	}

	if cloudInitRebuildRequired {
		if er := vmAPI.RebuildCloudInitDisk(ctx); er != nil {
			return diag.FromErr(err)
		}
	}

	// Change the disk locations and/or sizes, if necessary.
	return vmUpdateDiskLocationAndSize(
		ctx,
		d,
		m,
		!bool(template) && rebootRequired,
	)
}

func vmUpdateDiskLocationAndSize(
	ctx context.Context,
	d *schema.ResourceData,
	m interface{},
	reboot bool,
) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)
	started := d.Get(mkStarted).(bool)
	template := d.Get(mkTemplate).(bool)

	vmID, err := strconv.Atoi(d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	vmAPI := client.Node(nodeName).VM(vmID)

	// Determine if any of the disks are changing location and/or size, and initiate the necessary actions.
	//nolint: nestif
	if d.HasChange(disk.MkDisk) {
		diskOld, diskNew := d.GetChange(disk.MkDisk)

		resource := VM()

		diskOldEntries, err := disk.GetDiskDeviceObjects(
			d,
			resource,
			diskOld.([]interface{}),
		)
		if err != nil {
			return diag.FromErr(err)
		}

		diskNewEntries, err := disk.GetDiskDeviceObjects(
			d,
			resource,
			diskNew.([]interface{}),
		)
		if err != nil {
			return diag.FromErr(err)
		}

		// Add efidisk if it has changes
		if d.HasChange(mkEFIDisk) {
			diskOld, diskNew := d.GetChange(mkEFIDisk)

			oldEfiDisk, e := vmGetEfiDiskAsStorageDevice(d, diskOld.([]interface{}))
			if e != nil {
				return diag.FromErr(e)
			}

			newEfiDisk, e := vmGetEfiDiskAsStorageDevice(d, diskNew.([]interface{}))
			if e != nil {
				return diag.FromErr(e)
			}

			if oldEfiDisk != nil {
				diskOldEntries["efidisk0"] = oldEfiDisk
			}

			if newEfiDisk != nil {
				diskNewEntries["efidisk0"] = newEfiDisk
			}

			if oldEfiDisk != nil && newEfiDisk != nil && oldEfiDisk.Size != newEfiDisk.Size {
				return diag.Errorf(
					"resizing of efidisk is not supported.",
				)
			}
		}

		// Add tpm state if it has changes
		if d.HasChange(mkTPMState) {
			diskOld, diskNew := d.GetChange(mkTPMState)

			oldTPMState := vmGetTPMStateAsStorageDevice(d, diskOld.([]interface{}))
			newTPMState := vmGetTPMStateAsStorageDevice(d, diskNew.([]interface{}))

			if oldTPMState != nil {
				diskOldEntries["tpmstate0"] = oldTPMState
			}

			if newTPMState != nil {
				diskNewEntries["tpmstate0"] = newTPMState
			}

			if oldTPMState != nil && newTPMState != nil && oldTPMState.Size != newTPMState.Size {
				return diag.Errorf(
					"resizing of tpm state is not supported.",
				)
			}
		}

		var diskMoveBodies []*vms.MoveDiskRequestBody

		var diskResizeBodies []*vms.ResizeDiskRequestBody

		shutdownForDisksRequired := false

		for oldIface, oldDisk := range diskOldEntries {
			if _, present := diskNewEntries[oldIface]; !present {
				return diag.Errorf(
					"deletion of disks not supported. Please delete disk by hand. Old interface was %q",
					oldIface,
				)
			}

			if *oldDisk.DatastoreID != *diskNewEntries[oldIface].DatastoreID {
				if oldDisk.IsOwnedBy(vmID) {
					deleteOriginalDisk := types.CustomBool(true)

					diskMoveBodies = append(
						diskMoveBodies,
						&vms.MoveDiskRequestBody{
							DeleteOriginalDisk: &deleteOriginalDisk,
							Disk:               oldIface,
							TargetStorage:      *diskNewEntries[oldIface].DatastoreID,
						},
					)

					// Cannot be done while VM is running.
					shutdownForDisksRequired = true
				} else {
					return diag.Errorf(
						"Cannot move %s:%s to datastore %s in VM %d configuration, it is not owned by this VM!",
						*oldDisk.DatastoreID,
						*oldDisk.PathInDatastore(),
						*diskNewEntries[oldIface].DatastoreID,
						vmID,
					)
				}
			}

			if *oldDisk.Size != *diskNewEntries[oldIface].Size {
				if *oldDisk.Size < *diskNewEntries[oldIface].Size {
					if oldDisk.IsOwnedBy(vmID) {
						diskResizeBodies = append(
							diskResizeBodies,
							&vms.ResizeDiskRequestBody{
								Disk: oldIface,
								Size: *diskNewEntries[oldIface].Size,
							},
						)
					} else {
						return diag.Errorf(
							"Cannot resize %s:%s in VM %d, it is not owned by this VM!",
							*oldDisk.DatastoreID,
							*oldDisk.PathInDatastore(),
							vmID,
						)
					}
				} else {
					return diag.Errorf(
						"Cannot shrink %s:%s in VM %d, it is not supported!",
						*oldDisk.DatastoreID,
						*oldDisk.PathInDatastore(),
						vmID,
					)
				}
			}
		}

		if shutdownForDisksRequired && !template {
			if e := vmShutdown(ctx, vmAPI, d); e != nil {
				return e
			}
		}

		for _, reqBody := range diskMoveBodies {
			err = vmAPI.MoveVMDisk(ctx, reqBody)
			if err != nil {
				return diag.FromErr(err)
			}
		}

		for _, reqBody := range diskResizeBodies {
			err = vmAPI.ResizeVMDisk(ctx, reqBody)
			if err != nil {
				return diag.FromErr(err)
			}
		}

		if shutdownForDisksRequired && started && !template {
			if diags := vmStart(ctx, vmAPI, d); diags != nil {
				return diags
			}

			// This concludes an equivalent of a reboot, avoid doing another.
			reboot = false
		}
	}

	// Perform a regular reboot in case it's necessary and haven't already been done.
	if reboot {
		canReboot := d.Get(mkRebootAfterUpdate).(bool)
		if !canReboot {
			return []diag.Diagnostic{{
				Severity: diag.Warning,
				Summary: "a reboot is required to apply configuration changes, but automatic " +
					"reboots are disabled by 'reboot_after_update = false'. Please reboot the VM manually.",
			}}
		}

		vmStatus, err := vmAPI.GetVMStatus(ctx)
		if err != nil {
			return diag.FromErr(err)
		}

		if vmStatus.Status != "stopped" {
			rebootTimeoutSec := d.Get(mkTimeoutReboot).(int)

			if e := vmAPI.RebootVMAndWaitForRunning(ctx, rebootTimeoutSec); e != nil {
				return diag.FromErr(e)
			}
		}
	}

	return vmRead(ctx, d, m)
}

func vmDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	timeout := d.Get(mkTimeoutStopVM).(int)
	shutdownTimeout := d.Get(mkTimeoutShutdownVM).(int)

	if shutdownTimeout > timeout {
		timeout = shutdownTimeout
	}

	// reset the default timeout for the delete operation
	ctx = context.WithoutCancel(ctx)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(timeout)*time.Second)
	defer cancel()

	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkNodeName).(string)

	vmID, err := strconv.Atoi(d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	vmAPI := client.Node(nodeName).VM(vmID)

	// Stop or shut down the virtual machine before deleting it.
	status, err := vmAPI.GetVMStatus(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	stop := d.Get(mkStopOnDestroy).(bool)

	//nolint: nestif
	if status.Status != "stopped" {
		if stop {
			if e := vmStop(ctx, vmAPI, d); e != nil {
				return e
			}
		} else {
			if e := vmShutdown(ctx, vmAPI, d); e != nil {
				return e
			}
		}
	}

	err = vmAPI.DeleteVM(ctx)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	// Wait for the state to become unavailable as that clearly indicates the destruction of the VM.
	err = vmAPI.WaitForVMStatus(ctx, "")
	if err == nil {
		return diag.Errorf("failed to delete VM \"%d\"", vmID)
	}

	d.SetId("")

	return nil
}

// getDiskDatastores returns a list of the used datastores in a VM.
func getDiskDatastores(vm *vms.GetResponseData, d *schema.ResourceData) []string {
	storageDevices := disk.GetInfo(vm, d)
	datastoresSet := map[string]int{}

	for _, diskInfo := range storageDevices {
		// Ignore empty storage devices and storage devices (like ide) which may not have any media mounted
		if diskInfo == nil || diskInfo.FileVolume == "none" {
			continue
		}

		fileIDParts := strings.Split(diskInfo.FileVolume, ":")
		datastoresSet[fileIDParts[0]] = 1
	}

	if vm.EFIDisk != nil {
		fileIDParts := strings.Split(vm.EFIDisk.FileVolume, ":")
		datastoresSet[fileIDParts[0]] = 1
	}

	if vm.TPMState != nil {
		fileIDParts := strings.Split(vm.TPMState.FileVolume, ":")
		datastoresSet[fileIDParts[0]] = 1
	}

	var datastores []string //nolint: prealloc
	for datastore := range datastoresSet {
		datastores = append(datastores, datastore)
	}

	return datastores
}

func getNUMAInfo(resp *vms.GetResponseData, _ *schema.ResourceData) map[string]*vms.CustomNUMADevice {
	numaDevices := map[string]*vms.CustomNUMADevice{}

	numaDevices["numa0"] = resp.NUMADevices0
	numaDevices["numa1"] = resp.NUMADevices1
	numaDevices["numa2"] = resp.NUMADevices2
	numaDevices["numa3"] = resp.NUMADevices3
	numaDevices["numa4"] = resp.NUMADevices4
	numaDevices["numa5"] = resp.NUMADevices5
	numaDevices["numa6"] = resp.NUMADevices6
	numaDevices["numa7"] = resp.NUMADevices7

	return numaDevices
}

func getUSBInfo(resp *vms.GetResponseData, _ *schema.ResourceData) map[string]*vms.CustomUSBDevice {
	usbDevices := map[string]*vms.CustomUSBDevice{}

	usbDevices["usb0"] = resp.USBDevice0
	usbDevices["usb1"] = resp.USBDevice1
	usbDevices["usb2"] = resp.USBDevice2
	usbDevices["usb3"] = resp.USBDevice3

	return usbDevices
}

func parseImportIDWithNodeName(id string) (string, string, error) {
	nodeName, id, found := strings.Cut(id, "/")

	if !found {
		return "", "", fmt.Errorf("unexpected format of ID (%s), expected node/id", id)
	}

	return nodeName, id, nil
}

func getAgentTimeout(d *schema.ResourceData) (time.Duration, error) {
	resource := VM()

	agentBlock, err := structure.GetSchemaBlock(
		resource,
		d,
		[]string{mkAgent},
		0,
		true,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get agent block: %w", err)
	}

	agentTimeout, err := time.ParseDuration(
		agentBlock[mkAgentTimeout].(string),
	)
	if err != nil {
		return 0, fmt.Errorf("failed to parse agent timeout: %w", err)
	}

	return agentTimeout, nil
}
`````

## File: proxmoxtf/resource/certificate_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestCertificateInstantiation tests whether the Certificate instance can be instantiated.
func TestCertificateInstantiation(t *testing.T) {
	t.Parallel()

	s := Certificate()
	if s == nil {
		t.Fatalf("Cannot instantiate Certificate")
	}
}

// TestCertificateSchema tests the Certificate schema.
func TestCertificateSchema(t *testing.T) {
	t.Parallel()

	s := Certificate().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentCertificateCertificate,
		mkResourceVirtualEnvironmentCertificateNodeName,
		mkResourceVirtualEnvironmentCertificatePrivateKey,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkResourceVirtualEnvironmentCertificateCertificateChain,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkResourceVirtualEnvironmentCertificateExpirationDate,
		mkResourceVirtualEnvironmentCertificateFileName,
		mkResourceVirtualEnvironmentCertificateIssuer,
		mkResourceVirtualEnvironmentCertificatePublicKeySize,
		mkResourceVirtualEnvironmentCertificatePublicKeyType,
		mkResourceVirtualEnvironmentCertificateSSLFingerprint,
		mkResourceVirtualEnvironmentCertificateStartDate,
		mkResourceVirtualEnvironmentCertificateSubject,
		mkResourceVirtualEnvironmentCertificateSubjectAlternativeNames,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentCertificateCertificate:             schema.TypeString,
		mkResourceVirtualEnvironmentCertificateCertificateChain:        schema.TypeString,
		mkResourceVirtualEnvironmentCertificateExpirationDate:          schema.TypeString,
		mkResourceVirtualEnvironmentCertificateFileName:                schema.TypeString,
		mkResourceVirtualEnvironmentCertificateIssuer:                  schema.TypeString,
		mkResourceVirtualEnvironmentCertificateNodeName:                schema.TypeString,
		mkResourceVirtualEnvironmentCertificatePrivateKey:              schema.TypeString,
		mkResourceVirtualEnvironmentCertificatePublicKeySize:           schema.TypeInt,
		mkResourceVirtualEnvironmentCertificatePublicKeyType:           schema.TypeString,
		mkResourceVirtualEnvironmentCertificateSSLFingerprint:          schema.TypeString,
		mkResourceVirtualEnvironmentCertificateStartDate:               schema.TypeString,
		mkResourceVirtualEnvironmentCertificateSubject:                 schema.TypeString,
		mkResourceVirtualEnvironmentCertificateSubjectAlternativeNames: schema.TypeList,
	})
}
`````

## File: proxmoxtf/resource/certificate.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	dvResourceVirtualEnvironmentCertificateCertificateChain = ""
	dvResourceVirtualEnvironmentCertificateOverwrite        = false

	mkResourceVirtualEnvironmentCertificateCertificate             = "certificate"
	mkResourceVirtualEnvironmentCertificateCertificateChain        = "certificate_chain"
	mkResourceVirtualEnvironmentCertificateFileName                = "file_name"
	mkResourceVirtualEnvironmentCertificateIssuer                  = "issuer"
	mkResourceVirtualEnvironmentCertificateNodeName                = "node_name"
	mkResourceVirtualEnvironmentCertificateExpirationDate          = "expiration_date"
	mkResourceVirtualEnvironmentCertificateOverwrite               = "overwrite"
	mkResourceVirtualEnvironmentCertificatePrivateKey              = "private_key"
	mkResourceVirtualEnvironmentCertificatePublicKeySize           = "public_key_size"
	mkResourceVirtualEnvironmentCertificatePublicKeyType           = "public_key_type"
	mkResourceVirtualEnvironmentCertificateSSLFingerprint          = "ssl_fingerprint"
	mkResourceVirtualEnvironmentCertificateStartDate               = "start_date"
	mkResourceVirtualEnvironmentCertificateSubject                 = "subject"
	mkResourceVirtualEnvironmentCertificateSubjectAlternativeNames = "subject_alternative_names"
)

// Certificate returns a resource that manages a certificate.
func Certificate() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentCertificateCertificate: {
				Type:        schema.TypeString,
				Description: "The PEM encoded certificate",
				Required:    true,
			},
			mkResourceVirtualEnvironmentCertificateCertificateChain: {
				Type:        schema.TypeString,
				Description: "The PEM encoded certificate chain",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentCertificateCertificateChain,
			},
			mkResourceVirtualEnvironmentCertificateExpirationDate: {
				Type:        schema.TypeString,
				Description: "The expiration date",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateFileName: {
				Type:        schema.TypeString,
				Description: "The file name",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateIssuer: {
				Type:        schema.TypeString,
				Description: "The issuer",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentCertificateOverwrite: {
				Type:        schema.TypeBool,
				Description: "Whether to overwrite an existing certificate",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentCertificateOverwrite,
			},
			mkResourceVirtualEnvironmentCertificatePrivateKey: {
				Type:        schema.TypeString,
				Description: "The PEM encoded private key",
				Required:    true,
				Sensitive:   true,
			},
			mkResourceVirtualEnvironmentCertificatePublicKeySize: {
				Type:        schema.TypeInt,
				Description: "The public key size",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificatePublicKeyType: {
				Type:        schema.TypeString,
				Description: "The public key type",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateSSLFingerprint: {
				Type:        schema.TypeString,
				Description: "The SSL fingerprint",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateStartDate: {
				Type:        schema.TypeString,
				Description: "The start date",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateSubject: {
				Type:        schema.TypeString,
				Description: "The subject",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentCertificateSubjectAlternativeNames: {
				Type:        schema.TypeList,
				Description: "The subject alternative names",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		CreateContext: certificateCreate,
		ReadContext:   certificateRead,
		UpdateContext: certificateUpdate,
		DeleteContext: certificateDelete,
	}
}

func certificateCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	diags := certificateUpdate(ctx, d, m)
	if diags.HasError() {
		return diags
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentCertificateNodeName).(string)

	d.SetId(fmt.Sprintf("%s_certificate", nodeName))

	return nil
}

func certificateGetUpdateBody(d *schema.ResourceData) *nodes.CertificateUpdateRequestBody {
	certificate := d.Get(mkResourceVirtualEnvironmentCertificateCertificate).(string)
	certificateChain := d.Get(mkResourceVirtualEnvironmentCertificateCertificateChain).(string)
	overwrite := types.CustomBool(d.Get(mkResourceVirtualEnvironmentCertificateOverwrite).(bool))
	privateKey := d.Get(mkResourceVirtualEnvironmentCertificatePrivateKey).(string)

	combinedCertificates := strings.TrimSpace(certificate) + "\n"

	if certificateChain != "" {
		combinedCertificates += strings.TrimSpace(certificateChain) + "\n"
	}

	force := overwrite

	if d.Id() != "" {
		force = true
	}

	restart := types.CustomBool(true)

	body := &nodes.CertificateUpdateRequestBody{
		Certificates: combinedCertificates,
		Force:        &force,
		PrivateKey:   &privateKey,
		Restart:      &restart,
	}

	return body
}

func certificateRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentCertificateNodeName).(string)

	list, err := api.Node(nodeName).ListCertificates(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	err = d.Set(mkResourceVirtualEnvironmentCertificateCertificate, "")
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkResourceVirtualEnvironmentCertificateCertificateChain, "")
	diags = append(diags, diag.FromErr(err)...)

	certificateChain := d.Get(mkResourceVirtualEnvironmentCertificateCertificateChain).(string)

	for _, c := range *list {
		if c.FileName != nil && *c.FileName == "pveproxy-ssl.pem" {
			if c.Certificates != nil {
				newCertificate := ""
				newCertificateChain := ""

				if certificateChain != "" {
					certificates := strings.Split(strings.TrimSpace(*c.Certificates), "\n")
					newCertificate = certificates[0] + "\n"

					if len(certificates) > 1 {
						newCertificateChain = strings.Join(certificates[1:], "\n") + "\n"
					}
				} else {
					newCertificate = *c.Certificates
				}

				err = d.Set(mkResourceVirtualEnvironmentCertificateCertificate, newCertificate)
				diags = append(diags, diag.FromErr(err)...)
				err = d.Set(
					mkResourceVirtualEnvironmentCertificateCertificateChain,
					newCertificateChain,
				)
				diags = append(diags, diag.FromErr(err)...)
			}

			err = d.Set(mkResourceVirtualEnvironmentCertificateFileName, *c.FileName)
			diags = append(diags, diag.FromErr(err)...)

			if c.NotAfter != nil {
				t := time.Time(*c.NotAfter)
				err = d.Set(
					mkResourceVirtualEnvironmentCertificateExpirationDate,
					t.UTC().Format(time.RFC3339),
				)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificateExpirationDate, "")
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.Issuer != nil {
				err = d.Set(mkResourceVirtualEnvironmentCertificateIssuer, *c.Issuer)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificateIssuer, "")
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.PublicKeyBits != nil {
				err = d.Set(mkResourceVirtualEnvironmentCertificatePublicKeySize, *c.PublicKeyBits)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificatePublicKeySize, 0)
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.PublicKeyType != nil {
				pkType := *c.PublicKeyType
				for _, pkt := range []string{"ecdsa", "dsa", "rsa"} {
					if strings.Contains(pkType, pkt) {
						pkType = pkt
					}
				}
				err = d.Set(mkResourceVirtualEnvironmentCertificatePublicKeyType, pkType)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificatePublicKeyType, "")
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.Fingerprint != nil {
				err = d.Set(mkResourceVirtualEnvironmentCertificateSSLFingerprint, *c.Fingerprint)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificateSSLFingerprint, "")
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.NotBefore != nil {
				t := time.Time(*c.NotBefore)
				err = d.Set(
					mkResourceVirtualEnvironmentCertificateStartDate,
					t.UTC().Format(time.RFC3339),
				)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificateStartDate, "")
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.Subject != nil {
				err = d.Set(mkResourceVirtualEnvironmentCertificateSubject, *c.Subject)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificateSubject, "")
			}
			diags = append(diags, diag.FromErr(err)...)

			if c.SubjectAlternativeNames != nil {
				sanList := make([]interface{}, len(*c.SubjectAlternativeNames))
				for i, san := range *c.SubjectAlternativeNames {
					sanList[i] = san
				}
				err = d.Set(mkResourceVirtualEnvironmentCertificateSubjectAlternativeNames, sanList)
			} else {
				err = d.Set(mkResourceVirtualEnvironmentCertificateSubjectAlternativeNames, []interface{}{})
			}
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	return diags
}

func certificateUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentCertificateNodeName).(string)

	body := certificateGetUpdateBody(d)

	err = api.Node(nodeName).UpdateCertificate(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	return certificateRead(ctx, d, m)
}

func certificateDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentCertificateNodeName).(string)

	restart := types.CustomBool(true)

	err = api.Node(nodeName).DeleteCertificate(
		ctx,
		&nodes.CertificateDeleteRequestBody{
			Restart: &restart,
		},
	)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/dns_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestDNSInstantiation tests whether the DNS instance can be instantiated.
func TestDNSInstantiation(t *testing.T) {
	t.Parallel()

	s := DNS()
	if s == nil {
		t.Fatalf("Cannot instantiate DNS")
	}
}

// TestDNSSchema tests the DNS schema.
func TestDNSSchema(t *testing.T) {
	t.Parallel()

	s := DNS().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentDNSDomain,
		mkResourceVirtualEnvironmentDNSNodeName,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkResourceVirtualEnvironmentDNSServers,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentDNSDomain:   schema.TypeString,
		mkResourceVirtualEnvironmentDNSNodeName: schema.TypeString,
		mkResourceVirtualEnvironmentDNSServers:  schema.TypeList,
	})
}
`````

## File: proxmoxtf/resource/dns.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkResourceVirtualEnvironmentDNSDomain   = "domain"
	mkResourceVirtualEnvironmentDNSNodeName = "node_name"
	mkResourceVirtualEnvironmentDNSServers  = "servers"
)

// DNS returns a resource that manages DNS settings for a node.
func DNS() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentDNSDomain: {
				Type:        schema.TypeString,
				Description: "The DNS search domain",
				Required:    true,
			},
			mkResourceVirtualEnvironmentDNSNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentDNSServers: {
				Type:        schema.TypeList,
				Description: "The DNS servers",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{}, nil
				},
				Elem:     &schema.Schema{Type: schema.TypeString},
				MinItems: 0,
				MaxItems: 3,
			},
		},
		CreateContext: dnsCreate,
		ReadContext:   dnsRead,
		UpdateContext: dnsUpdate,
		DeleteContext: dnsDelete,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				nodeName := d.Id()

				err := d.Set(mkResourceVirtualEnvironmentDNSNodeName, nodeName)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				d.SetId(fmt.Sprintf("%s_dns", nodeName))

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func dnsCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	diags := dnsUpdate(ctx, d, m)
	if diags.HasError() {
		return diags
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentDNSNodeName).(string)

	d.SetId(fmt.Sprintf("%s_dns", nodeName))

	return nil
}

func dnsGetUpdateBody(d *schema.ResourceData) *nodes.DNSUpdateRequestBody {
	domain := d.Get(mkResourceVirtualEnvironmentDNSDomain).(string)
	servers := d.Get(mkResourceVirtualEnvironmentDNSServers).([]interface{})

	body := &nodes.DNSUpdateRequestBody{
		SearchDomain: &domain,
	}

	for i, server := range servers {
		s := server.(string)

		switch i {
		case 0:
			body.Server1 = &s
		case 1:
			body.Server2 = &s
		case 2:
			body.Server3 = &s
		}
	}

	return body
}

func dnsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentDNSNodeName).(string)

	dns, err := api.Node(nodeName).GetDNS(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	if dns.SearchDomain != nil {
		err = d.Set(mkResourceVirtualEnvironmentDNSDomain, *dns.SearchDomain)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentDNSDomain, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	var servers []interface{}

	if dns.Server1 != nil {
		servers = append(servers, *dns.Server1)
	}

	if dns.Server2 != nil {
		servers = append(servers, *dns.Server2)
	}

	if dns.Server3 != nil {
		servers = append(servers, *dns.Server3)
	}

	err = d.Set(mkResourceVirtualEnvironmentDNSServers, servers)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func dnsUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentDNSNodeName).(string)

	body := dnsGetUpdateBody(d)

	err = api.Node(nodeName).UpdateDNS(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	return dnsRead(ctx, d, m)
}

func dnsDelete(_ context.Context, d *schema.ResourceData, _ interface{}) diag.Diagnostics {
	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/file_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"reflect"
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestFileInstantiation tests whether the File instance can be instantiated.
func TestFileInstantiation(t *testing.T) {
	t.Parallel()

	s := File()
	if s == nil {
		t.Fatalf("Cannot instantiate File")
	}
}

// TestFileSchema tests the File schema.
func TestFileSchema(t *testing.T) {
	t.Parallel()

	s := File().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentFileDatastoreID,
		mkResourceVirtualEnvironmentFileNodeName,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkResourceVirtualEnvironmentFileContentType,
		mkResourceVirtualEnvironmentFileSourceFile,
		mkResourceVirtualEnvironmentFileFileMode,
		mkResourceVirtualEnvironmentFileSourceRaw,
		mkResourceVirtualEnvironmentFileTimeoutUpload,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkResourceVirtualEnvironmentFileFileModificationDate,
		mkResourceVirtualEnvironmentFileFileName,
		mkResourceVirtualEnvironmentFileFileSize,
		mkResourceVirtualEnvironmentFileFileTag,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentFileContentType:          schema.TypeString,
		mkResourceVirtualEnvironmentFileDatastoreID:          schema.TypeString,
		mkResourceVirtualEnvironmentFileFileModificationDate: schema.TypeString,
		mkResourceVirtualEnvironmentFileFileName:             schema.TypeString,
		mkResourceVirtualEnvironmentFileFileMode:             schema.TypeString,
		mkResourceVirtualEnvironmentFileFileSize:             schema.TypeInt,
		mkResourceVirtualEnvironmentFileFileTag:              schema.TypeString,
		mkResourceVirtualEnvironmentFileNodeName:             schema.TypeString,
		mkResourceVirtualEnvironmentFileSourceFile:           schema.TypeList,
		mkResourceVirtualEnvironmentFileSourceRaw:            schema.TypeList,
		mkResourceVirtualEnvironmentFileTimeoutUpload:        schema.TypeInt,
	})

	sourceFileSchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentFileSourceFile)

	test.AssertRequiredArguments(t, sourceFileSchema, []string{
		mkResourceVirtualEnvironmentFileSourceFilePath,
	})

	test.AssertOptionalArguments(t, sourceFileSchema, []string{
		mkResourceVirtualEnvironmentFileSourceFileChanged,
		mkResourceVirtualEnvironmentFileSourceFileChecksum,
		mkResourceVirtualEnvironmentFileSourceFileFileName,
		mkResourceVirtualEnvironmentFileSourceFileInsecure,
	})

	test.AssertValueTypes(t, sourceFileSchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentFileSourceFileChanged:  schema.TypeBool,
		mkResourceVirtualEnvironmentFileSourceFileChecksum: schema.TypeString,
		mkResourceVirtualEnvironmentFileSourceFileFileName: schema.TypeString,
		mkResourceVirtualEnvironmentFileSourceFileInsecure: schema.TypeBool,
		mkResourceVirtualEnvironmentFileSourceFilePath:     schema.TypeString,
	})

	sourceRawSchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentFileSourceRaw)

	test.AssertRequiredArguments(t, sourceRawSchema, []string{
		mkResourceVirtualEnvironmentFileSourceRawData,
		mkResourceVirtualEnvironmentFileSourceRawFileName,
	})

	test.AssertOptionalArguments(t, sourceRawSchema, []string{
		mkResourceVirtualEnvironmentFileSourceRawResize,
	})

	test.AssertValueTypes(t, sourceRawSchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentFileSourceRawData:     schema.TypeString,
		mkResourceVirtualEnvironmentFileSourceRawFileName: schema.TypeString,
		mkResourceVirtualEnvironmentFileSourceRawResize:   schema.TypeInt,
	})
}

func Test_fileParseVolumeID(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		id      string
		want    fileVolumeID
		wantErr bool
	}{
		{"empty", "", fileVolumeID{}, true},
		{"missing datastore", "iso/file.ido", fileVolumeID{}, true},
		{"missing type", "local:/file.ido", fileVolumeID{}, true},
		{"missing file", "local:iso", fileVolumeID{}, true},
		{"missing file", "local:iso/", fileVolumeID{}, true},
		{"valid", "local:iso/file.iso", fileVolumeID{
			datastoreID: "local",
			contentType: "iso",
			fileName:    "file.iso",
		}, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			got, err := fileParseVolumeID(tt.id)
			if (err != nil) != tt.wantErr {
				t.Errorf("fileParseVolumeID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("fileParseVolumeID() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_fileParseImportID(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		id      string
		node    string
		volID   fileVolumeID
		wantErr bool
	}{
		{"empty", "", "", fileVolumeID{}, true},
		{"missing node", "local:iso/file.iso", "", fileVolumeID{}, true},
		{"missing node 2", "/local:iso/file.iso", "", fileVolumeID{}, true},
		{
			"valid", "pve/local:iso/file.iso",
			"pve",
			fileVolumeID{
				datastoreID: "local",
				contentType: "iso",
				fileName:    "file.iso",
			},
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			node, volID, err := fileParseImportID(tt.id)
			if (err != nil) != tt.wantErr {
				t.Errorf("fileParseImportID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if node != tt.node {
				t.Errorf("fileParseImportID() got node = %v, want %v", node, tt.node)
			}

			if !reflect.DeepEqual(volID, tt.volID) {
				t.Errorf("fileParseImportID() got volID = %v, want %v", volID, tt.volID)
			}
		})
	}
}
`````

## File: proxmoxtf/resource/file.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"bytes"
	"context"
	"crypto/sha256"
	"crypto/tls"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"time"

	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/resource/validators"
	"github.com/bpg/terraform-provider-proxmox/utils"
)

const (
	dvResourceVirtualEnvironmentFileSourceFileChanged  = false
	dvResourceVirtualEnvironmentFileSourceFileChecksum = ""
	dvResourceVirtualEnvironmentFileSourceFileFileName = ""
	dvResourceVirtualEnvironmentFileSourceFileInsecure = false
	dvResourceVirtualEnvironmentFileSourceFileMinTLS   = ""
	dvResourceVirtualEnvironmentFileOverwrite          = true
	dvResourceVirtualEnvironmentFileSourceRawResize    = 0
	dvResourceVirtualEnvironmentFileTimeoutUpload      = 1800

	mkResourceVirtualEnvironmentFileContentType          = "content_type"
	mkResourceVirtualEnvironmentFileDatastoreID          = "datastore_id"
	mkResourceVirtualEnvironmentFileFileModificationDate = "file_modification_date"
	mkResourceVirtualEnvironmentFileFileName             = "file_name"
	mkResourceVirtualEnvironmentFileFileMode             = "file_mode"
	mkResourceVirtualEnvironmentFileFileSize             = "file_size"
	mkResourceVirtualEnvironmentFileFileTag              = "file_tag"
	mkResourceVirtualEnvironmentFileNodeName             = "node_name"
	mkResourceVirtualEnvironmentFileOverwrite            = "overwrite"
	mkResourceVirtualEnvironmentFileSourceFile           = "source_file"
	mkResourceVirtualEnvironmentFileSourceFilePath       = "path"
	mkResourceVirtualEnvironmentFileSourceFileChanged    = "changed"
	mkResourceVirtualEnvironmentFileSourceFileChecksum   = "checksum"
	mkResourceVirtualEnvironmentFileSourceFileFileName   = "file_name"
	mkResourceVirtualEnvironmentFileSourceFileInsecure   = "insecure"
	mkResourceVirtualEnvironmentFileSourceFileMinTLS     = "min_tls"
	mkResourceVirtualEnvironmentFileSourceRaw            = "source_raw"
	mkResourceVirtualEnvironmentFileSourceRawData        = "data"
	mkResourceVirtualEnvironmentFileSourceRawFileName    = "file_name"
	mkResourceVirtualEnvironmentFileSourceRawResize      = "resize"
	mkResourceVirtualEnvironmentFileTimeoutUpload        = "timeout_upload"
)

// File returns a resource that manages files on a node.
func File() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentFileContentType: {
				Type:             schema.TypeString,
				Description:      "The content type",
				Optional:         true,
				ForceNew:         true,
				Computed:         true,
				ValidateDiagFunc: validators.ContentType(),
			},
			mkResourceVirtualEnvironmentFileDatastoreID: {
				Type:        schema.TypeString,
				Description: "The datastore id",
				Required:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentFileFileModificationDate: {
				Type:        schema.TypeString,
				Description: "The file modification date",
				Computed:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentFileFileName: {
				Type:        schema.TypeString,
				Description: "The file name",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentFileFileMode: {
				Type: schema.TypeString,
				Description: `The file mode in octal format, e.g. "0700" or "600".` +
					`Note that the prefixes "0o" and "0x" are not supported!` +
					`Setting this attribute is also only allowed for "root@pam" authenticated user.`,
				Optional:         true,
				ValidateDiagFunc: validators.FileMode(),
				ForceNew:         true,
			},
			mkResourceVirtualEnvironmentFileFileSize: {
				Type:        schema.TypeInt,
				Description: "The file size in bytes",
				Computed:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentFileFileTag: {
				Type:        schema.TypeString,
				Description: "The file tag",
				Computed:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentFileNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentFileSourceFile: {
				Type:        schema.TypeList,
				Description: "The source file",
				Optional:    true,
				ForceNew:    true,
				DefaultFunc: func() (interface{}, error) {
					return make([]interface{}, 1), nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentFileSourceFilePath: {
							Type:        schema.TypeString,
							Description: "A path to a local file or a URL",
							Required:    true,
							ForceNew:    true,
						},
						mkResourceVirtualEnvironmentFileSourceFileChanged: {
							Type:        schema.TypeBool,
							Description: "Whether the source file has changed since the last run",
							Optional:    true,
							ForceNew:    true,
							Default:     dvResourceVirtualEnvironmentFileSourceFileChanged,
						},
						mkResourceVirtualEnvironmentFileSourceFileChecksum: {
							Type:        schema.TypeString,
							Description: "The SHA256 checksum of the source file",
							Optional:    true,
							ForceNew:    true,
							Default:     dvResourceVirtualEnvironmentFileSourceFileChecksum,
						},
						mkResourceVirtualEnvironmentFileSourceFileFileName: {
							Type:        schema.TypeString,
							Description: "The file name to use instead of the source file name",
							Optional:    true,
							ForceNew:    true,
							Default:     dvResourceVirtualEnvironmentFileSourceFileFileName,
						},
						mkResourceVirtualEnvironmentFileSourceFileInsecure: {
							Type:        schema.TypeBool,
							Description: "Whether to skip the TLS verification step for HTTPS sources",
							Optional:    true,
							ForceNew:    true,
							Default:     dvResourceVirtualEnvironmentFileSourceFileInsecure,
						},
						mkResourceVirtualEnvironmentFileSourceFileMinTLS: {
							Type: schema.TypeString,
							Description: "The minimum required TLS version for HTTPS sources." +
								"Supported values: `1.0|1.1|1.2|1.3`. Defaults to `1.3`.",
							Optional: true,
							ForceNew: true,
							Default:  dvResourceVirtualEnvironmentFileSourceFileMinTLS,
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkResourceVirtualEnvironmentFileSourceRaw: {
				Type:        schema.TypeList,
				Description: "The raw source",
				Optional:    true,
				ForceNew:    true,
				DefaultFunc: func() (interface{}, error) {
					return make([]interface{}, 1), nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentFileSourceRawData: {
							Type:        schema.TypeString,
							Description: "The raw data",
							Required:    true,
							ForceNew:    true,
						},
						mkResourceVirtualEnvironmentFileSourceRawFileName: {
							Type:        schema.TypeString,
							Description: "The file name",
							Required:    true,
							ForceNew:    true,
						},
						mkResourceVirtualEnvironmentFileSourceRawResize: {
							Type:        schema.TypeInt,
							Description: "The number of bytes to resize the file to",
							Optional:    true,
							ForceNew:    true,
							Default:     dvResourceVirtualEnvironmentFileSourceRawResize,
						},
					},
				},
				MaxItems: 1,
				MinItems: 0,
			},
			mkResourceVirtualEnvironmentFileTimeoutUpload: {
				Type:        schema.TypeInt,
				Description: "Timeout for uploading ISO/VSTMPL files in seconds",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentFileTimeoutUpload,
			},
			mkResourceVirtualEnvironmentFileOverwrite: {
				Type:        schema.TypeBool,
				Description: "Whether to overwrite the file if it already exists",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentFileOverwrite,
			},
		},
		CreateContext: fileCreate,
		ReadContext:   fileRead,
		DeleteContext: fileDelete,
		UpdateContext: fileUpdate,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				node, volID, err := fileParseImportID(d.Id())
				if err != nil {
					return nil, err
				}

				d.SetId(volID.String())

				err = d.Set(mkResourceVirtualEnvironmentFileNodeName, node)
				if err != nil {
					return nil, fmt.Errorf("failed setting 'node_name' in state during import: %w", err)
				}

				err = d.Set(mkResourceVirtualEnvironmentFileDatastoreID, volID.datastoreID)
				if err != nil {
					return nil, fmt.Errorf("failed setting 'datastore_id' in state during import: %w", err)
				}

				err = d.Set(mkResourceVirtualEnvironmentFileContentType, volID.contentType)
				if err != nil {
					return nil, fmt.Errorf("failed setting 'content_type' in state during import: %w", err)
				}

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

type fileVolumeID struct {
	datastoreID string
	contentType string
	fileName    string
}

func (v fileVolumeID) String() string {
	return fmt.Sprintf("%s:%s/%s", v.datastoreID, v.contentType, v.fileName)
}

// fileParseVolumeID parses a volume ID in the format datastore_id:content_type/file_name.
func fileParseVolumeID(id string) (fileVolumeID, error) {
	parts := strings.SplitN(id, ":", 2)

	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		return fileVolumeID{}, fmt.Errorf("unexpected format of ID (%s), expected datastore_id:content_type/file_name", id)
	}

	datastoreID := parts[0]

	parts = strings.SplitN(parts[1], "/", 2)

	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		return fileVolumeID{}, fmt.Errorf("unexpected format of ID (%s), expected datastore_id:content_type/file_name", id)
	}

	contentType := parts[0]
	fileName := parts[1]

	return fileVolumeID{
		datastoreID: datastoreID,
		contentType: contentType,
		fileName:    fileName,
	}, nil
}

// fileParseImportID parses an import ID in the format node/datastore_id:content_type/file_name.
func fileParseImportID(id string) (string, fileVolumeID, error) {
	parts := strings.SplitN(id, "/", 2)

	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		return "", fileVolumeID{},
			fmt.Errorf("unexpected format of ID (%s), expected node/datastore_id:content_type/file_name", id)
	}

	node := parts[0]

	volID, err := fileParseVolumeID(parts[1])
	if err != nil {
		return "", fileVolumeID{}, err
	}

	return node, volID, nil
}

func fileCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	uploadTimeout := d.Get(mkResourceVirtualEnvironmentFileTimeoutUpload).(int)
	fileMode := d.Get(mkResourceVirtualEnvironmentFileFileMode).(string)

	ctx, cancel := context.WithTimeout(ctx, time.Duration(uploadTimeout)*time.Second)
	defer cancel()

	var diags diag.Diagnostics

	contentType, dg := fileGetContentType(d)
	diags = append(diags, dg...)

	fileName, err := fileGetSourceFileName(d)
	diags = append(diags, diag.FromErr(err)...)

	if diags.HasError() {
		return diags
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentFileNodeName).(string)
	datastoreID := d.Get(mkResourceVirtualEnvironmentFileDatastoreID).(string)

	config := m.(proxmoxtf.ProviderConfiguration)

	capi, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	list, err := capi.Node(nodeName).Storage(datastoreID).ListDatastoreFiles(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	for _, file := range list {
		volumeID, e := fileParseVolumeID(file.VolumeID)
		if e != nil {
			tflog.Warn(ctx, "failed to parse volume ID", map[string]interface{}{
				"error": err,
			})

			continue
		}

		if volumeID.fileName == *fileName {
			if d.Get(mkResourceVirtualEnvironmentFileOverwrite).(bool) {
				diags = append(diags, diag.Diagnostic{
					Severity: diag.Warning,
					Summary:  fmt.Sprintf("the existing file %q has been overwritten by the resource", volumeID),
				})
			} else {
				return diag.Errorf("file %q already exists", volumeID)
			}
		}
	}

	sourceFile := d.Get(mkResourceVirtualEnvironmentFileSourceFile).([]interface{})
	sourceRaw := d.Get(mkResourceVirtualEnvironmentFileSourceRaw).([]interface{})

	sourceFilePathLocal := ""

	// Determine if both source_data and source_file is specified as this is not supported.
	if len(sourceFile) > 0 && len(sourceRaw) > 0 {
		diags = append(diags, diag.Errorf(
			"please specify \"%s.%s\" or \"%s\" - not both",
			mkResourceVirtualEnvironmentFileSourceFile,
			mkResourceVirtualEnvironmentFileSourceFilePath,
			mkResourceVirtualEnvironmentFileSourceRaw,
		)...)
	}

	if diags.HasError() {
		return diags
	}

	// Determine if we're dealing with raw file data or a reference to a file or URL.
	// In case of a URL, we must first download the file before proceeding.
	// This is due to lack of support for chunked transfers in the Proxmox VE API.
	if len(sourceFile) > 0 {
		sourceFileBlock := sourceFile[0].(map[string]interface{})
		sourceFilePath := sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFilePath].(string)
		sourceFileChecksum := sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFileChecksum].(string)
		sourceFileMinTLS := sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFileMinTLS].(string)
		sourceFileInsecure := sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFileInsecure].(bool)

		if fileIsURL(d) {
			tflog.Debug(ctx, "Downloading file from URL", map[string]interface{}{
				"url": sourceFilePath,
			})

			version, e := api.GetMinTLSVersion(sourceFileMinTLS)
			if e != nil {
				return diag.FromErr(e)
			}

			httpClient := http.Client{
				Transport: &http.Transport{
					TLSClientConfig: &tls.Config{
						MinVersion:         version,
						InsecureSkipVerify: sourceFileInsecure,
					},
				},
			}

			res, err := httpClient.Get(sourceFilePath)
			if err != nil {
				return diag.FromErr(err)
			}

			defer utils.CloseOrLogError(ctx)(res.Body)

			tempDownloadedFile, err := os.CreateTemp(config.TempDir(), "download")
			if err != nil {
				return diag.FromErr(err)
			}

			tempDownloadedFileName := tempDownloadedFile.Name()
			defer func(name string) {
				err := os.Remove(name)
				if err != nil {
					tflog.Error(ctx, "Failed to remove temporary file", map[string]interface{}{
						"error": err,
						"file":  name,
					})
				}
			}(tempDownloadedFileName)

			_, err = io.Copy(tempDownloadedFile, res.Body)
			diags = append(diags, diag.FromErr(err)...)
			err = tempDownloadedFile.Close()
			diags = append(diags, diag.FromErr(err)...)

			if diags.HasError() {
				return diags
			}

			sourceFilePathLocal = tempDownloadedFileName
		} else {
			sourceFilePathLocal = sourceFilePath
		}

		// Calculate the checksum of the source file now that it's available locally.
		if sourceFileChecksum != "" {
			file, err := os.Open(sourceFilePathLocal)
			if err != nil {
				return diag.FromErr(err)
			}

			h := sha256.New()
			_, err = io.Copy(h, file)
			diags = append(diags, diag.FromErr(err)...)
			err = file.Close()
			diags = append(diags, diag.FromErr(err)...)
			if diags.HasError() {
				return diags
			}

			calculatedChecksum := fmt.Sprintf("%x", h.Sum(nil))
			tflog.Debug(ctx, "Calculated checksum", map[string]interface{}{
				"source": sourceFilePath,
				"sha256": calculatedChecksum,
			})

			if sourceFileChecksum != calculatedChecksum {
				return diag.Errorf(
					"the calculated SHA256 checksum \"%s\" does not match source checksum \"%s\"",
					calculatedChecksum,
					sourceFileChecksum,
				)
			}
		}
	}

	//nolint:nestif
	if len(sourceRaw) > 0 {
		sourceRawBlock := sourceRaw[0].(map[string]interface{})
		sourceRawData := sourceRawBlock[mkResourceVirtualEnvironmentFileSourceRawData].(string)
		sourceRawResize := sourceRawBlock[mkResourceVirtualEnvironmentFileSourceRawResize].(int)

		if sourceRawResize > 0 {
			if len(sourceRawData) <= sourceRawResize {
				sourceRawData = fmt.Sprintf(fmt.Sprintf("%%-%dv", sourceRawResize), sourceRawData)
			} else {
				return diag.Errorf("cannot resize %d bytes to %d bytes", len(sourceRawData), sourceRawResize)
			}
		}

		tempRawFile, e := os.CreateTemp(config.TempDir(), "raw")
		if e != nil {
			return diag.FromErr(err)
		}

		tempRawFileName := tempRawFile.Name()
		_, err = io.Copy(tempRawFile, bytes.NewBufferString(sourceRawData))
		diags = append(diags, diag.FromErr(err)...)
		err = tempRawFile.Close()
		diags = append(diags, diag.FromErr(err)...)
		if diags.HasError() {
			return diags
		}

		defer func(name string) {
			err := os.Remove(name)
			if err != nil {
				tflog.Error(ctx, "Failed to remove temporary file", map[string]interface{}{
					"error": err,
					"file":  name,
				})
			}
		}(tempRawFileName)

		sourceFilePathLocal = tempRawFileName
	}

	// Open the source file for reading in order to upload it.
	file, err := os.Open(sourceFilePathLocal)
	if err != nil {
		return diag.FromErr(err)
	}

	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			tflog.Error(ctx, "Failed to close file", map[string]interface{}{
				"error": err,
			})
		}
	}(file)

	request := &api.FileUploadRequest{
		ContentType: *contentType,
		FileName:    *fileName,
		File:        file,
		Mode:        fileMode,
	}

	switch *contentType {
	case "iso", "vztmpl":
		_, err = capi.Node(nodeName).Storage(datastoreID).APIUpload(
			ctx, request, config.TempDir(),
		)
		if err != nil {
			diags = append(diags, diag.FromErr(err)...)
			return diags
		}
	default:
		// For all other content types, we need to upload the file to the node's
		// datastore using SFTP.
		datastore, err2 := capi.Storage().GetDatastore(ctx, datastoreID)
		if err2 != nil {
			return diag.Errorf("failed to get datastore: %s", err2)
		}

		if datastore.Path == nil || *datastore.Path == "" {
			return diag.Errorf("failed to determine the datastore path")
		}

		sort.Strings(datastore.Content)

		_, found := slices.BinarySearch(datastore.Content, *contentType)
		if !found {
			diags = append(diags, diag.Diagnostics{
				diag.Diagnostic{
					Severity: diag.Warning,
					Summary: fmt.Sprintf("the datastore %q does not support content type %q; supported content types are: %v",
						*datastore.Storage, *contentType, datastore.Content,
					),
				},
			}...)
		}

		// PVE expects backups to be located at the "dump" directory of the datastore.
		if *contentType == "backup" {
			request.ContentType = "dump"
		}

		err = capi.SSH().NodeStreamUpload(ctx, nodeName, *datastore.Path, request)
		if err != nil {
			diags = append(diags, diag.FromErr(err)...)
			return diags
		}

	}

	volID, di := fileGetVolumeID(d)
	diags = append(diags, di...)
	if diags.HasError() {
		return diags
	}

	d.SetId(volID.String())

	diags = append(diags, fileRead(ctx, d, m)...)

	if d.Id() == "" {
		diags = append(diags, diag.Errorf("failed to read file from %q", volID.String())...)
	}

	return diags
}

func fileGetContentType(d *schema.ResourceData) (*string, diag.Diagnostics) {
	contentType := d.Get(mkResourceVirtualEnvironmentFileContentType).(string)
	sourceFile := d.Get(mkResourceVirtualEnvironmentFileSourceFile).([]interface{})
	sourceRaw := d.Get(mkResourceVirtualEnvironmentFileSourceRaw).([]interface{})

	sourceFilePath := ""

	if len(sourceFile) > 0 {
		sourceFileBlock := sourceFile[0].(map[string]interface{})
		sourceFilePath = sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFilePath].(string)
	} else if len(sourceRaw) > 0 {
		sourceRawBlock := sourceRaw[0].(map[string]interface{})
		sourceFilePath = sourceRawBlock[mkResourceVirtualEnvironmentFileSourceRawFileName].(string)
	} else {
		return nil, diag.Errorf(
			"missing argument \"%s.%s\" or \"%s\"",
			mkResourceVirtualEnvironmentFileSourceFile,
			mkResourceVirtualEnvironmentFileSourceFilePath,
			mkResourceVirtualEnvironmentFileSourceRaw,
		)
	}

	if contentType == "" {
		if strings.HasSuffix(sourceFilePath, ".tar.gz") ||
			strings.HasSuffix(sourceFilePath, ".tar.xz") {
			contentType = "vztmpl"
		} else {
			ext := strings.TrimLeft(strings.ToLower(filepath.Ext(sourceFilePath)), ".")

			switch ext {
			case "img", "iso":
				contentType = "iso"
			case "yaml", "yml":
				contentType = "snippets"
			}
		}

		if contentType == "" {
			return nil, diag.Errorf(
				"cannot determine the content type of source \"%s\" - Please manually define the \"%s\" argument",
				sourceFilePath,
				mkResourceVirtualEnvironmentFileContentType,
			)
		}
	}

	ctValidator := validators.ContentType()
	diags := ctValidator(contentType, cty.GetAttrPath(mkResourceVirtualEnvironmentFileContentType))

	return &contentType, diags
}

func fileGetSourceFileName(d *schema.ResourceData) (*string, error) {
	sourceFile := d.Get(mkResourceVirtualEnvironmentFileSourceFile).([]interface{})
	sourceRaw := d.Get(mkResourceVirtualEnvironmentFileSourceRaw).([]interface{})

	sourceFileFileName := ""
	sourceFilePath := ""

	if len(sourceFile) > 0 {
		sourceFileBlock := sourceFile[0].(map[string]interface{})
		sourceFileFileName = sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFileFileName].(string)
		sourceFilePath = sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFilePath].(string)
	} else if len(sourceRaw) > 0 {
		sourceRawBlock := sourceRaw[0].(map[string]interface{})
		sourceFileFileName = sourceRawBlock[mkResourceVirtualEnvironmentFileSourceRawFileName].(string)
	} else {
		return nil, fmt.Errorf(
			"missing argument \"%s.%s\"",
			mkResourceVirtualEnvironmentFileSourceFile,
			mkResourceVirtualEnvironmentFileSourceFilePath,
		)
	}

	if sourceFileFileName == "" {
		if fileIsURL(d) {
			downloadURL, err := url.ParseRequestURI(sourceFilePath)
			if err != nil {
				return nil, err
			}

			path := strings.Split(downloadURL.Path, "/")
			sourceFileFileName = path[len(path)-1]

			if sourceFileFileName == "" {
				return nil, fmt.Errorf(
					"failed to determine file name from the URL \"%s\"",
					sourceFilePath,
				)
			}
		} else {
			sourceFileFileName = filepath.Base(sourceFilePath)
		}
	}

	return &sourceFileFileName, nil
}

func fileGetVolumeID(d *schema.ResourceData) (fileVolumeID, diag.Diagnostics) {
	fileName, err := fileGetSourceFileName(d)
	if err != nil {
		return fileVolumeID{}, diag.FromErr(err)
	}

	datastoreID := d.Get(mkResourceVirtualEnvironmentFileDatastoreID).(string)
	contentType, diags := fileGetContentType(d)

	return fileVolumeID{
		datastoreID: datastoreID,
		contentType: *contentType,
		fileName:    *fileName,
	}, diags
}

func fileIsURL(d *schema.ResourceData) bool {
	sourceFile := d.Get(mkResourceVirtualEnvironmentFileSourceFile).([]interface{})
	sourceFilePath := ""

	if len(sourceFile) > 0 {
		sourceFileBlock := sourceFile[0].(map[string]interface{})
		sourceFilePath = sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFilePath].(string)
	} else {
		return false
	}

	return strings.HasPrefix(sourceFilePath, "http://") ||
		strings.HasPrefix(sourceFilePath, "https://")
}

func fileRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	capi, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	datastoreID := d.Get(mkResourceVirtualEnvironmentFileDatastoreID).(string)
	nodeName := d.Get(mkResourceVirtualEnvironmentFileNodeName).(string)
	sourceFile := d.Get(mkResourceVirtualEnvironmentFileSourceFile).([]interface{})

	list, err := capi.Node(nodeName).Storage(datastoreID).ListDatastoreFiles(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	readFileAttrs := readFile
	if fileIsURL(d) {
		readFileAttrs = readURL(capi.API().HTTP())
	}

	var diags diag.Diagnostics

	found := false
	for _, v := range list {
		if v.VolumeID == d.Id() {
			found = true

			volID, err := fileParseVolumeID(v.VolumeID)
			diags = append(diags, diag.FromErr(err)...)

			err = d.Set(mkResourceVirtualEnvironmentFileFileName, volID.fileName)
			diags = append(diags, diag.FromErr(err)...)

			err = d.Set(mkResourceVirtualEnvironmentFileContentType, v.ContentType)
			diags = append(diags, diag.FromErr(err)...)

			if len(sourceFile) == 0 {
				continue
			}

			sourceFileBlock := sourceFile[0].(map[string]interface{})
			sourceFilePath := sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFilePath].(string)

			fileModificationDate, fileSize, fileTag, err := readFileAttrs(ctx, sourceFilePath)
			diags = append(diags, diag.FromErr(err)...)

			if fileModificationDate != "" || fileSize != 0 || fileTag != "" {
				// only when file from state exists
				err = d.Set(mkResourceVirtualEnvironmentFileFileModificationDate, fileModificationDate)
				diags = append(diags, diag.FromErr(err)...)
				err = d.Set(mkResourceVirtualEnvironmentFileFileSize, fileSize)
				diags = append(diags, diag.FromErr(err)...)
				err = d.Set(mkResourceVirtualEnvironmentFileFileTag, fileTag)
				diags = append(diags, diag.FromErr(err)...)
			}

			lastFileMD := d.Get(mkResourceVirtualEnvironmentFileFileModificationDate).(string)
			lastFileSize := int64(d.Get(mkResourceVirtualEnvironmentFileFileSize).(int))
			lastFileTag := d.Get(mkResourceVirtualEnvironmentFileFileTag).(string)

			// just to make the logic easier to read
			changed := false
			if lastFileMD != "" && lastFileSize != 0 && lastFileTag != "" {
				changed = lastFileMD != fileModificationDate || lastFileSize != fileSize || lastFileTag != fileTag
			}

			sourceFileBlock[mkResourceVirtualEnvironmentFileSourceFileChanged] = changed
			err = d.Set(mkResourceVirtualEnvironmentFileSourceFile, sourceFile)
			diags = append(diags, diag.FromErr(err)...)

			if diags.HasError() {
				return diags
			}
			return nil
		}
	}

	if !found {
		// an empty ID is used to signal that the resource does not exist when provider reads the state
		// back after creation, or on the state refresh.
		d.SetId("")
	}

	return nil
}

//nolint:nonamedreturns
func readFile(
	ctx context.Context,
	sourceFilePath string,
) (fileModificationDate string, fileSize int64, fileTag string, err error) {
	f, err := os.Open(sourceFilePath)
	if err != nil {
		if os.IsNotExist(err) {
			// File does not exist, return zero values and no error
			return "", 0, "", nil
		}
		return
	}

	defer func(f *os.File) {
		e := f.Close()
		if e != nil {
			tflog.Error(ctx, "failed to close the file", map[string]interface{}{
				"error": e.Error(),
			})
		}
	}(f)

	fileInfo, err := f.Stat()
	if err != nil {
		return
	}

	fileModificationDate = fileInfo.ModTime().UTC().Format(time.RFC3339)
	fileSize = fileInfo.Size()
	fileTag = fmt.Sprintf("%x-%x", fileInfo.ModTime().UTC().Unix(), fileInfo.Size())

	return fileModificationDate, fileSize, fileTag, nil
}

func readURL(
	httClient *http.Client,
) func(
	ctx context.Context,
	sourceFilePath string,
) (fileModificationDate string, fileSize int64, fileTag string, err error) {
	return func(
		ctx context.Context,
		sourceFilePath string,
	) (string, int64, string, error) {
		req, err := http.NewRequestWithContext(ctx, http.MethodHead, sourceFilePath, nil)
		if err != nil {
			return "", 0, "", fmt.Errorf("failed to create a new request: %w", err)
		}

		res, err := httClient.Do(req) //nolint:bodyclose
		if err != nil {
			return "", 0, "", fmt.Errorf("failed to HEAD the URL: %w", err)
		}

		defer utils.CloseOrLogError(ctx)(res.Body)

		fileModificationDate := ""
		fileSize := res.ContentLength
		fileTag := ""
		httpLastModified := res.Header.Get("Last-Modified")

		if httpLastModified != "" {
			var timeParsed time.Time
			timeParsed, err = time.Parse(time.RFC1123, httpLastModified)
			if err != nil {
				timeParsed, err = time.Parse(time.RFC1123Z, httpLastModified)
				if err != nil {
					return fileModificationDate, fileSize, fileTag, fmt.Errorf("failed to parse Last-Modified header: %w", err)
				}
			}

			fileModificationDate = timeParsed.UTC().Format(time.RFC3339)
		}

		httpTag := res.Header.Get("ETag")

		if httpTag != "" {
			httpTagParts := strings.Split(httpTag, "\"")

			if len(httpTagParts) > 1 {
				fileTag = httpTagParts[1]
			}
		}

		return fileModificationDate, fileSize, fileTag, nil
	}
}

func fileDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	capi, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	datastoreID := d.Get(mkResourceVirtualEnvironmentFileDatastoreID).(string)
	nodeName := d.Get(mkResourceVirtualEnvironmentFileNodeName).(string)

	err = capi.Node(nodeName).Storage(datastoreID).DeleteDatastoreFile(ctx, d.Id())
	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}

func fileUpdate(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// a pass-through update function -- no actual resource update is needed / allowed
	// only the TF state is updated, for example, a timeout_upload attribute value
	return nil
}
`````

## File: proxmoxtf/resource/group_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestGroupInstantiation tests whether the Group instance can be instantiated.
func TestGroupInstantiation(t *testing.T) {
	t.Parallel()

	s := Group()
	if s == nil {
		t.Fatalf("Cannot instantiate Group")
	}
}

// TestGroupSchema tests the Group schema.
func TestGroupSchema(t *testing.T) {
	t.Parallel()

	s := Group().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentGroupID,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkResourceVirtualEnvironmentGroupACL,
		mkResourceVirtualEnvironmentGroupComment,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkResourceVirtualEnvironmentGroupMembers,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentGroupACL:     schema.TypeSet,
		mkResourceVirtualEnvironmentGroupComment: schema.TypeString,
		mkResourceVirtualEnvironmentGroupID:      schema.TypeString,
		mkResourceVirtualEnvironmentGroupMembers: schema.TypeSet,
	})

	aclSchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentGroupACL)

	test.AssertRequiredArguments(t, aclSchema, []string{
		mkResourceVirtualEnvironmentGroupACLPath,
		mkResourceVirtualEnvironmentGroupACLRoleID,
	})

	test.AssertOptionalArguments(t, aclSchema, []string{
		mkResourceVirtualEnvironmentGroupACLPropagate,
	})

	test.AssertValueTypes(t, aclSchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentGroupACLPath:      schema.TypeString,
		mkResourceVirtualEnvironmentGroupACLPropagate: schema.TypeBool,
		mkResourceVirtualEnvironmentGroupACLRoleID:    schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/group.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"errors"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	dvResourceVirtualEnvironmentGroupComment = ""

	mkResourceVirtualEnvironmentGroupACL          = "acl"
	mkResourceVirtualEnvironmentGroupACLPath      = "path"
	mkResourceVirtualEnvironmentGroupACLPropagate = "propagate"
	mkResourceVirtualEnvironmentGroupACLRoleID    = "role_id"
	mkResourceVirtualEnvironmentGroupComment      = "comment"
	mkResourceVirtualEnvironmentGroupID           = "group_id"
	mkResourceVirtualEnvironmentGroupMembers      = "members"
)

// Group returns a resource that manages a group in the Proxmox VE access control list.
func Group() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentGroupACL: {
				Type:        schema.TypeSet,
				Description: "The access control list",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentGroupACLPath: {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The path",
						},
						mkResourceVirtualEnvironmentGroupACLPropagate: {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to propagate to child paths",
							Default:     false,
						},
						mkResourceVirtualEnvironmentGroupACLRoleID: {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The role id",
						},
					},
				},
			},
			mkResourceVirtualEnvironmentGroupComment: {
				Type:        schema.TypeString,
				Description: "The group comment",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentGroupComment,
			},
			mkResourceVirtualEnvironmentGroupID: {
				Type:        schema.TypeString,
				Description: "The group id",
				Required:    true,
				ForceNew:    true,
			},
			mkResourceVirtualEnvironmentGroupMembers: {
				Type:        schema.TypeSet,
				Description: "The group members",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
		},
		CreateContext: groupCreate,
		ReadContext:   groupRead,
		UpdateContext: groupUpdate,
		DeleteContext: groupDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func groupCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	comment := d.Get(mkResourceVirtualEnvironmentGroupComment).(string)
	groupID := d.Get(mkResourceVirtualEnvironmentGroupID).(string)

	body := &access.GroupCreateRequestBody{
		Comment: &comment,
		ID:      groupID,
	}

	err = client.Access().CreateGroup(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(groupID)

	aclParsed := d.Get(mkResourceVirtualEnvironmentGroupACL).(*schema.Set).List()

	for _, v := range aclParsed {
		aclDelete := types.CustomBool(false)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentGroupACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Groups:    []string{groupID},
			Path:      aclEntry[mkResourceVirtualEnvironmentGroupACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentGroupACLRoleID].(string)},
		}

		err := client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return groupRead(ctx, d, m)
}

func groupRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	groupID := d.Id()
	group, err := client.Access().GetGroup(ctx, groupID)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")

			return nil
		}
		return diag.FromErr(err)
	}

	acl, err := client.Access().GetACL(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	var aclParsed []interface{}

	for _, v := range acl {
		if v.Type == "group" && v.UserOrGroupID == groupID {
			aclEntry := map[string]interface{}{}

			aclEntry[mkResourceVirtualEnvironmentGroupACLPath] = v.Path

			if v.Propagate != nil {
				aclEntry[mkResourceVirtualEnvironmentGroupACLPropagate] = bool(*v.Propagate)
			} else {
				aclEntry[mkResourceVirtualEnvironmentGroupACLPropagate] = false
			}

			aclEntry[mkResourceVirtualEnvironmentGroupACLRoleID] = v.RoleID

			aclParsed = append(aclParsed, aclEntry)
		}
	}

	err = d.Set(mkResourceVirtualEnvironmentGroupACL, aclParsed)
	diags = append(diags, diag.FromErr(err)...)

	if group.Comment != nil {
		err = d.Set(mkResourceVirtualEnvironmentGroupComment, group.Comment)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentGroupComment, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	err = d.Set(mkResourceVirtualEnvironmentGroupMembers, group.Members)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func groupUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	comment := d.Get(mkResourceVirtualEnvironmentGroupComment).(string)
	groupID := d.Id()

	body := &access.GroupUpdateRequestBody{
		Comment: &comment,
	}

	err = client.Access().UpdateGroup(ctx, groupID, body)
	if err != nil {
		return diag.FromErr(err)
	}

	aclArgOld, aclArg := d.GetChange(mkResourceVirtualEnvironmentGroupACL)
	aclParsedOld := aclArgOld.(*schema.Set).List()

	for _, v := range aclParsedOld {
		aclDelete := types.CustomBool(true)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentGroupACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Groups:    []string{groupID},
			Path:      aclEntry[mkResourceVirtualEnvironmentGroupACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentGroupACLRoleID].(string)},
		}

		err := client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	aclParsed := aclArg.(*schema.Set).List()

	for _, v := range aclParsed {
		aclDelete := types.CustomBool(false)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentGroupACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Groups:    []string{groupID},
			Path:      aclEntry[mkResourceVirtualEnvironmentGroupACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentGroupACLRoleID].(string)},
		}

		err := client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return groupRead(ctx, d, m)
}

func groupDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	aclParsed := d.Get(mkResourceVirtualEnvironmentGroupACL).(*schema.Set).List()
	groupID := d.Id()

	for _, v := range aclParsed {
		aclDelete := types.CustomBool(true)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentGroupACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Groups:    []string{groupID},
			Path:      aclEntry[mkResourceVirtualEnvironmentGroupACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentGroupACLRoleID].(string)},
		}

		err = client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	err = client.Access().DeleteGroup(ctx, groupID)

	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/hosts_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestHostsInstantiation tests whether the Hosts instance can be instantiated.
func TestHostsInstantiation(t *testing.T) {
	t.Parallel()

	s := Hosts()
	if s == nil {
		t.Fatalf("Cannot instantiate Hosts")
	}
}

// TestHostsSchema tests the Hosts schema.
func TestHostsSchema(t *testing.T) {
	t.Parallel()

	s := Hosts().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentHostsEntry,
		mkResourceVirtualEnvironmentHostsNodeName,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkResourceVirtualEnvironmentHostsAddresses,
		mkResourceVirtualEnvironmentHostsDigest,
		mkResourceVirtualEnvironmentHostsEntries,
		mkResourceVirtualEnvironmentHostsHostnames,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentHostsAddresses: schema.TypeList,
		mkResourceVirtualEnvironmentHostsDigest:    schema.TypeString,
		mkResourceVirtualEnvironmentHostsEntries:   schema.TypeList,
		mkResourceVirtualEnvironmentHostsEntry:     schema.TypeList,
		mkResourceVirtualEnvironmentHostsHostnames: schema.TypeList,
		mkResourceVirtualEnvironmentHostsNodeName:  schema.TypeString,
	})

	entriesSchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentHostsEntries)

	test.AssertComputedAttributes(t, entriesSchema, []string{
		mkResourceVirtualEnvironmentHostsEntriesAddress,
		mkResourceVirtualEnvironmentHostsEntriesHostnames,
	})

	test.AssertValueTypes(t, entriesSchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentHostsEntriesAddress:   schema.TypeString,
		mkResourceVirtualEnvironmentHostsEntriesHostnames: schema.TypeList,
	})

	entrySchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentHostsEntry)

	test.AssertRequiredArguments(t, entrySchema, []string{
		mkResourceVirtualEnvironmentHostsEntryAddress,
		mkResourceVirtualEnvironmentHostsEntryHostnames,
	})

	test.AssertValueTypes(t, entrySchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentHostsEntryAddress:   schema.TypeString,
		mkResourceVirtualEnvironmentHostsEntryHostnames: schema.TypeList,
	})
}
`````

## File: proxmoxtf/resource/hosts.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkResourceVirtualEnvironmentHostsAddresses        = "addresses"
	mkResourceVirtualEnvironmentHostsDigest           = "digest"
	mkResourceVirtualEnvironmentHostsEntries          = "entries"
	mkResourceVirtualEnvironmentHostsEntriesAddress   = "address"
	mkResourceVirtualEnvironmentHostsEntriesHostnames = "hostnames"
	mkResourceVirtualEnvironmentHostsEntry            = "entry"
	mkResourceVirtualEnvironmentHostsEntryAddress     = "address"
	mkResourceVirtualEnvironmentHostsEntryHostnames   = "hostnames"
	mkResourceVirtualEnvironmentHostsHostnames        = "hostnames"
	mkResourceVirtualEnvironmentHostsNodeName         = "node_name"
)

// Hosts returns a resource that manages hosts settings for a node.
func Hosts() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentHostsAddresses: {
				Type:        schema.TypeList,
				Description: "The addresses",
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkResourceVirtualEnvironmentHostsDigest: {
				Type:        schema.TypeString,
				Description: "The SHA1 digest",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentHostsEntries: {
				Type:        schema.TypeList,
				Description: "The host entries",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentHostsEntriesAddress: {
							Type:        schema.TypeString,
							Description: "The address",
							Computed:    true,
						},
						mkResourceVirtualEnvironmentHostsEntriesHostnames: {
							Type:        schema.TypeList,
							Description: "The hostnames",
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			mkResourceVirtualEnvironmentHostsEntry: {
				Type:        schema.TypeList,
				Description: "The host entries",
				Required:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentHostsEntryAddress: {
							Type:        schema.TypeString,
							Description: "The address",
							Required:    true,
						},
						mkResourceVirtualEnvironmentHostsEntryHostnames: {
							Type:        schema.TypeList,
							Description: "The hostnames",
							Required:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							MinItems:    1,
						},
					},
				},
				MinItems: 1,
			},
			mkResourceVirtualEnvironmentHostsHostnames: {
				Type:        schema.TypeList,
				Description: "The hostnames",
				Computed:    true,
				Elem: &schema.Schema{
					Type: schema.TypeList,
					Elem: &schema.Schema{Type: schema.TypeString},
				},
			},
			mkResourceVirtualEnvironmentHostsNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
		},
		CreateContext: hostsCreate,
		ReadContext:   hostsRead,
		UpdateContext: hostsUpdate,
		DeleteContext: hostsDelete,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				nodeName := d.Id()

				err := d.Set(mkResourceVirtualEnvironmentHostsNodeName, nodeName)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				d.SetId(fmt.Sprintf("%s_hosts", nodeName))

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func hostsCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	diags := hostsUpdate(ctx, d, m)
	if diags.HasError() {
		return diags
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentHostsNodeName).(string)

	d.SetId(fmt.Sprintf("%s_hosts", nodeName))

	return diags
}

func hostsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentHostsNodeName).(string)

	hosts, err := api.Node(nodeName).GetHosts(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	// Parse the entries in the hosts file.
	var addresses []interface{}
	var entries []interface{}
	var hostnames []interface{}
	lines := strings.Split(hosts.Data, "\n")

	for _, line := range lines {
		if strings.HasPrefix(line, "#") {
			continue
		}

		line = strings.ReplaceAll(line, "\t", " ")
		values := strings.Split(line, " ")

		if values[0] == "" {
			continue
		}

		addresses = append(addresses, values[0])
		entry := map[string]interface{}{}
		var hostnamesForAddress []interface{}

		for _, hostname := range values[1:] {
			if hostname != "" {
				hostnamesForAddress = append(hostnamesForAddress, hostname)
			}
		}

		entry[mkResourceVirtualEnvironmentHostsEntriesAddress] = values[0]
		entry[mkResourceVirtualEnvironmentHostsEntriesHostnames] = hostnamesForAddress

		entries = append(entries, entry)
		hostnames = append(hostnames, hostnamesForAddress)
	}

	err = d.Set(mkResourceVirtualEnvironmentHostsAddresses, addresses)
	diags = append(diags, diag.FromErr(err)...)

	if hosts.Digest != nil {
		err = d.Set(mkResourceVirtualEnvironmentHostsDigest, *hosts.Digest)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentHostsDigest, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	err = d.Set(mkResourceVirtualEnvironmentHostsEntries, entries)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkResourceVirtualEnvironmentHostsEntry, entries)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkResourceVirtualEnvironmentHostsHostnames, hostnames)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func hostsUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	entry := d.Get(mkResourceVirtualEnvironmentHostsEntry).([]interface{})
	nodeName := d.Get(mkResourceVirtualEnvironmentHostsNodeName).(string)

	// Generate the data for the hosts file based on the specified entries.
	body := nodes.HostsUpdateRequestBody{
		Data: "",
	}

	for _, e := range entry {
		eMap := e.(map[string]interface{})

		address := eMap[mkResourceVirtualEnvironmentHostsEntryAddress].(string)
		hostnames := eMap[mkResourceVirtualEnvironmentHostsEntryHostnames].([]interface{})

		body.Data += address

		for _, h := range hostnames {
			hostname := h.(string)
			body.Data += " " + hostname
		}

		body.Data += "\n"
	}

	err = api.Node(nodeName).UpdateHosts(ctx, &body)
	if err != nil {
		return diag.FromErr(err)
	}

	return hostsRead(ctx, d, m)
}

func hostsDelete(_ context.Context, d *schema.ResourceData, _ interface{}) diag.Diagnostics {
	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/pool_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestPoolInstantiation tests whether the Pool instance can be instantiated.
func TestPoolInstantiation(t *testing.T) {
	t.Parallel()

	s := Pool()
	if s == nil {
		t.Fatalf("Cannot instantiate Pool")
	}
}

// TestPoolSchema tests the Pool schema.
func TestPoolSchema(t *testing.T) {
	t.Parallel()

	s := Pool().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentPoolPoolID,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkResourceVirtualEnvironmentPoolComment,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkResourceVirtualEnvironmentPoolMembers,
	})

	membersSchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentPoolMembers)

	test.AssertComputedAttributes(t, membersSchema, []string{
		mkResourceVirtualEnvironmentPoolMembersDatastoreID,
		mkResourceVirtualEnvironmentPoolMembersID,
		mkResourceVirtualEnvironmentPoolMembersNodeName,
		mkResourceVirtualEnvironmentPoolMembersType,
		mkResourceVirtualEnvironmentPoolMembersVMID,
	})

	test.AssertValueTypes(t, membersSchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentPoolMembersDatastoreID: schema.TypeString,
		mkResourceVirtualEnvironmentPoolMembersID:          schema.TypeString,
		mkResourceVirtualEnvironmentPoolMembersNodeName:    schema.TypeString,
		mkResourceVirtualEnvironmentPoolMembersType:        schema.TypeString,
		mkResourceVirtualEnvironmentPoolMembersVMID:        schema.TypeInt,
	})
}
`````

## File: proxmoxtf/resource/pool.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"errors"
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/pools"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	dvResourceVirtualEnvironmentPoolComment = ""

	mkResourceVirtualEnvironmentPoolComment            = "comment"
	mkResourceVirtualEnvironmentPoolMembers            = "members"
	mkResourceVirtualEnvironmentPoolMembersDatastoreID = "datastore_id"
	mkResourceVirtualEnvironmentPoolMembersID          = "id"
	mkResourceVirtualEnvironmentPoolMembersNodeName    = "node_name"
	mkResourceVirtualEnvironmentPoolMembersType        = "type"
	mkResourceVirtualEnvironmentPoolMembersVMID        = "vm_id"
	mkResourceVirtualEnvironmentPoolPoolID             = "pool_id"
)

// Pool returns a resource that manages pools.
func Pool() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentPoolComment: {
				Type:        schema.TypeString,
				Description: "The pool comment",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentPoolComment,
			},
			mkResourceVirtualEnvironmentPoolMembers: {
				Type:        schema.TypeList,
				Description: "The pool members",
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentPoolMembersDatastoreID: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The datastore id",
						},
						mkResourceVirtualEnvironmentPoolMembersID: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The member id",
						},
						mkResourceVirtualEnvironmentPoolMembersNodeName: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The node name",
						},
						mkResourceVirtualEnvironmentPoolMembersType: {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The member type",
						},
						mkResourceVirtualEnvironmentPoolMembersVMID: {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "The virtual machine id",
						},
					},
				},
			},
			mkResourceVirtualEnvironmentPoolPoolID: {
				Type:        schema.TypeString,
				Description: "The pool id",
				Required:    true,
				ForceNew:    true,
			},
		},
		CreateContext: poolCreate,
		ReadContext:   poolRead,
		UpdateContext: poolUpdate,
		DeleteContext: poolDelete,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				d.SetId(d.Id())
				err := d.Set(mkResourceVirtualEnvironmentPoolPoolID, d.Id())
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func poolCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	comment := d.Get(mkResourceVirtualEnvironmentPoolComment).(string)
	poolID := d.Get(mkResourceVirtualEnvironmentPoolPoolID).(string)

	body := &pools.PoolCreateRequestBody{
		Comment: &comment,
		ID:      poolID,
	}

	err = client.Pool().CreatePool(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(poolID)

	return poolRead(ctx, d, m)
}

func poolRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	poolID := d.Id()
	pool, err := client.Pool().GetPool(ctx, poolID)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")
			return nil
		}
		return diag.FromErr(err)
	}

	if pool.Comment != nil {
		err = d.Set(mkResourceVirtualEnvironmentPoolComment, pool.Comment)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentPoolComment, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	members := make([]interface{}, len(pool.Members))

	for i, v := range pool.Members {
		values := map[string]interface{}{}

		values[mkResourceVirtualEnvironmentPoolMembersID] = v.ID
		values[mkResourceVirtualEnvironmentPoolMembersNodeName] = v.Node

		if v.DatastoreID != nil {
			values[mkResourceVirtualEnvironmentPoolMembersDatastoreID] = v.DatastoreID
		} else {
			values[mkResourceVirtualEnvironmentPoolMembersDatastoreID] = ""
		}

		values[mkResourceVirtualEnvironmentPoolMembersType] = v.Type

		if v.VMID != nil {
			values[mkResourceVirtualEnvironmentPoolMembersVMID] = v.VMID
		} else {
			values[mkResourceVirtualEnvironmentPoolMembersVMID] = 0
		}

		members[i] = values
	}

	err = d.Set(mkResourceVirtualEnvironmentPoolMembers, members)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func poolUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	comment := d.Get(mkResourceVirtualEnvironmentPoolComment).(string)
	poolID := d.Id()

	body := &pools.PoolUpdateRequestBody{
		Comment: &comment,
	}

	err = client.Pool().UpdatePool(ctx, poolID, body)
	if err != nil {
		return diag.FromErr(err)
	}

	return poolRead(ctx, d, m)
}

func poolDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	poolID := d.Id()

	err = client.Pool().DeletePool(ctx, poolID)
	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/role_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestRoleInstantiation tests whether the Role instance can be instantiated.
func TestRoleInstantiation(t *testing.T) {
	t.Parallel()

	s := Role()
	if s == nil {
		t.Fatalf("Cannot instantiate Role")
	}
}

// TestRoleSchema tests the Role schema.
func TestRoleSchema(t *testing.T) {
	t.Parallel()

	s := Role().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentRolePrivileges,
		mkResourceVirtualEnvironmentRoleRoleID,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentRolePrivileges: schema.TypeSet,
		mkResourceVirtualEnvironmentRoleRoleID:     schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/role.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"errors"
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkResourceVirtualEnvironmentRolePrivileges = "privileges"
	mkResourceVirtualEnvironmentRoleRoleID     = "role_id"
)

// Role returns a resource that manages roles.
func Role() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentRolePrivileges: {
				Type:        schema.TypeSet,
				Description: "The role privileges",
				Required:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			mkResourceVirtualEnvironmentRoleRoleID: {
				Type:        schema.TypeString,
				Description: "The role id",
				Required:    true,
				ForceNew:    true,
			},
		},
		CreateContext: roleCreate,
		ReadContext:   roleRead,
		UpdateContext: roleUpdate,
		DeleteContext: roleDelete,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				roleID := d.Id()

				err := d.Set(mkResourceVirtualEnvironmentRoleRoleID, roleID)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func roleCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	privileges := d.Get(mkResourceVirtualEnvironmentRolePrivileges).(*schema.Set).List()
	customPrivileges := make(types.CustomPrivileges, len(privileges))
	roleID := d.Get(mkResourceVirtualEnvironmentRoleRoleID).(string)

	for i, v := range privileges {
		customPrivileges[i] = v.(string)
	}

	body := &access.RoleCreateRequestBody{
		ID:         roleID,
		Privileges: customPrivileges,
	}

	err = client.Access().CreateRole(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(roleID)

	return roleRead(ctx, d, m)
}

func roleRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	roleID := d.Id()

	role, err := client.Access().GetRole(ctx, roleID)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")

			return nil
		}

		return diag.FromErr(err)
	}

	privileges := schema.NewSet(schema.HashString, []interface{}{})

	if *role != nil {
		for _, v := range *role {
			privileges.Add(v)
		}
	}

	err = d.Set(mkResourceVirtualEnvironmentRolePrivileges, privileges)

	return diag.FromErr(err)
}

func roleUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	privileges := d.Get(mkResourceVirtualEnvironmentRolePrivileges).(*schema.Set).List()
	customPrivileges := make(types.CustomPrivileges, len(privileges))
	roleID := d.Id()

	for i, v := range privileges {
		customPrivileges[i] = v.(string)
	}

	body := &access.RoleUpdateRequestBody{
		Privileges: customPrivileges,
	}

	err = client.Access().UpdateRole(ctx, roleID, body)
	if err != nil {
		return diag.FromErr(err)
	}

	return roleRead(ctx, d, m)
}

func roleDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)

	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	roleID := d.Id()

	err = client.Access().DeleteRole(ctx, roleID)
	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/time_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestTimeInstantiation tests whether the Time instance can be instantiated.
func TestTimeInstantiation(t *testing.T) {
	t.Parallel()

	s := Time()
	if s == nil {
		t.Fatalf("Cannot instantiate Time")
	}
}

// TestTimeSchema tests the Time schema.
func TestTimeSchema(t *testing.T) {
	t.Parallel()

	s := Time().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentTimeNodeName,
		mkResourceVirtualEnvironmentTimeTimeZone,
	})

	test.AssertComputedAttributes(t, s, []string{
		mkResourceVirtualEnvironmentTimeLocalTime,
		mkResourceVirtualEnvironmentTimeUTCTime,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentTimeLocalTime: schema.TypeString,
		mkResourceVirtualEnvironmentTimeNodeName:  schema.TypeString,
		mkResourceVirtualEnvironmentTimeTimeZone:  schema.TypeString,
		mkResourceVirtualEnvironmentTimeUTCTime:   schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/time.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"fmt"
	"time"
	_ "time/tzdata" // Load time zone data, see https://pkg.go.dev/time/tzdata

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmox/nodes"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	mkResourceVirtualEnvironmentTimeLocalTime = "local_time"
	mkResourceVirtualEnvironmentTimeNodeName  = "node_name"
	mkResourceVirtualEnvironmentTimeTimeZone  = "time_zone"
	mkResourceVirtualEnvironmentTimeUTCTime   = "utc_time"
)

// Time returns a resource that manages time settings for a node.
func Time() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentTimeLocalTime: {
				Type:        schema.TypeString,
				Description: "The local timestamp",
				Computed:    true,
			},
			mkResourceVirtualEnvironmentTimeNodeName: {
				Type:        schema.TypeString,
				Description: "The node name",
				Required:    true,
			},
			mkResourceVirtualEnvironmentTimeTimeZone: {
				Type:        schema.TypeString,
				Description: "The time zone",
				Required:    true,
			},
			mkResourceVirtualEnvironmentTimeUTCTime: {
				Type:        schema.TypeString,
				Description: "The UTC timestamp",
				Computed:    true,
			},
		},
		CreateContext: timeCreate,
		ReadContext:   timeRead,
		UpdateContext: timeUpdate,
		DeleteContext: timeDelete,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				nodeName := d.Id()

				err := d.Set(mkResourceVirtualEnvironmentTimeNodeName, nodeName)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				d.SetId(fmt.Sprintf("%s_time", nodeName))

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func timeCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	diags := timeUpdate(ctx, d, m)
	if diags.HasError() {
		return diags
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentTimeNodeName).(string)

	d.SetId(fmt.Sprintf("%s_time", nodeName))

	return nil
}

func timeRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics

	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentTimeNodeName).(string)
	nodeTime, err := api.Node(nodeName).GetTime(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	localLocation, err := time.LoadLocation(nodeTime.TimeZone)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(fmt.Sprintf("%s_time", nodeName))

	localTimeOffset := time.Time(nodeTime.LocalTime).Sub(time.Now().UTC())
	localTime := time.Time(nodeTime.LocalTime).Add(-localTimeOffset).In(localLocation)

	err = d.Set(mkResourceVirtualEnvironmentTimeLocalTime, localTime.Format(time.RFC3339))
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(mkResourceVirtualEnvironmentTimeTimeZone, nodeTime.TimeZone)
	diags = append(diags, diag.FromErr(err)...)
	err = d.Set(
		mkResourceVirtualEnvironmentTimeUTCTime,
		time.Time(nodeTime.UTCTime).Format(time.RFC3339),
	)
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func timeUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	api, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	nodeName := d.Get(mkResourceVirtualEnvironmentTimeNodeName).(string)
	timeZone := d.Get(mkResourceVirtualEnvironmentTimeTimeZone).(string)

	err = api.Node(nodeName).UpdateTime(
		ctx,
		&nodes.UpdateTimeRequestBody{
			TimeZone: timeZone,
		},
	)
	if err != nil {
		return diag.FromErr(err)
	}

	return timeRead(ctx, d, m)
}

func timeDelete(_ context.Context, d *schema.ResourceData, _ interface{}) diag.Diagnostics {
	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/resource/user_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/test"
)

// TestUserInstantiation tests whether the User instance can be instantiated.
func TestUserInstantiation(t *testing.T) {
	t.Parallel()

	s := User()
	if s == nil {
		t.Fatalf("Cannot instantiate User")
	}
}

// TestUserSchema tests the User schema.
func TestUserSchema(t *testing.T) {
	t.Parallel()

	s := User().Schema

	test.AssertRequiredArguments(t, s, []string{
		mkResourceVirtualEnvironmentUserUserID,
	})

	test.AssertOptionalArguments(t, s, []string{
		mkResourceVirtualEnvironmentUserACL,
		mkResourceVirtualEnvironmentUserComment,
		mkResourceVirtualEnvironmentUserEmail,
		mkResourceVirtualEnvironmentUserEnabled,
		mkResourceVirtualEnvironmentUserExpirationDate,
		mkResourceVirtualEnvironmentUserFirstName,
		mkResourceVirtualEnvironmentUserGroups,
		mkResourceVirtualEnvironmentUserKeys,
		mkResourceVirtualEnvironmentUserLastName,
		mkResourceVirtualEnvironmentUserPassword,
	})

	test.AssertValueTypes(t, s, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentUserACL:            schema.TypeSet,
		mkResourceVirtualEnvironmentUserComment:        schema.TypeString,
		mkResourceVirtualEnvironmentUserEmail:          schema.TypeString,
		mkResourceVirtualEnvironmentUserEnabled:        schema.TypeBool,
		mkResourceVirtualEnvironmentUserExpirationDate: schema.TypeString,
		mkResourceVirtualEnvironmentUserFirstName:      schema.TypeString,
		mkResourceVirtualEnvironmentUserGroups:         schema.TypeSet,
		mkResourceVirtualEnvironmentUserKeys:           schema.TypeString,
		mkResourceVirtualEnvironmentUserLastName:       schema.TypeString,
		mkResourceVirtualEnvironmentUserPassword:       schema.TypeString,
		mkResourceVirtualEnvironmentUserUserID:         schema.TypeString,
	})

	aclSchema := test.AssertNestedSchemaExistence(t, s, mkResourceVirtualEnvironmentUserACL)

	test.AssertRequiredArguments(t, aclSchema, []string{
		mkResourceVirtualEnvironmentUserACLPath,
		mkResourceVirtualEnvironmentUserACLRoleID,
	})

	test.AssertOptionalArguments(t, aclSchema, []string{
		mkResourceVirtualEnvironmentUserACLPropagate,
	})

	test.AssertValueTypes(t, aclSchema, map[string]schema.ValueType{
		mkResourceVirtualEnvironmentUserACLPath:      schema.TypeString,
		mkResourceVirtualEnvironmentUserACLPropagate: schema.TypeBool,
		mkResourceVirtualEnvironmentUserACLRoleID:    schema.TypeString,
	})
}
`````

## File: proxmoxtf/resource/user.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package resource

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/bpg/terraform-provider-proxmox/proxmox/access"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/types"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf"
)

const (
	dvResourceVirtualEnvironmentUserComment   = ""
	dvResourceVirtualEnvironmentUserEmail     = ""
	dvResourceVirtualEnvironmentUserEnabled   = true
	dvResourceVirtualEnvironmentUserFirstName = ""
	dvResourceVirtualEnvironmentUserKeys      = ""
	dvResourceVirtualEnvironmentUserLastName  = ""

	mkResourceVirtualEnvironmentUserACL            = "acl"
	mkResourceVirtualEnvironmentUserACLPath        = "path"
	mkResourceVirtualEnvironmentUserACLPropagate   = "propagate"
	mkResourceVirtualEnvironmentUserACLRoleID      = "role_id"
	mkResourceVirtualEnvironmentUserComment        = "comment"
	mkResourceVirtualEnvironmentUserEmail          = "email"
	mkResourceVirtualEnvironmentUserEnabled        = "enabled"
	mkResourceVirtualEnvironmentUserExpirationDate = "expiration_date"
	mkResourceVirtualEnvironmentUserFirstName      = "first_name"
	mkResourceVirtualEnvironmentUserGroups         = "groups"
	mkResourceVirtualEnvironmentUserKeys           = "keys"
	mkResourceVirtualEnvironmentUserLastName       = "last_name"
	mkResourceVirtualEnvironmentUserPassword       = "password"
	mkResourceVirtualEnvironmentUserUserID         = "user_id"
)

// User returns a resource that manages a user in the Proxmox VE access control list.
func User() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentUserACL: {
				Type:        schema.TypeSet,
				Description: "The access control list",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []interface{}{}, nil
				},
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						mkResourceVirtualEnvironmentUserACLPath: {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The path",
						},
						mkResourceVirtualEnvironmentUserACLPropagate: {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Whether to propagate to child paths",
							Default:     false,
						},
						mkResourceVirtualEnvironmentUserACLRoleID: {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The role id",
						},
					},
				},
			},
			mkResourceVirtualEnvironmentUserComment: {
				Type:        schema.TypeString,
				Description: "The user comment",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentUserComment,
			},
			mkResourceVirtualEnvironmentUserEmail: {
				Type:        schema.TypeString,
				Description: "The user's email address",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentUserEmail,
			},
			mkResourceVirtualEnvironmentUserEnabled: {
				Type:        schema.TypeBool,
				Description: "Whether the user account is enabled",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentUserEnabled,
			},
			mkResourceVirtualEnvironmentUserExpirationDate: {
				Type:         schema.TypeString,
				Description:  "The user account's expiration date",
				Optional:     true,
				Default:      time.Unix(0, 0).UTC().Format(time.RFC3339),
				ValidateFunc: validation.IsRFC3339Time,
			},
			mkResourceVirtualEnvironmentUserFirstName: {
				Type:        schema.TypeString,
				Description: "The user's first name",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentUserFirstName,
			},
			mkResourceVirtualEnvironmentUserGroups: {
				Type:        schema.TypeSet,
				Description: "The user's groups",
				Optional:    true,
				DefaultFunc: func() (interface{}, error) {
					return []string{}, nil
				},
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			mkResourceVirtualEnvironmentUserKeys: {
				Type:        schema.TypeString,
				Description: "The user's keys",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentUserKeys,
			},
			mkResourceVirtualEnvironmentUserLastName: {
				Type:        schema.TypeString,
				Description: "The user's last name",
				Optional:    true,
				Default:     dvResourceVirtualEnvironmentUserLastName,
			},
			mkResourceVirtualEnvironmentUserPassword: {
				Type:        schema.TypeString,
				Description: "The user's password",
				Optional:    true,
				Sensitive:   true,
			},
			mkResourceVirtualEnvironmentUserUserID: {
				Type:        schema.TypeString,
				Description: "The user id",
				Required:    true,
				ForceNew:    true,
			},
		},
		CreateContext: userCreate,
		ReadContext:   userRead,
		UpdateContext: userUpdate,
		DeleteContext: userDelete,
		Importer: &schema.ResourceImporter{
			StateContext: func(_ context.Context, d *schema.ResourceData, _ interface{}) ([]*schema.ResourceData, error) {
				roleID := d.Id()

				err := d.Set(mkResourceVirtualEnvironmentUserUserID, roleID)
				if err != nil {
					return nil, fmt.Errorf("failed setting state during import: %w", err)
				}

				return []*schema.ResourceData{d}, nil
			},
		},
	}
}

func userCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	comment := d.Get(mkResourceVirtualEnvironmentUserComment).(string)
	email := d.Get(mkResourceVirtualEnvironmentUserEmail).(string)
	enabled := types.CustomBool(d.Get(mkResourceVirtualEnvironmentUserEnabled).(bool))
	expirationDate, err := time.Parse(
		time.RFC3339,
		d.Get(mkResourceVirtualEnvironmentUserExpirationDate).(string),
	)
	if err != nil {
		return diag.FromErr(err)
	}

	expirationDateCustom := expirationDate.Unix()
	firstName := d.Get(mkResourceVirtualEnvironmentUserFirstName).(string)
	groups := d.Get(mkResourceVirtualEnvironmentUserGroups).(*schema.Set).List()
	groupsCustom := make([]string, len(groups))

	for i, v := range groups {
		groupsCustom[i] = v.(string)
	}

	keys := d.Get(mkResourceVirtualEnvironmentUserKeys).(string)
	lastName := d.Get(mkResourceVirtualEnvironmentUserLastName).(string)
	password := d.Get(mkResourceVirtualEnvironmentUserPassword).(string)
	userID := d.Get(mkResourceVirtualEnvironmentUserUserID).(string)

	body := &access.UserCreateRequestBody{
		Comment:        &comment,
		Email:          &email,
		Enabled:        &enabled,
		ExpirationDate: &expirationDateCustom,
		FirstName:      &firstName,
		Groups:         groupsCustom,
		ID:             userID,
		Keys:           &keys,
		LastName:       &lastName,
		Password:       password,
	}

	err = client.Access().CreateUser(ctx, body)
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(userID)

	aclParsed := d.Get(mkResourceVirtualEnvironmentUserACL).(*schema.Set).List()

	for _, v := range aclParsed {
		aclDelete := types.CustomBool(false)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentUserACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Path:      aclEntry[mkResourceVirtualEnvironmentUserACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentUserACLRoleID].(string)},
			Users:     []string{userID},
		}

		err := client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return userRead(ctx, d, m)
}

func userRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	userID := d.Id()
	user, err := client.Access().GetUser(ctx, userID)
	if err != nil {
		if errors.Is(err, api.ErrResourceDoesNotExist) {
			d.SetId("")

			return nil
		}
		return diag.FromErr(err)
	}

	acl, err := client.Access().GetACL(ctx)
	if err != nil {
		return diag.FromErr(err)
	}

	var diags diag.Diagnostics

	err = d.Set(mkResourceVirtualEnvironmentUserUserID, userID)
	diags = append(diags, diag.FromErr(err)...)

	var aclParsed []interface{}

	for _, v := range acl {
		if v.Type == "user" && v.UserOrGroupID == userID {
			aclEntry := map[string]interface{}{}

			aclEntry[mkResourceVirtualEnvironmentUserACLPath] = v.Path

			if v.Propagate != nil {
				aclEntry[mkResourceVirtualEnvironmentUserACLPropagate] = bool(*v.Propagate)
			} else {
				aclEntry[mkResourceVirtualEnvironmentUserACLPropagate] = false
			}

			aclEntry[mkResourceVirtualEnvironmentUserACLRoleID] = v.RoleID

			aclParsed = append(aclParsed, aclEntry)
		}
	}

	err = d.Set(mkResourceVirtualEnvironmentUserACL, aclParsed)
	diags = append(diags, diag.FromErr(err)...)

	if user.Comment != nil {
		err = d.Set(mkResourceVirtualEnvironmentUserComment, user.Comment)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserComment, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if user.Email != nil {
		err = d.Set(mkResourceVirtualEnvironmentUserEmail, user.Email)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserEmail, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if user.Enabled != nil {
		err = d.Set(mkResourceVirtualEnvironmentUserEnabled, user.Enabled)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserEnabled, true)
	}
	diags = append(diags, diag.FromErr(err)...)

	if user.ExpirationDate != nil {
		err = d.Set(
			mkResourceVirtualEnvironmentUserExpirationDate,
			time.Unix(*user.ExpirationDate, 0).UTC().Format(time.RFC3339),
		)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserExpirationDate, time.Unix(0, 0).UTC().Format(time.RFC3339))
	}
	diags = append(diags, diag.FromErr(err)...)

	if user.FirstName != nil {
		err = d.Set(mkResourceVirtualEnvironmentUserFirstName, user.FirstName)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserFirstName, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	groups := schema.NewSet(schema.HashString, []interface{}{})

	if user.Groups != nil {
		for _, v := range *user.Groups {
			groups.Add(v)
		}
	}

	err = d.Set(mkResourceVirtualEnvironmentUserGroups, groups)
	diags = append(diags, diag.FromErr(err)...)

	if user.Keys != nil {
		err = d.Set(mkResourceVirtualEnvironmentUserKeys, user.Keys)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserKeys, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	if user.LastName != nil {
		err = d.Set(mkResourceVirtualEnvironmentUserLastName, user.LastName)
	} else {
		err = d.Set(mkResourceVirtualEnvironmentUserLastName, "")
	}
	diags = append(diags, diag.FromErr(err)...)

	return diags
}

func userUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	comment := d.Get(mkResourceVirtualEnvironmentUserComment).(string)
	email := d.Get(mkResourceVirtualEnvironmentUserEmail).(string)
	enabled := types.CustomBool(d.Get(mkResourceVirtualEnvironmentUserEnabled).(bool))
	expirationDate, err := time.Parse(
		time.RFC3339,
		d.Get(mkResourceVirtualEnvironmentUserExpirationDate).(string),
	)
	if err != nil {
		return diag.FromErr(err)
	}

	expirationDateCustom := expirationDate.Unix()
	firstName := d.Get(mkResourceVirtualEnvironmentUserFirstName).(string)
	groups := d.Get(mkResourceVirtualEnvironmentUserGroups).(*schema.Set).List()
	groupsCustom := make([]string, len(groups))

	for i, v := range groups {
		groupsCustom[i] = v.(string)
	}

	keys := d.Get(mkResourceVirtualEnvironmentUserKeys).(string)
	lastName := d.Get(mkResourceVirtualEnvironmentUserLastName).(string)

	body := &access.UserUpdateRequestBody{
		Comment:        &comment,
		Email:          &email,
		Enabled:        &enabled,
		ExpirationDate: &expirationDateCustom,
		FirstName:      &firstName,
		Groups:         groupsCustom,
		Keys:           &keys,
		LastName:       &lastName,
	}

	userID := d.Id()
	err = client.Access().UpdateUser(ctx, userID, body)
	if err != nil {
		return diag.FromErr(err)
	}

	if d.HasChange(mkResourceVirtualEnvironmentUserPassword) {
		password := d.Get(mkResourceVirtualEnvironmentUserPassword).(string)
		err = client.Access().ChangeUserPassword(ctx, userID, password)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	aclArgOld, aclArg := d.GetChange(mkResourceVirtualEnvironmentUserACL)
	aclParsedOld := aclArgOld.(*schema.Set).List()

	for _, v := range aclParsedOld {
		aclDelete := types.CustomBool(true)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentUserACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Path:      aclEntry[mkResourceVirtualEnvironmentUserACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentUserACLRoleID].(string)},
			Users:     []string{userID},
		}

		err := client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	aclParsed := aclArg.(*schema.Set).List()

	for _, v := range aclParsed {
		aclDelete := types.CustomBool(false)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentUserACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Path:      aclEntry[mkResourceVirtualEnvironmentUserACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentUserACLRoleID].(string)},
			Users:     []string{userID},
		}

		err := client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	return userRead(ctx, d, m)
}

func userDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	config := m.(proxmoxtf.ProviderConfiguration)
	client, err := config.GetClient()
	if err != nil {
		return diag.FromErr(err)
	}

	aclParsed := d.Get(mkResourceVirtualEnvironmentUserACL).(*schema.Set).List()
	userID := d.Id()

	for _, v := range aclParsed {
		aclDelete := types.CustomBool(true)
		aclEntry := v.(map[string]interface{})
		aclPropagate := types.CustomBool(
			aclEntry[mkResourceVirtualEnvironmentUserACLPropagate].(bool),
		)

		aclBody := &access.ACLUpdateRequestBody{
			Delete:    &aclDelete,
			Path:      aclEntry[mkResourceVirtualEnvironmentUserACLPath].(string),
			Propagate: &aclPropagate,
			Roles:     []string{aclEntry[mkResourceVirtualEnvironmentUserACLRoleID].(string)},
			Users:     []string{userID},
		}

		err = client.Access().UpdateACL(ctx, aclBody)
		if err != nil {
			return diag.FromErr(err)
		}
	}

	err = client.Access().DeleteUser(ctx, userID)
	if err != nil && !errors.Is(err, api.ErrResourceDoesNotExist) {
		return diag.FromErr(err)
	}

	d.SetId("")

	return nil
}
`````

## File: proxmoxtf/structure/schema.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package structure

import (
	"fmt"
	"reflect"
	"sort"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/utils"
)

// MergeSchema merges the map[string]*schema.Schema from src into dst.
// Panicking enforces safety against conflicts.
func MergeSchema(dst, src map[string]*schema.Schema) {
	for k, v := range src {
		if _, ok := dst[k]; ok {
			panic(fmt.Errorf("conflicting schema key: %s", k))
		}

		dst[k] = v
	}
}

// GetSchemaBlock returns a map[string]interface{} of a nested resource by key(s) from a schema.ResourceData.
func GetSchemaBlock(
	r *schema.Resource,
	d *schema.ResourceData,
	k []string,
	i int,
	allowDefault bool,
) (map[string]interface{}, error) {
	var resourceBlock map[string]interface{}

	var resourceData interface{}

	var resourceSchema *schema.Schema

	for ki, kv := range k {
		if ki == 0 {
			resourceData = d.Get(kv)
			resourceSchema = r.Schema[kv]
		} else if resourceSchema != nil {
			mapValues := resourceData.([]interface{})

			if len(mapValues) <= i {
				return resourceBlock, fmt.Errorf("index out of bounds %d", i)
			}

			mapValue := mapValues[i].(map[string]interface{})

			resourceData = mapValue[kv]
			resourceSchema = resourceSchema.Elem.(*schema.Resource).Schema[kv]
		}
	}

	if resourceSchema == nil {
		return nil, fmt.Errorf("schema not found for %s", strings.Join(k, "."))
	}

	list := resourceData.([]interface{})

	if len(list) == 0 {
		if allowDefault {
			listDefault, err := resourceSchema.DefaultValue()
			if err != nil {
				return nil, fmt.Errorf("failed to get default value for %s: %w", strings.Join(k, "."), err)
			}

			list = listDefault.([]interface{})
		}
	}

	if len(list) > i {
		resourceBlock = list[i].(map[string]interface{})
	}

	return resourceBlock, nil
}

// SuppressIfListsAreEqualIgnoringOrder is a customdiff.SuppressionFunc that suppresses
// changes to a list if the old and new lists are equal, ignoring the order of the
// elements.
// It will be called for each list item, so it is not super efficient. It is
// recommended to use it only for small lists.
// Ref: https://github.com/hashicorp/terraform-plugin-sdk/issues/477
func SuppressIfListsAreEqualIgnoringOrder(key, _, _ string, d *schema.ResourceData) bool {
	// the key is a path to the list item, not the list itself, e.g. "tags.#"
	lastDotIndex := strings.LastIndex(key, ".")
	if lastDotIndex != -1 {
		key = key[:lastDotIndex]
	}

	oldData, newData := d.GetChange(key)
	if oldData == nil || newData == nil {
		return false
	}

	oldArray := oldData.([]interface{})
	newArray := newData.([]interface{})

	if len(oldArray) != len(newArray) {
		return false
	}

	oldEvents := make([]string, len(oldArray))
	newEvents := make([]string, len(newArray))

	for i, oldEvt := range oldArray {
		oldEvents[i] = fmt.Sprint(oldEvt)
	}

	for j, newEvt := range newArray {
		newEvents[j] = fmt.Sprint(newEvt)
	}

	sort.Strings(oldEvents)
	sort.Strings(newEvents)

	return reflect.DeepEqual(oldEvents, newEvents)
}

// SuppressIfListsOfMapsAreEqualIgnoringOrderByKey is a customdiff.SuppressionFunc that suppresses
// changes to a list of resources if the old and new lists are equal, ignoring the order of the
// elements.
// It will be called for each resource attribute, so it is not super efficient. It is
// recommended to use it only for small lists / small resources.
// The keyAttr is the attribute that will be used as the key to compare the resources.
// The ignoreKeys are the keys that will be ignored when comparing the resources. Include computed read-only
// attributes here.
//
// Ref: https://github.com/hashicorp/terraform-plugin-sdk/issues/477
func SuppressIfListsOfMapsAreEqualIgnoringOrderByKey(
	keyAttr string,
	ignoreKeys ...string,
) schema.SchemaDiffSuppressFunc {
	// the attr is a path to the item's attribute, not the list itself, e.g. "numa.0.device"
	return func(attr, _, _ string, d *schema.ResourceData) bool {
		lastDotIndex := strings.LastIndex(attr, ".")
		if lastDotIndex != -1 {
			attr = attr[:lastDotIndex]
		}

		lastDotIndex = strings.LastIndex(attr, ".")
		if lastDotIndex != -1 {
			attr = attr[:lastDotIndex]
		}

		oldData, newData := d.GetChange(attr)
		if oldData == nil || newData == nil {
			return false
		}

		oldArray, ok := oldData.([]interface{})
		if !ok {
			return false
		}

		newArray, ok := newData.([]interface{})
		if !ok {
			return false
		}

		if len(oldArray) != len(newArray) {
			return false
		}

		oldMap := utils.MapResourcesByAttribute(oldArray, keyAttr)
		newMap := utils.MapResourcesByAttribute(newArray, keyAttr)

		for k, v := range oldMap {
			if _, ok := newMap[k]; !ok {
				return false
			}

			for _, ignoreKey := range ignoreKeys {
				delete(v.(map[string]interface{}), ignoreKey)
				delete(newMap[k].(map[string]interface{}), ignoreKey)
			}

			if !reflect.DeepEqual(v, newMap[k]) {
				return false
			}
		}

		return true
	}
}
`````

## File: proxmoxtf/test/utils.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package test

import (
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// AssertComputedAttributes checks that the given schema has the given computed attributes.
func AssertComputedAttributes(t *testing.T, s map[string]*schema.Schema, keys []string) {
	t.Helper()

	for _, v := range keys {
		require.NotNil(t, s[v], "Error in Schema: Missing definition for \"%s\"", v)
		assert.True(t, s[v].Computed, "Error in Schema: Attribute \"%s\" is not computed", v)
	}
}

// AssertNestedSchemaExistence checks that the given schema has a nested schema for the given key.
func AssertNestedSchemaExistence(t *testing.T, s map[string]*schema.Schema, key string) map[string]*schema.Schema {
	t.Helper()

	r, ok := s[key].Elem.(*schema.Resource)

	if !ok {
		t.Fatalf("Error in Schema: Missing nested schema for \"%s\"", key)

		return nil
	}

	return r.Schema
}

// AssertListMaxItems checks that the given schema attribute has given expected MaxItems value.
func AssertListMaxItems(t *testing.T, s map[string]*schema.Schema, key string, expectedMaxItems int) {
	t.Helper()

	require.NotNil(t, s[key], "Error in Schema: Missing definition for \"%s\"", key)
	assert.Equal(t, expectedMaxItems, s[key].MaxItems,
		"Error in Schema: Argument \"%s\" has \"MaxItems: %#v\", but value %#v is expected!",
		key, s[key].MaxItems, expectedMaxItems)
}

// AssertOptionalArguments checks that the given schema has the given optional arguments.
func AssertOptionalArguments(t *testing.T, s map[string]*schema.Schema, keys []string) {
	t.Helper()

	for _, v := range keys {
		require.NotNil(t, s[v], "Error in Schema: Missing definition for \"%s\"", v)
		assert.True(t, s[v].Optional, "Error in Schema: Argument \"%s\" is not optional", v)
	}
}

// AssertRequiredArguments checks that the given schema has the given required arguments.
func AssertRequiredArguments(t *testing.T, s map[string]*schema.Schema, keys []string) {
	t.Helper()

	for _, v := range keys {
		require.NotNil(t, s[v], "Error in Schema: Missing definition for \"%s\"", v)
		assert.True(t, s[v].Required, "Error in Schema: Argument \"%s\" is not required", v)
	}
}

// AssertValueTypes checks that the given schema has the given value types for the given fields.
func AssertValueTypes(t *testing.T, s map[string]*schema.Schema, f map[string]schema.ValueType) {
	t.Helper()

	for fn, ft := range f {
		require.NotNil(t, s[fn], "Error in Schema: Missing definition for \"%s\"", fn)
		assert.Equal(t, ft, s[fn].Type, "Error in Schema: Argument or attribute \"%s\" is not of type \"%v\"", fn, ft)
	}
}
`````

## File: proxmoxtf/config.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package proxmoxtf

import (
	"errors"
	"os"

	"github.com/bpg/terraform-provider-proxmox/proxmox"
	"github.com/bpg/terraform-provider-proxmox/proxmox/api"
	"github.com/bpg/terraform-provider-proxmox/proxmox/cluster"
	"github.com/bpg/terraform-provider-proxmox/proxmox/ssh"
)

// ProviderConfiguration is the configuration for the provider.
type ProviderConfiguration struct {
	apiClient      api.Client
	sshClient      ssh.Client
	tmpDirOverride string
	idGenerator    cluster.IDGenerator
}

// NewProviderConfiguration creates a new provider configuration.
func NewProviderConfiguration(
	apiClient api.Client,
	sshClient ssh.Client,
	tmpDirOverride string,
	idCfg cluster.IDGeneratorConfig,
) (ProviderConfiguration, error) {
	cfg := ProviderConfiguration{
		apiClient:      apiClient,
		sshClient:      sshClient,
		tmpDirOverride: tmpDirOverride,
	}

	client, err := cfg.GetClient()
	if err != nil {
		return cfg, err
	}

	cfg.idGenerator = cluster.NewIDGenerator(client.Cluster(), idCfg)

	return cfg, nil
}

// GetClient returns the Proxmox API client.
func (c *ProviderConfiguration) GetClient() (proxmox.Client, error) {
	if c.apiClient == nil {
		return nil, errors.New(
			"you must specify the API access details in the provider configuration",
		)
	}

	if c.sshClient == nil {
		return nil, errors.New(
			"you must specify the SSH access details in the provider configuration",
		)
	}

	return proxmox.NewClient(c.apiClient, c.sshClient, c.tmpDirOverride), nil
}

// TempDir returns (possibly overridden) os.TempDir().
func (c *ProviderConfiguration) TempDir() string {
	if c.tmpDirOverride != "" {
		return c.tmpDirOverride
	}

	return os.TempDir()
}

// GetIDGenerator returns the IDGenerator.
func (c *ProviderConfiguration) GetIDGenerator() cluster.IDGenerator {
	return c.idGenerator
}
`````

## File: templates/data-sources/virtual_environment_vm2.md.tmpl
`````
---
layout: page
title: {{.Name}}
parent: Data Sources
subcategory: Virtual Environment
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

!> **DO NOT USE**
{{ .Description | trimspace }}

{{ if .HasExample -}}
## Example Usage

{{ codefile "terraform" .ExampleFile }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}
`````

## File: templates/guides/clone-vm.md.tmpl
`````
---
layout: page
page_title: "Clone a VM"
subcategory: Guides
description: |-
    This guide explains how to create a VM template and then clone it to another VM.
---

# Clone a VM

## Create a VM template

VM templates in Proxmox provide an efficient way to create multiple identical VMs. Templates act as a base image that can be cloned to create new VMs, ensuring consistency and reducing the time needed to provision new instances. When a VM is created as a template, it is read-only and can't be started, but can be cloned multiple times to create new VMs.

You can create a template directly in Proxmox by setting the `template` attribute to `true` when creating the VM resource:

{{ codefile "terraform" "examples/guides/clone-vm/template.tf" }}

Once you have a template, you can clone it to create new VMs. The cloned VMs will inherit all the configuration from the template but can be customized further as needed.

{{ codefile "terraform" "examples/guides/clone-vm/clone.tf" }}
`````

## File: templates/guides/cloud-image.md.tmpl
`````
---
layout: page
page_title: "Create a VM from a Cloud Image"
subcategory: Guides
description: |-
    This guide explains how to create a VM from a cloud image.
---

# Create a VM from a Cloud Image

## Download a public cloud image from URL

Proxmox does not natively support QCOW2 images, but provider can do the conversion for you.

Example of how to create a CentOS 8 VM from a "generic cloud" `qcow2` image. CentOS 8 images are available at [cloud.centos.org](https://cloud.centos.org/centos/8-stream/x86_64/images/):

{{ codefile "terraform" "examples/guides/cloud-image/centos-qcow2/main.tf" }}

Ubuntu cloud images are available at [cloud-images.ubuntu.com](https://cloud-images.ubuntu.com/). Ubuntu cloud images are in `qcow2` format as well, but stored with `.img` extension, so they can be directly uploaded to Proxmox without renaming.

{{ codefile "terraform" "examples/guides/cloud-image/ubuntu-img/main.tf" }}

For [large images](https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_file#important-notes), you may want to use a dedicated temporary directory [configured](https://registry.terraform.io/providers/bpg/proxmox/latest/docs#tmp_dir) for provider via `tmp_dir` attribute, instead of system's default temporary directory. This is especially useful if you are deploying from a container with limited disk space.

## Create a VM from an existing image on Proxmox

If you already have a cloud image on Proxmox, you can use it to create a VM:

{{ codefile "terraform" "examples/guides/cloud-image/debian-from-storage/main.tf" }}
`````

## File: templates/guides/cloud-init.md.tmpl
`````
---
layout: page
page_title: "Configure a VM with Cloud-Init"
subcategory: Guides
description: |-
    This guide explains how to use the Proxmox provider to create and manage virtual machines using cloud-init.
---

# Configure a VM with Cloud-Init

## Native Proxmox Cloud-Init Support

Proxmox supports cloud-init natively, so you can use the `initialization` block to configure your VM:

{{ codefile "terraform" "examples/guides/cloud-init/native/main.tf" }}

Note that many cloud images do not have `qemu-guest-agent` installed by default, so you won't be able to retrieve the dynamic IP address of the VM from Proxmox, as this is agent's responsibility. You can use the `ip_config` block to configure a static IP address instead.

## Custom Cloud-Init Configuration

Due to several limitations of the native Proxmox cloud-init support, you may want to use a custom Cloud-Init configuration instead. This allows you to adjust the VM configuration to your needs and install the `qemu-guest-agent` and additional packages.

To use a custom cloud-init configuration, create a cloud-config snippet file and pass it to the VM as a `user_data_file_id` parameter. Use the `proxmox_virtual_environment_file` resource to create the file. Ensure the "Snippets" content type is enabled on the target datastore in Proxmox before applying the configuration below.

Note that you need to explicitly set the `hostname` in the provided cloud-init configuration, as the custom user data cloud-init config overwrites the config set by Proxmox, as shown in the example below.

{{ codefile "terraform" "examples/guides/cloud-init/custom/cloud-config.tf" }}

{{ codefile "terraform" "examples/guides/cloud-init/custom/main.tf" }}

If you wish to keep the user data cloud-init config generic, for example, when deploying multiple VMs for a Kubernetes cluster, you can use a separate snippet with the metadata cloud-init config to set the hostname. Note that it uses the `local-hostname` configuration parameter. See more details in the [cloud-init documentation](https://docs.cloud-init.io/en/latest/reference/yaml_examples/update_hostname.html).

```terraform
resource "proxmox_virtual_environment_file" "meta_data_cloud_config" {
  content_type = "snippets"
  datastore_id = "local"
  node_name    = "pve"

  source_raw {
    data = <<-EOF
    #cloud-config
    local-hostname: test-ubuntu
    EOF

    file_name = "meta-data-cloud-config.yaml"
  }
}
```

```terraform
resource "proxmox_virtual_environment_vm" "ubuntu_vm" {
  # ...

  initialization {
    # ...
    user_data_file_id = proxmox_virtual_environment_file.user_data_cloud_config.id
    meta_data_file_id = proxmox_virtual_environment_file.meta_data_cloud_config.id
  }

  # ...
}
```
`````

## File: templates/guides/setup-proxmox-for-tests.md.tmpl
`````
---
layout: page
page_title: "Setup a VM with Proxmox"
subcategory: Guides
description: |-
  This guide will help you setup a proxmox node in VM using virt-manager for a job.
---

# Setup VM with Proxmox to run examples and acceptance tests

## Who

Contributors

## Motivation

To test changes, it's best to try it on real proxmox cluster. There is dedicated `make example` command that will try to apply changes defined in `example` directory. Most resources have its examples declarations there. For example, if you add new resource, you could add new file with example resource there (ideally after adding tests). If nothing breaks, apply works fine, new resource is created and all other resources are fine, then likely change is safe.

But, proxmox node setup can be tricky task for some contributors.

## Preconditions

Be sure to install `go` and `terraform` on your system first.

## Linux (Debian/Ubuntu) with virt-manager

Goal is to have a proxmox node in VM using <https://virt-manager.org/> for a job. This text assumes some linux knowledge. Tested on Debian 12 bookworm and proxmox VE 8.1. For other distros, with any luck steps should be similar.

1. `sudo apt-get install virt-manager`.

2. Download some proxmox image from <http://download.proxmox.com/iso/>, currently latest is `proxmox-ve_8.1-1.iso`.

3. Run `virt-manager` and "create a new virtual machine", use a file you just downloaded, choose debian as a operating system, leave default network settings.

4. Give it enough RAM and disk size (required minimum is unknown for make example though I used 4GB on my 8GB laptop and 30GB disk size with success).

5. Proceed forward with installation, choose whatever you want for timezone, country, password, domain, email. Don't change other default settings.

6. After installation, log in using password from previous step and `root` username (it's proxmox default). Run: `ip a` to get assigned ip (this also appears during installation). In my case it is `192.168.122.43`.

   It may look like this:

   ```txt
   root@proxmox:~# ip a
   1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
       link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
       inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
       inet6 ::1/128 scope host noprefixroute
       valid_lft forever preferred_lft forever
   2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master vmbr0 state UP group default qlen 1000
       link/ether 52:54:00:b3:22:f5 brd ff:ff:ff:ff:ff:ff
   3: vmbr0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
       link/ether 52:54:00:b3:22:f5 brd ff:ff:ff:ff:ff:ff
       inet 192.168.122.43/24 scope global vmbr0
       valid_lft forever preferred_lft forever
       inet6 fe80::5054:ff:feb3:22f5/64 scope link
       valid_lft forever preferred_lft forever
   ```

7. (Optional) On **your** computer, there should be new interface created mapped to that one you see on proxmox. Again `ip a`:

   ```txt
   ...

   8: virbr0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
       link/ether 52:54:00:ca:65:49 brd ff:ff:ff:ff:ff:ff
       inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever

   ...

   ```

8. (Optional) You can SSH into proxmox node:

   ```bash
   ssh root@192.168.122.43
   ```

   You can also use browser and visit console at <https://192.168.122.43:8006>.

9. Create `terraform.tfvars` file (it will be git ignored file) in `example` folder with credentials for you new proxmox node.

   ```txt
   # example/terraform.tfvars
   virtual_environment_username = "root@pam"
   virtual_environment_endpoint = "https://192.168.122.43:8006/"
   virtual_environment_password = "your password from step 5"

   ```

10. Now you can run `make example`.

11. If you see error with proxmox_virtual_environment_file: the datastore "local" does not support content type "snippets"; supported content types are: `[backup, iso, vztmpl]`, you need to enable them, see <https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_file#snippets>.
`````

## File: templates/resources/virtual_environment_download_file.md.tmpl
`````
---
layout: page
title: {{.Name}}
parent: Resources
subcategory: Virtual Environment
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

{{ .Description | trimspace }}

~> Besides the `Datastore.AllocateTemplate` privilege, this resource requires both the `Sys.Audit` and `Sys.Modify` privileges.<br><br>
For more details, see the [`download-url`](https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/storage/{storage}/download-url) API documentation under the "Required permissions" section.

{{ if .HasExample -}}
## Example Usage

{{ codefile "terraform" .ExampleFile }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}
{{- if .HasImport }}

## Import

Import is supported using the following syntax:

{{ codefile "shell" .ImportFile }}
{{- end }}
`````

## File: templates/resources/virtual_environment_vm2.md.tmpl
`````
---
layout: page
title: {{.Name}}
parent: Resources
subcategory: Virtual Environment
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

!> **DO NOT USE**
{{ .Description | trimspace }}

-> Many attributes are marked as **optional** _and_ **computed** in the schema,
hence you may seem added to the plan with "(known after apply)" status, even if they are not set in the configuration.
This is done to support the `clone` operation, when a VM is created from an existing VM or template,
and the source attributes are copied to the clone.<br><br>
Computed attributes allow the provider to set those attributes without user input.
The attributes are also marked as optional to allow the practitioner to set (or overwrite) them if needed.

{{ if .HasExample -}}
## Example Usage

{{ codefile "terraform" .ExampleFile }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}
{{- if .HasImport }}

## Import

Import is supported using the following syntax:

{{ codefile "shell" .ImportFile }}
{{- end }}
`````

## File: templates/data-sources.md.tmpl
`````
---
layout: page
title: {{.Name}}
parent: Data Sources
subcategory: Virtual Environment
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

{{ .Description | trimspace }}

{{ if .HasExample -}}
## Example Usage

{{ codefile "terraform" .ExampleFile }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}
`````

## File: templates/resources.md.tmpl
`````
---
layout: page
title: {{.Name}}
parent: Resources
subcategory: Virtual Environment
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Type}}: {{.Name}}

{{ .Description | trimspace }}

{{ if .HasExample -}}
## Example Usage

{{ codefile "terraform" .ExampleFile }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}
{{- if .HasImport }}

## Import

Import is supported using the following syntax:

{{ codefile "shell" .ImportFile }}
{{- end }}
`````

## File: utils/env.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import (
	"os"
	"strconv"
)

// GetAnyStringEnv returns the first non-empty string value from the environment variables.
func GetAnyStringEnv(ks ...string) string {
	for _, k := range ks {
		if v := os.Getenv(k); v != "" {
			return v
		}
	}

	return ""
}

// GetAnyBoolEnv returns the first non-empty boolean value from the environment variables.
func GetAnyBoolEnv(ks ...string) bool {
	val := ""

	for _, k := range ks {
		if v := os.Getenv(k); v != "" {
			val = v
			break
		}
	}

	return val == "true" || val == "1"
}

// GetAnyIntEnv returns the first non-empty integer value from the environment variables.
func GetAnyIntEnv(ks ...string) int {
	for _, k := range ks {
		if v := os.Getenv(k); v != "" {
			if i, err := strconv.Atoi(v); err == nil {
				return i
			}
		}
	}

	return 0
}
`````

## File: utils/io_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCloseOrLogError(t *testing.T) {
	t.Parallel()

	f := CloseOrLogError(t.Context())

	c := &testCloser{}
	b := &badCloser{}

	func() {
		defer f(c)
		defer f(b)
		assert.False(t, c.isClosed)
	}()

	assert.True(t, c.isClosed)
}

type testCloser struct {
	isClosed bool
}

func (t *testCloser) Close() error {
	t.isClosed = true
	return nil
}

type badCloser struct{}

func (t *badCloser) Close() error {
	return fmt.Errorf("bad")
}
`````

## File: utils/io.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import (
	"context"
	"io"

	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// CloseOrLogError closes the given io.Closer and logs any error.
func CloseOrLogError(ctx context.Context) func(io.Closer) {
	return func(c io.Closer) {
		if err := c.Close(); err != nil {
			tflog.Error(ctx, "Failed to close", map[string]interface{}{
				"error": err,
			})
		}
	}
}
`````

## File: utils/maps_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestOrderedListFromMap(t *testing.T) {
	t.Parallel()

	inputMap := map[string]interface{}{
		"value1": map[string]interface{}{"name": "resource1", "attr": "value1"},
		"value3": map[string]interface{}{"name": "resource3", "attr": "value3"},
		"value2": map[string]interface{}{"name": "resource2", "attr": "value2"},
	}

	expected := []interface{}{
		map[string]interface{}{"name": "resource1", "attr": "value1"},
		map[string]interface{}{"name": "resource2", "attr": "value2"},
		map[string]interface{}{"name": "resource3", "attr": "value3"},
	}

	result := OrderedListFromMap(inputMap)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("ListResourcesAttributeValue() = %v, want %v", result, expected)
	}
}

func TestMapResourceList(t *testing.T) {
	t.Parallel()

	resourceList := []interface{}{
		map[string]interface{}{"name": "resource1", "attr": "value1"},
		map[string]interface{}{"name": "resource2", "attr": "value2"},
		nil,
		map[string]interface{}{"name": "resource3", "attr": "value3"},
		map[string]interface{}{"name": "resource4", "attr": "value4"},
	}

	expected := []string{
		"value1",
		"value2",
		"value3",
		"value4",
	}

	result := ListResourcesAttributeValue(resourceList, "attr")

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("ListResourcesAttributeValue() = %v, want %v", result, expected)
	}
}

func TestOrderedListFromMapByKeyValues(t *testing.T) {
	t.Parallel()

	inputMap := map[string]interface{}{
		"key1": "value1",
		"key2": "value2",
		"key3": "value3",
		"key4": "value4",
	}

	keyList := []string{"key2", "key1", "key4"}

	expected := []interface{}{"value2", "value1", "value4"}

	result := OrderedListFromMapByKeyValues(inputMap, keyList)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("OrderedListFromMapByKeyValues() = %v, want %v", result, expected)
	}
}

func TestCompareWithPrefix(t *testing.T) {
	t.Parallel()

	type args struct {
		a string
		b string
	}

	tests := []struct {
		name string
		args args
		want int
	}{
		{"equal", args{"a", "a"}, 0},
		{"a < b", args{"a", "b"}, -1},
		{"b > a", args{"b", "a"}, 1},
		{"a < b with prefix", args{"a1", "a2"}, -1},
		{"b > a with prefix", args{"a2", "a1"}, 1},
		{"a < b with different prefix", args{"a1", "b1"}, -1},
		{"b > a with different prefix", args{"b1", "a1"}, 1},
		{"a < b with different prefix and numbers", args{"a1", "a10"}, -1},
		{"b > a with different prefix and numbers", args{"a10", "a1"}, 1},
		{"a < b with different prefix and numbers", args{"a10", "b1"}, -1},
		{"b > a with different prefix and numbers", args{"b1", "a10"}, 1},
		{"a < b with different prefix and numbers", args{"a10", "b10"}, -1},
		{"b > a with different prefix and numbers", args{"b10", "a10"}, 1},
		{"b > a with different numbers leading zeros", args{"dev01", "dev001"}, 1},
		{"a > b with different numbers leading zeros", args{"dev001", "dev01"}, -1},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			assert.Equalf(t, tt.want, compareWithPrefix(tt.args.a, tt.args.b), "compareWithPrefix(%v, %v)", tt.args.a, tt.args.b)
		})
	}
}
`````

## File: utils/maps.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import (
	"reflect"
	"slices"
	"strconv"
	"strings"
)

// OrderedListFromMap generates a list from a map's values. The values are sorted based on the map's keys.
// The sorting is done using a custom comparison function that compares the keys with special rules, assuming they
// are strings representing device names or similar, i.e. "disk0", "net1", etc.
func OrderedListFromMap(inputMap map[string]interface{}) []interface{} {
	itemCount := len(inputMap)
	keyList := make([]string, itemCount)
	i := 0

	for key := range inputMap {
		keyList[i] = key
		i++
	}

	slices.SortFunc(keyList, compareWithPrefix)

	return OrderedListFromMapByKeyValues(inputMap, keyList)
}

// CompareWithPrefix compares two string values with special rules:
// - If both start with the same prefix, trims the prefix and compares the rest as numbers if possible.
// - If numbers are equal, falls back to string comparison (preserving digit formatting).
// - If numeric parsing fails, falls back to string comparison.
// - If prefixes differ, compares the whole values as strings.
func compareWithPrefix(a, b string) int {
	prefix := commonPrefix(a, b)

	if prefix != "" {
		aRest := strings.TrimPrefix(a, prefix)
		bRest := strings.TrimPrefix(b, prefix)

		aNum, aErr := strconv.Atoi(aRest)
		bNum, bErr := strconv.Atoi(bRest)

		if aErr == nil && bErr == nil {
			if aNum != bNum {
				if aNum < bNum {
					return -1
				}

				return 1
			}
			// numeric values equal, fallback to string comparison
			return strings.Compare(aRest, bRest)
		}

		return strings.Compare(aRest, bRest)
	}

	return strings.Compare(a, b)
}

// commonPrefix returns the longest common prefix of two strings.
func commonPrefix(a, b string) string {
	minLen := len(a)
	if len(b) < minLen {
		minLen = len(b)
	}

	for i := range minLen {
		if a[i] != b[i] {
			return a[:i]
		}
	}

	return a[:minLen]
}

// ListResourcesAttributeValue generates a list of strings from a Terraform resource list (which is list of maps).
// The list is generated by extracting a specific key attribute from each resource. If the attribute is not found in a
// resource, it is skipped.
func ListResourcesAttributeValue(resourceList []interface{}, keyAttr string) []string {
	var l []string

	for _, resource := range resourceList {
		if resource == nil {
			continue
		}

		r := resource.(map[string]interface{})
		if value, ok := r[keyAttr].(string); ok {
			l = append(l, value)
		}
	}

	return l
}

// MapResourcesByAttribute generates a map of resources from a resource list, using a specified attribute as the key
// and the resource as the value. If the attribute is not found in a resource, it is skipped.
func MapResourcesByAttribute(resourceList []interface{}, keyAttr string) map[string]interface{} {
	m := make(map[string]interface{}, len(resourceList))

	for _, resource := range resourceList {
		if resource == nil {
			continue
		}

		r := resource.(map[string]interface{})
		if key, ok := r[keyAttr].(string); ok {
			m[key] = r
		}
	}

	return m
}

// OrderedListFromMapByKeyValues generates a list from a map's values.
// The values are sorted based on the provided key list. If a key is not found in the map, it is skipped.
func OrderedListFromMapByKeyValues(inputMap map[string]interface{}, keyList []string) []interface{} {
	orderedList := make([]interface{}, len(keyList))

	for i, k := range keyList {
		val, ok := inputMap[k]
		if ok {
			orderedList[i] = val
		}
	}

	return orderedList
}

// MapDiff compares the difference between two maps and returns the elements that are in the plan but not
// in the state (toCreate), the elements that are in the plan and in the state but are different (toUpdate),
// and the elements that are in the state but not in the plan (toDelete).
// The keyFunc is used to extract a unique key from each element to compare them.
func MapDiff[T any](plan map[string]T, state map[string]T) (map[string]T, map[string]T, map[string]T) {
	toCreate := map[string]T{}
	toUpdate := map[string]T{}
	toDelete := map[string]T{}

	for key, p := range plan {
		s, ok := state[key]
		if !ok {
			toCreate[key] = p
		} else if !reflect.DeepEqual(p, s) {
			toUpdate[key] = p
		}
	}

	for key, s := range state {
		_, ok := plan[key]
		if !ok {
			toDelete[key] = s
		}
	}

	return toCreate, toUpdate, toDelete
}
`````

## File: utils/sets_test.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSetDiff(t *testing.T) {
	t.Parallel()

	type args[T any] struct {
		plan  []T
		state []T
	}

	type testCase[T any] struct {
		name         string
		args         args[T]
		wantToCreate []T
		wantToUpdate []T
		wantToDelete []T
	}

	type rec struct {
		n string
		v string
	}

	tests := []testCase[rec]{
		{
			name: "empty",
			args: args[rec]{
				plan:  []rec{},
				state: []rec{},
			},
			wantToCreate: nil,
			wantToUpdate: nil,
			wantToDelete: nil,
		},
		{
			name: "create",
			args: args[rec]{
				plan:  []rec{{"a", "1"}, {"b", "2"}, {"c", "3"}},
				state: []rec{},
			},
			wantToCreate: []rec{{"a", "1"}, {"b", "2"}, {"c", "3"}},
			wantToUpdate: nil,
			wantToDelete: nil,
		},
		{
			name: "create and delete",
			args: args[rec]{
				plan:  []rec{{"a", "1"}, {"b", "2"}, {"c", "3"}},
				state: []rec{{"b", "2"}, {"c", "3"}, {"d", "4"}},
			},
			wantToCreate: []rec{{"a", "1"}},
			wantToUpdate: nil,
			wantToDelete: []rec{{"d", "4"}},
		},
		{
			name: "update",
			args: args[rec]{
				plan:  []rec{{"a", "1"}, {"b", "2"}, {"c", "3"}},
				state: []rec{{"a", "1"}, {"b", "2"}, {"c", "4"}},
			},
			wantToCreate: nil,
			wantToUpdate: []rec{{"c", "3"}},
			wantToDelete: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			gotToCreate, gotToUpdate, gotToDelete := SetDiff(
				tt.args.plan, tt.args.state, func(t rec) string { return t.n },
			)
			assert.Equalf(t, tt.wantToCreate, gotToCreate, "toCreate is different")
			assert.Equalf(t, tt.wantToUpdate, gotToUpdate, "toUpdate is different")
			assert.Equalf(t, tt.wantToDelete, gotToDelete, "toDelete is different")
		})
	}
}
`````

## File: utils/sets.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

import "reflect"

// SetDiff compares two slices of elements and returns the elements that are in the plan but not
// in the state (toCreate), the elements that are in the plan and in the state but are different (toUpdate),
// and the elements that are in the state but not in the plan (toDelete).
// The keyFunc is used to extract a unique key from each element to compare them.
func SetDiff[T any](plan []T, state []T, keyFunc func(t T) string) ([]T, []T, []T) {
	var toCreate, toUpdate, toDelete []T

	stateMap := map[string]T{}
	for _, s := range state {
		stateMap[keyFunc(s)] = s
	}

	planMap := map[string]T{}
	for _, p := range plan {
		planMap[keyFunc(p)] = p
	}

	for _, p := range plan {
		s, ok := stateMap[keyFunc(p)]
		if !ok {
			toCreate = append(toCreate, p)
		} else if !reflect.DeepEqual(p, s) {
			toUpdate = append(toUpdate, p)
		}
	}

	for _, s := range state {
		_, ok := planMap[keyFunc(s)]
		if !ok {
			toDelete = append(toDelete, s)
		}
	}

	return toCreate, toUpdate, toDelete
}
`````

## File: utils/strings.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package utils

// ConvertToStringSlice helps convert interface slice to string slice.
func ConvertToStringSlice(interfaceSlice []interface{}) []string {
	resultSlice := make([]string, len(interfaceSlice))

	for i, val := range interfaceSlice {
		resultSlice[i] = val.(string)
	}

	return resultSlice
}
`````

## File: .all-contributorsrc
`````
{
  "projectName": "terraform-provider-proxmox",
  "projectOwner": "bpg",
  "repoType": "github",
  "repoHost": "https://github.com",
  "files": [
    "CONTRIBUTORS.md"
  ],
  "imageSize": 100,
  "commit": false,
  "commitConvention": "angular",
  "contributors": [
    {
      "login": "danitso-dp",
      "name": "Dan R. Petersen",
      "avatar_url": "https://avatars.githubusercontent.com/u/7096448?v=4",
      "profile": "https://danitso.com/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "bpg",
      "name": "Pavel Boldyrev",
      "avatar_url": "https://avatars.githubusercontent.com/u/627562?v=4",
      "profile": "https://github.com/bpg",
      "contributions": [
        "code",
        "maintenance"
      ]
    },
    {
      "login": "luhahn",
      "name": "Lucas Hahn",
      "avatar_url": "https://avatars.githubusercontent.com/u/61747797?v=4",
      "profile": "https://github.com/luhahn",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "blz-ea",
      "name": "Alex Kulikovskikh",
      "avatar_url": "https://avatars.githubusercontent.com/u/19339605?v=4",
      "profile": "https://github.com/blz-ea",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "otopetrik",
      "name": "Oto Pet≈ô√≠k",
      "avatar_url": "https://avatars.githubusercontent.com/u/972298?v=4",
      "profile": "https://github.com/otopetrik",
      "contributions": [
        "code",
        "question",
        "bug",
        "doc"
      ]
    },
    {
      "login": "qazbnm456",
      "name": "Boik",
      "avatar_url": "https://avatars.githubusercontent.com/u/6451933?v=4",
      "profile": "https://www.patreon.com/boik",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "abdo-farag",
      "name": "Abdelfadeel Farag",
      "avatar_url": "https://avatars.githubusercontent.com/u/10170837?v=4",
      "profile": "https://github.com/abdo-farag",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kugo12",
      "name": "Szczepan Wi≈õniowski",
      "avatar_url": "https://avatars.githubusercontent.com/u/15050771?v=4",
      "profile": "https://github.com/kugo12",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "xonvanetta",
      "name": "Fabian Heib",
      "avatar_url": "https://avatars.githubusercontent.com/u/11271952?v=4",
      "profile": "https://github.com/xonvanetta",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kaje783",
      "name": "kaje783",
      "avatar_url": "https://avatars.githubusercontent.com/u/120482249?v=4",
      "profile": "https://github.com/kaje783",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "michalg91",
      "name": "michalg91",
      "avatar_url": "https://avatars.githubusercontent.com/u/63045346?v=4",
      "profile": "https://github.com/michalg91",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "1-cameron",
      "name": "Cameron",
      "avatar_url": "https://avatars.githubusercontent.com/u/68611194?v=4",
      "profile": "https://github.com/1-cameron",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "magikid",
      "name": "Chris Jones",
      "avatar_url": "https://avatars.githubusercontent.com/u/115515?v=4",
      "profile": "https://christopherjones.us/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "wombelix",
      "name": "Dominik Wombacher",
      "avatar_url": "https://avatars.githubusercontent.com/u/16312366?v=4",
      "profile": "https://dominik.wombacher.cc/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Frankkkkk",
      "name": "Frank Villaro-Dixon",
      "avatar_url": "https://avatars.githubusercontent.com/u/17879459?v=4",
      "profile": "http://frank.villaro-dixon.eu/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "groggemans",
      "name": "Gertjan Roggemans",
      "avatar_url": "https://avatars.githubusercontent.com/u/11381284?v=4",
      "profile": "https://github.com/groggemans",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "HenriAW",
      "name": "Henri Williams",
      "avatar_url": "https://avatars.githubusercontent.com/u/24527359?v=4",
      "profile": "https://github.com/HenriAW",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "zeddD1abl0",
      "name": "Jordan Keith",
      "avatar_url": "https://avatars.githubusercontent.com/u/8335605?v=4",
      "profile": "https://github.com/zeddD1abl0",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "shortmann",
      "name": "Kai Kahllund",
      "avatar_url": "https://avatars.githubusercontent.com/u/20142334?v=4",
      "profile": "https://github.com/shortmann",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "kevinglasson",
      "name": "Kevin",
      "avatar_url": "https://avatars.githubusercontent.com/u/22187575?v=4",
      "profile": "https://github.com/kevinglasson",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "krzysztof-magosa",
      "name": "Krzysztof Magosa",
      "avatar_url": "https://avatars.githubusercontent.com/u/6112411?v=4",
      "profile": "https://github.com/krzysztof-magosa",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "mattburchett",
      "name": "Matt Burchett",
      "avatar_url": "https://avatars.githubusercontent.com/u/783042?v=4",
      "profile": "https://burchett.dev/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "moyiz",
      "name": "Moyiz",
      "avatar_url": "https://avatars.githubusercontent.com/u/8603313?v=4",
      "profile": "https://github.com/moyiz",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "pescobar",
      "name": "Pablo Escobar Lopez",
      "avatar_url": "https://avatars.githubusercontent.com/u/103797?v=4",
      "profile": "https://github.com/pescobar",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ForsakenHarmony",
      "name": "Leah",
      "avatar_url": "https://avatars.githubusercontent.com/u/8845940?v=4",
      "profile": "https://hrmny.sh/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "wbpascal",
      "name": "Pascal Wiedenbeck",
      "avatar_url": "https://avatars.githubusercontent.com/u/9532590?v=4",
      "profile": "https://github.com/wbpascal",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Patricol",
      "name": "Patrick Collins",
      "avatar_url": "https://avatars.githubusercontent.com/u/13428020?v=4",
      "profile": "https://github.com/Patricol",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "PrajwalBorkar",
      "name": "Prajwal",
      "avatar_url": "https://avatars.githubusercontent.com/u/48290911?v=4",
      "profile": "https://prajwal-portfolio.netlify.app/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "rafsaf",
      "name": "Rafa≈Ç Safin",
      "avatar_url": "https://avatars.githubusercontent.com/u/51059348?v=4",
      "profile": "https://github.com/rafsaf",
      "contributions": [
        "code",
        "doc",
        "ideas"
      ]
    },
    {
      "login": "RemkoMolier",
      "name": "Remko Molier",
      "avatar_url": "https://avatars.githubusercontent.com/u/16520301?v=4",
      "profile": "https://github.com/RemkoMolier",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Tumetsu",
      "name": "Tuomas Salmi",
      "avatar_url": "https://avatars.githubusercontent.com/u/3398165?v=4",
      "profile": "http://www.tuomassalmi.com/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ikiris",
      "name": "ikiris",
      "avatar_url": "https://avatars.githubusercontent.com/u/4852950?v=4",
      "profile": "https://github.com/ikiris",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "mleone87",
      "name": "mleone87",
      "avatar_url": "https://avatars.githubusercontent.com/u/807457?v=4",
      "profile": "https://github.com/mleone87",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ryan4yin",
      "name": "Ryan Yin",
      "avatar_url": "https://avatars.githubusercontent.com/u/22363274?v=4",
      "profile": "https://thiscute.world/en/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "zoop-btc",
      "name": "zoop",
      "avatar_url": "https://avatars.githubusercontent.com/u/101409458?v=4",
      "profile": "https://github.com/zoop-btc",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "si458",
      "name": "Simon Smith",
      "avatar_url": "https://avatars.githubusercontent.com/u/765314?v=4",
      "profile": "https://www.si458.co.uk",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "grzeg1",
      "name": "grzeg1",
      "avatar_url": "https://avatars.githubusercontent.com/u/8179857?v=4",
      "profile": "https://github.com/grzeg1",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "moustafab",
      "name": "Moustafa Baiou",
      "avatar_url": "https://avatars.githubusercontent.com/u/27738648?v=4",
      "profile": "https://github.com/moustafab",
      "contributions": [
        "bug",
        "code"
      ]
    },
    {
      "login": "dandaolrian",
      "name": "dandaolrian",
      "avatar_url": "https://avatars.githubusercontent.com/u/86479955?v=4",
      "profile": "https://github.com/dandaolrian",
      "contributions": [
        "code",
        "test"
      ]
    },
    {
      "login": "yoshikakbudto",
      "name": "Dmitry",
      "avatar_url": "https://avatars.githubusercontent.com/u/10331946?v=4",
      "profile": "https://github.com/yoshikakbudto",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "michaelfranzl",
      "name": "Michael Franzl",
      "avatar_url": "https://avatars.githubusercontent.com/u/72123?v=4",
      "profile": "https://michael.franzl.name",
      "contributions": [
        "bug",
        "code",
        "test"
      ]
    },
    {
      "login": "tseeker",
      "name": "Emmanuel Beno√Æt",
      "avatar_url": "https://avatars.githubusercontent.com/u/1409844?v=4",
      "profile": "http://www.ebenoit.info",
      "contributions": [
        "code",
        "bug",
        "test"
      ]
    },
    {
      "login": "mandrav",
      "name": "mandrav",
      "avatar_url": "https://avatars.githubusercontent.com/u/1273530?v=4",
      "profile": "https://github.com/mandrav",
      "contributions": [
        "code",
        "bug"
      ]
    },
    {
      "login": "michaelze",
      "name": "Michael Iseli",
      "avatar_url": "https://avatars.githubusercontent.com/u/673902?v=4",
      "profile": "https://github.com/michaelze",
      "contributions": [
        "code",
        "bug"
      ]
    },
    {
      "login": "zharalim",
      "name": "Risto Oikarinen",
      "avatar_url": "https://avatars.githubusercontent.com/u/1004061?v=4",
      "profile": "https://github.com/zharalim",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "dawidole",
      "name": "dawidole",
      "avatar_url": "https://avatars.githubusercontent.com/u/37155335?v=4",
      "profile": "https://github.com/dawidole",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "GJKrupa",
      "name": "Gerard Krupa",
      "avatar_url": "https://avatars.githubusercontent.com/u/5756726?v=4",
      "profile": "http://www.krupa.me.uk/",
      "contributions": [
        "test"
      ]
    },
    {
      "login": "simoncaron",
      "name": "Simon Caron",
      "avatar_url": "https://avatars.githubusercontent.com/u/8635747?v=4",
      "profile": "https://simoncaron.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ishioni",
      "name": "Piotr Maksymiuk",
      "avatar_url": "https://avatars.githubusercontent.com/u/50323052?v=4",
      "profile": "https://github.com/ishioni",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "0xinterface",
      "name": "Kristopher",
      "avatar_url": "https://avatars.githubusercontent.com/u/890207?v=4",
      "profile": "https://github.com/0xinterface",
      "contributions": [
        "ideas"
      ]
    },
    {
      "login": "mritalian",
      "name": "Eric B",
      "avatar_url": "https://avatars.githubusercontent.com/u/15789014?v=4",
      "profile": "https://github.com/mritalian",
      "contributions": [
        "test",
        "doc",
        "bug"
      ]
    },
    {
      "login": "2b",
      "name": "2b",
      "avatar_url": "https://avatars.githubusercontent.com/u/829041?v=4",
      "profile": "https://github.com/2b",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "TheNotary",
      "name": "TheNotary",
      "avatar_url": "https://avatars.githubusercontent.com/u/799247?v=4",
      "profile": "https://github.com/TheNotary",
      "contributions": [
        "code",
        "test",
        "doc"
      ]
    },
    {
      "login": "zamrih",
      "name": "zamrih",
      "avatar_url": "https://avatars.githubusercontent.com/u/1061718?v=4",
      "profile": "https://github.com/zamrih",
      "contributions": [
        "bug",
        "code"
      ]
    },
    {
      "login": "ratiborusx",
      "name": "Ratiborus",
      "avatar_url": "https://avatars.githubusercontent.com/u/123507924?v=4",
      "profile": "https://github.com/ratiborusx",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "skleinjung",
      "name": "Sean Kleinjung",
      "avatar_url": "https://avatars.githubusercontent.com/u/17599474?v=4",
      "profile": "https://github.com/skleinjung",
      "contributions": [
        "bug",
        "financial"
      ]
    },
    {
      "login": "muhlba91",
      "name": "Daniel M√ºhlbachler-Pietrzykowski",
      "avatar_url": "https://avatars.githubusercontent.com/u/653739?v=4",
      "profile": "https://github.com/muhlba91",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "windowsrefund",
      "name": "windowsrefund",
      "avatar_url": "https://avatars.githubusercontent.com/u/512222?v=4",
      "profile": "https://github.com/windowsrefund",
      "contributions": [
        "test",
        "doc"
      ]
    },
    {
      "login": "Fabiosilvero",
      "name": "Fabiosilvero",
      "avatar_url": "https://avatars.githubusercontent.com/u/22865938?v=4",
      "profile": "https://github.com/Fabiosilvero",
      "contributions": [
        "test"
      ]
    },
    {
      "login": "DanielHabenicht",
      "name": "DanielHabenicht",
      "avatar_url": "https://avatars.githubusercontent.com/u/13590797?v=4",
      "profile": "https://danielhabenicht.github.io/",
      "contributions": [
        "bug",
        "doc",
        "code"
      ]
    },
    {
      "login": "dark-vex",
      "name": "Daniele De Lorenzi",
      "avatar_url": "https://avatars.githubusercontent.com/u/2905124?v=4",
      "profile": "https://github.com/dark-vex",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "simplysoft",
      "name": "simplysoft",
      "avatar_url": "https://avatars.githubusercontent.com/u/1588210?v=4",
      "profile": "http://www.simplysoft.ch",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "rgl",
      "name": "Rui Lopes",
      "avatar_url": "https://avatars.githubusercontent.com/u/43356?v=4",
      "profile": "http://ruilopes.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "midoriiro",
      "name": "Alexis Bekhdadi",
      "avatar_url": "https://avatars.githubusercontent.com/u/2159328?v=4",
      "profile": "https://soundcloud.com/midoriiro",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "geoshapka",
      "name": "geoshapka",
      "avatar_url": "https://avatars.githubusercontent.com/u/32462387?v=4",
      "profile": "https://github.com/geoshapka",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "tarik02",
      "name": "Taras",
      "avatar_url": "https://avatars.githubusercontent.com/u/12175048?v=4",
      "profile": "https://github.com/tarik02",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "redpimpernel",
      "name": "redpimpernel",
      "avatar_url": "https://avatars.githubusercontent.com/u/50511476?v=4",
      "profile": "https://github.com/redpimpernel",
      "contributions": [
        "test"
      ]
    },
    {
      "login": "dylanbegin",
      "name": "Dylan Begin",
      "avatar_url": "https://avatars.githubusercontent.com/u/64234261?v=4",
      "profile": "https://github.com/dylanbegin",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "ActualTrash",
      "name": "Chase H",
      "avatar_url": "https://avatars.githubusercontent.com/u/31072505?v=4",
      "profile": "https://github.com/ActualTrash",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "zmingxie",
      "name": "Ming Xie",
      "avatar_url": "https://avatars.githubusercontent.com/u/1136583?v=4",
      "profile": "https://github.com/zmingxie",
      "contributions": [
        "code",
        "doc"
      ]
    },
    {
      "login": "frostyfab",
      "name": "frostyfab",
      "avatar_url": "https://avatars.githubusercontent.com/u/140175283?v=4",
      "profile": "https://github.com/frostyfab",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "joek-office",
      "name": "joek-office",
      "avatar_url": "https://avatars.githubusercontent.com/u/124031385?v=4",
      "profile": "https://github.com/joek-office",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "mkopnsrc",
      "name": "Mahesh K.",
      "avatar_url": "https://avatars.githubusercontent.com/u/2036998?v=4",
      "profile": "http://opnsrc.dev",
      "contributions": [
        "financial"
      ]
    },
    {
      "login": "bitchecker",
      "name": "bitchecker",
      "avatar_url": "https://avatars.githubusercontent.com/u/11056930?v=4",
      "profile": "https://github.com/bitchecker",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "olemathias",
      "name": "Ole Mathias Aa. Heggem",
      "avatar_url": "https://avatars.githubusercontent.com/u/891048?v=4",
      "profile": "https://github.com/olemathias",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "scibi",
      "name": "scibi",
      "avatar_url": "https://avatars.githubusercontent.com/u/703860?v=4",
      "profile": "https://github.com/scibi",
      "contributions": [
        "bug",
        "ideas"
      ]
    },
    {
      "login": "LEI",
      "name": "Guillaume",
      "avatar_url": "https://avatars.githubusercontent.com/u/4112243?v=4",
      "profile": "https://github.com/LEI",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "loganmancuso",
      "name": "Logan Mancuso",
      "avatar_url": "https://avatars.githubusercontent.com/u/18329590?v=4",
      "profile": "https://loganmancuso.github.io/",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "benbouillet",
      "name": "Ben Bouillet",
      "avatar_url": "https://avatars.githubusercontent.com/u/15980664?v=4",
      "profile": "https://github.com/benbouillet",
      "contributions": [
        "financial"
      ]
    },
    {
      "login": "CppBunny",
      "name": "CppBunny",
      "avatar_url": "https://avatars.githubusercontent.com/u/7388307?v=4",
      "profile": "https://github.com/CppBunny",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "srautiai",
      "name": "Sakari Rautiainen",
      "avatar_url": "https://avatars.githubusercontent.com/u/1098080?v=4",
      "profile": "https://github.com/srautiai",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "tomstokes",
      "name": "Tom Stokes",
      "avatar_url": "https://avatars.githubusercontent.com/u/1216926?v=4",
      "profile": "http://tomstok.es",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "jkossis",
      "name": "Jason Kossis",
      "avatar_url": "https://avatars.githubusercontent.com/u/1247832?v=4",
      "profile": "https://github.com/jkossis",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "lfelicetti-softatnet",
      "name": "lfelicetti-softatnet",
      "avatar_url": "https://avatars.githubusercontent.com/u/138860955?v=4",
      "profile": "https://github.com/lfelicetti-softatnet",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "xoxys",
      "name": "Robert Kaussow",
      "avatar_url": "https://avatars.githubusercontent.com/u/3391958?v=4",
      "profile": "https://thegeeklab.de",
      "contributions": [
        "code",
        "ideas"
      ]
    },
    {
      "login": "laktosterror",
      "name": "laktosterror",
      "avatar_url": "https://avatars.githubusercontent.com/u/55037659?v=4",
      "profile": "https://github.com/laktosterror",
      "contributions": [
        "ideas"
      ]
    },
    {
      "login": "jtamas96",
      "name": "J√°nosi Tam√°s",
      "avatar_url": "https://avatars.githubusercontent.com/u/25171705?v=4",
      "profile": "https://github.com/jtamas96",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "romner-set",
      "name": "romner",
      "avatar_url": "https://avatars.githubusercontent.com/u/41077433?v=4",
      "profile": "https://starless.one",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "Jayden-Lind",
      "name": "Jayden Lind",
      "avatar_url": "https://avatars.githubusercontent.com/u/70465314?v=4",
      "profile": "https://jayden-lind.github.io",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Eusebius1920",
      "name": "Eusebius1920",
      "avatar_url": "https://avatars.githubusercontent.com/u/8429638?v=4",
      "profile": "https://github.com/Eusebius1920",
      "contributions": [
        "bug",
        "doc"
      ]
    },
    {
      "login": "kvangent",
      "name": "kvangent",
      "avatar_url": "https://avatars.githubusercontent.com/u/10712294?v=4",
      "profile": "https://github.com/kvangent",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "ecanuto",
      "name": "Everaldo Canuto",
      "avatar_url": "https://avatars.githubusercontent.com/u/55260?v=4",
      "profile": "https://github.com/ecanuto",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Dr-Shadow",
      "name": "Dr-Shadow",
      "avatar_url": "https://avatars.githubusercontent.com/u/5308086?v=4",
      "profile": "https://github.com/Dr-Shadow",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "FabFaeb",
      "name": "Fabian Franz",
      "avatar_url": "https://avatars.githubusercontent.com/u/10672940?v=4",
      "profile": "https://github.com/FabFaeb",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "s-vincent",
      "name": "Sebastien Vincent",
      "avatar_url": "https://avatars.githubusercontent.com/u/745464?v=4",
      "profile": "https://github.com/s-vincent",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "jackhodgkiss",
      "name": "Jack Hodgkiss",
      "avatar_url": "https://avatars.githubusercontent.com/u/52131498?v=4",
      "profile": "https://github.com/jackhodgkiss",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "marvkos",
      "name": "marvkos",
      "avatar_url": "https://avatars.githubusercontent.com/u/87067609?v=4",
      "profile": "https://github.com/marvkos",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Koloss5421",
      "name": "Koloss5421",
      "avatar_url": "https://avatars.githubusercontent.com/u/26049477?v=4",
      "profile": "https://github.com/Koloss5421",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "samhug",
      "name": "Sam Hug",
      "avatar_url": "https://avatars.githubusercontent.com/u/171470?v=4",
      "profile": "https://sa.m-h.ug/",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "dyadMisha",
      "name": "dyadMisha",
      "avatar_url": "https://avatars.githubusercontent.com/u/37950256?v=4",
      "profile": "https://github.com/dyadMisha",
      "contributions": [
        "test"
      ]
    },
    {
      "login": "msdnna",
      "name": "msdnna",
      "avatar_url": "https://avatars.githubusercontent.com/u/11697271?v=4",
      "profile": "https://github.com/msdnna",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "soubinan",
      "name": "Soubinan KACOU",
      "avatar_url": "https://avatars.githubusercontent.com/u/20760371?v=4",
      "profile": "https://github.com/soubinan",
      "contributions": [
        "bug",
        "code"
      ]
    },
    {
      "login": "sergelogvinov",
      "name": "Serge",
      "avatar_url": "https://avatars.githubusercontent.com/u/5407715?v=4",
      "profile": "https://github.com/sergelogvinov",
      "contributions": [
        "code",
        "financial"
      ]
    },
    {
      "login": "batonogov",
      "name": "Fedor Batonogov",
      "avatar_url": "https://avatars.githubusercontent.com/u/52496117?v=4",
      "profile": "https://github.com/batonogov",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "TheDevMinerTV",
      "name": "DevMiner",
      "avatar_url": "https://avatars.githubusercontent.com/u/29845135?v=4",
      "profile": "https://devminer.xyz",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "tyxieblub",
      "name": "joris",
      "avatar_url": "https://avatars.githubusercontent.com/u/5111464?v=4",
      "profile": "https://github.com/tyxieblub",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "svengreb",
      "name": "Sven Greb",
      "avatar_url": "https://avatars.githubusercontent.com/u/13448100?v=4",
      "profile": "https://www.nordtheme.com",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "niektoniekde",
      "name": "Jaroslav Petras",
      "avatar_url": "https://avatars.githubusercontent.com/u/271951?v=4",
      "profile": "https://github.com/niektoniekde",
      "contributions": [
        "financial"
      ]
    },
    {
      "login": "nankeen",
      "name": "Kai",
      "avatar_url": "https://avatars.githubusercontent.com/u/6895854?v=4",
      "profile": "http://nankeen.me",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Sparta142",
      "name": "Brian",
      "avatar_url": "https://avatars.githubusercontent.com/u/2008922?v=4",
      "profile": "https://github.com/Sparta142",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "AtaLuZiK",
      "name": "Kil'jaeden",
      "avatar_url": "https://avatars.githubusercontent.com/u/15212835?v=4",
      "profile": "https://kiljaeden.net",
      "contributions": [
        "test",
        "ideas"
      ]
    },
    {
      "login": "Blefish",
      "name": "Rudolf Tammekivi",
      "avatar_url": "https://avatars.githubusercontent.com/u/1191779?v=4",
      "profile": "https://www.linkedin.com/in/rudolf-tammekivi/",
      "contributions": [
        "bug",
        "code"
      ]
    },
    {
      "login": "karliemeads",
      "name": "Karlie Meads",
      "avatar_url": "https://avatars.githubusercontent.com/u/68717336?v=4",
      "profile": "https://github.com/karliemeads",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "chrodrigues",
      "name": "Charles Rodrigues",
      "avatar_url": "https://avatars.githubusercontent.com/u/56375916?v=4",
      "profile": "https://www.linkedin.com/in/charles-rodrigues-313ba9179/",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "CCreek96",
      "name": "Connor Creek",
      "avatar_url": "https://avatars.githubusercontent.com/u/33628343?v=4",
      "profile": "https://www.linkedin.com/in/connor-creek-318a86107/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "lingfish",
      "name": "Jason Lingohr",
      "avatar_url": "https://avatars.githubusercontent.com/u/1295960?v=4",
      "profile": "https://blog.lucid.net.au",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "simonebenati",
      "name": "Simone Benati",
      "avatar_url": "https://avatars.githubusercontent.com/u/102557087?v=4",
      "profile": "https://github.com/simonebenati",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "konstantin-kornienko",
      "name": "Konstantin Kornienko",
      "avatar_url": "https://avatars.githubusercontent.com/u/50887992?v=4",
      "profile": "https://github.com/konstantin-kornienko",
      "contributions": [
        "code",
        "ideas"
      ]
    },
    {
      "login": "KingKeithC",
      "name": "Keith",
      "avatar_url": "https://avatars.githubusercontent.com/u/23621671?v=4",
      "profile": "https://github.com/KingKeithC",
      "contributions": [
        "code",
        "test"
      ]
    },
    {
      "login": "ZauberNerd",
      "name": "Bj√∂rn Brauer",
      "avatar_url": "https://avatars.githubusercontent.com/u/249542?v=4",
      "profile": "https://github.com/ZauberNerd",
      "contributions": [
        "code",
        "ideas"
      ]
    },
    {
      "login": "Diskoteket",
      "name": "Tim Wetterek",
      "avatar_url": "https://avatars.githubusercontent.com/u/69105072?v=4",
      "profile": "https://github.com/Diskoteket",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "andreaswolf",
      "name": "Andreas Wolf",
      "avatar_url": "https://avatars.githubusercontent.com/u/159919?v=4",
      "profile": "https://a-w.io",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "jordangarside",
      "name": "Jordan Garside",
      "avatar_url": "https://avatars.githubusercontent.com/u/6321824?v=4",
      "profile": "https://jordangarside.com/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "vanillaSprinkles",
      "name": "vanillaSprinkles",
      "avatar_url": "https://avatars.githubusercontent.com/u/577861?v=4",
      "profile": "http://vanillasprinkles.com/",
      "contributions": [
        "code",
        "ideas"
      ]
    },
    {
      "login": "seankoneill",
      "name": "Sean O'Neill",
      "avatar_url": "https://avatars.githubusercontent.com/u/35414430?v=4",
      "profile": "https://github.com/seankoneill",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "nrsmac",
      "name": "Noah Schill",
      "avatar_url": "https://avatars.githubusercontent.com/u/8288816?v=4",
      "profile": "https://github.com/nrsmac",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "camaeel",
      "name": "Kamil Krzywicki",
      "avatar_url": "https://avatars.githubusercontent.com/u/12999736?v=4",
      "profile": "https://github.com/camaeel",
      "contributions": [
        "bug"
      ]
    },
    {
      "login": "joshmcorreia",
      "name": "joshmcorreia",
      "avatar_url": "https://avatars.githubusercontent.com/u/86431308?v=4",
      "profile": "https://stackoverflow.com/users/7487335/josh-correia",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "Mrton0121",
      "name": "Mrton0121",
      "avatar_url": "https://avatars.githubusercontent.com/u/60232434?v=4",
      "profile": "https://github.com/Mrton0121",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "dagi3d",
      "name": "dagi3d",
      "avatar_url": "https://avatars.githubusercontent.com/u/11283?v=4",
      "profile": "http://dagi3d.net",
      "contributions": [
        "financial"
      ]
    },
    {
      "login": "QlemWasTaken",
      "name": "Qlem",
      "avatar_url": "https://avatars.githubusercontent.com/u/73081296?v=4",
      "profile": "https://github.com/QlemWasTaken",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Tarasa24",
      "name": "Petr Gajdosik",
      "avatar_url": "https://avatars.githubusercontent.com/u/20138731?v=4",
      "profile": "https://tarasa24.dev",
      "contributions": [
        "code",
        "test"
      ]
    },
    {
      "login": "gifff",
      "name": "Gifary Dhimas Fadhillah",
      "avatar_url": "https://avatars.githubusercontent.com/u/4391866?v=4",
      "profile": "https://dhimas.net",
      "contributions": [
        "code",
        "bug"
      ]
    },
    {
      "login": "h3krn",
      "name": "H3Krn",
      "avatar_url": "https://avatars.githubusercontent.com/u/13312478?v=4",
      "profile": "https://github.com/h3krn",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "cgeopapa",
      "name": "cgeopapa",
      "avatar_url": "https://avatars.githubusercontent.com/u/12190384?v=4",
      "profile": "https://cgeopapa.github.io/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "fulsiram",
      "name": "fulsiram",
      "avatar_url": "https://avatars.githubusercontent.com/u/79424365?v=4",
      "profile": "https://github.com/fulsiram",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "nakamorichi",
      "name": "Mikael Nakajima",
      "avatar_url": "https://avatars.githubusercontent.com/u/36138?v=4",
      "profile": "https://github.com/nakamorichi",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Nemesees",
      "name": "Nemesees",
      "avatar_url": "https://avatars.githubusercontent.com/u/75946990?v=4",
      "profile": "https://github.com/Nemesees",
      "contributions": [
        "financial"
      ]
    },
    {
      "login": "149segolte",
      "name": "Shreyansh Nayak",
      "avatar_url": "https://avatars.githubusercontent.com/u/37300847?v=4",
      "profile": "https://149segolte.dev",
      "contributions": [
        "ideas"
      ]
    },
    {
      "login": "techuser9182",
      "name": "techuser9182",
      "avatar_url": "https://avatars.githubusercontent.com/u/130158571?v=4",
      "profile": "https://github.com/techuser9182",
      "contributions": [
        "financial"
      ]
    },
    {
      "login": "pileus-lines",
      "name": "pileus-lines",
      "avatar_url": "https://avatars.githubusercontent.com/u/74184010?v=4",
      "profile": "https://github.com/pileus-lines",
      "contributions": [
        "doc"
      ]
    },
    {
      "login": "CaptaiNiveau",
      "name": "CaptaiNiveau",
      "avatar_url": "https://avatars.githubusercontent.com/u/79282544?v=4",
      "profile": "https://github.com/CaptaiNiveau",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "TomaszDom",
      "name": "TomaszDom",
      "avatar_url": "https://avatars.githubusercontent.com/u/9348532?v=4",
      "profile": "https://github.com/TomaszDom",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "Guldoman",
      "name": "Guldoman",
      "avatar_url": "https://avatars.githubusercontent.com/u/2798487?v=4",
      "profile": "https://github.com/Guldoman",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "felinira",
      "name": "Fina",
      "avatar_url": "https://avatars.githubusercontent.com/u/121945?v=4",
      "profile": "https://github.com/felinira",
      "contributions": [
        "code",
        "test"
      ]
    },
    {
      "login": "antoniacobaeus",
      "name": "Anton Iacobaeus",
      "avatar_url": "https://avatars.githubusercontent.com/u/46004494?v=4",
      "profile": "https://github.com/antoniacobaeus",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Bartosz-lab",
      "name": "Bartosz Cie≈õlik",
      "avatar_url": "https://avatars.githubusercontent.com/u/73119351?v=4",
      "profile": "https://github.com/Bartosz-lab",
      "contributions": [
        "code"
      ]
    }
  ],
  "contributorsPerLine": 7,
  "skipCi": false,
  "linkToUsage": true,
  "commitType": "docs"
}
`````

## File: .gitignore
`````
/example/terraform-provider-*
/pkg/
/test/
/website/.vagrant
/website/.bundle
/website/build
/website/node_modules
/website/vendor

autogenerated/
bin/
build/
cache/
dist/
modules-dev/

.terraform/
.vagrant/
.run/

*~
*#
*.backup
*.bak
*.dll
*.exe
*.iml
*.lock.hcl
*.log
*.test
*.tfplan
*.tfstate
*.tfstate.lock.info
*.tfvars
*.env
id_rsa.pub

.*.swp
.DS_Store
.idea

# Test exclusions
!command/test-fixtures/**/*.tfstate
!command/test-fixtures/**/.terraform/

# Binary
terraform-provider-proxmox*

# VScode / Cursor
.vscode/settings.json
.cursor/
.cursorrules
coverage.out
`````

## File: .golangci.yml
`````yaml
version: "2"
linters:
  default: all
  disable:
    - canonicalheader
    - cyclop
    - depguard
    - err113
    - exhaustruct
    - forcetypeassert
    - funlen
    - funcorder # nice to have, but currently generating too many errors
    - gocognit
    - gocyclo
    - ireturn
    - maintidx
    - mnd
    - nestif
    - nlreturn
    - perfsprint
    - rowserrcheck
    - tagliatelle
    - testpackage
    - tparallel
    - varnamelen
    - wastedassign
  settings:
    cyclop:
      max-complexity: 25
    dupl:
      threshold: 150
    errcheck:
      check-blank: true
    exhaustive:
      default-signifies-exhaustive: true
    funlen:
      lines: 80
      statements: 60
    goconst:
      min-len: 10
      min-occurrences: 4
    gosec:
      excludes:
        - G115
    revive:
      rules:
        - name: "package-comments"
          disabled: true
    wrapcheck:
      ignore-package-globs:
        - github.com/bpg/terraform-provider-proxmox/*
  exclusions:
    generated: lax
    presets:
      - common-false-positives
      - legacy
      - std-error-handling
    rules:
      - linters:
          - cyclop
          - dupl
          - funlen
          - gocognit
          - gosec
          - lll
        path: _(test|gen)\.go
      - linters:
          - recvcheck
        path: .*/types/.+\.go
      - linters:
          - lll
          - recvcheck
        path: _types\.go
      - linters:
          - paralleltest
        path: fwprovider/.*_test\.go
      - linters:
          - lll
        source: ^.*https?://.*$
    paths:
      - third_party$
      - builtin$
      - examples$
issues:
  max-issues-per-linter: 0
  max-same-issues: 0
  new-from-rev: 9101977dc81f64db077b9a1eda2fe401359854c9
formatters:
  enable:
    - gofmt
    - gofumpt
    - goimports
  exclusions:
    generated: lax
    paths:
      - third_party$
      - builtin$
      - examples$
`````

## File: .goreleaser.yaml
`````yaml
# yaml-language-server: $schema=https://goreleaser.com/static/schema.json
# vim: set ts=2 sw=2 tw=0 fo=cnqoj

version: 2

builds:
  - env:
      - CGO_ENABLED=0
    goos:
      - freebsd
      - windows
      - linux
      - darwin
    goarch:
      - amd64
      - '386'
      - arm
      - arm64
    ignore:
      - goos: darwin
        goarch: '386'
    binary: '{{ .ProjectName }}_v{{ .Version }}'
archives:
  - formats: [ 'zip' ]
    name_template: '{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}'
checksum:
  extra_files:
    - glob: 'terraform-registry-manifest.json'
      name_template: '{{ .ProjectName }}_{{ .Version }}_manifest.json'
  name_template: '{{ .ProjectName }}_{{ .Version }}_SHA256SUMS'
  algorithm: sha256
signs:
  - artifacts: checksum
    args:
      # if you are using this in a GitHub action or some other automated pipeline, you
      # need to pass the batch flag to indicate its not interactive.
      - "--batch"
      - "--local-user"
      - "{{ .Env.GPG_FINGERPRINT }}" # set this environment variable for your signing key
      - "--output"
      - "${signature}"
      - "--detach-sign"
      - "${artifact}"
release:
  extra_files:
    - glob: 'terraform-registry-manifest.json'
      name_template: '{{ .ProjectName }}_{{ .Version }}_manifest.json'
  # If you want to manually examine the release before its live, uncomment this line:
  # draft: true
changelog:
  disable: true
`````

## File: .lycheeignore
`````
https://.*:8006/
`````

## File: .markdownlint.json
`````json
{
    "MD007": false,
    "MD013": false,
    "MD025": false,
    "MD033": false,
    "MD041": false,
    "MD059": false
}
`````

## File: .markdownlintignore
`````
CHANGELOG.md
`````

## File: .release-please-manifest.json
`````json
{
    ".": "0.78.1"
}
`````

## File: CHANGELOG.md
`````markdown
# Changelog

## [0.78.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.78.0...v0.78.1) (2025-05-24)


### Bug Fixes

* **lxc:** increase maximum supported passthrough devices to 128 ([#1968](https://github.com/bpg/terraform-provider-proxmox/issues/1968)) ([3631240](https://github.com/bpg/terraform-provider-proxmox/commit/36312406d3a4ea55f3dfde522d54f9a527ef36a9))
* **vm:** allow `scsi` and `sata` for CD-ROM interface ([#1971](https://github.com/bpg/terraform-provider-proxmox/issues/1971)) ([b1b8d15](https://github.com/bpg/terraform-provider-proxmox/commit/b1b8d1570f4ff71f7825ac3a0f3a6d25ada4c99e))


### Miscellaneous

* **ci:** improve devcontainer UX ([#1973](https://github.com/bpg/terraform-provider-proxmox/issues/1973)) ([d8a7bc0](https://github.com/bpg/terraform-provider-proxmox/commit/d8a7bc093f99d4e46c86d1d1f46c939b2690d741))
* **deps:** pin image golang to 4c0a181 ([#1975](https://github.com/bpg/terraform-provider-proxmox/issues/1975)) ([f643f2a](https://github.com/bpg/terraform-provider-proxmox/commit/f643f2aecfea97ddf9a681ddc699e721ce947ff3))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1966](https://github.com/bpg/terraform-provider-proxmox/issues/1966)) ([9655bd9](https://github.com/bpg/terraform-provider-proxmox/commit/9655bd9ec7309e72216dd0bbef24b5e0f0d27274))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1974](https://github.com/bpg/terraform-provider-proxmox/issues/1974)) ([71ade27](https://github.com/bpg/terraform-provider-proxmox/commit/71ade273487b7d3e2c260fa44b7f0e7a3807e5be))

## [0.78.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.77.1...v0.78.0) (2025-05-14)


### Features

* **vm:** add support for AMD SEV ([#1952](https://github.com/bpg/terraform-provider-proxmox/issues/1952)) ([28ae95b](https://github.com/bpg/terraform-provider-proxmox/commit/28ae95bd096353522af261b0219e7331beebbad2))


### Bug Fixes

* **network:** adjust Linux Bridge name validator ([#1961](https://github.com/bpg/terraform-provider-proxmox/issues/1961)) ([2a7a2ff](https://github.com/bpg/terraform-provider-proxmox/commit/2a7a2ff4938832076f401f912a5cb3286180a584))


### Miscellaneous

* **ci:** update actions/setup-go digest (0aaccfd ‚Üí d35c59a) ([#1958](https://github.com/bpg/terraform-provider-proxmox/issues/1958)) ([a639257](https://github.com/bpg/terraform-provider-proxmox/commit/a6392572899543cea3e97c82e4307393f80a1b61))
* **ci:** update jetbrains/qodana-action action (v2025.1.0 ‚Üí v2025.1.1) ([#1955](https://github.com/bpg/terraform-provider-proxmox/issues/1955)) ([12f8a40](https://github.com/bpg/terraform-provider-proxmox/commit/12f8a406f36f1e909f8dbdc01c822338dcebaaab))
* **ci:** update lycheeverse/lychee-action action (v2.4.0 ‚Üí v2.4.1) ([#1956](https://github.com/bpg/terraform-provider-proxmox/issues/1956)) ([68132bb](https://github.com/bpg/terraform-provider-proxmox/commit/68132bb1fbd312c1a4fffb10ccefd236f176e551))
* **deps:** update module github.com/hashicorp/terraform-plugin-framework-validators (v0.17.0 ‚Üí v0.18.0) ([#1965](https://github.com/bpg/terraform-provider-proxmox/issues/1965)) ([9d91cdd](https://github.com/bpg/terraform-provider-proxmox/commit/9d91cddbe894089e2a38cf095d21dde29333ec5a))
* **docs:** update terraform local (2.5.2 ‚Üí 2.5.3) ([#1964](https://github.com/bpg/terraform-provider-proxmox/issues/1964)) ([10cda1f](https://github.com/bpg/terraform-provider-proxmox/commit/10cda1f257e5c24a1ceb94826eb856d557018dcf))

## [0.77.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.77.0...v0.77.1) (2025-05-06)


### Bug Fixes

* **lxc:** spurious ip_config diff when interface has both IPv4 and IPv6 addresses ([15b0ae9](https://github.com/bpg/terraform-provider-proxmox/commit/15b0ae90be23c46d5cc106a7f8b4f867fce7d84e))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v2.0.2 ‚Üí v2.0.3) ([#1941](https://github.com/bpg/terraform-provider-proxmox/issues/1941)) ([922d1eb](https://github.com/bpg/terraform-provider-proxmox/commit/922d1ebd8af5fd9e1e3091da13e46f9a9a3754f0))
* **ci:** update actions/create-github-app-token action (v2.0.3 ‚Üí v2.0.6) ([#1946](https://github.com/bpg/terraform-provider-proxmox/issues/1946)) ([84c9b72](https://github.com/bpg/terraform-provider-proxmox/commit/84c9b72e71cda1de5952030f830150599ca4b226))
* **ci:** Update golangci/golangci-lint-action action (v7 ‚Üí v8) ([#1950](https://github.com/bpg/terraform-provider-proxmox/issues/1950)) ([8ded437](https://github.com/bpg/terraform-provider-proxmox/commit/8ded437d45a2a5b290a761c8ef1ef296c790536e))
* **code:** fix new qodana warnings ([#1951](https://github.com/bpg/terraform-provider-proxmox/issues/1951)) ([d23f7ab](https://github.com/bpg/terraform-provider-proxmox/commit/d23f7ab1c005fea2e28b9d969da5cfbe139c2fd7))
* **deps:** update golangci/golangci-lint (v2.1.5 ‚Üí v2.1.6) ([#1947](https://github.com/bpg/terraform-provider-proxmox/issues/1947)) ([462c153](https://github.com/bpg/terraform-provider-proxmox/commit/462c153b32e82b6764c8459e06cc0125c877efd4))
* **deps:** update module golang.org/x/net (v0.39.0 ‚Üí v0.40.0) ([#1949](https://github.com/bpg/terraform-provider-proxmox/issues/1949)) ([58cee6d](https://github.com/bpg/terraform-provider-proxmox/commit/58cee6d35f20b8a96ce8d13e7b8df094086b1779))

## [0.77.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.76.1...v0.77.0) (2025-04-30)


### Features

* **lxc:** increase number of supported mount points to 256 ([#1939](https://github.com/bpg/terraform-provider-proxmox/issues/1939)) ([a99220e](https://github.com/bpg/terraform-provider-proxmox/commit/a99220e9fb170935026edc5449fce8d0a388abc8))


### Bug Fixes

* **file:** better error message on download failure ([#1923](https://github.com/bpg/terraform-provider-proxmox/issues/1923)) ([d463990](https://github.com/bpg/terraform-provider-proxmox/commit/d46399024f0390a57d52e4f89dd8027184815e01))
* **firewall:** prevent reordering of CIDRs in `ipset` resource with mixed IPv4/IPv6 ([#1935](https://github.com/bpg/terraform-provider-proxmox/issues/1935)) ([64147cd](https://github.com/bpg/terraform-provider-proxmox/commit/64147cd24e84c09605633a8cec4aae5f39c4f903))
* **lxc:** do not reboot for cpu block changes ([#1932](https://github.com/bpg/terraform-provider-proxmox/issues/1932)) ([5e49b98](https://github.com/bpg/terraform-provider-proxmox/commit/5e49b98f8e0b004e285a22bfc4687f114609710c))


### Miscellaneous

* **ci:** update actions/attest-build-provenance digest (c074443 ‚Üí db473fd) ([#1937](https://github.com/bpg/terraform-provider-proxmox/issues/1937)) ([7b5042d](https://github.com/bpg/terraform-provider-proxmox/commit/7b5042d945e9e8d5cfd10d624e68ab22f91caab8))
* **ci:** Update JetBrains/qodana-action action (v2024.3.4 ‚Üí v2025.1.0) ([#1927](https://github.com/bpg/terraform-provider-proxmox/issues/1927)) ([d4bfc24](https://github.com/bpg/terraform-provider-proxmox/commit/d4bfc24cb432b694517cadfb78c69aeec5f71e4b))
* **code:** fix code problems reported by Qodana ([#1934](https://github.com/bpg/terraform-provider-proxmox/issues/1934)) ([ebd5399](https://github.com/bpg/terraform-provider-proxmox/commit/ebd5399e14f13fa92e20effc70114813efb8c331))
* **deps:** update golangci/golangci-lint (v2.1.2 ‚Üí v2.1.5) ([#1926](https://github.com/bpg/terraform-provider-proxmox/issues/1926)) ([6b2749f](https://github.com/bpg/terraform-provider-proxmox/commit/6b2749feeace459fc383c4c8b3eb373e236d464f))
* **docs:** update terraform tls (4.0.6 ‚Üí 4.1.0) ([#1925](https://github.com/bpg/terraform-provider-proxmox/issues/1925)) ([2de77b6](https://github.com/bpg/terraform-provider-proxmox/commit/2de77b6a8e1193d864a71faa17389d2e0b61740e))

## [0.76.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.76.0...v0.76.1) (2025-04-21)


### Bug Fixes

* **provider:** improve `known_hosts` handling in SSH client ([#1918](https://github.com/bpg/terraform-provider-proxmox/issues/1918)) ([49d366e](https://github.com/bpg/terraform-provider-proxmox/commit/49d366e45b0741310130c22c875748ffe0348643))
* **vm:** cloned VM may be recreated/updated on re-apply ([#1914](https://github.com/bpg/terraform-provider-proxmox/issues/1914)) ([5974d8b](https://github.com/bpg/terraform-provider-proxmox/commit/5974d8b3a37835735c182c901ab873ab3b3c71eb))


### Miscellaneous

* **code:** move `hardwaremapping` package from `node` to `cluster` in `fwprovider` ([#1917](https://github.com/bpg/terraform-provider-proxmox/issues/1917)) ([fd24c5a](https://github.com/bpg/terraform-provider-proxmox/commit/fd24c5a740446418927aab67b24675f1df655494))
* **docs:** fix broken links in documentation ([#1916](https://github.com/bpg/terraform-provider-proxmox/issues/1916)) ([d27b24f](https://github.com/bpg/terraform-provider-proxmox/commit/d27b24f5f61e14bc2506594f8968165f8adbf2eb))

## [0.76.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.75.0...v0.76.0) (2025-04-17)


### Features

* **hardwaremapping:** Introduce support for directory mappings ([#1902](https://github.com/bpg/terraform-provider-proxmox/issues/1902)) ([6dbff43](https://github.com/bpg/terraform-provider-proxmox/commit/6dbff43bd13fbae86cc5b4fa2075164ef9cf9b62))
* **vm:** add support for `virtiofs` ([#1900](https://github.com/bpg/terraform-provider-proxmox/issues/1900)) ([55b3f73](https://github.com/bpg/terraform-provider-proxmox/commit/55b3f7391ae03fbed60744a55e7966df20577139))


### Bug Fixes

* **vm,lxc:** error parsing disk ID when datastore name contains `.` ([#1894](https://github.com/bpg/terraform-provider-proxmox/issues/1894)) ([1340146](https://github.com/bpg/terraform-provider-proxmox/commit/13401465c9b4136b75d3814f470f0e7f46e05fe6))
* **vm:** edge case error when cloning a VM with EFI disk ([#1897](https://github.com/bpg/terraform-provider-proxmox/issues/1897)) ([4ca2f32](https://github.com/bpg/terraform-provider-proxmox/commit/4ca2f32ac63b7f1844566023071adcd7eca12868))
* **vm:** race condition on reboot causing inconsistent VM state ([#1911](https://github.com/bpg/terraform-provider-proxmox/issues/1911)) ([7fd190a](https://github.com/bpg/terraform-provider-proxmox/commit/7fd190aaebdc1ce13f3023a41d2191d1e4ad9fd2))


### Miscellaneous

* **deps:** update golangci/golangci-lint (v2.0.2 ‚Üí v2.1.2) ([#1903](https://github.com/bpg/terraform-provider-proxmox/issues/1903)) ([ce5cc74](https://github.com/bpg/terraform-provider-proxmox/commit/ce5cc746f99c2d3a9731cdb4594dd66741e263d9))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.20.1 ‚Üí v0.21.0) ([#1898](https://github.com/bpg/terraform-provider-proxmox/issues/1898)) ([504a84c](https://github.com/bpg/terraform-provider-proxmox/commit/504a84cb8354922f429967a7b1bc005774d686b8))
* **docs:** indicate support of Proxmox VE 8.4 ([#1899](https://github.com/bpg/terraform-provider-proxmox/issues/1899)) ([35a5296](https://github.com/bpg/terraform-provider-proxmox/commit/35a529609d50cdfffbb1506ed6d01d35bb967a70))
* **vm:** add an acc test for `disk.backup` update edge case ([#1906](https://github.com/bpg/terraform-provider-proxmox/issues/1906)) ([ad41476](https://github.com/bpg/terraform-provider-proxmox/commit/ad41476962c3ff3e7e7ac530fe6f5ad85797b994))

## [0.75.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.74.1...v0.75.0) (2025-04-08)


### ‚ö† BREAKING CHANGES

* **vm:** remove deprecated `initialization.dns.server`, `initialization.upgrade` ([#1884](https://github.com/bpg/terraform-provider-proxmox/issues/1884))
* **datastores:** implement new structured format and filters for `datastores` data source ([#1875](https://github.com/bpg/terraform-provider-proxmox/issues/1875))

### Features

* **datastores:** implement new structured format and filters for `datastores` data source ([#1875](https://github.com/bpg/terraform-provider-proxmox/issues/1875)) ([b5b61b4](https://github.com/bpg/terraform-provider-proxmox/commit/b5b61b48dcb4a7a4943d1c40a07928cff34c8b68))
* **vm:** do not force VM re-create on `initialization.user_account` changes ([#1885](https://github.com/bpg/terraform-provider-proxmox/issues/1885)) ([d631ccb](https://github.com/bpg/terraform-provider-proxmox/commit/d631ccbf908c38a91eefce9b7904f2c1dcc5d20b))


### Miscellaneous

* **ci:** pin golangci/golangci-lint-action action to ([#1872](https://github.com/bpg/terraform-provider-proxmox/issues/1872)) ([f7706c8](https://github.com/bpg/terraform-provider-proxmox/commit/f7706c805879d1773de312ca6a8106821e6b44ee))
* **ci:** Update actions/create-github-app-token action (v1.12.0 ‚Üí v2.0.2) ([#1880](https://github.com/bpg/terraform-provider-proxmox/issues/1880)) ([3d0c47a](https://github.com/bpg/terraform-provider-proxmox/commit/3d0c47ae7988bd2434e08985dd707892756bd344))
* **ci:** update lycheeverse/lychee-action action (v2.3.0 ‚Üí v2.4.0) ([#1873](https://github.com/bpg/terraform-provider-proxmox/issues/1873)) ([ece13f7](https://github.com/bpg/terraform-provider-proxmox/commit/ece13f7716e2bc5f63cd91c33ec0f791a4ae8247))
* **deps:** update module golang.org/x/crypto (v0.36.0 ‚Üí v0.37.0) ([#1882](https://github.com/bpg/terraform-provider-proxmox/issues/1882)) ([c526208](https://github.com/bpg/terraform-provider-proxmox/commit/c526208f4bfd16985e0d2ec206da8474d5ec7065))
* **deps:** update module golang.org/x/net (v0.38.0 ‚Üí v0.39.0) ([#1887](https://github.com/bpg/terraform-provider-proxmox/issues/1887)) ([5035965](https://github.com/bpg/terraform-provider-proxmox/commit/50359656bdaa8cc92e52b2169a5c1d10dd9ae7ab))
* **docs:** add known issue to the README about Debian 12 VM requiring a serial device ([#1886](https://github.com/bpg/terraform-provider-proxmox/issues/1886)) ([8e231f9](https://github.com/bpg/terraform-provider-proxmox/commit/8e231f9737113eb62e8969da05620959e320f7f5))
* **vm:** remove deprecated `initialization.dns.server`, `initialization.upgrade` ([#1884](https://github.com/bpg/terraform-provider-proxmox/issues/1884)) ([51e6d7b](https://github.com/bpg/terraform-provider-proxmox/commit/51e6d7b8db05c5200ce6dd0569c590a2fbe0aed2))

## [0.74.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.74.0...v0.74.1) (2025-03-31)


### Bug Fixes

* **auth:** do not reset user token value in TF state during update ([#1857](https://github.com/bpg/terraform-provider-proxmox/issues/1857)) ([2da4e3d](https://github.com/bpg/terraform-provider-proxmox/commit/2da4e3de1c2ab8969afd1d86575a6101a8dc07f5))
* **docs:** clarify `tags` behaviour for container ([#1851](https://github.com/bpg/terraform-provider-proxmox/issues/1851)) ([b19d28e](https://github.com/bpg/terraform-provider-proxmox/commit/b19d28e841926a1433a1898777b984a3b659edd5))
* **lxc:** multiple issues during container import ([#1867](https://github.com/bpg/terraform-provider-proxmox/issues/1867)) ([aa9cdba](https://github.com/bpg/terraform-provider-proxmox/commit/aa9cdba0bf6dfd817c57384f6f688009a9e82635))
* **lxc:** prevent spurious `dns` config change when updating `initialization` block ([#1859](https://github.com/bpg/terraform-provider-proxmox/issues/1859)) ([03f2079](https://github.com/bpg/terraform-provider-proxmox/commit/03f20799029b56ab0d9d0e096e8890f0d61780d8))
* **vm:** allow to set `machine` type in clone ([#1865](https://github.com/bpg/terraform-provider-proxmox/issues/1865)) ([7090b10](https://github.com/bpg/terraform-provider-proxmox/commit/7090b1036a2c5a8640eef62daf23b56af521e409))
* **vm:** improve error handling when updating `initialization` block ([#1858](https://github.com/bpg/terraform-provider-proxmox/issues/1858)) ([539b902](https://github.com/bpg/terraform-provider-proxmox/commit/539b902633b07e1f9089274b9ddd7e7d3edd317d))
* **vm:** prevent cloud-init password reset to `**********` during update ([#1864](https://github.com/bpg/terraform-provider-proxmox/issues/1864)) ([4f522ec](https://github.com/bpg/terraform-provider-proxmox/commit/4f522ec34227a9b6f713e9600c00fcd110bea5d9))
* **vm:** prevent cloud-init username reset to `" "` during create ([#1863](https://github.com/bpg/terraform-provider-proxmox/issues/1863)) ([c9fcb30](https://github.com/bpg/terraform-provider-proxmox/commit/c9fcb30762a46a3d6a0e48a8bb6201aa8b205dcd))
* **vm:** remove `qcow2` as the default for `disk.file_format` ([#1862](https://github.com/bpg/terraform-provider-proxmox/issues/1862)) ([af46a9c](https://github.com/bpg/terraform-provider-proxmox/commit/af46a9c71af8d8ffe687c0b5a87de9f0ca4f1a37))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.11.7 ‚Üí v1.12.0) ([#1860](https://github.com/bpg/terraform-provider-proxmox/issues/1860)) ([7ba9417](https://github.com/bpg/terraform-provider-proxmox/commit/7ba94171bfba19b29426429d043b03adb8fbaa1e))
* **ci:** update crazy-max/ghaction-import-gpg action (v6.2.0 ‚Üí v6.3.0) ([#1868](https://github.com/bpg/terraform-provider-proxmox/issues/1868)) ([4d30ba7](https://github.com/bpg/terraform-provider-proxmox/commit/4d30ba71860c2a2656f03fcb8e25d4c0bbfaadc0))
* **ci:** update goreleaser/goreleaser-action action (v6.2.1 ‚Üí v6.3.0) ([#1869](https://github.com/bpg/terraform-provider-proxmox/issues/1869)) ([8c42d80](https://github.com/bpg/terraform-provider-proxmox/commit/8c42d8063f6c18ea3f4ae720f14f42e306dfaefb))
* **deps:** update module golang.org/x/net (v0.37.0 ‚Üí v0.38.0) ([#1861](https://github.com/bpg/terraform-provider-proxmox/issues/1861)) ([f030a49](https://github.com/bpg/terraform-provider-proxmox/commit/f030a49e9f6798fcea7bb64defdcf7ddfd009bc0))
* **docs:** add known issue for HA VMs and containers in README ([#1855](https://github.com/bpg/terraform-provider-proxmox/issues/1855)) ([de65997](https://github.com/bpg/terraform-provider-proxmox/commit/de65997de49fa40cb5874b5f5cace0732babe6ef))

## [0.74.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.73.2...v0.74.0) (2025-03-26)


### ‚ö† BREAKING CHANGES

* **docs:** clarify disk behaviour in clone operation ([#1850](https://github.com/bpg/terraform-provider-proxmox/issues/1850))

### Bug Fixes

* **vm:** handle update of disks moved during VM clone ([#1849](https://github.com/bpg/terraform-provider-proxmox/issues/1849)) ([09d3e97](https://github.com/bpg/terraform-provider-proxmox/commit/09d3e97d020ced9b7d7ee7e15087f8e5d708a681))


### Miscellaneous

* **ci:** pin actions/attest-build-provenance action to ([#1843](https://github.com/bpg/terraform-provider-proxmox/issues/1843)) ([ef66b55](https://github.com/bpg/terraform-provider-proxmox/commit/ef66b55fc26878c23c569f9018b443dc92494d1c))
* **deps:** Update golangci/golangci-lint (v1.64.8 ‚Üí v2.0.2) ([#1847](https://github.com/bpg/terraform-provider-proxmox/issues/1847)) ([1eee8cd](https://github.com/bpg/terraform-provider-proxmox/commit/1eee8cdbd0c401d5078b0befc3304e21f3faef17))
* **deps:** update module github.com/pkg/sftp (v1.13.8 ‚Üí v1.13.9) ([#1846](https://github.com/bpg/terraform-provider-proxmox/issues/1846)) ([2ae7725](https://github.com/bpg/terraform-provider-proxmox/commit/2ae77257d3c5e9b5672ff6e0e5f7b58ae2d7c06e))
* **docs:** clarify disk behaviour in clone operation ([#1850](https://github.com/bpg/terraform-provider-proxmox/issues/1850)) ([75281b2](https://github.com/bpg/terraform-provider-proxmox/commit/75281b2652a44f2374951d085830711af5e96df5))

## [0.73.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.73.1...v0.73.2) (2025-03-21)


### Bug Fixes

* **provider:** better error handling for non-existent resources([#1824](https://github.com/bpg/terraform-provider-proxmox/issues/1824)) ([febf239](https://github.com/bpg/terraform-provider-proxmox/commit/febf239b58b725e273397e060563b31846a0acf7))
* **vm:** fix and improve disk management for cloned VMs ([#1840](https://github.com/bpg/terraform-provider-proxmox/issues/1840)) ([faeada9](https://github.com/bpg/terraform-provider-proxmox/commit/faeada970c2bbddea6d26e30fb3a40ae227cf55f))


### Miscellaneous

* **ci:** enable attestation ([#1841](https://github.com/bpg/terraform-provider-proxmox/issues/1841)) ([33e1eb4](https://github.com/bpg/terraform-provider-proxmox/commit/33e1eb4f4da71834a16ecdb606825facb8ad8dd2))
* **ci:** pin dependencies ([#1822](https://github.com/bpg/terraform-provider-proxmox/issues/1822)) ([189e81a](https://github.com/bpg/terraform-provider-proxmox/commit/189e81aba3dda3670c7c1258911b361c0c7a657c))
* **ci:** update actions/create-github-app-token action (v1.11.6 ‚Üí v1.11.7) ([#1839](https://github.com/bpg/terraform-provider-proxmox/issues/1839)) ([267eb3d](https://github.com/bpg/terraform-provider-proxmox/commit/267eb3d07d9cf8a47f3d4fd9bf69d9590f4386b3))
* **ci:** update actions/setup-go digest (f111f33 ‚Üí 0aaccfd) ([#1831](https://github.com/bpg/terraform-provider-proxmox/issues/1831)) ([bd5ab91](https://github.com/bpg/terraform-provider-proxmox/commit/bd5ab9103cb0128bde2d8fe60b2873b2ff99219b))
* **ci:** update actions/upload-artifact digest (4cec3d8 ‚Üí ea165f8) ([#1832](https://github.com/bpg/terraform-provider-proxmox/issues/1832)) ([3bd2dac](https://github.com/bpg/terraform-provider-proxmox/commit/3bd2dac4d1f93f0b3aa5b795a8bd7101df32bcb7))
* **ci:** update golangci/golangci-lint-action digest (4696ba8 ‚Üí 55c2c14) ([#1833](https://github.com/bpg/terraform-provider-proxmox/issues/1833)) ([319eecd](https://github.com/bpg/terraform-provider-proxmox/commit/319eecdedc532b53d62ea7f4dfaf62d0b05b5a24))
* **deps:** update golangci/golangci-lint ([#1834](https://github.com/bpg/terraform-provider-proxmox/issues/1834)) ([292811b](https://github.com/bpg/terraform-provider-proxmox/commit/292811bddef8f3bc009f228b1483696babadba32))
* **deps:** update golangci/golangci-lint (1.64.5 ‚Üí 1.64.7) ([#1810](https://github.com/bpg/terraform-provider-proxmox/issues/1810)) ([0977473](https://github.com/bpg/terraform-provider-proxmox/commit/0977473dd24fc2e393d1a4467856b98e14917cee))
* **deps:** update golangci/golangci-lint (v1.64.5 ‚Üí v1.64.7) ([#1821](https://github.com/bpg/terraform-provider-proxmox/issues/1821)) ([57244d2](https://github.com/bpg/terraform-provider-proxmox/commit/57244d2f99e20b3c8c68e99c2077eb2b9102495b))
* **deps:** update image mcr.microsoft.com/devcontainers/go (1.23 ‚Üí 1.24) ([#1835](https://github.com/bpg/terraform-provider-proxmox/issues/1835)) ([27fe170](https://github.com/bpg/terraform-provider-proxmox/commit/27fe17008f38adb4585702b3ae0bec42f135a440))
* **deps:** update module github.com/hashicorp/go-cty (v1.4.1 ‚Üí v1.5.0) ([#1836](https://github.com/bpg/terraform-provider-proxmox/issues/1836)) ([53d0045](https://github.com/bpg/terraform-provider-proxmox/commit/53d0045cdf8652c814c9c3d4df414c5852e91d7f))
* **deps:** update module github.com/hashicorp/terraform-plugin-testing (v1.11.0 ‚Üí v1.12.0) ([#1837](https://github.com/bpg/terraform-provider-proxmox/issues/1837)) ([bb13d05](https://github.com/bpg/terraform-provider-proxmox/commit/bb13d05f019b33cecf6f940dc126424c18bccb79))
* **deps:** update module github.com/pkg/sftp (v1.13.7 ‚Üí v1.13.8) ([#1819](https://github.com/bpg/terraform-provider-proxmox/issues/1819)) ([b38a29a](https://github.com/bpg/terraform-provider-proxmox/commit/b38a29a1da1fa841b2b9911a81eadd6b228310eb))
* **docs:** update cloud-init configuration examples ([#1830](https://github.com/bpg/terraform-provider-proxmox/issues/1830)) ([a681e82](https://github.com/bpg/terraform-provider-proxmox/commit/a681e828bfe3de8e680a4c0c7ea3a363d98e3766))
* **docs:** update project badges ([#1842](https://github.com/bpg/terraform-provider-proxmox/issues/1842)) ([d3d3910](https://github.com/bpg/terraform-provider-proxmox/commit/d3d39106559bda5fc9e84b29b513150d0c8419c7))

## [0.73.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.73.0...v0.73.1) (2025-03-10)


### Bug Fixes

* **vm:** fix vm machine type validation in order to support viommu ([#1798](https://github.com/bpg/terraform-provider-proxmox/issues/1798)) ([57c3970](https://github.com/bpg/terraform-provider-proxmox/commit/57c3970d540bac6fb562a913ed82003ea5553c0c))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.11.5 ‚Üí v1.11.6) ([#1809](https://github.com/bpg/terraform-provider-proxmox/issues/1809)) ([1145718](https://github.com/bpg/terraform-provider-proxmox/commit/1145718166c9c2375700c83a99d2ce27a4b44c2f))
* **ci:** update googleapis/release-please-action action (v4.1.3 ‚Üí v4.1.4) ([#1804](https://github.com/bpg/terraform-provider-proxmox/issues/1804)) ([748fb0d](https://github.com/bpg/terraform-provider-proxmox/commit/748fb0dc7750656c21d89af30fe008ea7b88513a))
* **ci:** update googleapis/release-please-action action (v4.1.4 ‚Üí v4.2.0) ([#1812](https://github.com/bpg/terraform-provider-proxmox/issues/1812)) ([b526e75](https://github.com/bpg/terraform-provider-proxmox/commit/b526e756a3c136d5ad021410dda32cff2885da9a))
* **deps:** update module github.com/avast/retry-go/v4 (v4.6.0 ‚Üí v4.6.1) ([#1791](https://github.com/bpg/terraform-provider-proxmox/issues/1791)) ([b3c862b](https://github.com/bpg/terraform-provider-proxmox/commit/b3c862b986f283a4be7d1a4f78562664a21003cd))
* **deps:** update module github.com/hashicorp/go-cty (v1.4.1-0.20241127173709-a0325cb22c13 ‚Üí v1.4.1) ([#1811](https://github.com/bpg/terraform-provider-proxmox/issues/1811)) ([51b93cf](https://github.com/bpg/terraform-provider-proxmox/commit/51b93cfd19f8e4472f76429ce0d0cd763e70fdf2))
* **deps:** update module github.com/rogpeppe/go-internal (v1.13.1 ‚Üí v1.14.0) ([#1792](https://github.com/bpg/terraform-provider-proxmox/issues/1792)) ([c5e4d5c](https://github.com/bpg/terraform-provider-proxmox/commit/c5e4d5ca2cff885589cc511c82c4e4e43bfa7d9c))
* **deps:** update module github.com/rogpeppe/go-internal (v1.14.0 ‚Üí v1.14.1) ([#1805](https://github.com/bpg/terraform-provider-proxmox/issues/1805)) ([ed1b25a](https://github.com/bpg/terraform-provider-proxmox/commit/ed1b25a93608114438e49e950c46bc6035e36d29))
* **deps:** update module golang.org/x/crypto (v0.34.0 ‚Üí v0.35.0) ([#1793](https://github.com/bpg/terraform-provider-proxmox/issues/1793)) ([a04ff63](https://github.com/bpg/terraform-provider-proxmox/commit/a04ff63f094e0fd4e1407a1d48bb52146fde3f89))
* **deps:** update module golang.org/x/crypto (v0.35.0 ‚Üí v0.36.0) ([#1813](https://github.com/bpg/terraform-provider-proxmox/issues/1813)) ([be6ddb4](https://github.com/bpg/terraform-provider-proxmox/commit/be6ddb47129f32c23b514b2b01175b32b40c37e7))
* **deps:** update module golang.org/x/net (v0.35.0 ‚Üí v0.37.0) ([#1814](https://github.com/bpg/terraform-provider-proxmox/issues/1814)) ([c126928](https://github.com/bpg/terraform-provider-proxmox/commit/c126928f3b4221753271e3a2400c3d4b2ef7d10b))
* **docs:** update sponsorship section ([#1803](https://github.com/bpg/terraform-provider-proxmox/issues/1803)) ([654a5fc](https://github.com/bpg/terraform-provider-proxmox/commit/654a5fc73d67ad90447749c646abe4c431d3d92c))

## [0.73.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.72.0...v0.73.0) (2025-02-24)


### Features

* **vm:** add optional `reboot_after_update` configuration flag ([#1777](https://github.com/bpg/terraform-provider-proxmox/issues/1777)) ([5e726c4](https://github.com/bpg/terraform-provider-proxmox/commit/5e726c48d447bee1b6487bad8472c032d00e8931))


### Miscellaneous

* **build:** update Go version and linter /documentation workflows ([#1789](https://github.com/bpg/terraform-provider-proxmox/issues/1789)) ([8ed271b](https://github.com/bpg/terraform-provider-proxmox/commit/8ed271b55121829b3c58b35a049ffeab43062ae9))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1782](https://github.com/bpg/terraform-provider-proxmox/issues/1782)) ([9c46bf0](https://github.com/bpg/terraform-provider-proxmox/commit/9c46bf0ee01fa07c5a2855a6c2ec151ff182584f))
* **deps:** update module github.com/google/go-cmp (v0.6.0 ‚Üí v0.7.0) ([#1783](https://github.com/bpg/terraform-provider-proxmox/issues/1783)) ([f516f80](https://github.com/bpg/terraform-provider-proxmox/commit/f516f804f6bc10600a58d4e3a282c7009342fcf8))
* **deps:** update module github.com/hashicorp/terraform-plugin-sdk/v2 (v2.36.0 ‚Üí v2.36.1) ([#1781](https://github.com/bpg/terraform-provider-proxmox/issues/1781)) ([74141bf](https://github.com/bpg/terraform-provider-proxmox/commit/74141bf9892d50d2d02eada3161685b4e05ecc88))
* **deps:** update module golang.org/x/crypto (v0.33.0 ‚Üí v0.34.0) ([#1784](https://github.com/bpg/terraform-provider-proxmox/issues/1784)) ([e013e54](https://github.com/bpg/terraform-provider-proxmox/commit/e013e54ae934fce1284033f0641b68e10baf0081))

## [0.72.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.71.0...v0.72.0) (2025-02-17)


### Features

* **lxc:** add container datasource ([#1750](https://github.com/bpg/terraform-provider-proxmox/issues/1750)) ([3834564](https://github.com/bpg/terraform-provider-proxmox/commit/3834564ea43d1f679e4f281c89ce0a815ddfbd12))
* **vm:** add RNG device  support ([#1774](https://github.com/bpg/terraform-provider-proxmox/issues/1774)) ([3119194](https://github.com/bpg/terraform-provider-proxmox/commit/31191942928722d18f1ae6ea467c030da1f2fa71))


### Bug Fixes

* **docs:** update incorrect reference to meta_data_file_id ([#1759](https://github.com/bpg/terraform-provider-proxmox/issues/1759)) ([28327f9](https://github.com/bpg/terraform-provider-proxmox/commit/28327f90e37840b73704dafd4e6ec983dbff53c0))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.11.3 ‚Üí v1.11.5) ([#1773](https://github.com/bpg/terraform-provider-proxmox/issues/1773)) ([3d48a97](https://github.com/bpg/terraform-provider-proxmox/commit/3d48a97fb1a5bb35d8cc124b175275931f8c7d3b))
* **ci:** update goreleaser/goreleaser-action action (v6.1.0 ‚Üí v6.2.1) ([#1764](https://github.com/bpg/terraform-provider-proxmox/issues/1764)) ([54624fb](https://github.com/bpg/terraform-provider-proxmox/commit/54624fb6531b7447b112bf6098062aa978265148))
* **code:** update linters config ([#1775](https://github.com/bpg/terraform-provider-proxmox/issues/1775)) ([45806f3](https://github.com/bpg/terraform-provider-proxmox/commit/45806f38f47a75635a777f4043dd7aaa9f461893))
* **deps:** update module github.com/golangci/golangci-lint (v1.63.4 ‚Üí v1.64.2) in /tools ([#1765](https://github.com/bpg/terraform-provider-proxmox/issues/1765)) ([6e21bca](https://github.com/bpg/terraform-provider-proxmox/commit/6e21bca2d5c1903f62c20d6b76106382ef342e26))
* **deps:** update module github.com/golangci/golangci-lint (v1.64.2 ‚Üí v1.64.4) in /tools ([#1769](https://github.com/bpg/terraform-provider-proxmox/issues/1769)) ([a5251d1](https://github.com/bpg/terraform-provider-proxmox/commit/a5251d119a6f50ac4808baeaa68af6640de1d7b7))
* **deps:** update module github.com/golangci/golangci-lint (v1.64.4 ‚Üí v1.64.5) in /tools ([#1772](https://github.com/bpg/terraform-provider-proxmox/issues/1772)) ([417cdff](https://github.com/bpg/terraform-provider-proxmox/commit/417cdff50c71c3517010990c0824b9b2b69f3c47))
* **deps:** update module golang.org/x/net (v0.34.0 ‚Üí v0.35.0) ([#1766](https://github.com/bpg/terraform-provider-proxmox/issues/1766)) ([d350c65](https://github.com/bpg/terraform-provider-proxmox/commit/d350c65f4cde83a2b9b4f46b09f15f21687b5a87))
* **docs:** add security policy ([#1758](https://github.com/bpg/terraform-provider-proxmox/issues/1758)) ([cbff3e4](https://github.com/bpg/terraform-provider-proxmox/commit/cbff3e4fd458b3dabd4c9ff6c28ea277db2db0b4))
* **docs:** remove broken links from SECURITY.md ([#1776](https://github.com/bpg/terraform-provider-proxmox/issues/1776)) ([4c06d0f](https://github.com/bpg/terraform-provider-proxmox/commit/4c06d0f12e6b89d0fb1085865a1e699808db462c))
* **docs:** reorganize API token auth section ([#1761](https://github.com/bpg/terraform-provider-proxmox/issues/1761)) ([4057d13](https://github.com/bpg/terraform-provider-proxmox/commit/4057d137151bb7926d0d196e48ceb6a97c42b618))
* **docs:** update project documentation and contribution guidelines ([#1756](https://github.com/bpg/terraform-provider-proxmox/issues/1756)) ([8c0c79b](https://github.com/bpg/terraform-provider-proxmox/commit/8c0c79be3c78ed85e6790ba1cbbdb1ece3d5290c))

## [0.71.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.70.1...v0.71.0) (2025-02-09)


### Features

* **cluster:** add `proxmox_virtual_environment_metrics_server` resource ([#1719](https://github.com/bpg/terraform-provider-proxmox/issues/1719)) ([d1cc214](https://github.com/bpg/terraform-provider-proxmox/commit/d1cc2144f858f655a1a5752a7af0e9d551995dd5))
* **vm:** deprecate `enabled` attribute on `cdrom`/`disk` devices ([#1746](https://github.com/bpg/terraform-provider-proxmox/issues/1746)) ([5f00314](https://github.com/bpg/terraform-provider-proxmox/commit/5f003143f882aca0e38637a9456f615d7fc6bbd0))


### Bug Fixes

* **file:** fix for datastore does not support content type "dump" ([#1752](https://github.com/bpg/terraform-provider-proxmox/issues/1752)) ([0aa2b50](https://github.com/bpg/terraform-provider-proxmox/commit/0aa2b505e59985d347149b90dd05d21ca041092b))
* **lxc:** allow container disk size 0 for lxc zfs/brfs subvols ([#1737](https://github.com/bpg/terraform-provider-proxmox/issues/1737)) ([2925ae6](https://github.com/bpg/terraform-provider-proxmox/commit/2925ae63f5b233e007ff4621a9edffd8dcb139f0))
* **provider:** improve provider credentials error handling ([#1754](https://github.com/bpg/terraform-provider-proxmox/issues/1754)) ([f221a85](https://github.com/bpg/terraform-provider-proxmox/commit/f221a85f8f16be600ed6808ce4b2ba7b26aecfb5))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.11.2 ‚Üí v1.11.3) ([#1743](https://github.com/bpg/terraform-provider-proxmox/issues/1743)) ([ccc263f](https://github.com/bpg/terraform-provider-proxmox/commit/ccc263f8ad1b4a69135e81406ba7df24029ffd73))
* **ci:** update lycheeverse/lychee-action action (v2.2.0 ‚Üí v2.3.0) ([#1744](https://github.com/bpg/terraform-provider-proxmox/issues/1744)) ([0700975](https://github.com/bpg/terraform-provider-proxmox/commit/0700975ec25094bb3e0ce574961e47a56334e883))
* **deps:** update module github.com/hashicorp/terraform-plugin-sdk/v2 (v2.35.0 ‚Üí v2.36.0) ([#1745](https://github.com/bpg/terraform-provider-proxmox/issues/1745)) ([bf9c496](https://github.com/bpg/terraform-provider-proxmox/commit/bf9c496f2956202618b83cfb982fff5771349572))
* **deps:** update module golang.org/x/crypto (v0.32.0 ‚Üí v0.33.0) ([#1751](https://github.com/bpg/terraform-provider-proxmox/issues/1751)) ([96594e4](https://github.com/bpg/terraform-provider-proxmox/commit/96594e42705032fdf8f1457a70f5c7c51ceb8d05))
* **docs:** update terraform proxmox (0.70.0 ‚Üí 0.70.1) ([#1741](https://github.com/bpg/terraform-provider-proxmox/issues/1741)) ([9bd0b57](https://github.com/bpg/terraform-provider-proxmox/commit/9bd0b57254768519d70fb6b1589d038e06d93842))

## [0.70.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.70.0...v0.70.1) (2025-01-31)


### Bug Fixes

* **lxc:** support `device_passthrough` config on non-clone container ([#1722](https://github.com/bpg/terraform-provider-proxmox/issues/1722)) ([e92b006](https://github.com/bpg/terraform-provider-proxmox/commit/e92b0064bf3a2a9b0c9582928665d93d8dc1993a))
* **vm:** `vga` block defaults handling during create / clone ([#1732](https://github.com/bpg/terraform-provider-proxmox/issues/1732)) ([c992dfc](https://github.com/bpg/terraform-provider-proxmox/commit/c992dfc1f30437071cb5f4784cbfea3f3d199b0f))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.11.1 ‚Üí v1.11.2) ([#1733](https://github.com/bpg/terraform-provider-proxmox/issues/1733)) ([4d89d34](https://github.com/bpg/terraform-provider-proxmox/commit/4d89d3484b1145be1eb4ee1f7f7f7068e641a823))
* **deps:** update module github.com/brianvoe/gofakeit/v7 (v7.1.2 ‚Üí v7.2.1) ([#1735](https://github.com/bpg/terraform-provider-proxmox/issues/1735)) ([d4b1d5f](https://github.com/bpg/terraform-provider-proxmox/commit/d4b1d5f1b694d70581e763be5ff20577916308f0))
* **deps:** update module github.com/hashicorp/terraform-plugin-go (v0.25.0 ‚Üí v0.26.0) ([#1726](https://github.com/bpg/terraform-provider-proxmox/issues/1726)) ([198f0ad](https://github.com/bpg/terraform-provider-proxmox/commit/198f0ad337c914a93bc81c543a4b665aaf2255eb))
* **deps:** update module github.com/hashicorp/terraform-plugin-mux (v0.17.0 ‚Üí v0.18.0) ([#1727](https://github.com/bpg/terraform-provider-proxmox/issues/1727)) ([e031a38](https://github.com/bpg/terraform-provider-proxmox/commit/e031a38d5026727b99fe6b8de898544710b19090))
* **deps:** update module github.com/skeema/knownhosts (v1.3.0 ‚Üí v1.3.1) ([#1734](https://github.com/bpg/terraform-provider-proxmox/issues/1734)) ([4cedbf1](https://github.com/bpg/terraform-provider-proxmox/commit/4cedbf1813aee9d8f4421e5f1cebab7b06722fbb))
* **docs:** update terraform proxmox (0.69.1 ‚Üí 0.70.0) ([#1717](https://github.com/bpg/terraform-provider-proxmox/issues/1717)) ([56f81cc](https://github.com/bpg/terraform-provider-proxmox/commit/56f81ccac39242b86cf55aba7724aa6c98a990a5))
* **testacc:** add missing acceptance build tags, improve vscode settings ([#1723](https://github.com/bpg/terraform-provider-proxmox/issues/1723)) ([974a3c9](https://github.com/bpg/terraform-provider-proxmox/commit/974a3c906925bbaf0978f79f285d0dbd1fd76c68))
* **testacc:** update apt repository acceptance tests ([#1725](https://github.com/bpg/terraform-provider-proxmox/issues/1725)) ([5e7e799](https://github.com/bpg/terraform-provider-proxmox/commit/5e7e7994d5ca5be7a2cd40bccad4b18425a00cd1))

## [0.70.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.69.1...v0.70.0) (2025-01-18)


### Features

* **docs:** basic guide how to clone a VM template ([#1716](https://github.com/bpg/terraform-provider-proxmox/issues/1716)) ([ccaae92](https://github.com/bpg/terraform-provider-proxmox/commit/ccaae927e68a74197d0aac8d2d7a05e0ebdf7a7a))
* **lxc:** add support for `device_passthrough` config option ([#1706](https://github.com/bpg/terraform-provider-proxmox/issues/1706)) ([7cbd1b4](https://github.com/bpg/terraform-provider-proxmox/commit/7cbd1b46fad999fe8a0ae5608d57ad708d9635c5))


### Bug Fixes

* **vm:** do not delete a VM during retry on `create` ([#1711](https://github.com/bpg/terraform-provider-proxmox/issues/1711)) ([c57dc78](https://github.com/bpg/terraform-provider-proxmox/commit/c57dc781192819bbcf942dc0b7c9e9d432d49edc))
* **vm:** handle PVE node availability in VM datasource ([#1715](https://github.com/bpg/terraform-provider-proxmox/issues/1715)) ([3ecd044](https://github.com/bpg/terraform-provider-proxmox/commit/3ecd0443bbbdfce9bc7e8b8f082d662aac247760))


### Miscellaneous

* **deps:** update module github.com/hashicorp/terraform-plugin-framework-timeouts (v0.4.1 ‚Üí v0.5.0) ([#1714](https://github.com/bpg/terraform-provider-proxmox/issues/1714)) ([eccd55f](https://github.com/bpg/terraform-provider-proxmox/commit/eccd55f522893708d9e9ebb88c581b4b9e40e714))
* **deps:** update module golang.org/x/crypto (v0.31.0 ‚Üí v0.32.0) ([#1702](https://github.com/bpg/terraform-provider-proxmox/issues/1702)) ([d22f9d3](https://github.com/bpg/terraform-provider-proxmox/commit/d22f9d32f022d42247897803ee8493c4019dc233))
* **deps:** update module golang.org/x/net (v0.33.0 ‚Üí v0.34.0) ([#1703](https://github.com/bpg/terraform-provider-proxmox/issues/1703)) ([3808aef](https://github.com/bpg/terraform-provider-proxmox/commit/3808aef33e822b85ae33a97cc87d6020b21abbfe))
* **docs:** add 'stop_on_destroy' configuration to cloud image examples ([#1705](https://github.com/bpg/terraform-provider-proxmox/issues/1705)) ([ab09b09](https://github.com/bpg/terraform-provider-proxmox/commit/ab09b09fbf36b523e610fcfa0ac36def61a2eaa0))
* **docs:** update README.md ([#1707](https://github.com/bpg/terraform-provider-proxmox/issues/1707)) ([6f65789](https://github.com/bpg/terraform-provider-proxmox/commit/6f657892c0a29d6677ef6d72690dbfb991a67ad1))

## [0.69.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.69.0...v0.69.1) (2025-01-04)


### Miscellaneous

* **build:** update devcontainer and CI workflows ([#1691](https://github.com/bpg/terraform-provider-proxmox/issues/1691)) ([5ec64b8](https://github.com/bpg/terraform-provider-proxmox/commit/5ec64b8b1925f5237db8fe0ff9b6f1972ffd67c3))
* **ci:** update actions/create-github-app-token action (v1.11.0 ‚Üí v1.11.1) ([#1692](https://github.com/bpg/terraform-provider-proxmox/issues/1692)) ([0f3798b](https://github.com/bpg/terraform-provider-proxmox/commit/0f3798b371944eaa5a75c723128af53fd26cb25f))
* **ci:** update jetbrains/qodana-action action (v2024.3.3 ‚Üí v2024.3.4) ([#1694](https://github.com/bpg/terraform-provider-proxmox/issues/1694)) ([493cbac](https://github.com/bpg/terraform-provider-proxmox/commit/493cbac0066d5d3884c6c7db9f304e863f41b27d))
* **ci:** update lycheeverse/lychee-action action (v2.1.0 ‚Üí v2.2.0) ([#1690](https://github.com/bpg/terraform-provider-proxmox/issues/1690)) ([1afaf6c](https://github.com/bpg/terraform-provider-proxmox/commit/1afaf6cc440586c404ebaff83abe841182024cd3))
* **deps:** update golang.org/x/exp digest (b2144cd ‚Üí 7d7fa50) ([#1696](https://github.com/bpg/terraform-provider-proxmox/issues/1696)) ([100e8c7](https://github.com/bpg/terraform-provider-proxmox/commit/100e8c7f8bd9de8bb7c64f71075fade3230db1b2))
* **deps:** update module github.com/golangci/golangci-lint (v1.62.2 ‚Üí v1.63.4) in /tools ([#1697](https://github.com/bpg/terraform-provider-proxmox/issues/1697)) ([9257a11](https://github.com/bpg/terraform-provider-proxmox/commit/9257a11336b5cc6d68c837e109ea911e4cdd125d))
* **deps:** update module golang.org/x/net (v0.32.0 ‚Üí v0.33.0) [security] ([#1688](https://github.com/bpg/terraform-provider-proxmox/issues/1688)) ([a637884](https://github.com/bpg/terraform-provider-proxmox/commit/a63788450b68cde1be7ff79d52d719f828f3ec85))
* **docs:** update README.md ([#1698](https://github.com/bpg/terraform-provider-proxmox/issues/1698)) ([b3170c3](https://github.com/bpg/terraform-provider-proxmox/commit/b3170c3751dad52c2466d24da1edeb91564b5454))

## [0.69.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.68.1...v0.69.0) (2024-12-18)


### ‚ö† BREAKING CHANGES

* **vm:** improve `cpu.architecture` handling ([#1683](https://github.com/bpg/terraform-provider-proxmox/issues/1683))

### Bug Fixes

* **vm:** edge case of deleting incomplete VM if `create` fails and provider retries ([#1684](https://github.com/bpg/terraform-provider-proxmox/issues/1684)) ([bf9e243](https://github.com/bpg/terraform-provider-proxmox/commit/bf9e2436d4e0b3c51fe56be8c839de5a692c2ae1))
* **vm:** improve `cpu.architecture` handling ([#1683](https://github.com/bpg/terraform-provider-proxmox/issues/1683)) ([be6f220](https://github.com/bpg/terraform-provider-proxmox/commit/be6f2207797dc12bac1a3f964d1628d6ffbdc66c))
* **vm:** retry `start` if it fails with a transient error ([#1685](https://github.com/bpg/terraform-provider-proxmox/issues/1685)) ([9d2118d](https://github.com/bpg/terraform-provider-proxmox/commit/9d2118d7625f7448c44ecc1d158a608479121ee4))


### Miscellaneous

* **ci:** pin image versions in CI workflows ([#1686](https://github.com/bpg/terraform-provider-proxmox/issues/1686)) ([59c9f1e](https://github.com/bpg/terraform-provider-proxmox/commit/59c9f1e6bea7c4c818c1ad706f3f3aca993c8f46))
* **ci:** update jetbrains/qodana-action action (v2024.2.6 ‚Üí v2024.3.2) ([#1676](https://github.com/bpg/terraform-provider-proxmox/issues/1676)) ([c6e0d94](https://github.com/bpg/terraform-provider-proxmox/commit/c6e0d94798add00b1ad26725a15bba55b9867365))
* **ci:** update jetbrains/qodana-action action (v2024.3.2 ‚Üí v2024.3.3) ([#1687](https://github.com/bpg/terraform-provider-proxmox/issues/1687)) ([943889d](https://github.com/bpg/terraform-provider-proxmox/commit/943889de52d6b706049327662f3806aff470114f))
* **deps:** update golang.org/x/exp digest (1829a12 ‚Üí b2144cd) ([#1682](https://github.com/bpg/terraform-provider-proxmox/issues/1682)) ([1069543](https://github.com/bpg/terraform-provider-proxmox/commit/1069543ac5f704e970e50ffa01e4557e0bba0632))
* **deps:** update golang.org/x/exp digest (43b7b7c ‚Üí 1829a12) ([#1675](https://github.com/bpg/terraform-provider-proxmox/issues/1675)) ([3ac0c57](https://github.com/bpg/terraform-provider-proxmox/commit/3ac0c57bae98239bd87358308dc742488b4a2ec4))
* **deps:** update module github.com/hashicorp/terraform-plugin-framework-validators (v0.15.0 ‚Üí v0.16.0) ([#1678](https://github.com/bpg/terraform-provider-proxmox/issues/1678)) ([84fbdce](https://github.com/bpg/terraform-provider-proxmox/commit/84fbdceb248ab63b3eb6e3afe1dcb49640cc2664))
* **deps:** update module golang.org/x/crypto (v0.30.0 ‚Üí v0.31.0) [security] ([#1673](https://github.com/bpg/terraform-provider-proxmox/issues/1673)) ([476a6b8](https://github.com/bpg/terraform-provider-proxmox/commit/476a6b8c9baf438838b50878c154b7d9fea7038a))

## [0.68.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.68.0...v0.68.1) (2024-12-07)


### Bug Fixes

* **vm:** `timeout_create` / `timeout_clone` does not always apply ([#1671](https://github.com/bpg/terraform-provider-proxmox/issues/1671)) ([a57bd7e](https://github.com/bpg/terraform-provider-proxmox/commit/a57bd7e14cfb9d096eabae9b5a525be708bb658b))
* **vm:** add validation for `node_name` values ([#1659](https://github.com/bpg/terraform-provider-proxmox/issues/1659)) ([106bcd2](https://github.com/bpg/terraform-provider-proxmox/commit/106bcd2ff9c92edaf0b33c12f209bddfc84a28c8))


### Miscellaneous

* **deps:** update github.com/hashicorp/go-cty digest (8598007 ‚Üí a0325cb) ([#1661](https://github.com/bpg/terraform-provider-proxmox/issues/1661)) ([c865896](https://github.com/bpg/terraform-provider-proxmox/commit/c8658967e8b4fa196ff34315ff6fe4f9a91f3566))
* **deps:** update golang.org/x/exp digest (2d47ceb ‚Üí 43b7b7c) ([#1667](https://github.com/bpg/terraform-provider-proxmox/issues/1667)) ([4490fe8](https://github.com/bpg/terraform-provider-proxmox/commit/4490fe8b286c6b19d3b27c50ae079288692a40bd))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.20.0 ‚Üí v0.20.1) in /tools ([#1662](https://github.com/bpg/terraform-provider-proxmox/issues/1662)) ([3a9764e](https://github.com/bpg/terraform-provider-proxmox/commit/3a9764e85ffb8c8e7d2a71c4ec2f25e52db5fe57))
* **deps:** update module golang.org/x/crypto (v0.29.0 ‚Üí v0.30.0) ([#1668](https://github.com/bpg/terraform-provider-proxmox/issues/1668)) ([b97df0b](https://github.com/bpg/terraform-provider-proxmox/commit/b97df0b6361399d6ce3e8c54e87059e360a67579))
* **deps:** update module golang.org/x/net (v0.31.0 ‚Üí v0.32.0) ([#1669](https://github.com/bpg/terraform-provider-proxmox/issues/1669)) ([e56c627](https://github.com/bpg/terraform-provider-proxmox/commit/e56c6275eaef0cb7ad2119f2c04a7e298a48b280))
* **docs:** add examples with VM hostname configuration to cloud-init guide ([#1670](https://github.com/bpg/terraform-provider-proxmox/issues/1670)) ([dc73e0b](https://github.com/bpg/terraform-provider-proxmox/commit/dc73e0ba048bf3762c7816e61af6d859f5ad47f7))
* **docs:** update README.md to PVE 8.3 ([#1663](https://github.com/bpg/terraform-provider-proxmox/issues/1663)) ([00497f3](https://github.com/bpg/terraform-provider-proxmox/commit/00497f3b3527a3c43ea6b5490b55a81935153de5))

## [0.68.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.67.1...v0.68.0) (2024-11-26)


### Features

* **node:** add support for node config API ([#1482](https://github.com/bpg/terraform-provider-proxmox/issues/1482)) ([3e025fd](https://github.com/bpg/terraform-provider-proxmox/commit/3e025fd6c82d7b8d2bc141ce6c029f11b6da9ba3))
* **vm:** add bz2 (bzip2) as a valid download file compression algorithm ([#1655](https://github.com/bpg/terraform-provider-proxmox/issues/1655)) ([e29dc53](https://github.com/bpg/terraform-provider-proxmox/commit/e29dc5364fa3d8de65010ffa321e3b44e79bd818))


### Bug Fixes

* **vm:** add retries to VM `update` operation ([#1650](https://github.com/bpg/terraform-provider-proxmox/issues/1650)) ([d92710d](https://github.com/bpg/terraform-provider-proxmox/commit/d92710d0b5c54a816fc06785553c13af8a13131c))


### Miscellaneous

* **ci:** remove mergify config ([#1652](https://github.com/bpg/terraform-provider-proxmox/issues/1652)) ([45eede7](https://github.com/bpg/terraform-provider-proxmox/commit/45eede724b70fedea6d4dd32f66409324e36930d))
* **ci:** update qodana config ([#1653](https://github.com/bpg/terraform-provider-proxmox/issues/1653)) ([6dad660](https://github.com/bpg/terraform-provider-proxmox/commit/6dad6601370c15f3a2c5c39ac6acd28fd7a2be80))
* **deps:** update module github.com/golangci/golangci-lint (v1.62.0 ‚Üí v1.62.2) in /tools ([#1657](https://github.com/bpg/terraform-provider-proxmox/issues/1657)) ([826b406](https://github.com/bpg/terraform-provider-proxmox/commit/826b406d89160c44e66ed0cbddd874388bab51d3))
* **deps:** update module github.com/stretchr/testify (v1.9.0 ‚Üí v1.10.0) ([#1654](https://github.com/bpg/terraform-provider-proxmox/issues/1654)) ([7967299](https://github.com/bpg/terraform-provider-proxmox/commit/796729935ce8ff2ef97a2562f464113a446e6946))

## [0.67.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.67.0...v0.67.1) (2024-11-21)


### Bug Fixes

* **provider:** "context deadline exceeded" error when retrieving the next available VM identifier ([#1647](https://github.com/bpg/terraform-provider-proxmox/issues/1647)) ([2385975](https://github.com/bpg/terraform-provider-proxmox/commit/23859750b105b7793a15116bb6e63f4dcf94187c))

## [0.67.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.66.3...v0.67.0) (2024-11-20)


### Features

* **provider:** better error logging when provider can't generate a VM/Container ID ([#1645](https://github.com/bpg/terraform-provider-proxmox/issues/1645)) ([071cad4](https://github.com/bpg/terraform-provider-proxmox/commit/071cad4df2573d07d2c7cb4216cb2b33a0c98242))
* **vm:** add CPU type support for EPYC-v4 ([#1611](https://github.com/bpg/terraform-provider-proxmox/issues/1611)) ([8b51e99](https://github.com/bpg/terraform-provider-proxmox/commit/8b51e9991efefc404eb9fb7f0d1bc9fd1c1ce010))


### Bug Fixes

* **cluster:** `insecure` `migration_type` validation ([#1607](https://github.com/bpg/terraform-provider-proxmox/issues/1607)) ([0ba36e4](https://github.com/bpg/terraform-provider-proxmox/commit/0ba36e48da8e07ad95b776fc8a9e0fe65430bd83))


### Miscellaneous

* **ci:** remove semgrep workflow ([#1644](https://github.com/bpg/terraform-provider-proxmox/issues/1644)) ([e1e55f9](https://github.com/bpg/terraform-provider-proxmox/commit/e1e55f9b3b6608d43b27833afb8b8567bc1e702f))
* **ci:** update crazy-max/ghaction-import-gpg action (v6.1.0 ‚Üí v6.2.0) ([#1613](https://github.com/bpg/terraform-provider-proxmox/issues/1613)) ([21dd8ee](https://github.com/bpg/terraform-provider-proxmox/commit/21dd8ee708ba7010cab389de1cb3530e7dc22d75))
* **ci:** update goreleaser/goreleaser-action action (v6.0.0 ‚Üí v6.1.0) ([#1627](https://github.com/bpg/terraform-provider-proxmox/issues/1627)) ([93c391c](https://github.com/bpg/terraform-provider-proxmox/commit/93c391cf0d7d4b40e91a31a53086b13e9b0ab644))
* **ci:** update jetbrains/qodana-action action (v2024.2.5 ‚Üí v2024.2.6) ([#1612](https://github.com/bpg/terraform-provider-proxmox/issues/1612)) ([46ab49c](https://github.com/bpg/terraform-provider-proxmox/commit/46ab49ccaeeebac86c3dc2f0d77be0cacfff2746))
* **ci:** update lycheeverse/lychee-action action (v2.0.2 ‚Üí v2.1.0) ([#1628](https://github.com/bpg/terraform-provider-proxmox/issues/1628)) ([32d6b7d](https://github.com/bpg/terraform-provider-proxmox/commit/32d6b7d80f10f71e707e05df0b65f82c02801d40))
* **config:** migrate config .github/renovate.json5 ([2e27b4a](https://github.com/bpg/terraform-provider-proxmox/commit/2e27b4ad0db143bcedcbc618794176ba40538d77))
* **config:** migrate renovate config ([#1632](https://github.com/bpg/terraform-provider-proxmox/issues/1632)) ([2e27b4a](https://github.com/bpg/terraform-provider-proxmox/commit/2e27b4ad0db143bcedcbc618794176ba40538d77))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1614](https://github.com/bpg/terraform-provider-proxmox/issues/1614)) ([be6b660](https://github.com/bpg/terraform-provider-proxmox/commit/be6b660495f68b5af293eeb491b9abd87408f9d5))
* **deps:** update golang.org/x/exp digest (f66d83c ‚Üí 2d47ceb) ([#1626](https://github.com/bpg/terraform-provider-proxmox/issues/1626)) ([eeefa36](https://github.com/bpg/terraform-provider-proxmox/commit/eeefa36680fcb6250f238df457856d3f35c044a8))
* **deps:** update module github.com/brianvoe/gofakeit/v7 (v7.0.4 ‚Üí v7.1.2) ([#1606](https://github.com/bpg/terraform-provider-proxmox/issues/1606)) ([c0048db](https://github.com/bpg/terraform-provider-proxmox/commit/c0048db58a2bd0f2b0e13edbeb9f8186fa51e642))
* **deps:** update module github.com/golangci/golangci-lint (v1.61.0 ‚Üí v1.62.0) in /tools ([#1634](https://github.com/bpg/terraform-provider-proxmox/issues/1634)) ([e67a8f7](https://github.com/bpg/terraform-provider-proxmox/commit/e67a8f783d261991ceb1c105e542ee725578ccb8))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.19.4 ‚Üí v0.20.0) in /tools ([#1629](https://github.com/bpg/terraform-provider-proxmox/issues/1629)) ([5aaf61e](https://github.com/bpg/terraform-provider-proxmox/commit/5aaf61ed9a932e68c0f7c07fb41fea12cbbd095e))
* **deps:** update module github.com/hashicorp/terraform-plugin-sdk/v2 (v2.34.0 ‚Üí v2.35.0) ([#1615](https://github.com/bpg/terraform-provider-proxmox/issues/1615)) ([fea548c](https://github.com/bpg/terraform-provider-proxmox/commit/fea548c1e974458cea1e9734053eb1bc1e55def9))
* **deps:** update module github.com/hashicorp/terraform-plugin-testing (v1.10.0 ‚Üí v1.11.0) ([#1643](https://github.com/bpg/terraform-provider-proxmox/issues/1643)) ([8c17e81](https://github.com/bpg/terraform-provider-proxmox/commit/8c17e81476b71e4785a68656283fbe6de5de87c4))
* **docs:** clarify use of `dump` content type in`proxmox_virtual_environment_file` resource ([#1635](https://github.com/bpg/terraform-provider-proxmox/issues/1635)) ([ca22717](https://github.com/bpg/terraform-provider-proxmox/commit/ca227179a60f9d593792fe09dd35e95c84c4709e))

## [0.66.3](https://github.com/bpg/terraform-provider-proxmox/compare/v0.66.2...v0.66.3) (2024-10-25)


### Bug Fixes

* **tests:** add missing example.tfrc to test api-authentication folder ([#1596](https://github.com/bpg/terraform-provider-proxmox/issues/1596)) ([1e57684](https://github.com/bpg/terraform-provider-proxmox/commit/1e57684029a1052c58967fdba08be69f1d284047))
* **vm:** incorrect detection of disk resize ([#1602](https://github.com/bpg/terraform-provider-proxmox/issues/1602)) ([2781d75](https://github.com/bpg/terraform-provider-proxmox/commit/2781d7525aa87801f652559318c66689b5ccc945))


### Miscellaneous

* **ci:** update actions/checkout action (v4.2.1 ‚Üí v4.2.2) ([#1603](https://github.com/bpg/terraform-provider-proxmox/issues/1603)) ([547b314](https://github.com/bpg/terraform-provider-proxmox/commit/547b3148f74af916155267e3677c9bccff5d686f))
* **ci:** update jetbrains/qodana-action action (v2024.2.3 ‚Üí v2024.2.5) ([#1604](https://github.com/bpg/terraform-provider-proxmox/issues/1604)) ([c4a6190](https://github.com/bpg/terraform-provider-proxmox/commit/c4a6190a302d78251f28c028cee02a79f22272ed))
* **ci:** update lycheeverse/lychee-action action (v2.0.1 ‚Üí v2.0.2) ([#1595](https://github.com/bpg/terraform-provider-proxmox/issues/1595)) ([18fc8d4](https://github.com/bpg/terraform-provider-proxmox/commit/18fc8d418bc46c42407b3d83d65e7c362e1bc7e7))
* **deps:** update module github.com/hashicorp/terraform-plugin-framework-validators (v0.13.0 ‚Üí v0.14.0) ([#1598](https://github.com/bpg/terraform-provider-proxmox/issues/1598)) ([7a26cfe](https://github.com/bpg/terraform-provider-proxmox/commit/7a26cfe53c8281de30e4f4244f4e57a20c1935d6))
* **deps:** update module github.com/pkg/sftp (v1.13.6 ‚Üí v1.13.7) ([#1605](https://github.com/bpg/terraform-provider-proxmox/issues/1605)) ([0453e71](https://github.com/bpg/terraform-provider-proxmox/commit/0453e71f701ba3d0f4c68e20a22f2a42bb4b154f))
* **tests:** add script to test/view api-authentication successes/failures ([#1562](https://github.com/bpg/terraform-provider-proxmox/issues/1562)) ([bce2ceb](https://github.com/bpg/terraform-provider-proxmox/commit/bce2ceb5224a27c0deb5536a176c575dda69ca63))

## [0.66.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.66.1...v0.66.2) (2024-10-12)


### Bug Fixes

* **docs:** typo in cloud-image.md guide, exiting -&gt; existing ([#1584](https://github.com/bpg/terraform-provider-proxmox/issues/1584)) ([af7b0e7](https://github.com/bpg/terraform-provider-proxmox/commit/af7b0e71303a27e22e94e5d854d1b4d83ba4ff34))
* **docs:** update README.md ([#1578](https://github.com/bpg/terraform-provider-proxmox/issues/1578)) ([51d0338](https://github.com/bpg/terraform-provider-proxmox/commit/51d0338bbaec723ef103b256ae82a54f68a0149d))
* **vm:** do not reboot at disk resize ([#1580](https://github.com/bpg/terraform-provider-proxmox/issues/1580)) ([90c50fc](https://github.com/bpg/terraform-provider-proxmox/commit/90c50fcb471c66448652f089039ed8cef9a3bbc7))


### Miscellaneous

* **ci:** update actions/checkout action (v4.2.0 ‚Üí v4.2.1) ([#1581](https://github.com/bpg/terraform-provider-proxmox/issues/1581)) ([95f00ef](https://github.com/bpg/terraform-provider-proxmox/commit/95f00ef1e2f0717803b5d4bb3bf6993faa3af80f))
* **ci:** Update lycheeverse/lychee-action action (v1.10.0 ‚Üí v2.0.0) ([#1583](https://github.com/bpg/terraform-provider-proxmox/issues/1583)) ([d1d8228](https://github.com/bpg/terraform-provider-proxmox/commit/d1d8228d6a85f99e08d0cfeec8111794f37bb922))
* **ci:** update lycheeverse/lychee-action action (v2.0.0 ‚Üí v2.0.1) ([#1590](https://github.com/bpg/terraform-provider-proxmox/issues/1590)) ([dcb8b60](https://github.com/bpg/terraform-provider-proxmox/commit/dcb8b60ca72c6562e0436cec6f974fcd525dfc76))
* **deps:** update golang.org/x/exp digest (225e2ab ‚Üí f66d83c) ([#1586](https://github.com/bpg/terraform-provider-proxmox/issues/1586)) ([e103029](https://github.com/bpg/terraform-provider-proxmox/commit/e1030294ae3d882812b7e111b585a36c3e1f4125))

## [0.66.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.66.0...v0.66.1) (2024-10-05)


### Bug Fixes

* **docs:** typo in container guide ([#1566](https://github.com/bpg/terraform-provider-proxmox/issues/1566)) ([77634cb](https://github.com/bpg/terraform-provider-proxmox/commit/77634cbd5978124b0c9a3979d47a91938a2d1479))
* **provider:** sequentially generated `vm_id`s may clash with exiting VM / Container IDs ([#1574](https://github.com/bpg/terraform-provider-proxmox/issues/1574)) ([e838c6b](https://github.com/bpg/terraform-provider-proxmox/commit/e838c6b645f3bc70728d58384fb22a5ad1829ee4))


### Miscellaneous

* **deps:** update golang.org/x/exp digest (701f63a ‚Üí 225e2ab) ([#1570](https://github.com/bpg/terraform-provider-proxmox/issues/1570)) ([65f35f3](https://github.com/bpg/terraform-provider-proxmox/commit/65f35f31c136b0e978c97d51d2f9f355aa46c652))
* **deps:** update module golang.org/x/net (v0.29.0 ‚Üí v0.30.0) ([#1572](https://github.com/bpg/terraform-provider-proxmox/issues/1572)) ([4379fca](https://github.com/bpg/terraform-provider-proxmox/commit/4379fcafa9d1063ae90f25e28fba78d73f6359e2))

## [0.66.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.65.0...v0.66.0) (2024-10-04)


### Features

* **provider:** add support for pre(external) auth'd session tokens ([#1441](https://github.com/bpg/terraform-provider-proxmox/issues/1441)) ([eb2f36b](https://github.com/bpg/terraform-provider-proxmox/commit/eb2f36be21bc8a74bbd7e74bc7a7f3f6ed2d8daf))
* **provider:** reliable sequential and random `vm_id` generation ([#1557](https://github.com/bpg/terraform-provider-proxmox/issues/1557)) ([72f7cb8](https://github.com/bpg/terraform-provider-proxmox/commit/72f7cb81a8bbe0fcd9aa739073db6e552820a7de))
* **vm:** add support for `watchdog` ([#1556](https://github.com/bpg/terraform-provider-proxmox/issues/1556)) ([d226b59](https://github.com/bpg/terraform-provider-proxmox/commit/d226b59e2e37ffebc737e27cc9bb0182d4bda993))


### Bug Fixes

* **docs:** correct url for template download in container resource example ([#1563](https://github.com/bpg/terraform-provider-proxmox/issues/1563)) ([7266583](https://github.com/bpg/terraform-provider-proxmox/commit/72665830be975f0671c6aecca47fc52906cb21e2))
* **lxc:** add new storage-backed mount point to existing container ([#1553](https://github.com/bpg/terraform-provider-proxmox/issues/1553)) ([89d72cd](https://github.com/bpg/terraform-provider-proxmox/commit/89d72cd37f63fd6238dbb09709ce90020e42e18a))
* **provider:** handle IPv6 in ssh client ([#1558](https://github.com/bpg/terraform-provider-proxmox/issues/1558)) ([18a7f8e](https://github.com/bpg/terraform-provider-proxmox/commit/18a7f8ec358a158ccc4f927e0c07b5eab77b01dd))


### Miscellaneous

* **ci:** update actions/checkout action (v4.1.7 ‚Üí v4.2.0) ([#1555](https://github.com/bpg/terraform-provider-proxmox/issues/1555)) ([471c5f2](https://github.com/bpg/terraform-provider-proxmox/commit/471c5f23bb67323abab77e57a359e07050ac536c))
* **ci:** update peter-evans/create-issue-from-file action (v5.0.0 ‚Üí v5.0.1) ([#1554](https://github.com/bpg/terraform-provider-proxmox/issues/1554)) ([049362a](https://github.com/bpg/terraform-provider-proxmox/commit/049362a94e585c17359a61ad410ad0c20b207d62))
* **docs:** document specifics of "ballooning device" in the `vm.memory` block ([#1550](https://github.com/bpg/terraform-provider-proxmox/issues/1550)) ([0b29ae2](https://github.com/bpg/terraform-provider-proxmox/commit/0b29ae281ed5075aa1349fbe262176d8f8791dfc))

## [0.65.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.64.0...v0.65.0) (2024-09-21)


### Features

* **vm:** remove deprecated `vga.enabled` ([#1533](https://github.com/bpg/terraform-provider-proxmox/issues/1533)) ([f4ee629](https://github.com/bpg/terraform-provider-proxmox/commit/f4ee6291ccd42ef6c6c7d0e8d6780f68a46ac218))


### Bug Fixes

* **file:** respect `download_file.override` attr when checking for the file size change ([#1537](https://github.com/bpg/terraform-provider-proxmox/issues/1537)) ([44e2814](https://github.com/bpg/terraform-provider-proxmox/commit/44e2814adf69588e219c522fa415fa38cef9dc3a))
* **vm:** handle more than 4 `hostpci` devices ([#1543](https://github.com/bpg/terraform-provider-proxmox/issues/1543)) ([569db6d](https://github.com/bpg/terraform-provider-proxmox/commit/569db6df3bcacd86d0c1dab77512ca73d7b04560))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.10.4 ‚Üí v1.11.0) ([#1532](https://github.com/bpg/terraform-provider-proxmox/issues/1532)) ([831207b](https://github.com/bpg/terraform-provider-proxmox/commit/831207b0e30ed0b91ec612681c130fb412210e61))
* **ci:** update jetbrains/qodana-action action (v2024.1.9 ‚Üí v2024.2.3) ([#1544](https://github.com/bpg/terraform-provider-proxmox/issues/1544)) ([13ceab8](https://github.com/bpg/terraform-provider-proxmox/commit/13ceab820501933c5b3b5d24aae1e9db69b2816b))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1545](https://github.com/bpg/terraform-provider-proxmox/issues/1545)) ([b5a4e32](https://github.com/bpg/terraform-provider-proxmox/commit/b5a4e32d7a9b7dc0328e114b60eaf42875d4fab6))
* **deps:** update golang.org/x/exp digest (e7e105d ‚Üí 701f63a) ([#1526](https://github.com/bpg/terraform-provider-proxmox/issues/1526)) ([b96532f](https://github.com/bpg/terraform-provider-proxmox/commit/b96532f884af73b562199d3b049b4ee4251fbf78))
* **deps:** update module github.com/golangci/golangci-lint (v1.60.3 ‚Üí v1.61.0) in /tools ([#1527](https://github.com/bpg/terraform-provider-proxmox/issues/1527)) ([356c978](https://github.com/bpg/terraform-provider-proxmox/commit/356c978ece6c60e3b130d753f9bcd644d8507fce))
* **docs:** add example for host disk pass-through to VM ([#1547](https://github.com/bpg/terraform-provider-proxmox/issues/1547)) ([e23d2f3](https://github.com/bpg/terraform-provider-proxmox/commit/e23d2f375cb72a1e8a7f67490cbcbe1a3ea5d86f))
* **docs:** improve `network_linux_bridge` documentation ([#1538](https://github.com/bpg/terraform-provider-proxmox/issues/1538)) ([8f9b036](https://github.com/bpg/terraform-provider-proxmox/commit/8f9b03685791088353b7ac0872130ebc7c832626))
* **docs:** update terraform local (2.5.1 ‚Üí 2.5.2) ([#1535](https://github.com/bpg/terraform-provider-proxmox/issues/1535)) ([f1ce62e](https://github.com/bpg/terraform-provider-proxmox/commit/f1ce62eeeb26d37ae1be2580869cd5baa95741be))
* **docs:** update terraform tls (4.0.5 ‚Üí 4.0.6) ([#1536](https://github.com/bpg/terraform-provider-proxmox/issues/1536)) ([a89cfbf](https://github.com/bpg/terraform-provider-proxmox/commit/a89cfbf045f2bddde3ac0d769686434467bb61d6))
* **lxc:** update list of supported OS-es in `operating_system.type` ([#1548](https://github.com/bpg/terraform-provider-proxmox/issues/1548)) ([14a62a7](https://github.com/bpg/terraform-provider-proxmox/commit/14a62a712ae4109bc5345b6e09248bd5e68002b5))

## [0.64.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.63.0...v0.64.0) (2024-09-08)


### Features

* **acme:** implement resources and data sources for ACME plugins ([#1479](https://github.com/bpg/terraform-provider-proxmox/issues/1479)) ([a6eb81a](https://github.com/bpg/terraform-provider-proxmox/commit/a6eb81af08f175ab078ae0369e0246425e77de6a))
* **lxc:** Implement support for container's "protection flag" ([#1512](https://github.com/bpg/terraform-provider-proxmox/issues/1512)) ([9b34c48](https://github.com/bpg/terraform-provider-proxmox/commit/9b34c485ab6ee8e29e8df2269d7789820a980558))


### Bug Fixes

* **docs:** improve "SSH User" section describing `sudo` privileges ([#1522](https://github.com/bpg/terraform-provider-proxmox/issues/1522)) ([84d55cf](https://github.com/bpg/terraform-provider-proxmox/commit/84d55cf5690df0d7a5231e2d664f5fec38064df8))
* **vm:** `cpu.architecture` showed as new attribute at re-apply after creation ([#1524](https://github.com/bpg/terraform-provider-proxmox/issues/1524)) ([c20d79d](https://github.com/bpg/terraform-provider-proxmox/commit/c20d79dfbe34b4f161d49a6c9b595354444bacd9))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.10.3 ‚Üí v1.10.4) ([#1518](https://github.com/bpg/terraform-provider-proxmox/issues/1518)) ([112f058](https://github.com/bpg/terraform-provider-proxmox/commit/112f058e66a5bb410696d1d40b11e7216ab3986e))
* **deps:** update golang.org/x/exp digest (0cdaa3a ‚Üí 9b4947d) ([#1506](https://github.com/bpg/terraform-provider-proxmox/issues/1506)) ([0623bfd](https://github.com/bpg/terraform-provider-proxmox/commit/0623bfd1561a7a30771685d8fa3f46c9bfb4d1d8))
* **deps:** update golang.org/x/exp digest (9b4947d ‚Üí e7e105d) ([#1517](https://github.com/bpg/terraform-provider-proxmox/issues/1517)) ([273b3c9](https://github.com/bpg/terraform-provider-proxmox/commit/273b3c93b3ffafa448076ca07f6d53066844f164))
* **deps:** update module github.com/golangci/golangci-lint (v1.60.1 ‚Üí v1.60.2) in /tools ([#1499](https://github.com/bpg/terraform-provider-proxmox/issues/1499)) ([35cbe98](https://github.com/bpg/terraform-provider-proxmox/commit/35cbe98d6b26b47c0b8797dd6d4f084585f846c7))
* **deps:** update module github.com/golangci/golangci-lint (v1.60.2 ‚Üí v1.60.3) in /tools ([#1507](https://github.com/bpg/terraform-provider-proxmox/issues/1507)) ([5707fea](https://github.com/bpg/terraform-provider-proxmox/commit/5707feab06750a4782e66c0be0e5cc2edd612aa0))
* **deps:** update module go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp (v0.53.0 ‚Üí v0.54.0) in /tools ([#1509](https://github.com/bpg/terraform-provider-proxmox/issues/1509)) ([9172ec6](https://github.com/bpg/terraform-provider-proxmox/commit/9172ec6a9fd01e876e18fa3e8664aee3b639c891))
* **deps:** update module golang.org/x/crypto (v0.26.0 ‚Üí v0.27.0) ([#1519](https://github.com/bpg/terraform-provider-proxmox/issues/1519)) ([3951bda](https://github.com/bpg/terraform-provider-proxmox/commit/3951bdab4a958761e6978ab0dc03857b797bd417))
* **deps:** update module golang.org/x/net (v0.28.0 ‚Üí v0.29.0) ([#1520](https://github.com/bpg/terraform-provider-proxmox/issues/1520)) ([a0bce8d](https://github.com/bpg/terraform-provider-proxmox/commit/a0bce8d699b6d633acb309c55e43e8743afb7122))
* **vm:** add acc test for no cdrom by default ([#1523](https://github.com/bpg/terraform-provider-proxmox/issues/1523)) ([35b6571](https://github.com/bpg/terraform-provider-proxmox/commit/35b6571bf468d09902c899f3e1782db9a13b78a0))

## [0.63.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.62.0...v0.63.0) (2024-08-21)


### Features

* **file:** add support to set the file mode ([#1478](https://github.com/bpg/terraform-provider-proxmox/issues/1478)) ([cc9d0e7](https://github.com/bpg/terraform-provider-proxmox/commit/cc9d0e713190d736861883f97058c1ec7f0a179d))


### Bug Fixes

* **doc:** update virtual_environment_vm.md ([#1495](https://github.com/bpg/terraform-provider-proxmox/issues/1495)) ([4f8e18d](https://github.com/bpg/terraform-provider-proxmox/commit/4f8e18da04419c0077d53c3eaf90e5d18a8d947f))
* **firewall:** remove limit for number of CIRDs in `ipset` ([#1487](https://github.com/bpg/terraform-provider-proxmox/issues/1487)) ([55bfe14](https://github.com/bpg/terraform-provider-proxmox/commit/55bfe14ce18a432849e544360561d7b9091ac4d8))


### Miscellaneous

* **ci:** update hashicorp/setup-terraform action (v3.1.1 ‚Üí v3.1.2) ([#1498](https://github.com/bpg/terraform-provider-proxmox/issues/1498)) ([3f6bc5e](https://github.com/bpg/terraform-provider-proxmox/commit/3f6bc5eba223c789e9b87bf74af6ec8c49bb6b60))
* **ci:** update jetbrains/qodana-action action (v2024.1.8 ‚Üí v2024.1.9) ([#1484](https://github.com/bpg/terraform-provider-proxmox/issues/1484)) ([dd6d5ec](https://github.com/bpg/terraform-provider-proxmox/commit/dd6d5ec88ffefc41cf68aeac6260915a05450463))
* **code:** align resource/datasource names in the fwprovider code ([#1488](https://github.com/bpg/terraform-provider-proxmox/issues/1488)) ([8f82d1a](https://github.com/bpg/terraform-provider-proxmox/commit/8f82d1a3848571f09aea400960b252d4b6c39fb1))
* **deps:** update go (1.22.6 ‚Üí 1.23.0) ([#1489](https://github.com/bpg/terraform-provider-proxmox/issues/1489)) ([3343a93](https://github.com/bpg/terraform-provider-proxmox/commit/3343a938409adc2d61658e7d2c2a52b452c50d48))
* **deps:** update golang.org/x/exp digest (8a7402a ‚Üí 0cdaa3a) ([#1483](https://github.com/bpg/terraform-provider-proxmox/issues/1483)) ([e566c4e](https://github.com/bpg/terraform-provider-proxmox/commit/e566c4e35e6680c2d24cbc42fb78aa1e753f1dd1))
* **deps:** update module github.com/hashicorp/terraform-plugin-testing (v1.9.0 ‚Üí v1.10.0) ([#1485](https://github.com/bpg/terraform-provider-proxmox/issues/1485)) ([767f680](https://github.com/bpg/terraform-provider-proxmox/commit/767f680cc3428484a6c5fe15c22c6ab7acf1dce8))
* **deps:** update tools ([#1490](https://github.com/bpg/terraform-provider-proxmox/issues/1490)) ([6635c89](https://github.com/bpg/terraform-provider-proxmox/commit/6635c89f632f61041382ea08344380f777ee54ba))
* **devcontainer:** configure provider override in post attach command ([#1481](https://github.com/bpg/terraform-provider-proxmox/issues/1481)) ([daaedf2](https://github.com/bpg/terraform-provider-proxmox/commit/daaedf2d99ee56a1873aeb6da4af94eb06fc7d5f))
* **example:** update links to container images, use faster mirror ([#1497](https://github.com/bpg/terraform-provider-proxmox/issues/1497)) ([abb0be4](https://github.com/bpg/terraform-provider-proxmox/commit/abb0be4684fa21dd5e7b600f238348c509b6c9af))

## [0.62.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.61.1...v0.62.0) (2024-08-08)


### Features

* **acme:** implement resources and data sources for ACME accounts ([#1455](https://github.com/bpg/terraform-provider-proxmox/issues/1455)) ([9de4037](https://github.com/bpg/terraform-provider-proxmox/commit/9de4037a8222fbf9d524df989d0b670c0ae13771))


### Bug Fixes

* **docs:** document role privileges required by `proxmox_virtual_environment_download_file` ([#1442](https://github.com/bpg/terraform-provider-proxmox/issues/1442)) ([2475d99](https://github.com/bpg/terraform-provider-proxmox/commit/2475d99317bbef3f4a2372ed1377c64590ad5df8))
* **storage:** ignore `os.ErrClosed` from deferred `fileReader.Close()` in storage.APIUpload ([#1468](https://github.com/bpg/terraform-provider-proxmox/issues/1468)) ([e8bd1fc](https://github.com/bpg/terraform-provider-proxmox/commit/e8bd1fcda7c60de485714af6ab788f6e6a99d28f))
* **tools:** ensure docs/guides files are copied correctly ([#1464](https://github.com/bpg/terraform-provider-proxmox/issues/1464)) ([f7c3560](https://github.com/bpg/terraform-provider-proxmox/commit/f7c35602608a7cfcdebceadd725ebae02c9b6cf6))


### Miscellaneous

* **deps:** update go (1.22.5 ‚Üí 1.22.6) ([#1469](https://github.com/bpg/terraform-provider-proxmox/issues/1469)) ([966ea7a](https://github.com/bpg/terraform-provider-proxmox/commit/966ea7aa40e89990177ead67598a642bce355b27))
* **deps:** update go (1.22.5 ‚Üí 1.22.6) in /tools ([#1470](https://github.com/bpg/terraform-provider-proxmox/issues/1470)) ([10b2340](https://github.com/bpg/terraform-provider-proxmox/commit/10b2340c5b820260ffd3efdb930f830783aea330))
* **deps:** update golang.org/x/exp digest (46b0784 ‚Üí e3f2596) ([#1448](https://github.com/bpg/terraform-provider-proxmox/issues/1448)) ([1ba422a](https://github.com/bpg/terraform-provider-proxmox/commit/1ba422a68ef86ef8903aafd0030a4dcdb76023e1))
* **deps:** update golang.org/x/exp digest (e3f2596 ‚Üí 8a7402a) ([#1452](https://github.com/bpg/terraform-provider-proxmox/issues/1452)) ([76ce03f](https://github.com/bpg/terraform-provider-proxmox/commit/76ce03f6142f5811400ba3f3724a9a35decbefc3))
* **deps:** update module github.com/hashicorp/terraform-plugin-framework (v1.10.0 ‚Üí v1.11.0) ([#1471](https://github.com/bpg/terraform-provider-proxmox/issues/1471)) ([b7a110e](https://github.com/bpg/terraform-provider-proxmox/commit/b7a110e8fbe341f4347f517153ef36da286e1ae8))
* **deps:** update module github.com/skeema/knownhosts (v1.2.2 ‚Üí v1.3.0) ([#1449](https://github.com/bpg/terraform-provider-proxmox/issues/1449)) ([f116127](https://github.com/bpg/terraform-provider-proxmox/commit/f1161276ad4106033a88de0ed99ceb1258817ea7))
* **deps:** update module golang.org/x/crypto (v0.25.0 ‚Üí v0.26.0) ([#1472](https://github.com/bpg/terraform-provider-proxmox/issues/1472)) ([e641b55](https://github.com/bpg/terraform-provider-proxmox/commit/e641b55734944ebe8b359c158e5ea2ee798f433d))
* **deps:** update module golang.org/x/net (v0.27.0 ‚Üí v0.28.0) ([#1474](https://github.com/bpg/terraform-provider-proxmox/issues/1474)) ([56b98bd](https://github.com/bpg/terraform-provider-proxmox/commit/56b98bd4e698ab26aef773dcd7ec2aa94be9ae35))
* **docs:** minor documentation updates ([#1463](https://github.com/bpg/terraform-provider-proxmox/issues/1463)) ([2bf9a94](https://github.com/bpg/terraform-provider-proxmox/commit/2bf9a9456210b7b0f60f7a5059b3dca108eef7b3))

## [0.61.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.61.0...v0.61.1) (2024-07-11)


### Bug Fixes

* **time:** embed timezone data to fix set/get TZ on windows  ([#1436](https://github.com/bpg/terraform-provider-proxmox/issues/1436)) ([b4d4e4f](https://github.com/bpg/terraform-provider-proxmox/commit/b4d4e4f9d4d1c38a5954e76beb0067f20652da19))
* **vm:** improve reliability of VM create / get operations ([#1431](https://github.com/bpg/terraform-provider-proxmox/issues/1431)) ([d193abd](https://github.com/bpg/terraform-provider-proxmox/commit/d193abd33e8f09aae0dc00d2405297908b21b7d5))
* **vm:** panic when reading VM with SPICE USB passthrough ([#1438](https://github.com/bpg/terraform-provider-proxmox/issues/1438)) ([fc42ac3](https://github.com/bpg/terraform-provider-proxmox/commit/fc42ac3a5e49daf391af21ec7cce7d97ecf8af20))


### Miscellaneous

* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1437](https://github.com/bpg/terraform-provider-proxmox/issues/1437)) ([b63c98b](https://github.com/bpg/terraform-provider-proxmox/commit/b63c98b13f7f4dde06f3fbc873939be9898571f8))
* **deps:** update golang.org/x/exp digest (7f521ea ‚Üí 46b0784) ([#1432](https://github.com/bpg/terraform-provider-proxmox/issues/1432)) ([0a978e5](https://github.com/bpg/terraform-provider-proxmox/commit/0a978e566417156b55a5973b2535a5314db992fd))

## [0.61.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.60.1...v0.61.0) (2024-07-06)


### Features

* **node:** implement initial support to manage APT repositories ([#1325](https://github.com/bpg/terraform-provider-proxmox/issues/1325)) ([357f7c7](https://github.com/bpg/terraform-provider-proxmox/commit/357f7c70a701c42dda62e0adef1337d319aaed04))
* **vm:** implement filtering in vms data source. ([#1423](https://github.com/bpg/terraform-provider-proxmox/issues/1423)) ([65f8ba5](https://github.com/bpg/terraform-provider-proxmox/commit/65f8ba5bfe3a8ca3872fd87830b1a858f24a7237))


### Bug Fixes

* **repo:** fix source.list path validation on Windows ([#1429](https://github.com/bpg/terraform-provider-proxmox/issues/1429)) ([6103e67](https://github.com/bpg/terraform-provider-proxmox/commit/6103e67ae97434991e1d85d368dbea738f6c8041))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.10.1 ‚Üí v1.10.2) ([#1416](https://github.com/bpg/terraform-provider-proxmox/issues/1416)) ([692ea94](https://github.com/bpg/terraform-provider-proxmox/commit/692ea944c34d85ec54d40c8b1d5f15ed887f42d9))
* **ci:** update actions/create-github-app-token action (v1.10.2 ‚Üí v1.10.3) ([#1419](https://github.com/bpg/terraform-provider-proxmox/issues/1419)) ([877251c](https://github.com/bpg/terraform-provider-proxmox/commit/877251c86eaa01aa1cce3f69afeb0e0214e87486))
* **ci:** update jetbrains/qodana-action action (v2024.1.5 ‚Üí v2024.1.8) ([#1425](https://github.com/bpg/terraform-provider-proxmox/issues/1425)) ([91a16af](https://github.com/bpg/terraform-provider-proxmox/commit/91a16af747332215b9bfccc58cccb13a478222b2))
* **deps:** update go (1.22.4 ‚Üí 1.22.5) ([#1420](https://github.com/bpg/terraform-provider-proxmox/issues/1420)) ([a521c60](https://github.com/bpg/terraform-provider-proxmox/commit/a521c60f0c7e9b36eac94ac78c9cfac83856e294))
* **deps:** update go (1.22.4 ‚Üí 1.22.5) in /tools ([#1421](https://github.com/bpg/terraform-provider-proxmox/issues/1421)) ([d55f670](https://github.com/bpg/terraform-provider-proxmox/commit/d55f6706a49232869efd7319a6d3fda14e9e9372))
* **deps:** update module go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp (v0.52.0 ‚Üí v0.53.0) in /tools ([#1426](https://github.com/bpg/terraform-provider-proxmox/issues/1426)) ([cf1142e](https://github.com/bpg/terraform-provider-proxmox/commit/cf1142e24b4c308637bfa481107f82d149a3b585))
* **deps:** update module golang.org/x/crypto (v0.24.0 ‚Üí v0.25.0) ([#1427](https://github.com/bpg/terraform-provider-proxmox/issues/1427)) ([3ad5b0a](https://github.com/bpg/terraform-provider-proxmox/commit/3ad5b0a9e10ff8d6a5e707dd2dfb2a9f0d70bd4b))
* **deps:** update module golang.org/x/net (v0.26.0 ‚Üí v0.27.0) ([#1430](https://github.com/bpg/terraform-provider-proxmox/issues/1430)) ([6436967](https://github.com/bpg/terraform-provider-proxmox/commit/6436967903970e7cdece9f85bbddc00afa9ce8f9))

## [0.60.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.60.0...v0.60.1) (2024-06-25)


### Bug Fixes

* **docs:** Mention alternate valid use of Volid's for containers ([#1407](https://github.com/bpg/terraform-provider-proxmox/issues/1407)) ([763654a](https://github.com/bpg/terraform-provider-proxmox/commit/763654ac8f88787de7c4d64e18aaf33e82990719))
* **lxc:** use default rootfs size (4Gb) prevents creation of mount points ([#1398](https://github.com/bpg/terraform-provider-proxmox/issues/1398)) ([4a8bf8d](https://github.com/bpg/terraform-provider-proxmox/commit/4a8bf8da27295d6fcca4be8cae05aedfe48d7cf3))


### Miscellaneous

* **code:** fix code quality warnings ([#1409](https://github.com/bpg/terraform-provider-proxmox/issues/1409)) ([4f70459](https://github.com/bpg/terraform-provider-proxmox/commit/4f70459c264e1d9d3e6541fa7276d5de57fa5d46))
* **deps:** update module github.com/brianvoe/gofakeit/v7 (v7.0.3 ‚Üí v7.0.4) ([#1405](https://github.com/bpg/terraform-provider-proxmox/issues/1405)) ([c926484](https://github.com/bpg/terraform-provider-proxmox/commit/c926484249af93b75c64d2acba3e1460f16f35da))
* refactor container acc test ([#1408](https://github.com/bpg/terraform-provider-proxmox/issues/1408)) ([a0d9300](https://github.com/bpg/terraform-provider-proxmox/commit/a0d9300f0ff1f49b4df08691f4c2286b276f84b5))
* **vm:** fix regression after storage devices refactoring ([#1399](https://github.com/bpg/terraform-provider-proxmox/issues/1399)) ([5d1c8c6](https://github.com/bpg/terraform-provider-proxmox/commit/5d1c8c606d61d91360325228655ccd372848602a))
* **vm:** refactor storage devices handling from/to API ([#1394](https://github.com/bpg/terraform-provider-proxmox/issues/1394)) ([cc7fc63](https://github.com/bpg/terraform-provider-proxmox/commit/cc7fc63ec1c167344191cd2d3496139747e5c112))

## [0.60.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.59.1...v0.60.0) (2024-06-14)


### Features

* **vm:** add support for `disk.serial` attribute  ([#1385](https://github.com/bpg/terraform-provider-proxmox/issues/1385)) ([de34952](https://github.com/bpg/terraform-provider-proxmox/commit/de349523fedac8185468620a7088c55deefdbd79))


### Bug Fixes

* **docs:** add more details about the `usb` block in VM ([#1382](https://github.com/bpg/terraform-provider-proxmox/issues/1382)) ([1eb64a2](https://github.com/bpg/terraform-provider-proxmox/commit/1eb64a25226d6c2ae48ac5cc4c24499e0bbb84cf))
* **docs:** update virtual_environment_vm.md ([#1377](https://github.com/bpg/terraform-provider-proxmox/issues/1377)) ([63f0cbf](https://github.com/bpg/terraform-provider-proxmox/commit/63f0cbfd27387a9d4fd0b5aa853be9a5a52475f2))
* **lxc:** make container vm_id computed ([#1386](https://github.com/bpg/terraform-provider-proxmox/issues/1386)) ([bc079c0](https://github.com/bpg/terraform-provider-proxmox/commit/bc079c0c192d1b3cb99c2b646f639a57cfbff7f6))


### Miscellaneous

* **ci:** update actions/checkout action (v4.1.6 ‚Üí v4.1.7) ([#1390](https://github.com/bpg/terraform-provider-proxmox/issues/1390)) ([fbf41dd](https://github.com/bpg/terraform-provider-proxmox/commit/fbf41dde93ff344950e4b879102b0070406bb227))
* **ci:** update googleapis/release-please-action action (v4.1.1 ‚Üí v4.1.3) ([#1380](https://github.com/bpg/terraform-provider-proxmox/issues/1380)) ([77f62e1](https://github.com/bpg/terraform-provider-proxmox/commit/77f62e1500e7d8468a4dcf60fba3bda907d5c7d9))
* **code:** remove goreleaser from `/tools` ([#1384](https://github.com/bpg/terraform-provider-proxmox/issues/1384)) ([cfe1b1c](https://github.com/bpg/terraform-provider-proxmox/commit/cfe1b1cc4b151a7ab5fee7a051429ecf57b497d6))
* **deps:** update golang.org/x/exp digest (fc45aab ‚Üí 7f521ea) ([#1391](https://github.com/bpg/terraform-provider-proxmox/issues/1391)) ([f22858c](https://github.com/bpg/terraform-provider-proxmox/commit/f22858ce4e311395f3127da4dd22d45c533caa2e))
* **deps:** Update module github.com/goreleaser/goreleaser (v1.26.2 ‚Üí v2.0.0) in /tools ([#1381](https://github.com/bpg/terraform-provider-proxmox/issues/1381)) ([095be69](https://github.com/bpg/terraform-provider-proxmox/commit/095be69d8d6ad281db0670d4a22d88c860eff0ff))

## [0.59.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.59.0...v0.59.1) (2024-06-10)


### Bug Fixes

* **vm:** ignore 599 task status response when waiting for VM start ([#1365](https://github.com/bpg/terraform-provider-proxmox/issues/1365)) ([5d4193b](https://github.com/bpg/terraform-provider-proxmox/commit/5d4193b6beb2b4b71b9f5be7507d4ddc6ea3b6b7))


### Miscellaneous

* **api:** refactor `nodes/vms/vms_types.go`: split into multiple files ([#1368](https://github.com/bpg/terraform-provider-proxmox/issues/1368)) ([580381f](https://github.com/bpg/terraform-provider-proxmox/commit/580381f89248f40ad645d8f9208e2223c66d6e4f))
* **code:** fix code inspection warnings ([#1375](https://github.com/bpg/terraform-provider-proxmox/issues/1375)) ([e647b21](https://github.com/bpg/terraform-provider-proxmox/commit/e647b21e3a90d49f0f1300fcaaa9e23312f67b2b))
* **deps:** update module github.com/golangci/golangci-lint (v1.59.0 ‚Üí v1.59.1) in /tools ([#1373](https://github.com/bpg/terraform-provider-proxmox/issues/1373)) ([24f9990](https://github.com/bpg/terraform-provider-proxmox/commit/24f9990249037893312636abdae8f30391cff207))
* **docs:** clarify `disk.file_id` format ([#1374](https://github.com/bpg/terraform-provider-proxmox/issues/1374)) ([f3ac15a](https://github.com/bpg/terraform-provider-proxmox/commit/f3ac15ad12b0638ed421e25b561f1d16f7d3a41d))
* **vm2:** add initial support for `cdrom` ([#1370](https://github.com/bpg/terraform-provider-proxmox/issues/1370)) ([80cafa6](https://github.com/bpg/terraform-provider-proxmox/commit/80cafa689f3795a808dc0c2ecbcf81608181e370))

## [0.59.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.58.1...v0.59.0) (2024-06-05)


### Features

* **vm:** allow `none` `cdrom` ([#1347](https://github.com/bpg/terraform-provider-proxmox/issues/1347)) ([994f367](https://github.com/bpg/terraform-provider-proxmox/commit/994f367cc2bb444a61ecc5b04e1280394aa6b345))


### Bug Fixes

* **access:** fix `user` and `role` import ([#1346](https://github.com/bpg/terraform-provider-proxmox/issues/1346)) ([bdd9225](https://github.com/bpg/terraform-provider-proxmox/commit/bdd9225041d1dbbc834f7df6adc7463bb3c09b9f))
* **lxc,vm:** fix panics when a resource block is empty ([#1345](https://github.com/bpg/terraform-provider-proxmox/issues/1345)) ([9bbbf8d](https://github.com/bpg/terraform-provider-proxmox/commit/9bbbf8db390ed43291126eca2d3fc391b7308acc))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.10.0 ‚Üí v1.10.1) ([#1356](https://github.com/bpg/terraform-provider-proxmox/issues/1356)) ([92476d4](https://github.com/bpg/terraform-provider-proxmox/commit/92476d4f4024c9746c3da987a0d7e210525b14ab))
* **ci:** Update goreleaser/goreleaser-action action (v5.1.0 ‚Üí v6.0.0) ([#1362](https://github.com/bpg/terraform-provider-proxmox/issues/1362)) ([9dbee1a](https://github.com/bpg/terraform-provider-proxmox/commit/9dbee1a12c2435db00fbf2011d45fbeffdb2b15c))
* **deps:** update go (1.22.3 ‚Üí 1.22.4) ([#1357](https://github.com/bpg/terraform-provider-proxmox/issues/1357)) ([ea509b2](https://github.com/bpg/terraform-provider-proxmox/commit/ea509b289ec002a085d500521519c93873eb0f65))
* **deps:** update golang.org/x/exp digest (23cca88 ‚Üí fd00a4e) ([#1343](https://github.com/bpg/terraform-provider-proxmox/issues/1343)) ([eaeff08](https://github.com/bpg/terraform-provider-proxmox/commit/eaeff08571e390cd29f037f00b0c08086e704f70))
* **deps:** update golang.org/x/exp digest (fd00a4e ‚Üí fc45aab) ([#1355](https://github.com/bpg/terraform-provider-proxmox/issues/1355)) ([8fb6410](https://github.com/bpg/terraform-provider-proxmox/commit/8fb64105075e370945c007411b0e74f703e51f4d))
* **deps:** Update module github.com/goreleaser/goreleaser (v1.26.2 ‚Üí v2.0.0) in /tools ([#1363](https://github.com/bpg/terraform-provider-proxmox/issues/1363)) ([7064f12](https://github.com/bpg/terraform-provider-proxmox/commit/7064f1259a7830e493e7a3e07a2dce79eef030fc))
* **deps:** update module github.com/hashicorp/terraform-plugin-framework (v1.8.0 ‚Üí v1.9.0) ([#1359](https://github.com/bpg/terraform-provider-proxmox/issues/1359)) ([27ad93e](https://github.com/bpg/terraform-provider-proxmox/commit/27ad93e793864310d0944591802876efcbfafbc2))
* **deps:** update tools ([#1358](https://github.com/bpg/terraform-provider-proxmox/issues/1358)) ([9c4b9db](https://github.com/bpg/terraform-provider-proxmox/commit/9c4b9dbcbad247d2926d9ee8b6407efc0ab91cb8))

## [0.58.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.58.0...v0.58.1) (2024-05-30)


### Bug Fixes

* **vm:** adding disks causes VM to be re-created ([#1336](https://github.com/bpg/terraform-provider-proxmox/issues/1336)) ([d02dc1e](https://github.com/bpg/terraform-provider-proxmox/commit/d02dc1eb0a524d89a06b4b96b1d36c504ab737fe))
* **vm:** host parameter is optional if using mapping for usb ([#1338](https://github.com/bpg/terraform-provider-proxmox/issues/1338)) ([76d9806](https://github.com/bpg/terraform-provider-proxmox/commit/76d980683c5349ac2376d4f8523df241c5c05e0b))
* **vm:** regression: `vga.clipboard` attribute check ([#1340](https://github.com/bpg/terraform-provider-proxmox/issues/1340)) ([2785c40](https://github.com/bpg/terraform-provider-proxmox/commit/2785c40d44ca950742cbd78e6b720b25bb6e7826))


### Miscellaneous

* **deps:** update golang.org/x/exp digest (4c93da0 ‚Üí 23cca88) ([#1333](https://github.com/bpg/terraform-provider-proxmox/issues/1333)) ([804b498](https://github.com/bpg/terraform-provider-proxmox/commit/804b498453621d308a3d3a4caae168076d494a08))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.19.2 ‚Üí v0.19.3) in /tools ([#1334](https://github.com/bpg/terraform-provider-proxmox/issues/1334)) ([2f87941](https://github.com/bpg/terraform-provider-proxmox/commit/2f87941f2b370bdda681d4f51dde78ca0e40154a))

## [0.58.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.57.1...v0.58.0) (2024-05-28)


### Features

* **vm:** add support for `vga.clipboard`, `virtio-gl` type ([#1326](https://github.com/bpg/terraform-provider-proxmox/issues/1326)) ([32de050](https://github.com/bpg/terraform-provider-proxmox/commit/32de05060527b68198a4746ec1402f531fe9c77f))


### Bug Fixes

* **lxc:** `mount_point.backup` should be `false` by default ([#1327](https://github.com/bpg/terraform-provider-proxmox/issues/1327)) ([206fc4b](https://github.com/bpg/terraform-provider-proxmox/commit/206fc4b03ddfcc7ecf43b01ee22df2e66a4505b5))
* **vm:** check task warning status against exit code ([#1330](https://github.com/bpg/terraform-provider-proxmox/issues/1330)) ([b7afd02](https://github.com/bpg/terraform-provider-proxmox/commit/b7afd02cc3bccfc43ab91f2484bf0bca4f532cbc))


### Miscellaneous

* **deps:** update golang.org/x/exp digest (9bf2ced ‚Üí 4c93da0) ([#1321](https://github.com/bpg/terraform-provider-proxmox/issues/1321)) ([1c6b9e4](https://github.com/bpg/terraform-provider-proxmox/commit/1c6b9e4935d448a00552323c0e8679656bf6978d))
* **deps:** update module github.com/golangci/golangci-lint (v1.58.2 ‚Üí v1.59.0) in /tools ([#1332](https://github.com/bpg/terraform-provider-proxmox/issues/1332)) ([e0097d9](https://github.com/bpg/terraform-provider-proxmox/commit/e0097d9880698203b9b293c4b9c76e46a697f662))
* **deps:** update module github.com/goreleaser/goreleaser (v1.26.1 ‚Üí v1.26.2) in /tools ([#1322](https://github.com/bpg/terraform-provider-proxmox/issues/1322)) ([93f86b1](https://github.com/bpg/terraform-provider-proxmox/commit/93f86b1e13ca092bb77ad0972927e52463358b5d))
* **docs:** document expectations for the default `root` shell on PVE nodes ([#1329](https://github.com/bpg/terraform-provider-proxmox/issues/1329)) ([ffffa56](https://github.com/bpg/terraform-provider-proxmox/commit/ffffa56518aed38ae93706ebdb22f5386baffcb1))
* **vm2:** add support for `vga` ([#1328](https://github.com/bpg/terraform-provider-proxmox/issues/1328)) ([d843e46](https://github.com/bpg/terraform-provider-proxmox/commit/d843e46b375e27a9cb0364537adad272beb3bcdb))

## [0.57.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.57.0...v0.57.1) (2024-05-22)


### Bug Fixes

* **file:** upload timeout with 596 response code ([#1315](https://github.com/bpg/terraform-provider-proxmox/issues/1315)) ([a6c6b98](https://github.com/bpg/terraform-provider-proxmox/commit/a6c6b98d449e2039edb76a9bdbb0a71ed7fdeb16))
* **vm:** allow `clone` to pass with warnings ([#1317](https://github.com/bpg/terraform-provider-proxmox/issues/1317)) ([fb1105d](https://github.com/bpg/terraform-provider-proxmox/commit/fb1105d93bd2fec4d9fe0cfa9155539d17d8b418))


### Miscellaneous

* **ci:** update actions/checkout action (v4.1.5 ‚Üí v4.1.6) ([#1305](https://github.com/bpg/terraform-provider-proxmox/issues/1305)) ([0494fcb](https://github.com/bpg/terraform-provider-proxmox/commit/0494fcb16772cd69d510d42594badfc83ae2e0ac))
* **ci:** update jetbrains/qodana-action action (v2024.1.4 ‚Üí v2024.1.5) ([#1306](https://github.com/bpg/terraform-provider-proxmox/issues/1306)) ([48fdb03](https://github.com/bpg/terraform-provider-proxmox/commit/48fdb03c8aac90f15040e7a7cad317acb535c797))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1309](https://github.com/bpg/terraform-provider-proxmox/issues/1309)) ([7d1b400](https://github.com/bpg/terraform-provider-proxmox/commit/7d1b4006412962aeef40bd64d38021c807543e0e))
* **deps:** update tools ([#1316](https://github.com/bpg/terraform-provider-proxmox/issues/1316)) ([3f97a7b](https://github.com/bpg/terraform-provider-proxmox/commit/3f97a7b5c3eb8926375e02f87f84d23a9b644d2c))
* **vm2:** add datasource implementation  ([#1318](https://github.com/bpg/terraform-provider-proxmox/issues/1318)) ([e3dd31f](https://github.com/bpg/terraform-provider-proxmox/commit/e3dd31f55e41047e004ebff34a713a4e9ed8616f))
* **vm2:** add support for `cpu` ([#1310](https://github.com/bpg/terraform-provider-proxmox/issues/1310)) ([aa309fd](https://github.com/bpg/terraform-provider-proxmox/commit/aa309fd9eabad00e7694b8bd7d63cad6180d7118))
* **vm2:** cleanup `cpu` implementation, refactor rearrange acc tests ([#1311](https://github.com/bpg/terraform-provider-proxmox/issues/1311)) ([2e34c57](https://github.com/bpg/terraform-provider-proxmox/commit/2e34c57f6c95bff2f3e35ee617e783a78616c900))

## [0.57.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.56.1...v0.57.0) (2024-05-16)


### Features

* **vm:** remove support for `initialization.upgrade` attribute ([#1295](https://github.com/bpg/terraform-provider-proxmox/issues/1295)) ([2b7dd08](https://github.com/bpg/terraform-provider-proxmox/commit/2b7dd08020c542b5e08d241aa577be1627f19301))


### Bug Fixes

* **access:** user token `expiration_date` handling ([#1293](https://github.com/bpg/terraform-provider-proxmox/issues/1293)) ([a436c24](https://github.com/bpg/terraform-provider-proxmox/commit/a436c24923d314575bebcebb4e2173dffc753651))
* **vm:** yet another fix for disk reordering ([#1297](https://github.com/bpg/terraform-provider-proxmox/issues/1297)) ([3180f81](https://github.com/bpg/terraform-provider-proxmox/commit/3180f81b4a14868bb0076ec8ab6299b3f6945510))


### Miscellaneous

* **ci:** update google-github-actions/release-please-action action (v4.1.0 ‚Üí v4.1.1) ([#1296](https://github.com/bpg/terraform-provider-proxmox/issues/1296)) ([71480bf](https://github.com/bpg/terraform-provider-proxmox/commit/71480bf9340d11d3a06c72a4eb5425f920ea03e3))
* **ci:** update release-please action ref ([bfb20e0](https://github.com/bpg/terraform-provider-proxmox/commit/bfb20e0bfdd7a326844351f6ece8d47c1a343085))
* **deps:** update module github.com/goreleaser/goreleaser (v1.26.0 ‚Üí v1.26.1) in /tools [security] ([#1301](https://github.com/bpg/terraform-provider-proxmox/issues/1301)) ([ea6bb93](https://github.com/bpg/terraform-provider-proxmox/commit/ea6bb93be5e8ae0ba645995165548a780424f008))

## [0.56.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.56.0...v0.56.1) (2024-05-13)


### Bug Fixes

* **vm:** `cdrom` is not attached when creating a VM from scratch ([#1287](https://github.com/bpg/terraform-provider-proxmox/issues/1287)) ([be4a3b7](https://github.com/bpg/terraform-provider-proxmox/commit/be4a3b7c6f73a441f5e562f2b97c1fafef06bad0))


### Miscellaneous

* **deps:** update module github.com/goreleaser/goreleaser (v1.25.1 ‚Üí v1.26.0) in /tools ([#1289](https://github.com/bpg/terraform-provider-proxmox/issues/1289)) ([7853a53](https://github.com/bpg/terraform-provider-proxmox/commit/7853a535270aa2a0782de8fad20a9d0c57f0b322))

## [0.56.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.55.1...v0.56.0) (2024-05-12)


### Features

* **access:** add ACL resource ([#1166](https://github.com/bpg/terraform-provider-proxmox/issues/1166)) ([afcbb41](https://github.com/bpg/terraform-provider-proxmox/commit/afcbb415a30fdf67912fc0c8ecace338c88fd003))
* **access:** add proxmox user token ([#1159](https://github.com/bpg/terraform-provider-proxmox/issues/1159)) ([8220271](https://github.com/bpg/terraform-provider-proxmox/commit/8220271eee5755e1d0d87f5064bfb00304a307bb))
* **provider:** add support for `ssh-agent` on Windows ([#1270](https://github.com/bpg/terraform-provider-proxmox/issues/1270)) ([ccf4834](https://github.com/bpg/terraform-provider-proxmox/commit/ccf4834c16797e099782a13254ab1ef011833133))


### Miscellaneous

* **ci:** update actions/checkout action (v4.1.4 ‚Üí v4.1.5) ([#1278](https://github.com/bpg/terraform-provider-proxmox/issues/1278)) ([10774f4](https://github.com/bpg/terraform-provider-proxmox/commit/10774f49e17ec4585508989ed225b9d10c2710fb))
* **ci:** update goreleaser/goreleaser-action action (v5.0.0 ‚Üí v5.1.0) ([#1284](https://github.com/bpg/terraform-provider-proxmox/issues/1284)) ([78f9d6e](https://github.com/bpg/terraform-provider-proxmox/commit/78f9d6e2bfecebd47018c16ab1ec22e6f00eb878))
* **ci:** update hashicorp/setup-terraform action (v3.1.0 ‚Üí v3.1.1) ([#1279](https://github.com/bpg/terraform-provider-proxmox/issues/1279)) ([e79cf12](https://github.com/bpg/terraform-provider-proxmox/commit/e79cf12f44602d9ca9c6e90b1554ac602d79f2b7))
* **ci:** update jetbrains/qodana-action action (v2024.1.3 ‚Üí v2024.1.4) ([#1280](https://github.com/bpg/terraform-provider-proxmox/issues/1280)) ([6ae9b58](https://github.com/bpg/terraform-provider-proxmox/commit/6ae9b581df6e82cfe9bae2bb9174d8cc3b46ea6c))
* **deps:** update go (1.22.2 ‚Üí 1.22.3) ([#1273](https://github.com/bpg/terraform-provider-proxmox/issues/1273)) ([097f3f9](https://github.com/bpg/terraform-provider-proxmox/commit/097f3f947ca97708a6acf67e036205d459b9c0bd))
* **deps:** update module github.com/brianvoe/gofakeit/v7 (v7.0.2 ‚Üí v7.0.3) ([#1274](https://github.com/bpg/terraform-provider-proxmox/issues/1274)) ([2be83eb](https://github.com/bpg/terraform-provider-proxmox/commit/2be83eba1ea4512579ea0188c77709fd5a409c29))
* **deps:** update module github.com/gorilla/schema (v1.2.1 ‚Üí v1.3.0) ([#1276](https://github.com/bpg/terraform-provider-proxmox/issues/1276)) ([1f80e9d](https://github.com/bpg/terraform-provider-proxmox/commit/1f80e9dc3132f16eca7533c918f2928e0eaf33e5))
* **deps:** update module github.com/hashicorp/terraform-plugin-mux (v0.15.0 ‚Üí v0.16.0) ([#1277](https://github.com/bpg/terraform-provider-proxmox/issues/1277)) ([ff98439](https://github.com/bpg/terraform-provider-proxmox/commit/ff9843945943ab0287535f84c3fe1bd60ec2b4d5))
* **deps:** update tools ([#1275](https://github.com/bpg/terraform-provider-proxmox/issues/1275)) ([d3ea1ac](https://github.com/bpg/terraform-provider-proxmox/commit/d3ea1ac560620552ac4d4f67a9a0a0eb4de43012))

## [0.55.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.55.0...v0.55.1) (2024-05-06)


### Bug Fixes

* **code:** update acc tests to PVE 8.2 ([#1269](https://github.com/bpg/terraform-provider-proxmox/issues/1269)) ([0b35f47](https://github.com/bpg/terraform-provider-proxmox/commit/0b35f47780a15d5c89b3d229e90c3af4ac35f7ce))
* **vm:** fix timeout when resizing custom disk at create ([#1260](https://github.com/bpg/terraform-provider-proxmox/issues/1260)) ([10790f6](https://github.com/bpg/terraform-provider-proxmox/commit/10790f668d4b57b8bfe0f62cb691bdb75e12fca3))
* **vm:** only set `initialization.upgrade` attribute when not using custom cloud-init file ([#1253](https://github.com/bpg/terraform-provider-proxmox/issues/1253)) ([9762405](https://github.com/bpg/terraform-provider-proxmox/commit/97624052f152d43cf325908ed717ef444306cbd7))
* **vm:** use `raw` file format for `efi_disk` by default ([#1249](https://github.com/bpg/terraform-provider-proxmox/issues/1249)) ([b3caf6a](https://github.com/bpg/terraform-provider-proxmox/commit/b3caf6af8252e1fc737489f71534b96188f50631))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.9.3 ‚Üí v1.10.0) ([#1262](https://github.com/bpg/terraform-provider-proxmox/issues/1262)) ([ce47411](https://github.com/bpg/terraform-provider-proxmox/commit/ce47411f99115a85d900a2671b2e57e21d680189))
* **ci:** update jetbrains/qodana-action action (v2024.1.2 ‚Üí v2024.1.3) ([#1261](https://github.com/bpg/terraform-provider-proxmox/issues/1261)) ([f08d139](https://github.com/bpg/terraform-provider-proxmox/commit/f08d139ba8b8e5bf3fececeda852a2d02ffd80cd))
* **deps:** update module github.com/golangci/golangci-lint (v1.57.2 ‚Üí v1.58.0) in /tools ([#1258](https://github.com/bpg/terraform-provider-proxmox/issues/1258)) ([452b24b](https://github.com/bpg/terraform-provider-proxmox/commit/452b24b36b15eb98cddba313227a37a770553f64))
* **deps:** update module github.com/hashicorp/terraform-plugin-go (v0.22.2 ‚Üí v0.23.0) ([#1266](https://github.com/bpg/terraform-provider-proxmox/issues/1266)) ([02302cb](https://github.com/bpg/terraform-provider-proxmox/commit/02302cb498999c09fe71479f2f35676a472c98fa))
* **deps:** update module golang.org/x/crypto (v0.22.0 ‚Üí v0.23.0) ([#1267](https://github.com/bpg/terraform-provider-proxmox/issues/1267)) ([c21da7e](https://github.com/bpg/terraform-provider-proxmox/commit/c21da7e1831a929703bac0ac98b3b4f3db55ea4d))
* **deps:** update module golang.org/x/exp (v0.0.0-20240416160154-fe59bbe5cc7f ‚Üí v0.0.0-20240506185415-9bf2ced13842) ([#1265](https://github.com/bpg/terraform-provider-proxmox/issues/1265)) ([6bacbe8](https://github.com/bpg/terraform-provider-proxmox/commit/6bacbe8b56562c5c814c65bbb44f03602fae41be))
* **deps:** update module golang.org/x/net (v0.24.0 ‚Üí v0.25.0) ([#1268](https://github.com/bpg/terraform-provider-proxmox/issues/1268)) ([2672bf3](https://github.com/bpg/terraform-provider-proxmox/commit/2672bf3ca12a134bc6daa5943a01e66a87ed77d6))

## [0.55.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.54.0...v0.55.0) (2024-04-30)


### Features

* **cluster:** Extend the available attributes for the `proxmox_virtual_environment_cluster_options` resource ([#1241](https://github.com/bpg/terraform-provider-proxmox/issues/1241)) ([2eb36f4](https://github.com/bpg/terraform-provider-proxmox/commit/2eb36f4134a7f89e2e3fb1f69f39d359730c2acc))
* **vm:** add initial support for IDE ([#1237](https://github.com/bpg/terraform-provider-proxmox/issues/1237)) ([bd195d6](https://github.com/bpg/terraform-provider-proxmox/commit/bd195d66069485fc290e13fc66d2b80b220ea731))


### Miscellaneous

* **ci:** update actions/checkout action (v4.1.1 ‚Üí v4.1.3) ([bb44a8d](https://github.com/bpg/terraform-provider-proxmox/commit/bb44a8d84491cdca770bbbf58df4d8b0c5605f1e))
* **ci:** update actions/checkout action (v4.1.3 ‚Üí v4.1.4) ([229883b](https://github.com/bpg/terraform-provider-proxmox/commit/229883b110f6e6ab22b9e79a52167d044971c4c8))
* **ci:** update hashicorp/setup-terraform action (v3.0.0 ‚Üí v3.1.0) ([84778a3](https://github.com/bpg/terraform-provider-proxmox/commit/84778a39656cc8c2bb36f767d1ce55916353073c))
* **ci:** update jetbrains/qodana-action action (v2024.1.1 ‚Üí v2024.1.2) ([4da06ec](https://github.com/bpg/terraform-provider-proxmox/commit/4da06ecb94b1d3097e2a0fb12c7aeafc907d60a1))
* **ci:** update lycheeverse/lychee-action action (v1.9.3 ‚Üí v1.10.0) ([0839c92](https://github.com/bpg/terraform-provider-proxmox/commit/0839c92ba69eb3ba53aa098a0b3a970ba405a533))
* **deps:** update go (1.22.0 ‚Üí 1.22.2) ([#1234](https://github.com/bpg/terraform-provider-proxmox/issues/1234)) ([ee939a3](https://github.com/bpg/terraform-provider-proxmox/commit/ee939a38a35bf4a490cbb549c14a8a5538e47e23))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.19.1 ‚Üí v0.19.2) in /tools ([#1247](https://github.com/bpg/terraform-provider-proxmox/issues/1247)) ([b9429cb](https://github.com/bpg/terraform-provider-proxmox/commit/b9429cbd682ab1fff65f05fd67bc9f34bd6f5906))
* **deps:** update tools ([#1238](https://github.com/bpg/terraform-provider-proxmox/issues/1238)) ([e13bb03](https://github.com/bpg/terraform-provider-proxmox/commit/e13bb03ddafac41e7e9ca815ab3e615b839b56e3))
* remove unused code ([#1236](https://github.com/bpg/terraform-provider-proxmox/issues/1236)) ([efd0d7b](https://github.com/bpg/terraform-provider-proxmox/commit/efd0d7b4662b0bb0bebf7827f9b3b508a2f298b6))
* **vm2:** experiment with sets, add `tags` support ([#1232](https://github.com/bpg/terraform-provider-proxmox/issues/1232)) ([961404d](https://github.com/bpg/terraform-provider-proxmox/commit/961404dd0b2be71c1b612201cc454226ac12c04e))
* **vm2:** experimental support for `clone` and inherited attributes ([#1235](https://github.com/bpg/terraform-provider-proxmox/issues/1235)) ([7209fe0](https://github.com/bpg/terraform-provider-proxmox/commit/7209fe03215c7fda32dd74ab9647b9824e0b8d61))

## [0.54.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.53.1...v0.54.0) (2024-04-19)


### Features

* **cluster:** Implement initial support for "hardware mappings" ([#1213](https://github.com/bpg/terraform-provider-proxmox/issues/1213)) ([76c1c22](https://github.com/bpg/terraform-provider-proxmox/commit/76c1c2282bb24ccc01cd5dd138ad19e830633d10))


### Bug Fixes

* **vm,lxc,file:** improve timeouts handling ([#1222](https://github.com/bpg/terraform-provider-proxmox/issues/1222)) ([0c9c206](https://github.com/bpg/terraform-provider-proxmox/commit/0c9c2066fd88abf2ec422423113de29651be0417))
* **vm:** state drift due to disk re-ordering ([#1215](https://github.com/bpg/terraform-provider-proxmox/issues/1215)) ([ad036a6](https://github.com/bpg/terraform-provider-proxmox/commit/ad036a67e8129ce6a50096792c33cb1ce364967e))


### Miscellaneous

* **code:** reorganize HA & node network code ([#1218](https://github.com/bpg/terraform-provider-proxmox/issues/1218)) ([163a773](https://github.com/bpg/terraform-provider-proxmox/commit/163a7730888dac2d436988499af87d4ff8f7d118))
* **deps:** bump golang.org/x/net from 0.22.0 to 0.23.0 in /tools ([#1225](https://github.com/bpg/terraform-provider-proxmox/issues/1225)) ([7e4710d](https://github.com/bpg/terraform-provider-proxmox/commit/7e4710d3f01ab076d2ed702885f660fd1d14b90f))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1228](https://github.com/bpg/terraform-provider-proxmox/issues/1228)) ([5a606ec](https://github.com/bpg/terraform-provider-proxmox/commit/5a606ec18e27a89289880cff06d767758f716ce6))
* **deps:** update go (1.22.0 ‚Üí 1.22.2) in /tools ([#1227](https://github.com/bpg/terraform-provider-proxmox/issues/1227)) ([c7e36ee](https://github.com/bpg/terraform-provider-proxmox/commit/c7e36ee1a18375e15fbc365e7014f9fa9d7be24b))
* **deps:** update golang.org/x/exp digest (93d18d7 ‚Üí fe59bbe) ([#1226](https://github.com/bpg/terraform-provider-proxmox/issues/1226)) ([83d835f](https://github.com/bpg/terraform-provider-proxmox/commit/83d835ff3ebaf05e960ab500192feb12e4ef6cc6))
* **deps:** update module github.com/avast/retry-go/v4 (v4.5.1 ‚Üí v4.6.0) ([#1229](https://github.com/bpg/terraform-provider-proxmox/issues/1229)) ([9387845](https://github.com/bpg/terraform-provider-proxmox/commit/938784531f331afddc1e0639a11b75e96e96af17))
* **deps:** update tools ([#1216](https://github.com/bpg/terraform-provider-proxmox/issues/1216)) ([1bf3bf0](https://github.com/bpg/terraform-provider-proxmox/commit/1bf3bf0f68bf73efd82e153d3efdc1ed4db75dd1))
* **vm2:** initial experimental VM resource implementation using Plugin Framework ([#1230](https://github.com/bpg/terraform-provider-proxmox/issues/1230)) ([d8202dd](https://github.com/bpg/terraform-provider-proxmox/commit/d8202dd7a1c4f41ba9503f83b97633bd1cba30d4))
* **vm:** fix acceptance test for hardware mapping ([#1223](https://github.com/bpg/terraform-provider-proxmox/issues/1223)) ([653e6f2](https://github.com/bpg/terraform-provider-proxmox/commit/653e6f25f848ccd13549b6e5d6ca7ba2e713ecc4))

## [0.53.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.53.0...v0.53.1) (2024-04-12)


### Bug Fixes

* **vm:** error 'resizing of efidisks is not supported' when clonning a VM with re-defined `efi_disk` ([#1206](https://github.com/bpg/terraform-provider-proxmox/issues/1206)) ([46d323d](https://github.com/bpg/terraform-provider-proxmox/commit/46d323d31b1568af363bbee84f7ea7e6a46a62cc))
* **vm:** regression: force VM recreation due to `initialization.upgrade` when it is not in the plan ([#1209](https://github.com/bpg/terraform-provider-proxmox/issues/1209)) ([628d0f1](https://github.com/bpg/terraform-provider-proxmox/commit/628d0f15dd7499a15b7ae1a00441a72191b130be))


### Miscellaneous

* **deps:** bump github.com/sigstore/cosign/v2 from 2.2.3 to 2.2.4 in /tools ([#1207](https://github.com/bpg/terraform-provider-proxmox/issues/1207)) ([19a13be](https://github.com/bpg/terraform-provider-proxmox/commit/19a13bee0a023c850854be02310a424762b7ed8c))

## [0.53.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.52.0...v0.53.0) (2024-04-10)


### Features

* **vm:** add Intel E1000E support ([#1191](https://github.com/bpg/terraform-provider-proxmox/issues/1191)) ([f0a7afa](https://github.com/bpg/terraform-provider-proxmox/commit/f0a7afa57d7dc538320efe436890e23cc89993e3))
* **vm:** add support for `initialization.upgrade` attribute ([#1203](https://github.com/bpg/terraform-provider-proxmox/issues/1203)) ([59972dc](https://github.com/bpg/terraform-provider-proxmox/commit/59972dc1b5c4171224c4e3ad3d9790a6efc66759))


### Bug Fixes

* **firewall:** remove strict validation for `rule.iface` attribute ([#1199](https://github.com/bpg/terraform-provider-proxmox/issues/1199)) ([ae88cf6](https://github.com/bpg/terraform-provider-proxmox/commit/ae88cf603d1d7e3ca86ba1506944be0f23f9301c))
* **vm:** panic if `initialization.user_account_keys` contains `null` ([#1197](https://github.com/bpg/terraform-provider-proxmox/issues/1197)) ([b4174a7](https://github.com/bpg/terraform-provider-proxmox/commit/b4174a7c82398970f9f318955fdd07d7ab378360))
* **vm:** panic if `numa` block is empty ([#1196](https://github.com/bpg/terraform-provider-proxmox/issues/1196)) ([c273111](https://github.com/bpg/terraform-provider-proxmox/commit/c27311183ab74bec3e12228917e1b5468a4b941c))


### Miscellaneous

* **deps:** update golang.org/x/exp digest (c0f41cb ‚Üí 93d18d7) ([#1201](https://github.com/bpg/terraform-provider-proxmox/issues/1201)) ([ead36dc](https://github.com/bpg/terraform-provider-proxmox/commit/ead36dcafbe1a475748dd846b0a05c94b831c600))
* **docs:** minor documentation updates ([#1200](https://github.com/bpg/terraform-provider-proxmox/issues/1200)) ([c14b7eb](https://github.com/bpg/terraform-provider-proxmox/commit/c14b7ebe1d524783badf299cb4e146168011729e))
* refactor acceptance tests ([#1195](https://github.com/bpg/terraform-provider-proxmox/issues/1195)) ([c772fb3](https://github.com/bpg/terraform-provider-proxmox/commit/c772fb3cf658fcda9051f8305125fdfc78ce3b3b))

## [0.52.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.51.1...v0.52.0) (2024-04-07)


### Features

* **vm:** add support for numa architecture attribute ([#1156](https://github.com/bpg/terraform-provider-proxmox/issues/1156)) ([#1175](https://github.com/bpg/terraform-provider-proxmox/issues/1175)) ([dbbd966](https://github.com/bpg/terraform-provider-proxmox/commit/dbbd966736716ab730da04ef1099cc82d2e85019))


### Bug Fixes

* **vm:** regression: provider always tries to update `memory.*hugepages` even if it is not specified ([#1188](https://github.com/bpg/terraform-provider-proxmox/issues/1188)) ([31b6812](https://github.com/bpg/terraform-provider-proxmox/commit/31b6812ce281da214261786f633ed7e93c197fb0))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.9.2 ‚Üí v1.9.3) ([#1190](https://github.com/bpg/terraform-provider-proxmox/issues/1190)) ([24daca5](https://github.com/bpg/terraform-provider-proxmox/commit/24daca59410bb3974045e7dd5825fdbe0ef1356e))
* **deps:** update tools ([#1184](https://github.com/bpg/terraform-provider-proxmox/issues/1184)) ([f4e5ef8](https://github.com/bpg/terraform-provider-proxmox/commit/f4e5ef8aaacdee4063eb65cd5fb53d197229335a))
* improve acceptance tests on CI ([#1173](https://github.com/bpg/terraform-provider-proxmox/issues/1173)) ([268c861](https://github.com/bpg/terraform-provider-proxmox/commit/268c8616494219463fc2f20b2279a166f17c791a))

## [0.51.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.51.0...v0.51.1) (2024-04-04)


### Bug Fixes

* **vm:** regressions: provider always tries to update `cpu.affinity` even if it is not specified ([#1182](https://github.com/bpg/terraform-provider-proxmox/issues/1182)) ([82d435f](https://github.com/bpg/terraform-provider-proxmox/commit/82d435f575576e495e0558d4f32b1620bbc4f842))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.9.0 ‚Üí v1.9.2) ([#1177](https://github.com/bpg/terraform-provider-proxmox/issues/1177)) ([7358257](https://github.com/bpg/terraform-provider-proxmox/commit/7358257dbaa0f5d4c9de2aaaa24c7142d390baf6))
* **deps:** update golang.org/x/exp digest (a685a6e ‚Üí c0f41cb) ([#1183](https://github.com/bpg/terraform-provider-proxmox/issues/1183)) ([e680aa9](https://github.com/bpg/terraform-provider-proxmox/commit/e680aa9318b638d0ea7d235893eccb6ef102c925))

## [0.51.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.50.0...v0.51.0) (2024-03-30)


### Features

* **vm:** add proxmox_virtual_environment_node datasource ([#1151](https://github.com/bpg/terraform-provider-proxmox/issues/1151)) ([9fee8c1](https://github.com/bpg/terraform-provider-proxmox/commit/9fee8c1e2e24a61cd8e75c3744227f5d44662c0f))
* **vm:** add support for cpu `affinity` attribute ([#1148](https://github.com/bpg/terraform-provider-proxmox/issues/1148)) ([#1153](https://github.com/bpg/terraform-provider-proxmox/issues/1153)) ([83a5971](https://github.com/bpg/terraform-provider-proxmox/commit/83a5971cf64451f41d9a24b6245f59cdfae14569))
* **vm:** add support for memory `hugepages` and `keep_hugepages` attributes ([#1158](https://github.com/bpg/terraform-provider-proxmox/issues/1158)) ([a2f055a](https://github.com/bpg/terraform-provider-proxmox/commit/a2f055a916104b1ba8008b7b359080acacb605f6))


### Bug Fixes

* **lxc:** improve configurable timeouts for containers operations ([#1161](https://github.com/bpg/terraform-provider-proxmox/issues/1161)) ([c45e336](https://github.com/bpg/terraform-provider-proxmox/commit/c45e3367e7128f82e6931fdf88bd31f9736147fd))
* prevent authenticating multiple times in parallel ([#1168](https://github.com/bpg/terraform-provider-proxmox/issues/1168)) ([e87bc4b](https://github.com/bpg/terraform-provider-proxmox/commit/e87bc4b941564aace95d60ff987b7ec0d508b437))
* **vm:** re-use ide, sata, and scsi cloud-init storage ([#1083](https://github.com/bpg/terraform-provider-proxmox/issues/1083)) ([#1141](https://github.com/bpg/terraform-provider-proxmox/issues/1141)) ([d41463d](https://github.com/bpg/terraform-provider-proxmox/commit/d41463de79dbae512a5560926cc95c2e46aba70f))


### Miscellaneous

* **deps:** update golang.org/x/exp digest (a85f2c6 ‚Üí a685a6e) ([#1171](https://github.com/bpg/terraform-provider-proxmox/issues/1171)) ([e60ee99](https://github.com/bpg/terraform-provider-proxmox/commit/e60ee990fa691228bdfe64c32d52ee8e381689a0))
* **deps:** update module github.com/golangci/golangci-lint (v1.56.2 ‚Üí v1.57.1) in /tools ([#1149](https://github.com/bpg/terraform-provider-proxmox/issues/1149)) ([48756b6](https://github.com/bpg/terraform-provider-proxmox/commit/48756b69ba8f1fcafd88b1186a925236cb93cc30))
* **deps:** update module github.com/golangci/golangci-lint (v1.57.1 ‚Üí v1.57.2) in /tools ([#1172](https://github.com/bpg/terraform-provider-proxmox/issues/1172)) ([02efdc4](https://github.com/bpg/terraform-provider-proxmox/commit/02efdc40bf28d85f08d7b1b185386063db81cd7a))
* **deps:** update module github.com/hashicorp/terraform-plugin-framework (v1.6.1 ‚Üí v1.7.0) ([#1150](https://github.com/bpg/terraform-provider-proxmox/issues/1150)) ([e5ef91e](https://github.com/bpg/terraform-provider-proxmox/commit/e5ef91e72d896b45fbe3e3d0c7179028db632b1d))

## [0.50.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.49.0...v0.50.0) (2024-03-21)


### Features

* **lxc:** add configurable timeout for container creation ([#1146](https://github.com/bpg/terraform-provider-proxmox/issues/1146)) ([84440d8](https://github.com/bpg/terraform-provider-proxmox/commit/84440d8329c607d7a1fd7ced8a078251cf23908c))
* **lxc:** support hook script for LXC ([#1140](https://github.com/bpg/terraform-provider-proxmox/issues/1140)) ([0deaf18](https://github.com/bpg/terraform-provider-proxmox/commit/0deaf1801ade7896500c43d4903a69ee5da240a3))
* **vm:** add support for `disconnected` attribute in network interface ([#1129](https://github.com/bpg/terraform-provider-proxmox/issues/1129)) ([11ca880](https://github.com/bpg/terraform-provider-proxmox/commit/11ca880f28b68c7beec1feb7e9dc7a6fbf00bf40))


### Bug Fixes

* **docs:** fix `sudo` configuration steps ([#1132](https://github.com/bpg/terraform-provider-proxmox/issues/1132)) ([0c6ecb8](https://github.com/bpg/terraform-provider-proxmox/commit/0c6ecb85ed0cc236db13874f87bf5f1b17c6c933))
* **docs:** typo in `container.console` attribute `mode` -&gt; `type` ([#1133](https://github.com/bpg/terraform-provider-proxmox/issues/1133)) ([5cd6b4a](https://github.com/bpg/terraform-provider-proxmox/commit/5cd6b4acdfd4777fb7eaa48b74328284a88e53ec))
* **examples:** `datastore_id` is missing in `initialization` block for vm ([#1136](https://github.com/bpg/terraform-provider-proxmox/issues/1136)) ([6a5becc](https://github.com/bpg/terraform-provider-proxmox/commit/6a5beccf9133c3c8306be37d6812f90f97508799))


### Miscellaneous

* **deps:** bump github.com/docker/docker from 24.0.7+incompatible to 24.0.9+incompatible in /tools ([#1142](https://github.com/bpg/terraform-provider-proxmox/issues/1142)) ([f4c80ad](https://github.com/bpg/terraform-provider-proxmox/commit/f4c80ad297c11e139d7a0b2bb851b00dd02b7ff7))
* **deps:** update golang.org/x/exp digest (814bf88 ‚Üí c7f7c64) ([#1130](https://github.com/bpg/terraform-provider-proxmox/issues/1130)) ([ab51262](https://github.com/bpg/terraform-provider-proxmox/commit/ab512622f7f21bbfcbae48793cf9d0b24af5c2d5))
* **deps:** update golang.org/x/exp digest (c7f7c64 ‚Üí a85f2c6) ([#1139](https://github.com/bpg/terraform-provider-proxmox/issues/1139)) ([6f8a472](https://github.com/bpg/terraform-provider-proxmox/commit/6f8a472981a3d1f478f9a0fd44abb83f2e19d641))
* **vm:** refactoring: extract network device code from vm.go ([#1127](https://github.com/bpg/terraform-provider-proxmox/issues/1127)) ([29b5438](https://github.com/bpg/terraform-provider-proxmox/commit/29b5438faf7c1d09291c549516ac359952e2a87b))

## [0.49.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.48.4...v0.49.0) (2024-03-15)


### Features

* **vm:** add support for `protection` attribute ([#1126](https://github.com/bpg/terraform-provider-proxmox/issues/1126)) ([cea65a8](https://github.com/bpg/terraform-provider-proxmox/commit/cea65a8a129168581451ecda5b84be8ddd2e3a3e))
* **vm:** add support for disk `aio`, `backup`, `iops*` attributes ([#1124](https://github.com/bpg/terraform-provider-proxmox/issues/1124)) ([014b59e](https://github.com/bpg/terraform-provider-proxmox/commit/014b59e04f30fc08bc512f68cf471fe2cfdc481c))


### Miscellaneous

* **deps:** bump google.golang.org/protobuf from 1.31.0 to 1.33.0 in /tools ([#1121](https://github.com/bpg/terraform-provider-proxmox/issues/1121)) ([1ffc40b](https://github.com/bpg/terraform-provider-proxmox/commit/1ffc40b77ae6d76c8eccf64373ef982e2b14f4d1))
* **deps:** update module github.com/skeema/knownhosts (v1.2.1 ‚Üí v1.2.2) ([#1123](https://github.com/bpg/terraform-provider-proxmox/issues/1123)) ([732f018](https://github.com/bpg/terraform-provider-proxmox/commit/732f0188d798fc082fcc01312b41a9f5ded2ae0c))

## [0.48.4](https://github.com/bpg/terraform-provider-proxmox/compare/v0.48.3...v0.48.4) (2024-03-13)


### Bug Fixes

* **ci:** missing releases from HashiCorp Registry ([#1118](https://github.com/bpg/terraform-provider-proxmox/issues/1118)) ([ffc64d2](https://github.com/bpg/terraform-provider-proxmox/commit/ffc64d209a392afb3198acee3ee5449b7392e579))

## [0.48.3](https://github.com/bpg/terraform-provider-proxmox/compare/v0.48.2...v0.48.3) (2024-03-12)


### Bug Fixes

* **provider:** EOF error when closing SSH session ([#1113](https://github.com/bpg/terraform-provider-proxmox/issues/1113)) ([b63f1b7](https://github.com/bpg/terraform-provider-proxmox/commit/b63f1b7889287558510526f8392cfdaa9d22524b))
* **vm:** timeout when resizing a disk during clone ([#1103](https://github.com/bpg/terraform-provider-proxmox/issues/1103)) ([449f9fc](https://github.com/bpg/terraform-provider-proxmox/commit/449f9fc31c0d737d2094b4c0db7a207b3e764122))


### Miscellaneous

* **ci:** update google-github-actions/release-please-action action (v4.0.2 ‚Üí v4.1.0) ([#1115](https://github.com/bpg/terraform-provider-proxmox/issues/1115)) ([04e7421](https://github.com/bpg/terraform-provider-proxmox/commit/04e74219e3cac4805c3ae9cedced42f7f64ed461))
* **deps:** update module github.com/hashicorp/terraform-plugin-go (v0.22.0 ‚Üí v0.22.1) ([#1114](https://github.com/bpg/terraform-provider-proxmox/issues/1114)) ([a059728](https://github.com/bpg/terraform-provider-proxmox/commit/a0597289b56219a07ece3296e587a8317b1251e9))
* **docs:** update terraform local (2.4.1 ‚Üí 2.5.1) ([#1116](https://github.com/bpg/terraform-provider-proxmox/issues/1116)) ([29d60f5](https://github.com/bpg/terraform-provider-proxmox/commit/29d60f593232f08440f7e2c9426d12c24eacd572))
* minor cleanups and doc updates ([#1108](https://github.com/bpg/terraform-provider-proxmox/issues/1108)) ([27dbcad](https://github.com/bpg/terraform-provider-proxmox/commit/27dbcad5cdd732a4777e886806c5eeb1a06129a4))

## [0.48.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.48.1...v0.48.2) (2024-03-09)


### Bug Fixes

* **network:** multiple fixes to `network_linux_bridge` resource ([#1095](https://github.com/bpg/terraform-provider-proxmox/issues/1095)) ([4aed7cb](https://github.com/bpg/terraform-provider-proxmox/commit/4aed7cb085c87aed68f3dc426644a9d76c075db1))
* **provider:** allow LDAP realm API tokens ([#1101](https://github.com/bpg/terraform-provider-proxmox/issues/1101)) ([461321c](https://github.com/bpg/terraform-provider-proxmox/commit/461321cf5e15dfd1b89a506ecf6a410e24bc8c5d))


### Miscellaneous

* **deps:** bump gopkg.in/go-jose/go-jose.v2 from 2.6.1 to 2.6.3 in /tools ([#1102](https://github.com/bpg/terraform-provider-proxmox/issues/1102)) ([4bc7b29](https://github.com/bpg/terraform-provider-proxmox/commit/4bc7b291fe9cedd41eb0a1c26107ff77710cf517))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1096](https://github.com/bpg/terraform-provider-proxmox/issues/1096)) ([4cac320](https://github.com/bpg/terraform-provider-proxmox/commit/4cac320ff9008b1274a944af4a6b3b302af276e0))
* **deps:** update module golang.org/x/crypto (v0.20.0 ‚Üí v0.21.0) ([#1097](https://github.com/bpg/terraform-provider-proxmox/issues/1097)) ([3b9739a](https://github.com/bpg/terraform-provider-proxmox/commit/3b9739ab5986acc4e0b25772704ce57d20818384))
* **deps:** update module golang.org/x/net (v0.21.0 ‚Üí v0.22.0) ([#1105](https://github.com/bpg/terraform-provider-proxmox/issues/1105)) ([7dea6f6](https://github.com/bpg/terraform-provider-proxmox/commit/7dea6f6ee8d3d8b5ff8027eea388c62a559ef4d6))

## [0.48.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.48.0...v0.48.1) (2024-03-05)


### Bug Fixes

* **ci:** TestAccResourceVMNetwork acc test fails when run on CI ([#1092](https://github.com/bpg/terraform-provider-proxmox/issues/1092)) ([61a0fcd](https://github.com/bpg/terraform-provider-proxmox/commit/61a0fcd936c3c88e6eb0b7b5d5517795b4c3c092))
* **docs:** fix wrong startup delay attributes ([#1088](https://github.com/bpg/terraform-provider-proxmox/issues/1088)) ([85705fd](https://github.com/bpg/terraform-provider-proxmox/commit/85705fdd51b5e64662bea169d86922ff85f062cb))


### Miscellaneous

* **deps:** update tools ([#1017](https://github.com/bpg/terraform-provider-proxmox/issues/1017)) ([fbd04ed](https://github.com/bpg/terraform-provider-proxmox/commit/fbd04ed95061f23747e4bb7224901f6a409f7547))
* **docs:** minor improvements around SSH private key usage ([#1091](https://github.com/bpg/terraform-provider-proxmox/issues/1091)) ([171dd2f](https://github.com/bpg/terraform-provider-proxmox/commit/171dd2f234b7e1effe00bbe66bc42c30f78f9e2d))

## [0.48.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.47.0...v0.48.0) (2024-03-03)


### ‚ö† BREAKING CHANGES

* **file:** snippets upload using SSH input stream ([#1085](https://github.com/bpg/terraform-provider-proxmox/issues/1085))

### Features

* **file:** snippets upload using SSH input stream ([#1085](https://github.com/bpg/terraform-provider-proxmox/issues/1085)) ([3195b3c](https://github.com/bpg/terraform-provider-proxmox/commit/3195b3cdf4c7c9d0c9e23177b4bd097de3b1fa65))
* **provider:** add support for private key authentication for SSH ([#1076](https://github.com/bpg/terraform-provider-proxmox/issues/1076)) ([2c6d3ad](https://github.com/bpg/terraform-provider-proxmox/commit/2c6d3ad01d7b6882597415d032380cd32cbaa68f))
* **vm:** add `VLAN` trunk support ([#1086](https://github.com/bpg/terraform-provider-proxmox/issues/1086)) ([cb5fc27](https://github.com/bpg/terraform-provider-proxmox/commit/cb5fc279cd44de9b9782aff5749a771975f72f51))


### Miscellaneous

* **ci:** setup acceptance tests ([#1071](https://github.com/bpg/terraform-provider-proxmox/issues/1071)) ([0bf42d5](https://github.com/bpg/terraform-provider-proxmox/commit/0bf42d52e5af26c423730bd5c339bd295abf2533))
* **ci:** split acceptance tests into a separate workflow ([#1084](https://github.com/bpg/terraform-provider-proxmox/issues/1084)) ([e38b45f](https://github.com/bpg/terraform-provider-proxmox/commit/e38b45f033a147f216228df0bf9a527665bbd808))
* **ci:** update actions/create-github-app-token action (v1.8.1 ‚Üí v1.9.0) ([66ec9f4](https://github.com/bpg/terraform-provider-proxmox/commit/66ec9f4b9b027eb963be6b9d1e8a56c6a4610fc4))
* **ci:** update dorny/paths-filter action (v3.0.1 ‚Üí v3.0.2) ([3d6cc75](https://github.com/bpg/terraform-provider-proxmox/commit/3d6cc75107c52d8eb42a46e83cd21673770968be))
* **deps:** update github.com/hashicorp/terraform-plugin-* ([#1078](https://github.com/bpg/terraform-provider-proxmox/issues/1078)) ([2398f6c](https://github.com/bpg/terraform-provider-proxmox/commit/2398f6c339c891d78eae501648c673af470793a8))
* **deps:** update module github.com/brianvoe/gofakeit/v7 (v7.0.1 ‚Üí v7.0.2) ([#1080](https://github.com/bpg/terraform-provider-proxmox/issues/1080)) ([0d4740f](https://github.com/bpg/terraform-provider-proxmox/commit/0d4740fb90dad40c16994269e03de8b73ffee5dd))
* **deps:** update module github.com/stretchr/testify (v1.8.4 ‚Üí v1.9.0) ([#1081](https://github.com/bpg/terraform-provider-proxmox/issues/1081)) ([dbd1655](https://github.com/bpg/terraform-provider-proxmox/commit/dbd1655974b31f1fae1f4c02766ef35cca77fa1e))
* **deps:** update module golang.org/x/crypto (v0.19.0 ‚Üí v0.20.0) ([#1082](https://github.com/bpg/terraform-provider-proxmox/issues/1082)) ([e3ddd6f](https://github.com/bpg/terraform-provider-proxmox/commit/e3ddd6f5fa70728607849077fdc426d71bcf2338))
* switch to `terraform-plugin-testing` for acceptance tests ([#1067](https://github.com/bpg/terraform-provider-proxmox/issues/1067)) ([14fce33](https://github.com/bpg/terraform-provider-proxmox/commit/14fce3366da5cf3bca04511535a2898026c3210c))

## [0.47.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.6...v0.47.0) (2024-02-27)


### Features

* **file:** add `overwrite_unmanaged` attribute to `virtual_environment_download_file` resource ([#1064](https://github.com/bpg/terraform-provider-proxmox/issues/1064)) ([c64fcd2](https://github.com/bpg/terraform-provider-proxmox/commit/c64fcd2948bf6ffbcf6c907fb3f15931a5595596))


### Bug Fixes

* **provider:** race condition in`~/.ssh` path existence check ([#1052](https://github.com/bpg/terraform-provider-proxmox/issues/1052)) ([f7f67db](https://github.com/bpg/terraform-provider-proxmox/commit/f7f67dbd3d3edb2b6e092b77c898962d7641256f))
* **user:** `expiration_date` attribute handling ([#1066](https://github.com/bpg/terraform-provider-proxmox/issues/1066)) ([3c52760](https://github.com/bpg/terraform-provider-proxmox/commit/3c5276093a6edc2282512aa8a489b7d5ad4eee51))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.8.0 ‚Üí v1.8.1) ([#1063](https://github.com/bpg/terraform-provider-proxmox/issues/1063)) ([9b52c12](https://github.com/bpg/terraform-provider-proxmox/commit/9b52c127ba11a4e01f7d63e2b1d06d7090cbadcb))
* **deps:** update golang.org/x/exp digest (v0.0.0-20240213143201-ec583247a57a ‚Üí ) ([#1057](https://github.com/bpg/terraform-provider-proxmox/issues/1057)) ([4959480](https://github.com/bpg/terraform-provider-proxmox/commit/4959480f02f08354bfc009128ddc33c25aa22cae))
* **deps:** update module github.com/brianvoe/gofakeit/v7 (v7.0.0 ‚Üí v7.0.1) ([#1058](https://github.com/bpg/terraform-provider-proxmox/issues/1058)) ([190ec39](https://github.com/bpg/terraform-provider-proxmox/commit/190ec39234bbe9a2d51f8cafa343dfa66df88e66))
* **vm:** refactor: move disks code out of vm.go ([#1062](https://github.com/bpg/terraform-provider-proxmox/issues/1062)) ([493ad1c](https://github.com/bpg/terraform-provider-proxmox/commit/493ad1c1219e666e61e05a6ad50a5fe746b4a69c))

## [0.46.6](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.5...v0.46.6) (2024-02-21)


### Bug Fixes

* **vm:** regression: `mac_addresses` list is missing some interfaces ([#1049](https://github.com/bpg/terraform-provider-proxmox/issues/1049)) ([518e25e](https://github.com/bpg/terraform-provider-proxmox/commit/518e25efaf6db6863d34ea3d83432eb0cd54d18a))


### Miscellaneous

* **lxc,vm:** refactor: move vm and container code to subpackages ([#1046](https://github.com/bpg/terraform-provider-proxmox/issues/1046)) ([0791194](https://github.com/bpg/terraform-provider-proxmox/commit/079119444d9f5a4c1266a4859c1aabe416c70b5d))

## [0.46.5](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.4...v0.46.5) (2024-02-20)


### Bug Fixes

* **lxc:** panic on empty `initialization.ip_config.ipv4|6` block ([#1043](https://github.com/bpg/terraform-provider-proxmox/issues/1043)) ([69c4a66](https://github.com/bpg/terraform-provider-proxmox/commit/69c4a66345547b79f4e1add7cb34d04125c6d451))
* **lxc:** panic when handling `network_interface.firewall` attribute ([#1042](https://github.com/bpg/terraform-provider-proxmox/issues/1042)) ([eb3e374](https://github.com/bpg/terraform-provider-proxmox/commit/eb3e3744321c2f5abc796b5e21e263703cff8916))


### Miscellaneous

* **deps:** Update module github.com/brianvoe/gofakeit/v6 (v6.28.0 ‚Üí v7.0.0) ([#1044](https://github.com/bpg/terraform-provider-proxmox/issues/1044)) ([7fda43f](https://github.com/bpg/terraform-provider-proxmox/commit/7fda43f4ea78695d4c962b99df196fa0a1535dc5))
* **docs:** update README.md ([#1045](https://github.com/bpg/terraform-provider-proxmox/issues/1045)) ([8e620dc](https://github.com/bpg/terraform-provider-proxmox/commit/8e620dc59b3562de84d94e9088c82158663a3b8c))
* **vm:** refactoring, add acceptance tests ([#1040](https://github.com/bpg/terraform-provider-proxmox/issues/1040)) ([b648e5b](https://github.com/bpg/terraform-provider-proxmox/commit/b648e5bcb0ca21874aa7d7a081995ff0d7bc1040))

## [0.46.4](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.3...v0.46.4) (2024-02-16)


### Bug Fixes

* **vm:** fix panic when a config block is empty ([#1033](https://github.com/bpg/terraform-provider-proxmox/issues/1033)) ([027cf1e](https://github.com/bpg/terraform-provider-proxmox/commit/027cf1e81a2ab25f9d934921c6510d091870e3ee))
* **vm:** multi-line description field is always marked as changed ([#1030](https://github.com/bpg/terraform-provider-proxmox/issues/1030)) ([797873b](https://github.com/bpg/terraform-provider-proxmox/commit/797873b257614246fbadf167e7649cc5ed8e17e8))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.7.0 ‚Üí v1.8.0) ([#1022](https://github.com/bpg/terraform-provider-proxmox/issues/1022)) ([0469192](https://github.com/bpg/terraform-provider-proxmox/commit/046919275607986c4ff380a846171f0c56e5e5f2))
* **ci:** update dorny/paths-filter action (v3.0.0 ‚Üí v3.0.1) ([#1032](https://github.com/bpg/terraform-provider-proxmox/issues/1032)) ([d444202](https://github.com/bpg/terraform-provider-proxmox/commit/d444202ab8b2f80f6d144d46ea2af55f25aa8af7))
* **ci:** update mergify config to auto-approve renovate PRs ([#1023](https://github.com/bpg/terraform-provider-proxmox/issues/1023)) ([dfb95a8](https://github.com/bpg/terraform-provider-proxmox/commit/dfb95a85f437c3e414f2e8c7020d0077ebe01bc7))
* **deps:** update golang.org/x/exp digest (v0.0.0-20240205201215-2c58cdc269a3 ‚Üí ) ([#1031](https://github.com/bpg/terraform-provider-proxmox/issues/1031)) ([4fab30e](https://github.com/bpg/terraform-provider-proxmox/commit/4fab30e5dfd62d63e29986b86dca57943f13d8af))
* **deps:** update module golang.org/x/crypto (v0.18.0 ‚Üí v0.19.0) ([#1018](https://github.com/bpg/terraform-provider-proxmox/issues/1018)) ([34d31e2](https://github.com/bpg/terraform-provider-proxmox/commit/34d31e2ed080dc944900f5219338dbe9846a3aad))
* **deps:** update module golang.org/x/net (v0.20.0 ‚Üí v0.21.0) ([#1020](https://github.com/bpg/terraform-provider-proxmox/issues/1020)) ([ed3bdb5](https://github.com/bpg/terraform-provider-proxmox/commit/ed3bdb5187dbf5588eedfc8d9ed193ab108edd64))
* **docs:** update links disk image link in examples ([#1028](https://github.com/bpg/terraform-provider-proxmox/issues/1028)) ([62a2130](https://github.com/bpg/terraform-provider-proxmox/commit/62a2130554c9ad09a7406d40e19678c4471f9364))

## [0.46.3](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.2...v0.46.3) (2024-02-07)


### Bug Fixes

* **file:** `error moving file` when uploading snippets ([#1013](https://github.com/bpg/terraform-provider-proxmox/issues/1013)) ([b6fbdcf](https://github.com/bpg/terraform-provider-proxmox/commit/b6fbdcf5ab3c191136c60814404153785aec806b))


### Miscellaneous

* **deps:** update module go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp (v0.47.0 ‚Üí v0.48.0) in /tools ([#1014](https://github.com/bpg/terraform-provider-proxmox/issues/1014)) ([303b7da](https://github.com/bpg/terraform-provider-proxmox/commit/303b7da684dcf2f986fd6a70a74e40b75d71911a))

## [0.46.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.1...v0.46.2) (2024-02-06)


### Bug Fixes

* **docs:** update sudo configuration to a more restrictive variant ([#1001](https://github.com/bpg/terraform-provider-proxmox/issues/1001)) ([6bd8ba5](https://github.com/bpg/terraform-provider-proxmox/commit/6bd8ba566a60c18121d9a66f1cdd056878fe6114))
* **file:** use `sudo` for snippets upload ([#1004](https://github.com/bpg/terraform-provider-proxmox/issues/1004)) ([60fb679](https://github.com/bpg/terraform-provider-proxmox/commit/60fb679e9f31b3be3e05bb9b25a0deb0ab37c48c))
* **vm:** error when creating custom disks on PVE with non-default shell ([#983](https://github.com/bpg/terraform-provider-proxmox/issues/983)) ([1f333ea](https://github.com/bpg/terraform-provider-proxmox/commit/1f333ea097f43097e3847d08153145ac2a44faad))
* **vm:** panic at import / state refresh if disk size is not set ([#994](https://github.com/bpg/terraform-provider-proxmox/issues/994)) ([363e502](https://github.com/bpg/terraform-provider-proxmox/commit/363e502a567f8c75c45b682795ce5974e993d082))


### Miscellaneous

* **ci:** update lycheeverse/lychee-action action (v1.9.2 ‚Üí v1.9.3) ([#999](https://github.com/bpg/terraform-provider-proxmox/issues/999)) ([f8004b0](https://github.com/bpg/terraform-provider-proxmox/commit/f8004b0e2a35616b94804fdb272df598cd2b88a2))
* **deps:** update golang.org/x/exp digest (v0.0.0-20240119083558-1b970713d09a ‚Üí ) ([9cfd383](https://github.com/bpg/terraform-provider-proxmox/commit/9cfd3833da3a8c38ef5800fae1e65f3cd6d3b696))
* **deps:** update golang.org/x/exp digest (v0.0.0-20240119083558-1b970713d09a 1b97071 ‚Üí 2c58cdc) ([#1007](https://github.com/bpg/terraform-provider-proxmox/issues/1007)) ([9cfd383](https://github.com/bpg/terraform-provider-proxmox/commit/9cfd3833da3a8c38ef5800fae1e65f3cd6d3b696))
* **deps:** update module github.com/goreleaser/goreleaser (v1.23.0 ‚Üí v1.24.0) in /tools [security] ([#1006](https://github.com/bpg/terraform-provider-proxmox/issues/1006)) ([e132f5a](https://github.com/bpg/terraform-provider-proxmox/commit/e132f5af4bbb892efd130777f7046269ddb0cfa6))
* **deps:** update module github.com/hashicorp/terraform-plugin-mux (v0.13.0 ‚Üí v0.14.0) ([#989](https://github.com/bpg/terraform-provider-proxmox/issues/989)) ([eb6377e](https://github.com/bpg/terraform-provider-proxmox/commit/eb6377e6fdbd84d3cbd59b254106f94325dbc479))
* **deps:** update module github.com/hashicorp/terraform-plugin-sdk/v2 (v2.31.0 ‚Üí v2.32.0) ([#990](https://github.com/bpg/terraform-provider-proxmox/issues/990)) ([c1eeefb](https://github.com/bpg/terraform-provider-proxmox/commit/c1eeefbb1214ef9c14341eac94b9469e7161e96f))
* **deps:** update module golang.org/x/net (v0.18.0 ‚Üí v0.20.0) ([#994](https://github.com/bpg/terraform-provider-proxmox/issues/994)) ([b196cdb](https://github.com/bpg/terraform-provider-proxmox/commit/b196cdb65bed27c34a755c3bab1654f71ef4a5e6))

## [0.46.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.46.0...v0.46.1) (2024-01-28)


### Bug Fixes

* **docs:** fix documentation tree structure in the TF registry ([#980](https://github.com/bpg/terraform-provider-proxmox/issues/980)) ([49a76bb](https://github.com/bpg/terraform-provider-proxmox/commit/49a76bb1a10c56ab2537e83b4b9fb20d2c7c9b9e))

## [0.46.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.45.1...v0.46.0) (2024-01-28)


### Features

* **docs:** rename howtos -&gt; guides and publish to the Terraform Registry ([#971](https://github.com/bpg/terraform-provider-proxmox/issues/971)) ([c39494b](https://github.com/bpg/terraform-provider-proxmox/commit/c39494b939afb0e1316776eea8730f2545135b4b))
* **provider:** add SOCKS5 proxy support for SSH connections ([#970](https://github.com/bpg/terraform-provider-proxmox/issues/970)) ([da1d780](https://github.com/bpg/terraform-provider-proxmox/commit/da1d7804af6b2ad6d6a1d698e52d19de3c1d5cb6))


### Bug Fixes

* **docs:** fix broken links ([#976](https://github.com/bpg/terraform-provider-proxmox/issues/976)) ([0e2eb80](https://github.com/bpg/terraform-provider-proxmox/commit/0e2eb80e9f4f2e13678ad9ca6afb3cf5de4d5f19))
* **lxc:** panic on empty `initialization.ip_config` block ([#977](https://github.com/bpg/terraform-provider-proxmox/issues/977)) ([0253eb9](https://github.com/bpg/terraform-provider-proxmox/commit/0253eb97576c6f6b06e4cf652b5c1e74ad20639d))
* **pool:** missing `pool_id` after import ([#974](https://github.com/bpg/terraform-provider-proxmox/issues/974)) ([ed33a18](https://github.com/bpg/terraform-provider-proxmox/commit/ed33a18c9b6499ff33bacb79cebfd510b24a29c8))
* **vm:** `timeout_start_vm` is ignored ([#978](https://github.com/bpg/terraform-provider-proxmox/issues/978)) ([625bdb6](https://github.com/bpg/terraform-provider-proxmox/commit/625bdb696f5c41f76c12f5572c89bb4594f81853))


### Miscellaneous

* **ci:** update actions/create-github-app-token action (v1.6.4 ‚Üí v1.7.0) ([2fad644](https://github.com/bpg/terraform-provider-proxmox/commit/2fad644ffd732283875ab38f70c852bf9723c409))
* **ci:** Update dorny/paths-filter action (v2.12.0 ‚Üí v3.0.0) ([#959](https://github.com/bpg/terraform-provider-proxmox/issues/959)) ([3790b52](https://github.com/bpg/terraform-provider-proxmox/commit/3790b522e71ccbab69ea0549b0a12b390bfb8848))
* **ci:** update lycheeverse/lychee-action action (v1.9.1 ‚Üí v1.9.2) ([105a694](https://github.com/bpg/terraform-provider-proxmox/commit/105a694ddf8ff3c8e60440d995ffa2f42cc70788))
* **ci:** Update peter-evans/create-issue-from-file action (v4.0.1 ‚Üí v5.0.0) ([#960](https://github.com/bpg/terraform-provider-proxmox/issues/960)) ([2ec8c1d](https://github.com/bpg/terraform-provider-proxmox/commit/2ec8c1d2cdd518d34245ce120937e852a6eedea0))

## [0.45.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.45.0...v0.45.1) (2024-01-27)


### Bug Fixes

* **docs:** inconsistent indentations in docs ([#961](https://github.com/bpg/terraform-provider-proxmox/issues/961)) ([0d548a7](https://github.com/bpg/terraform-provider-proxmox/commit/0d548a78078ee9ae3e0653ea8f5e75b228dc17ac))
* **docs:** update HOW-TOs for cloud-init ([#955](https://github.com/bpg/terraform-provider-proxmox/issues/955)) ([d91ec25](https://github.com/bpg/terraform-provider-proxmox/commit/d91ec25bfae08e6f24bb9923c0ba962792e765db))
* **vm:** regression: `sudo: command not found` when creating a VM ([#966](https://github.com/bpg/terraform-provider-proxmox/issues/966)) ([01a8f97](https://github.com/bpg/terraform-provider-proxmox/commit/01a8f9779c87a844f7d74ccaa8f9a3d4bc28bb55))


### Miscellaneous

* **ci:** update dorny/paths-filter action (v2.11.1 ‚Üí v2.12.0) ([#958](https://github.com/bpg/terraform-provider-proxmox/issues/958)) ([3a5e69d](https://github.com/bpg/terraform-provider-proxmox/commit/3a5e69d9c8e647a72b9e6141fe3e2d0f2363c991))
* **deps:** update module github.com/google/uuid (v1.5.0 ‚Üí v1.6.0) ([#954](https://github.com/bpg/terraform-provider-proxmox/issues/954)) ([b6474f8](https://github.com/bpg/terraform-provider-proxmox/commit/b6474f8ddbd8c1d3564c7d2f2bbe5a996862d443))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.17.0 ‚Üí v0.18.0) in /tools ([#957](https://github.com/bpg/terraform-provider-proxmox/issues/957)) ([4a03a78](https://github.com/bpg/terraform-provider-proxmox/commit/4a03a78dcd6d350b3a17fccabffb85b23c7f9fc3))
* **deps:** update module github.com/hashicorp/terraform-plugin-go (v0.20.0 ‚Üí v0.21.0) ([#964](https://github.com/bpg/terraform-provider-proxmox/issues/964)) ([63e7bfc](https://github.com/bpg/terraform-provider-proxmox/commit/63e7bfc042bd5f4b60f6fbf70c7fdfd344b91b05))

## [0.45.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.44.0...v0.45.0) (2024-01-22)


### Features

* **provider:** use `sudo` when running commands over SSH ([#950](https://github.com/bpg/terraform-provider-proxmox/issues/950)) ([9d764e5](https://github.com/bpg/terraform-provider-proxmox/commit/9d764e588976a5b1d35662501de2a6bc804fb693))


### Miscellaneous

* **ci:** add link checker, reformat actions code ([#944](https://github.com/bpg/terraform-provider-proxmox/issues/944)) ([a030542](https://github.com/bpg/terraform-provider-proxmox/commit/a030542da0524caa7f7bdb996892b18c78d45804))
* **ci:** update actions/create-github-app-token action (v1.6.3 ‚Üí v1.6.4) ([#939](https://github.com/bpg/terraform-provider-proxmox/issues/939)) ([25db34b](https://github.com/bpg/terraform-provider-proxmox/commit/25db34b149f29b25935ae14245fc97837bffc0d6))
* **ci:** Update google-github-actions/release-please-action action (v3.7.13 ‚Üí v4.0.2) ([#905](https://github.com/bpg/terraform-provider-proxmox/issues/905)) ([d4832b3](https://github.com/bpg/terraform-provider-proxmox/commit/d4832b3d5991c6b4610dacae7c43a31dea3f94ee))
* **ci:** update issue templates, renovate config ([#951](https://github.com/bpg/terraform-provider-proxmox/issues/951)) ([9644590](https://github.com/bpg/terraform-provider-proxmox/commit/96445909989fbb65a8a28aad4f98ce072db93e79))
* **docs:** move list of contributors to CONTRIBUTORS.md ([#945](https://github.com/bpg/terraform-provider-proxmox/issues/945)) ([aabfeb8](https://github.com/bpg/terraform-provider-proxmox/commit/aabfeb86a204bdd109b885e7e1cda84eff42d8a5))
* **docs:** update README.md, add note about OpenTofu support ([#943](https://github.com/bpg/terraform-provider-proxmox/issues/943)) ([b926c57](https://github.com/bpg/terraform-provider-proxmox/commit/b926c57a53002f955651dde8e95ac3734d453e8f))

## [0.44.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.43.3...v0.44.0) (2024-01-20)


### Features

* **lxc:** add container startup options ([#923](https://github.com/bpg/terraform-provider-proxmox/issues/923)) ([c9c3067](https://github.com/bpg/terraform-provider-proxmox/commit/c9c3067b61bf6fe7930c6d8281040aa382eac09d))
* **provider:** add min_tls option to provider config ([#931](https://github.com/bpg/terraform-provider-proxmox/issues/931)) ([01ff2cb](https://github.com/bpg/terraform-provider-proxmox/commit/01ff2cb7dba6e74e5aae51114dd13883740d028f))


### Bug Fixes

* **vm:** panic on empty `initialization.dns` block ([#928](https://github.com/bpg/terraform-provider-proxmox/issues/928)) ([e5bccbc](https://github.com/bpg/terraform-provider-proxmox/commit/e5bccbc53de66f73b95e92f00a80ba98af6becf1))


### Miscellaneous

* **deps:** update golang.org/x/exp digest (v0.0.0-20240112132812-db7319d0e0e3 ‚Üí ) ([#934](https://github.com/bpg/terraform-provider-proxmox/issues/934)) ([3ffd230](https://github.com/bpg/terraform-provider-proxmox/commit/3ffd2306828af30ffd25aaa753ed086700bd71a2))
* **deps:** update module github.com/brianvoe/gofakeit/v6 (v6.27.0 ‚Üí v6.28.0) ([#937](https://github.com/bpg/terraform-provider-proxmox/issues/937)) ([c1e9c08](https://github.com/bpg/terraform-provider-proxmox/commit/c1e9c089ba921bc522a363531cb8835dd14fc30a))
* **deps:** update module github.com/hashicorp/terraform-plugin-docs (v0.16.0 ‚Üí v0.17.0) in /tools ([#922](https://github.com/bpg/terraform-provider-proxmox/issues/922)) ([c8e298c](https://github.com/bpg/terraform-provider-proxmox/commit/c8e298cc4c6071f47fdaf90328548b5e690b674b))
* **deps:** update module go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp (v0.46.1 ‚Üí v0.47.0) in /tools ([#933](https://github.com/bpg/terraform-provider-proxmox/issues/933)) ([9326131](https://github.com/bpg/terraform-provider-proxmox/commit/932613110dc0ee0f4a6c438a910d14b64761f8a2))
* **docs:** remove static website generator with ruby dependencies ([#929](https://github.com/bpg/terraform-provider-proxmox/issues/929)) ([7d94bf7](https://github.com/bpg/terraform-provider-proxmox/commit/7d94bf73ec37bed1802cc2a37399832498ee35e7))
* **docs:** update activesupport (7.1.2 ‚Üí 7.1.3) ([#925](https://github.com/bpg/terraform-provider-proxmox/issues/925)) ([85109cb](https://github.com/bpg/terraform-provider-proxmox/commit/85109cbe3d3c2cfa8068e56978eae7a1472f9cc5))
* **docs:** update jekyll (3.9.3 ‚Üí 3.9.4) ([#921](https://github.com/bpg/terraform-provider-proxmox/issues/921)) ([93283ef](https://github.com/bpg/terraform-provider-proxmox/commit/93283ef3ab684d6155202d1fd62190a73fee1792))
* **docs:** update terraform proxmox (0.43.2 ‚Üí 0.43.3) ([#919](https://github.com/bpg/terraform-provider-proxmox/issues/919)) ([5cffafc](https://github.com/bpg/terraform-provider-proxmox/commit/5cffafc26e3d9e7b668cd53232c78006f757faea))

## [0.43.3](https://github.com/bpg/terraform-provider-proxmox/compare/v0.43.2...v0.43.3) (2024-01-16)


### Bug Fixes

* **docs:** fix indentation in `virtual_environment_container.md` ([#882](https://github.com/bpg/terraform-provider-proxmox/issues/882)) ([10dbfdd](https://github.com/bpg/terraform-provider-proxmox/commit/10dbfddc57c5dc3245b9a1827ec3f5d43f783e21))


### Miscellaneous

* **ci:** switch to renovate ([#891](https://github.com/bpg/terraform-provider-proxmox/issues/891)) ([01e6698](https://github.com/bpg/terraform-provider-proxmox/commit/01e669854bb4044afcf22144a1b6e3c4cbfe92b5))
* **ci:** update ([#890](https://github.com/bpg/terraform-provider-proxmox/issues/890)) ([c635044](https://github.com/bpg/terraform-provider-proxmox/commit/c635044db341422b458202a62538cffdaadb5fcc))
* **ci:** update dorny/paths-filter action ( v2.2.1 ‚Üí v2.11.1 ) ([#911](https://github.com/bpg/terraform-provider-proxmox/issues/911)) ([daa94d4](https://github.com/bpg/terraform-provider-proxmox/commit/daa94d4f8791d68747cf9be0dc7451fb466833bb))
* **ci:** update dorny/paths-filter digest ( 4512585 ‚Üí 3b817c9 ) ([#910](https://github.com/bpg/terraform-provider-proxmox/issues/910)) ([5574e60](https://github.com/bpg/terraform-provider-proxmox/commit/5574e60542861e5b3010f427aa295f780ce90437))
* **ci:** update renovate config ([8226c42](https://github.com/bpg/terraform-provider-proxmox/commit/8226c421f5e99fc4e8ca6254a9b0738d6395df1b))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.4.2 to 1.5.0 ([#889](https://github.com/bpg/terraform-provider-proxmox/issues/889)) ([c7bbb47](https://github.com/bpg/terraform-provider-proxmox/commit/c7bbb47223bce86a653f236841fa1285f2a5dfe5))
* **deps:** update activesupport (7.0.7.1 ‚Üí 7.1.2) ([#897](https://github.com/bpg/terraform-provider-proxmox/issues/897)) ([9a0b897](https://github.com/bpg/terraform-provider-proxmox/commit/9a0b8979befe5875b67315f231fbebc4ed7f0d63))
* **deps:** update github.com/hashicorp/go-cty digest ( d3edf31 ‚Üí 8598007 ) ([#892](https://github.com/bpg/terraform-provider-proxmox/issues/892)) ([34cb5a7](https://github.com/bpg/terraform-provider-proxmox/commit/34cb5a7c4eae16695b0e2ae84d078c783d6bf78f))
* **deps:** update golang.org/x/exp digest ( 9212866 ‚Üí db7319d ) ([#893](https://github.com/bpg/terraform-provider-proxmox/issues/893)) ([21264c0](https://github.com/bpg/terraform-provider-proxmox/commit/21264c039af6ee714006e3f6f84798ade22cf46a))
* **deps:** update jekyll (3.9.3 ‚Üí 3.9.4) ([#894](https://github.com/bpg/terraform-provider-proxmox/issues/894)) ([65f429e](https://github.com/bpg/terraform-provider-proxmox/commit/65f429e81cae3f83cf989eac4bf5d0a846459d90))
* **deps:** update just-the-docs (0.5.4 ‚Üí 0.7.0) ([#898](https://github.com/bpg/terraform-provider-proxmox/issues/898)) ([2f074d6](https://github.com/bpg/terraform-provider-proxmox/commit/2f074d6b2d5bc046036b8eaac66396ef924dc0a7))
* **deps:** update module github.com/brianvoe/gofakeit/v6 (v6.26.4 ‚Üí v6.27.0) ([#900](https://github.com/bpg/terraform-provider-proxmox/issues/900)) ([c500cc5](https://github.com/bpg/terraform-provider-proxmox/commit/c500cc5b9b54257cb8fd551034efa5a206ce84bb))
* **deps:** update module github.com/nats-io/nkeys (v0.4.6 ‚Üí v0.4.7) ([#895](https://github.com/bpg/terraform-provider-proxmox/issues/895)) ([268722c](https://github.com/bpg/terraform-provider-proxmox/commit/268722c1214627298aa1e34da5cd8d7ba73b20a2))
* **deps:** update module go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp (v0.44.0 ‚Üí v0.46.1) ([#901](https://github.com/bpg/terraform-provider-proxmox/issues/901)) ([8d5ef9a](https://github.com/bpg/terraform-provider-proxmox/commit/8d5ef9a73fbf99b112729ea34235d8c0ee259bf9))
* **deps:** update terraform local (2.2.2 ‚Üí 2.4.1) ([#902](https://github.com/bpg/terraform-provider-proxmox/issues/902)) ([c116db5](https://github.com/bpg/terraform-provider-proxmox/commit/c116db592b7b0d7dc345f84589075e1c9e679811))
* **deps:** update tzinfo-data (1.2023.3 ‚Üí 1.2023.4) ([#896](https://github.com/bpg/terraform-provider-proxmox/issues/896)) ([2edf2cb](https://github.com/bpg/terraform-provider-proxmox/commit/2edf2cbb1d5d4996c4f33f8a5be18983ffe3e9d9))
* **docs:** update terraform proxmox (0.38.1 ‚Üí 0.43.2) in docs ([#903](https://github.com/bpg/terraform-provider-proxmox/issues/903)) ([5d9f41c](https://github.com/bpg/terraform-provider-proxmox/commit/5d9f41c877e82a500da212c03cb611d5530f290a))
* **docs:** update terraform tls (3.1.0 ‚Üí 3.4.0) in docs ([#904](https://github.com/bpg/terraform-provider-proxmox/issues/904)) ([699f19d](https://github.com/bpg/terraform-provider-proxmox/commit/699f19d135529eb9772bd0dcacd8169e01abd1d7))
* **docs:** Update Terraform tls (3.4.0 ‚Üí 4.0.5) in docs ([#908](https://github.com/bpg/terraform-provider-proxmox/issues/908)) ([9e7d7d1](https://github.com/bpg/terraform-provider-proxmox/commit/9e7d7d17cb62bffcacacbfab64e2473f33d2f086))

## [0.43.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.43.1...v0.43.2) (2024-01-11)


### Bug Fixes

* **provider:** node DNS lookup fallback does not produce an IP ([#874](https://github.com/bpg/terraform-provider-proxmox/issues/874)) ([e436427](https://github.com/bpg/terraform-provider-proxmox/commit/e436427e00bd39ffe0df4ae7d6c3f445f0a0cb31))
* **vm:** missing disks when importing VM to a TF state ([#877](https://github.com/bpg/terraform-provider-proxmox/issues/877)) ([a8bf497](https://github.com/bpg/terraform-provider-proxmox/commit/a8bf497c7f3331e0c92501d479ccf04a8481e926))


### Miscellaneous

* **deps:** bump github.com/brianvoe/gofakeit/v6 from 6.26.3 to 6.26.4 ([#879](https://github.com/bpg/terraform-provider-proxmox/issues/879)) ([6aa56b3](https://github.com/bpg/terraform-provider-proxmox/commit/6aa56b3f6e7639ddd1190d84e4d53bd6c516a977))
* **deps:** bump golang.org/x/crypto from 0.17.0 to 0.18.0 ([#878](https://github.com/bpg/terraform-provider-proxmox/issues/878)) ([0f198eb](https://github.com/bpg/terraform-provider-proxmox/commit/0f198eb66b44d6aea23f6489587c404ef3d7ffdf))

## [0.43.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.43.0...v0.43.1) (2024-01-10)


### Bug Fixes

* **docs:** typos in `proxmox_virtual_environment_file` resource ([#872](https://github.com/bpg/terraform-provider-proxmox/issues/872)) ([74e0ef3](https://github.com/bpg/terraform-provider-proxmox/commit/74e0ef3b1e37c02b8671fb650b4593c378bf96d1))
* **vm:** optimize retrieval of VM volume attributes from a datastore ([#862](https://github.com/bpg/terraform-provider-proxmox/issues/862)) ([613be84](https://github.com/bpg/terraform-provider-proxmox/commit/613be842bee37eec4d0f74ddfa91a3a0bf8db43a))


### Miscellaneous

* **deps:** bump github.com/cloudflare/circl from 1.3.3 to 1.3.7 ([#869](https://github.com/bpg/terraform-provider-proxmox/issues/869)) ([ea653e1](https://github.com/bpg/terraform-provider-proxmox/commit/ea653e1f253655c0a97677376cbab8544b2a9c3c))
* **deps:** bump github.com/cloudflare/circl from 1.3.5 to 1.3.7 in /tools ([#870](https://github.com/bpg/terraform-provider-proxmox/issues/870)) ([ffafa06](https://github.com/bpg/terraform-provider-proxmox/commit/ffafa063af28e4c7b7d5180c82a937b9abd17ccb))

## [0.43.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.42.1...v0.43.0) (2024-01-04)


### Features

* **provider:** add DNS lookup fallback for node IP resolution ([#848](https://github.com/bpg/terraform-provider-proxmox/issues/848)) ([d398c9c](https://github.com/bpg/terraform-provider-proxmox/commit/d398c9c102fc2f6741b3e6d574fcfb8a4f7f49aa))
* **storage:** add new resource `proxmox_virtual_environment_download_file`  ([#837](https://github.com/bpg/terraform-provider-proxmox/issues/837)) ([58347c0](https://github.com/bpg/terraform-provider-proxmox/commit/58347c09fe012e35025613923d95c5aa8340318a))


### Miscellaneous

* **deps:** bump crazy-max/ghaction-import-gpg from 6.0.0 to 6.1.0 ([#855](https://github.com/bpg/terraform-provider-proxmox/issues/855)) ([620bb84](https://github.com/bpg/terraform-provider-proxmox/commit/620bb84635d38181e841a8d41cd8a01dd4afd83b))
* **deps:** bump github.com/goreleaser/goreleaser from 1.22.1 to 1.23.0 in /tools ([#854](https://github.com/bpg/terraform-provider-proxmox/issues/854)) ([3914bc2](https://github.com/bpg/terraform-provider-proxmox/commit/3914bc28b64decbcc853c0e6aa3188b3343ebf81))
* **docs:** update provider documentation with more details about token use ([#846](https://github.com/bpg/terraform-provider-proxmox/issues/846)) ([2677445](https://github.com/bpg/terraform-provider-proxmox/commit/2677445802bf792fbd2b92ec8120f1ddacdb299a))

## [0.42.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.42.0...v0.42.1) (2023-12-29)


### Bug Fixes

* **lxc:** add missing `onboot` param on container clone create ([#838](https://github.com/bpg/terraform-provider-proxmox/issues/838)) ([40102a6](https://github.com/bpg/terraform-provider-proxmox/commit/40102a6a501a5ead3219492f34255a25c4f21371))
* **vm,lxc:** accept IPv6 in `initialization.dns.servers` attribute ([#842](https://github.com/bpg/terraform-provider-proxmox/issues/842)) ([bf5cbd9](https://github.com/bpg/terraform-provider-proxmox/commit/bf5cbd9dad116a4515bd2eb193c296097b1e4b84))
* **vm,lxc:** unexpected state drift when using `initialization.dns.servers` ([#844](https://github.com/bpg/terraform-provider-proxmox/issues/844)) ([ac923cd](https://github.com/bpg/terraform-provider-proxmox/commit/ac923cd1b42c0c64d9829beb1ab552680b21d98b))
* **vm:** Fixed missing default for disk discard ([#840](https://github.com/bpg/terraform-provider-proxmox/issues/840)) ([5281ac2](https://github.com/bpg/terraform-provider-proxmox/commit/5281ac24921795ed933047e5d9ca953add15bdd0))


### Miscellaneous

* **deps:** bump github.com/go-git/go-git/v5 from 5.7.0 to 5.11.0 in /tools ([#839](https://github.com/bpg/terraform-provider-proxmox/issues/839)) ([f860c4b](https://github.com/bpg/terraform-provider-proxmox/commit/f860c4bab54344beb4fd54366adcf940ea1463fe))
* **tests:** Update acceptance tests to PVE 8.1, add docs ([#834](https://github.com/bpg/terraform-provider-proxmox/issues/834)) ([d8f82d4](https://github.com/bpg/terraform-provider-proxmox/commit/d8f82d47b3a74e4b64a26757522c067a635e4fa3))

## [0.42.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.41.0...v0.42.0) (2023-12-23)


### Features

* **vm, lxc:** add new `initialization.dns.servers` param to vm and container ([#832](https://github.com/bpg/terraform-provider-proxmox/issues/832)) ([16e571d](https://github.com/bpg/terraform-provider-proxmox/commit/16e571dc199c8977b3954e3c56c9b96cc351503e))
* **vm:** add new dns servers param to vm and container, deprecated server param ([16e571d](https://github.com/bpg/terraform-provider-proxmox/commit/16e571dc199c8977b3954e3c56c9b96cc351503e))
* **vm:** add support for up to 32 network interfaces ([#822](https://github.com/bpg/terraform-provider-proxmox/issues/822)) ([4113bec](https://github.com/bpg/terraform-provider-proxmox/commit/4113bec1b5184cd30c0435ae50470a8f7ab3ba39))


### Bug Fixes

* **provider:** allow FQDN for `ssh.node.address` in provider's config ([#824](https://github.com/bpg/terraform-provider-proxmox/issues/824)) ([34df977](https://github.com/bpg/terraform-provider-proxmox/commit/34df9773c34b43ba39b5d8505b5916b52f87ff3e))
* **vm:** update `smbios` during clone ([#827](https://github.com/bpg/terraform-provider-proxmox/issues/827)) ([0ffe75a](https://github.com/bpg/terraform-provider-proxmox/commit/0ffe75afa44995d4b648687281974e990029977e))


### Miscellaneous

* **deps:** bump golang.org/x/crypto from 0.14.0 to 0.17.0 in /tools ([#819](https://github.com/bpg/terraform-provider-proxmox/issues/819)) ([21a4b01](https://github.com/bpg/terraform-provider-proxmox/commit/21a4b01cd16fec6d3f04ae0e2c7eab9a021ee1e6))
* **deps:** bump golang.org/x/crypto from 0.16.0 to 0.17.0 ([#820](https://github.com/bpg/terraform-provider-proxmox/issues/820)) ([ec31d75](https://github.com/bpg/terraform-provider-proxmox/commit/ec31d75fe1a93e110f4e21108c4f69d12c9a38d7))
* **docs:** improve make example docs and add proxmox setup how-to ([#829](https://github.com/bpg/terraform-provider-proxmox/issues/829)) ([4f54f89](https://github.com/bpg/terraform-provider-proxmox/commit/4f54f89b5db4cf37321b9c021a411b747093325f))

## [0.41.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.40.0...v0.41.0) (2023-12-18)


### Features

* **vm:** add `cpu.limit` attribute ([#814](https://github.com/bpg/terraform-provider-proxmox/issues/814)) ([9712952](https://github.com/bpg/terraform-provider-proxmox/commit/9712952e2614a9af6a5a35a4cf318af44684f063))
* **vm:** support stopping (rather than shutting down) VMs on resource destroy ([#783](https://github.com/bpg/terraform-provider-proxmox/issues/783)) ([6ebe8dc](https://github.com/bpg/terraform-provider-proxmox/commit/6ebe8dcc60be12276d9f2847fb9242e93be98441))


### Bug Fixes

* **docs:** add clone/full parameter for vms ([#797](https://github.com/bpg/terraform-provider-proxmox/issues/797)) ([86d0f07](https://github.com/bpg/terraform-provider-proxmox/commit/86d0f07e9b6023d0c3627f45f9944f26d26a4e1d))
* **provider:** typo in provider example ([#785](https://github.com/bpg/terraform-provider-proxmox/issues/785)) ([32bdc21](https://github.com/bpg/terraform-provider-proxmox/commit/32bdc2175076a4a3cc89bc0ff18035fb9b8aa4d6))
* **vm:** hostpci devices not showing up in refresh plan ([#578](https://github.com/bpg/terraform-provider-proxmox/issues/578)) ([aa939c7](https://github.com/bpg/terraform-provider-proxmox/commit/aa939c731f7bc36213b6d0abc51cc284a1295338))
* **vm:** panic at read when cloud-init drive is on directory storage ([#811](https://github.com/bpg/terraform-provider-proxmox/issues/811)) ([3e0ef1d](https://github.com/bpg/terraform-provider-proxmox/commit/3e0ef1d08b036297a5d8326aedce6c43c1200bb2))


### Miscellaneous

* **deps:** bump actions/setup-go from 4 to 5 ([#791](https://github.com/bpg/terraform-provider-proxmox/issues/791)) ([164a72d](https://github.com/bpg/terraform-provider-proxmox/commit/164a72d19d9c3a952364bfbedb5a4295e2fd48ea))
* **deps:** bump actions/stale from 8 to 9 ([#790](https://github.com/bpg/terraform-provider-proxmox/issues/790)) ([02b5da7](https://github.com/bpg/terraform-provider-proxmox/commit/02b5da705da682b9325a1ac882f30993c8f96bb0))
* **deps:** bump github.com/brianvoe/gofakeit/v6 from 6.26.0 to 6.26.3 ([#807](https://github.com/bpg/terraform-provider-proxmox/issues/807)) ([1d69c69](https://github.com/bpg/terraform-provider-proxmox/commit/1d69c691acdacf062406f27e5daf993c70ed04d8))
* **deps:** bump github.com/google/uuid from 1.4.0 to 1.5.0 ([#805](https://github.com/bpg/terraform-provider-proxmox/issues/805)) ([3b4a69e](https://github.com/bpg/terraform-provider-proxmox/commit/3b4a69edfae45eaa7edb0b5bff7310f79fe542be))
* **deps:** bump github.com/hashicorp/terraform-plugin-mux from 0.12.0 to 0.13.0 ([#806](https://github.com/bpg/terraform-provider-proxmox/issues/806)) ([53270e2](https://github.com/bpg/terraform-provider-proxmox/commit/53270e23108657e0e878859950205a6dcc7e9b1c))
* **deps:** bump github.com/hashicorp/terraform-plugin-sdk/v2 from 2.30.0 to 2.31.0 ([#808](https://github.com/bpg/terraform-provider-proxmox/issues/808)) ([5c91b91](https://github.com/bpg/terraform-provider-proxmox/commit/5c91b91938e0f7e3101a3472ae3be866b3ec0f26))

## [0.40.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.39.0...v0.40.0) (2023-12-06)


### ‚ö† BREAKING CHANGES

* **lxc:** allow to update `features`, add mount type support ([#765](https://github.com/bpg/terraform-provider-proxmox/issues/765))

### Features

* **lxc:** allow to update `features`, add mount type support ([#765](https://github.com/bpg/terraform-provider-proxmox/issues/765)) ([8bf2609](https://github.com/bpg/terraform-provider-proxmox/commit/8bf26099e0da5db85f1997789cb867aa11db9906))
* **vm:** Add support for setting the VM TPM State device ([#743](https://github.com/bpg/terraform-provider-proxmox/issues/743)) ([66bba2a](https://github.com/bpg/terraform-provider-proxmox/commit/66bba2a0275e2e9e3a2c5c2de7414d89be89a53c))


### Bug Fixes

* **docs:** add more details about local testing of the provider ([#698](https://github.com/bpg/terraform-provider-proxmox/issues/698)) ([f1450cb](https://github.com/bpg/terraform-provider-proxmox/commit/f1450cb6dd13e291ce885130f0550cd26e97e99f))
* **lxc:** description is always showed as changed ([#762](https://github.com/bpg/terraform-provider-proxmox/issues/762)) ([d1f2093](https://github.com/bpg/terraform-provider-proxmox/commit/d1f2093d3977ff9d30b1af95f97e1fe601d22991))
* **lxc:** fixes for datastore-backed volume mounts ([#772](https://github.com/bpg/terraform-provider-proxmox/issues/772)) ([25deebb](https://github.com/bpg/terraform-provider-proxmox/commit/25deebba265ccea0031ea2261ee2e03f1c09f5d7))


### Miscellaneous

* configure vscode's linter to use proper .golangci.yml file ([#774](https://github.com/bpg/terraform-provider-proxmox/issues/774)) ([d0f43e1](https://github.com/bpg/terraform-provider-proxmox/commit/d0f43e1497325a5aafd915771c5da5d99f2c7ead))
* **deps:** bump github.com/brianvoe/gofakeit/v6 from 6.25.0 to 6.26.0 ([#775](https://github.com/bpg/terraform-provider-proxmox/issues/775)) ([006b5e9](https://github.com/bpg/terraform-provider-proxmox/commit/006b5e9caa51a24ae3a573abdb3bd7e21506e974))
* **docs:** update CONTRIBUTING.md and other project docs ([#771](https://github.com/bpg/terraform-provider-proxmox/issues/771)) ([7505b37](https://github.com/bpg/terraform-provider-proxmox/commit/7505b377087f08773c88819d287364c0f5be8d20))
* **docs:** update PR and issue templates ([#777](https://github.com/bpg/terraform-provider-proxmox/issues/777)) ([54288dd](https://github.com/bpg/terraform-provider-proxmox/commit/54288ddd76c4e96542921123c2f081aff51075be))

## [0.39.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.38.1...v0.39.0) (2023-11-30)


### Features

* **docs:** add initial mini-howtos for VM ([#730](https://github.com/bpg/terraform-provider-proxmox/issues/730)) ([e2717a9](https://github.com/bpg/terraform-provider-proxmox/commit/e2717a9a9ee542e7e17c0b518ccd1da78d5abdea))
* **provider:** modify the proxmox api client to support connecting through an https proxy ([#748](https://github.com/bpg/terraform-provider-proxmox/issues/748)) ([13e911c](https://github.com/bpg/terraform-provider-proxmox/commit/13e911cf592770740d88880e9e12d16f5d9bb8b6))
* **vm:** Support hook script ([#733](https://github.com/bpg/terraform-provider-proxmox/issues/733)) ([0eb04b2](https://github.com/bpg/terraform-provider-proxmox/commit/0eb04b2a250999893996ce62ea1b9109081494a7))


### Bug Fixes

* **cluster:** can't read back cluster options on PVE 8.1 ([#755](https://github.com/bpg/terraform-provider-proxmox/issues/755)) ([cd24cf2](https://github.com/bpg/terraform-provider-proxmox/commit/cd24cf238cb11c3ffb4b9e5378c52b04c6961068))
* **docs:** improve documentation for container feature flags ([#747](https://github.com/bpg/terraform-provider-proxmox/issues/747)) ([d5193b3](https://github.com/bpg/terraform-provider-proxmox/commit/d5193b3e9b0ddbaf0fde45381b2bc9d9e28bca18))
* **vm,lxc:** file ID validator to allow . in a storage name ([#750](https://github.com/bpg/terraform-provider-proxmox/issues/750)) ([a6fa40e](https://github.com/bpg/terraform-provider-proxmox/commit/a6fa40e1772dd29d919dc62be071a95b871facbd))
* **vm:** resize image once imported ([#753](https://github.com/bpg/terraform-provider-proxmox/issues/753)) ([d16b8e1](https://github.com/bpg/terraform-provider-proxmox/commit/d16b8e1696a50d5aca6bcce02a220069bfed0e87))
* **vm:** unable to clone as non-root due to `hook_script` ([#756](https://github.com/bpg/terraform-provider-proxmox/issues/756)) ([728eceb](https://github.com/bpg/terraform-provider-proxmox/commit/728eceb5e9fc342984218a0baf0155afae53fd71))


### Miscellaneous

* **deps:** bump github.com/brianvoe/gofakeit/v6 from 6.24.0 to 6.25.0 ([#741](https://github.com/bpg/terraform-provider-proxmox/issues/741)) ([9016641](https://github.com/bpg/terraform-provider-proxmox/commit/9016641c34d839ee1b5eb34892171897fac75880))
* **deps:** bump golang.org/x/crypto from 0.15.0 to 0.16.0 ([#752](https://github.com/bpg/terraform-provider-proxmox/issues/752)) ([a4ac84a](https://github.com/bpg/terraform-provider-proxmox/commit/a4ac84a78cca4b3f972d38e856adb294bb60fb2b))

## [0.38.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.38.0...v0.38.1) (2023-11-17)


### Bug Fixes

* **vm:** type error when unmarshalling `GetResponseData.data.memory` ([#728](https://github.com/bpg/terraform-provider-proxmox/issues/728)) ([b429f95](https://github.com/bpg/terraform-provider-proxmox/commit/b429f95ca578c530d08caae95228f20e57de0c03))

## [0.38.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.37.1...v0.38.0) (2023-11-17)


### Features

* **file:** rename content type `backup` -&gt; `dump` for backups ([#724](https://github.com/bpg/terraform-provider-proxmox/issues/724)) ([3280370](https://github.com/bpg/terraform-provider-proxmox/commit/3280370155ef339e5cf05ac4c94eb0e412d81d5c))
* **vm:** Add Win 11 as os type ([#720](https://github.com/bpg/terraform-provider-proxmox/issues/720)) ([0eeb7a7](https://github.com/bpg/terraform-provider-proxmox/commit/0eeb7a7fd924f4cd09e424219c532e55cc3ea721))


### Bug Fixes

* **vm:** memory size datatype conversion causing `null` on read ([#715](https://github.com/bpg/terraform-provider-proxmox/issues/715)) ([2bbf228](https://github.com/bpg/terraform-provider-proxmox/commit/2bbf228eecd4f34120f38b32102688d4b78eb220))
* **vm:** use int64 for resource memory and disk size ([#694](https://github.com/bpg/terraform-provider-proxmox/issues/694)) ([5fe6892](https://github.com/bpg/terraform-provider-proxmox/commit/5fe6892724a74906400d30a67c3047e1a0e86781))


### Miscellaneous

* **deps:** bump github.com/avast/retry-go/v4 from 4.5.0 to 4.5.1 ([#722](https://github.com/bpg/terraform-provider-proxmox/issues/722)) ([b0fea6d](https://github.com/bpg/terraform-provider-proxmox/commit/b0fea6d681301501826b95ae60e3f701e7bf79c2))
* **deps:** bump github.com/hashicorp/terraform-plugin-go from 0.19.0 to 0.19.1 ([#723](https://github.com/bpg/terraform-provider-proxmox/issues/723)) ([6c83e07](https://github.com/bpg/terraform-provider-proxmox/commit/6c83e07bdf65367f23326f8bd9f6f35cf254509f))
* **deps:** bump google-github-actions/release-please-action from 3.7.12 to 3.7.13 ([#716](https://github.com/bpg/terraform-provider-proxmox/issues/716)) ([4898d4d](https://github.com/bpg/terraform-provider-proxmox/commit/4898d4d80c352b47455431f1408366e4504ac524))

## [0.37.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.37.0...v0.37.1) (2023-11-12)


### Bug Fixes

* **docs:** add SSH info box to ressources needing it ([#690](https://github.com/bpg/terraform-provider-proxmox/issues/690)) ([e45c1c8](https://github.com/bpg/terraform-provider-proxmox/commit/e45c1c81263c723d1665c26c36d57f8c570b6ca3))
* **file:** display warning if directory is not found ([#703](https://github.com/bpg/terraform-provider-proxmox/issues/703)) ([e10b4b5](https://github.com/bpg/terraform-provider-proxmox/commit/e10b4b561793fd462f18ff1aa616b62ccfe586f2))
* **provider:** do not blindly use first IP for SSH ([#704](https://github.com/bpg/terraform-provider-proxmox/issues/704)) ([a586d03](https://github.com/bpg/terraform-provider-proxmox/commit/a586d0381e9c892b4b9aa2a0699f6c039c151ad2))
* **provider:** sanitize PVE endpoint value ([#686](https://github.com/bpg/terraform-provider-proxmox/issues/686)) ([3f582d8](https://github.com/bpg/terraform-provider-proxmox/commit/3f582d816334d4db370e8a5124f27ae4842c93f1))
* **storage:** unmarshal error when list storage containing large files ([#688](https://github.com/bpg/terraform-provider-proxmox/issues/688)) ([64c67d9](https://github.com/bpg/terraform-provider-proxmox/commit/64c67d947362e2653feaab7fa9ffb3b6016d0650))
* **vm:** update validation and docs for `machine` attribute ([#681](https://github.com/bpg/terraform-provider-proxmox/issues/681)) ([3fd6b6b](https://github.com/bpg/terraform-provider-proxmox/commit/3fd6b6b2ce36fa4bead31fa737f1137cd43cc16e))


### Miscellaneous

* **build:** add devcontainer ([#699](https://github.com/bpg/terraform-provider-proxmox/issues/699)) ([5bf9d1b](https://github.com/bpg/terraform-provider-proxmox/commit/5bf9d1b9da7359d3cc38ac123cfeb0629f215eca))
* **deps:** bump github.com/golangci/golangci-lint from 1.55.1 to 1.55.2 in /tools ([#680](https://github.com/bpg/terraform-provider-proxmox/issues/680)) ([2b8fd1a](https://github.com/bpg/terraform-provider-proxmox/commit/2b8fd1ad48540ad4552ab54b28e1d12379703c77))
* **deps:** bump github.com/goreleaser/goreleaser from 1.21.2 to 1.22.1 in /tools ([#709](https://github.com/bpg/terraform-provider-proxmox/issues/709)) ([48c89ff](https://github.com/bpg/terraform-provider-proxmox/commit/48c89ffe1327fe29ff8ccb22d298153d44d7669a))
* **deps:** bump github.com/hashicorp/terraform-plugin-sdk/v2 from 2.29.0 to 2.30.0 ([#708](https://github.com/bpg/terraform-provider-proxmox/issues/708)) ([817e43c](https://github.com/bpg/terraform-provider-proxmox/commit/817e43c912134be89c389cce1e718922ab993dde))
* **deps:** bump github.com/sigstore/cosign/v2 from 2.0.3-0.20230523133326-0544abd8fc8a to 2.2.1 in /tools ([#705](https://github.com/bpg/terraform-provider-proxmox/issues/705)) ([3e6fe4d](https://github.com/bpg/terraform-provider-proxmox/commit/3e6fe4db5598bfe475a0a844c3bd5937bc83aec3))
* **docs:** update hostpci id to mentions requirement around root user ([#710](https://github.com/bpg/terraform-provider-proxmox/issues/710)) ([0bf3a2a](https://github.com/bpg/terraform-provider-proxmox/commit/0bf3a2aea3d8d5e2821a24b3613bc44cd60b7b2d))
* **docs:** update VM ip address to mention the CIDR suffic requirement ([#697](https://github.com/bpg/terraform-provider-proxmox/issues/697)) ([d61cdc2](https://github.com/bpg/terraform-provider-proxmox/commit/d61cdc2b5c7efa50cc8228d5cebf789cc3f1cb5e))

## [0.37.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.36.0...v0.37.0) (2023-10-31)


### Features

* **vm:** add support for USB devices passthrough ([#666](https://github.com/bpg/terraform-provider-proxmox/issues/666)) ([cec4e65](https://github.com/bpg/terraform-provider-proxmox/commit/cec4e6586834feb876321520b93caf7ce4cb68d7))


### Bug Fixes

* **docs:** document qemu-guest-agent behavior ([#670](https://github.com/bpg/terraform-provider-proxmox/issues/670)) ([e2e5b4e](https://github.com/bpg/terraform-provider-proxmox/commit/e2e5b4e3441f46fbaef36751c6e5a6d1bc5ad671))
* **docs:** update `README.md` and file resource documentation ([#659](https://github.com/bpg/terraform-provider-proxmox/issues/659)) ([f6f05a5](https://github.com/bpg/terraform-provider-proxmox/commit/f6f05a56e4c9296491044ec8d5d0215a44da6f56))
* **vm:** MAC address validator should allow lowercase hex ([#660](https://github.com/bpg/terraform-provider-proxmox/issues/660)) ([7867e66](https://github.com/bpg/terraform-provider-proxmox/commit/7867e66d531484815b529fcdf0b8607fa837dc89))


### Miscellaneous

* **deps:** bump github.com/docker/docker from 24.0.2+incompatible to 24.0.7+incompatible in /tools ([#667](https://github.com/bpg/terraform-provider-proxmox/issues/667)) ([aea4a6f](https://github.com/bpg/terraform-provider-proxmox/commit/aea4a6f1cb0848a3274799dc605446c96dc192df))
* **deps:** bump github.com/golangci/golangci-lint from 1.55.0 to 1.55.1 in /tools ([#664](https://github.com/bpg/terraform-provider-proxmox/issues/664)) ([6ab1d5f](https://github.com/bpg/terraform-provider-proxmox/commit/6ab1d5fffbe265291e2991db162fb68fd1b50b02))
* **deps:** bump github.com/google/uuid from 1.3.1 to 1.4.0 ([#662](https://github.com/bpg/terraform-provider-proxmox/issues/662)) ([0ec8c24](https://github.com/bpg/terraform-provider-proxmox/commit/0ec8c2498b56a7f3d206409590f943e6764f8586))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.4.1 to 1.4.2 ([#663](https://github.com/bpg/terraform-provider-proxmox/issues/663)) ([b389080](https://github.com/bpg/terraform-provider-proxmox/commit/b38908063f523fc5738a9e1c987b848b80ecb5d3))

## [0.36.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.35.1...v0.36.0) (2023-10-26)


### Features

* **vm:** add configurable timeout for VM create operation ([#648](https://github.com/bpg/terraform-provider-proxmox/issues/648)) ([a30f96c](https://github.com/bpg/terraform-provider-proxmox/commit/a30f96c348888522ca9278d8fef4bd9b12b1b634))


### Bug Fixes

* **file:** handle missing file on state refresh ([#649](https://github.com/bpg/terraform-provider-proxmox/issues/649)) ([2a56c23](https://github.com/bpg/terraform-provider-proxmox/commit/2a56c23f52abda293f328196a0d80b9becd749a7))
* **vm:** better handle of ctrl+c when qemu is not responding  ([#627](https://github.com/bpg/terraform-provider-proxmox/issues/627)) ([aec09e4](https://github.com/bpg/terraform-provider-proxmox/commit/aec09e4ecd8f9df937a04845162a679098f0c480))


### Miscellaneous

* **deps:** bump github.com/brianvoe/gofakeit/v6 from 6.23.2 to 6.24.0 ([#642](https://github.com/bpg/terraform-provider-proxmox/issues/642)) ([72951dc](https://github.com/bpg/terraform-provider-proxmox/commit/72951dc65691bdb44bae5f31b218a31811ffdfb7))
* **deps:** bump google.golang.org/grpc from 1.57.0 to 1.57.1 ([#652](https://github.com/bpg/terraform-provider-proxmox/issues/652)) ([4740da0](https://github.com/bpg/terraform-provider-proxmox/commit/4740da0d1f413743c252be963f7b6252ed3f0d96))
* **deps:** bump google.golang.org/grpc from 1.57.0 to 1.57.1 in /tools ([#653](https://github.com/bpg/terraform-provider-proxmox/issues/653)) ([db9140d](https://github.com/bpg/terraform-provider-proxmox/commit/db9140d05ef71753c8a8e1310c259717fef6e417))
* fix linter error ([#645](https://github.com/bpg/terraform-provider-proxmox/issues/645)) ([1056180](https://github.com/bpg/terraform-provider-proxmox/commit/1056180ca571ef171870be5e864461fb49732bdf))

## [0.35.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.35.0...v0.35.1) (2023-10-22)


### Bug Fixes

* **vm:** better check for disk ownership ([#633](https://github.com/bpg/terraform-provider-proxmox/issues/633)) ([6753582](https://github.com/bpg/terraform-provider-proxmox/commit/6753582e4b1999fdf2fd9ea0f499c0cd0f7cd64c))
* **vm:** set FileVolume for disks with file_id ([#635](https://github.com/bpg/terraform-provider-proxmox/issues/635)) ([d1d7bd3](https://github.com/bpg/terraform-provider-proxmox/commit/d1d7bd39c741d99b2395ef858bf739cb067f0542))


### Miscellaneous

* **deps:** bump github.com/golangci/golangci-lint from 1.54.2 to 1.55.0 in /tools ([#636](https://github.com/bpg/terraform-provider-proxmox/issues/636)) ([bcd33bb](https://github.com/bpg/terraform-provider-proxmox/commit/bcd33bb139d20ea4986d7dadf145e6ebbe497e79))

## [0.35.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.34.0...v0.35.0) (2023-10-17)


### Features

* **vm:** add 'path_in_datastore' disk argument ([#606](https://github.com/bpg/terraform-provider-proxmox/issues/606)) ([aeb5e88](https://github.com/bpg/terraform-provider-proxmox/commit/aeb5e88bc9112686675c7058501fa9378b69af93))


### Bug Fixes

* **lxc:** unmarshal string/int vmid as int when read container status ([#622](https://github.com/bpg/terraform-provider-proxmox/issues/622)) ([b90445a](https://github.com/bpg/terraform-provider-proxmox/commit/b90445a12c31c970c1cd1d2f37508ffcee586bf8))
* **provider:** add informative error around ssh-agent  ([#620](https://github.com/bpg/terraform-provider-proxmox/issues/620)) ([388ce7c](https://github.com/bpg/terraform-provider-proxmox/commit/388ce7ce8d37964da427d2430c9e03b14f790856))


### Miscellaneous

* **deps:** bump github.com/google/go-cmp from 0.5.9 to 0.6.0 ([#624](https://github.com/bpg/terraform-provider-proxmox/issues/624)) ([21e48c7](https://github.com/bpg/terraform-provider-proxmox/commit/21e48c7fb8aef8b5f5a48fea76ca9a030ccd59cc))
* **deps:** bump golang.org/x/net from 0.13.0 to 0.17.0 ([#616](https://github.com/bpg/terraform-provider-proxmox/issues/616)) ([29894bd](https://github.com/bpg/terraform-provider-proxmox/commit/29894bda234baca2645fc5e0d5d6f05101406b18))
* **deps:** bump golang.org/x/net from 0.15.0 to 0.17.0 in /tools ([#617](https://github.com/bpg/terraform-provider-proxmox/issues/617)) ([7287f5d](https://github.com/bpg/terraform-provider-proxmox/commit/7287f5de4801d0f56faa8e3b99c80d41ac2f1f01))

## [0.34.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.33.0...v0.34.0) (2023-10-10)


### Features

* **lxc:** add support for the `start_on_boot` option ([#605](https://github.com/bpg/terraform-provider-proxmox/issues/605)) ([d36cf4e](https://github.com/bpg/terraform-provider-proxmox/commit/d36cf4eab81955184c926c86ce692bcf6c01b840))
* **provider:** configure temp directory ([#607](https://github.com/bpg/terraform-provider-proxmox/issues/607)) ([06ad004](https://github.com/bpg/terraform-provider-proxmox/commit/06ad00463c8ec0426f72a559924e6a0adfe4e2a8))
* **vm:** add option to enable multiqueue in network devices ([#614](https://github.com/bpg/terraform-provider-proxmox/issues/614)) ([be5251d](https://github.com/bpg/terraform-provider-proxmox/commit/be5251dd5ad535be6bdf8f9ef73c43f54a9dc2c7))


### Bug Fixes

* **lxc:** cloned container does not start by default ([#615](https://github.com/bpg/terraform-provider-proxmox/issues/615)) ([d5994a2](https://github.com/bpg/terraform-provider-proxmox/commit/d5994a2bd5323cef34b71f3fea895539a0cfccd8))
* **lxc:** create container when authenticated with API token ([#610](https://github.com/bpg/terraform-provider-proxmox/issues/610)) ([32bdc94](https://github.com/bpg/terraform-provider-proxmox/commit/32bdc94167253b7b3ec6eaecbccc2d2cc0104b61))
* **lxc:** multi-line description always shows as changed ([#611](https://github.com/bpg/terraform-provider-proxmox/issues/611)) ([088ad09](https://github.com/bpg/terraform-provider-proxmox/commit/088ad09e356e1baf17b7cb84656155d192d2909d))


### Miscellaneous

* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.4.0 to 1.4.1 ([#612](https://github.com/bpg/terraform-provider-proxmox/issues/612)) ([a266496](https://github.com/bpg/terraform-provider-proxmox/commit/a266496fcbf9c044712896ea1af5827f47869be1))
* **deps:** bump golang.org/x/crypto from 0.13.0 to 0.14.0 ([#613](https://github.com/bpg/terraform-provider-proxmox/issues/613)) ([0150a97](https://github.com/bpg/terraform-provider-proxmox/commit/0150a97cd4a2489311db943459f7d41b8ef8e61e))

## [0.33.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.32.2...v0.33.0) (2023-10-02)


### Features

* **file:** add optional `overwrite` flag to the file resource ([#593](https://github.com/bpg/terraform-provider-proxmox/issues/593)) ([5e24a75](https://github.com/bpg/terraform-provider-proxmox/commit/5e24a75d09b930aef07a067b37be0507c1948de1))
* **vm:** allow `scsi` and `sata` interfaces for CloudInit Drive ([#598](https://github.com/bpg/terraform-provider-proxmox/issues/598)) ([0b8f2e2](https://github.com/bpg/terraform-provider-proxmox/commit/0b8f2e2c6f80b0370290e6b32ba1e7add977018c))


### Bug Fixes

* **api:** set min TLS version 1.3, secure HTTP-only cookie ([#596](https://github.com/bpg/terraform-provider-proxmox/issues/596)) ([16ebf30](https://github.com/bpg/terraform-provider-proxmox/commit/16ebf30a79e8e3cc2df48787b210fd78950f8260))


### Miscellaneous

* **ci:** cleanup CI flows ([#595](https://github.com/bpg/terraform-provider-proxmox/issues/595)) ([bd09fd3](https://github.com/bpg/terraform-provider-proxmox/commit/bd09fd3d6ec954e6d2c8d01e51050faf5677d422))

## [0.32.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.32.1...v0.32.2) (2023-09-28)


### Bug Fixes

* **tasks:** fix UPID (task id) parsing error ([#591](https://github.com/bpg/terraform-provider-proxmox/issues/591)) ([294a9da](https://github.com/bpg/terraform-provider-proxmox/commit/294a9daa8711f7a2dbb054f1de750bf9f1bb4f3a))


### Miscellaneous

* **deps:** bump github.com/goreleaser/goreleaser from 1.20.0 to 1.21.0 in /tools ([#587](https://github.com/bpg/terraform-provider-proxmox/issues/587)) ([2573323](https://github.com/bpg/terraform-provider-proxmox/commit/257332393f48dc2c5367c8934923bea28964ffdc))
* **deps:** bump github.com/goreleaser/goreleaser from 1.21.0 to 1.21.2 in /tools ([#592](https://github.com/bpg/terraform-provider-proxmox/issues/592)) ([2621aad](https://github.com/bpg/terraform-provider-proxmox/commit/2621aadb5f089a88b6ddf027ce906c20031ee2a0))

## [0.32.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.32.0...v0.32.1) (2023-09-23)


### Bug Fixes

* **cluster:** inconsistencies in applying cluster options ([#573](https://github.com/bpg/terraform-provider-proxmox/issues/573)) ([03f3ed7](https://github.com/bpg/terraform-provider-proxmox/commit/03f3ed7871e2a2fe653d6cfe9dcb28196738e1e2))
* **network:** remove computed flag from mtu attribute ([#572](https://github.com/bpg/terraform-provider-proxmox/issues/572)) ([5720fe4](https://github.com/bpg/terraform-provider-proxmox/commit/5720fe4673873166e7dbf7bc687b57837b99b117))


### Miscellaneous

* **code:** bump go to v1.21 ([#585](https://github.com/bpg/terraform-provider-proxmox/issues/585)) ([11c0940](https://github.com/bpg/terraform-provider-proxmox/commit/11c09405ea2f6d9dfc28191ce50739f811b5f0c4))
* **code:** re-organize and cleanup "fwk provider"'s code ([#568](https://github.com/bpg/terraform-provider-proxmox/issues/568)) ([7d064a8](https://github.com/bpg/terraform-provider-proxmox/commit/7d064a8b27d78a1564c9da914f17340966d955d1))
* **deps:** bump github.com/skeema/knownhosts from 1.2.0 to 1.2.1 ([#584](https://github.com/bpg/terraform-provider-proxmox/issues/584)) ([7890212](https://github.com/bpg/terraform-provider-proxmox/commit/7890212a566036bf448f4db149a7f8816de187ab))
* **docs:** add "Proof of Work" section to the PR template ([#583](https://github.com/bpg/terraform-provider-proxmox/issues/583)) ([de1eb2b](https://github.com/bpg/terraform-provider-proxmox/commit/de1eb2b950ae6a001ad07a93f27a90858500749b))
* **docs:** add a note about DCO to CONTRIBUTING.md ([#574](https://github.com/bpg/terraform-provider-proxmox/issues/574)) ([d0c9b45](https://github.com/bpg/terraform-provider-proxmox/commit/d0c9b4594d46c327b5a0f09288ac5b88a48af61e))
* **docs:** update `proxmox_virtual_environment_file` documentation ([#580](https://github.com/bpg/terraform-provider-proxmox/issues/580)) ([7dde53c](https://github.com/bpg/terraform-provider-proxmox/commit/7dde53cf1cee1127cecb86cab3b6e75331410c56))

## [0.32.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.31.0...v0.32.0) (2023-09-13)


### Features

* **cluster:** add cluster options resource ([#548](https://github.com/bpg/terraform-provider-proxmox/issues/548)) ([de8b4ec](https://github.com/bpg/terraform-provider-proxmox/commit/de8b4ec41ada527b5a14883b5dcacdab2684fc37))


### Bug Fixes

* **lxc,vm:** error unmarshalling string `cpulimit` ([#563](https://github.com/bpg/terraform-provider-proxmox/issues/563)) ([11a8ec0](https://github.com/bpg/terraform-provider-proxmox/commit/11a8ec0c9594c1b9ff305edcd47f090309bc1466))


### Miscellaneous

* **ci:** cleanup and update project configs ([#549](https://github.com/bpg/terraform-provider-proxmox/issues/549)) ([edec5bf](https://github.com/bpg/terraform-provider-proxmox/commit/edec5bfd1cc25886fa36e1344a6de4a6d2427786))
* **code:** remove redundant `types2` import aliases ([#564](https://github.com/bpg/terraform-provider-proxmox/issues/564)) ([2dee65b](https://github.com/bpg/terraform-provider-proxmox/commit/2dee65bd0b872b795f559530cbd5b12c856e5771))
* **deps:** bump crazy-max/ghaction-import-gpg from 5 to 6 ([#558](https://github.com/bpg/terraform-provider-proxmox/issues/558)) ([1f8330a](https://github.com/bpg/terraform-provider-proxmox/commit/1f8330afc7f189964ab09fa652b39e2123e6187e))
* **deps:** bump github.com/hashicorp/terraform-plugin-* dependencies ([#561](https://github.com/bpg/terraform-provider-proxmox/issues/561)) ([3d7fbaa](https://github.com/bpg/terraform-provider-proxmox/commit/3d7fbaa7c7f8ce7a1cedf1dae3d31fceecad5ea1))
* **deps:** bump golang.org/x/crypto from 0.12.0 to 0.13.0 ([#554](https://github.com/bpg/terraform-provider-proxmox/issues/554)) ([1040aab](https://github.com/bpg/terraform-provider-proxmox/commit/1040aabb23d6eb7ff3841315aa5f608b24437e26))
* **deps:** bump goreleaser/goreleaser-action from 4.4.0 to 5.0.0 ([#560](https://github.com/bpg/terraform-provider-proxmox/issues/560)) ([ac556b5](https://github.com/bpg/terraform-provider-proxmox/commit/ac556b55150d271c098916b2134d3991f765891a))

## [0.31.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.30.3...v0.31.0) (2023-09-04)


### Features

* **file:** FORMAT CHANGE: update import id, so it matches the resource's format: `&lt;node_name&gt;/<datastore_id>:<content_type>/<file>` ([#543](https://github.com/bpg/terraform-provider-proxmox/issues/543)) ([7ace07d](https://github.com/bpg/terraform-provider-proxmox/commit/7ace07dfa47c4a6750973d04cb8d853fc9640047))
* **lxc:** add support for `keyctl` and `fuse` features ([#537](https://github.com/bpg/terraform-provider-proxmox/issues/537)) ([8ce9006](https://github.com/bpg/terraform-provider-proxmox/commit/8ce9006eed15dadc6f051464b8b98e3a1abd7d6d))
* **provider:** add optional SSH port param to node in provider ssh block ([#520](https://github.com/bpg/terraform-provider-proxmox/issues/520)) ([124cac2](https://github.com/bpg/terraform-provider-proxmox/commit/124cac247ce34e2603b0d1c1c94106d958185708))


### Bug Fixes

* **provider:** panic crash in provider, interface conversion error ([#545](https://github.com/bpg/terraform-provider-proxmox/issues/545)) ([13326bb](https://github.com/bpg/terraform-provider-proxmox/commit/13326bbd33648391f0f87d339db272145e3066ac))
* **vm:** explicitly allow `""` as a value for CloudInit interfaces ([#546](https://github.com/bpg/terraform-provider-proxmox/issues/546)) ([0233053](https://github.com/bpg/terraform-provider-proxmox/commit/0233053dd8f8aa0fbfae8f7c11bb8ce359576bce))


### Miscellaneous

* **code:** fix `proxmox` package dependencies ([#536](https://github.com/bpg/terraform-provider-proxmox/issues/536)) ([5ecf135](https://github.com/bpg/terraform-provider-proxmox/commit/5ecf13539862bb9602696a7575568f228fc85e29))
* **deps:** bump actions/checkout from 3 to 4 ([#541](https://github.com/bpg/terraform-provider-proxmox/issues/541)) ([44d6d6b](https://github.com/bpg/terraform-provider-proxmox/commit/44d6d6b080c534ad16b3d9911ae445d4e16acfa3))

## [0.30.3](https://github.com/bpg/terraform-provider-proxmox/compare/v0.30.2...v0.30.3) (2023-09-01)


### Bug Fixes

* **file:** file upload in multi-node PVE cluster ([#533](https://github.com/bpg/terraform-provider-proxmox/issues/533)) ([ef2f2c1](https://github.com/bpg/terraform-provider-proxmox/commit/ef2f2c115976dfd97de2ce557be899927672f4b8))

## [0.30.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.30.1...v0.30.2) (2023-08-31)


### Bug Fixes

* **core:** improve error handling while waiting for PVE tasks to complete ([#526](https://github.com/bpg/terraform-provider-proxmox/issues/526)) ([6f02df4](https://github.com/bpg/terraform-provider-proxmox/commit/6f02df4440566ed1d97e0c6d016311b91bd53125))
* **file:** forced replacement of file resources that missing `timeout_upload` attribute ([#528](https://github.com/bpg/terraform-provider-proxmox/issues/528)) ([11d8261](https://github.com/bpg/terraform-provider-proxmox/commit/11d82614e628d24d9ee8db5cccc33427bf5a811c))
* **node:** creating linux_bridge with 'vlan_aware=false' or 'autostart=false' ([#529](https://github.com/bpg/terraform-provider-proxmox/issues/529)) ([f00e48a](https://github.com/bpg/terraform-provider-proxmox/commit/f00e48a51e1618bccf1d1800590b81696db15071))
* **provider:** User-settable VLAN ID and name ([#518](https://github.com/bpg/terraform-provider-proxmox/issues/518)) ([5599c7a](https://github.com/bpg/terraform-provider-proxmox/commit/5599c7afe45dbea217457b1452186c02b07db90f))


### Miscellaneous

* **deps:** bump activesupport from 7.0.6 to 7.0.7.1 in /docs ([#522](https://github.com/bpg/terraform-provider-proxmox/issues/522)) ([cd7927b](https://github.com/bpg/terraform-provider-proxmox/commit/cd7927bec347f22ecce500147866fbe01e742b51))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework-validators from 0.11.0 to 0.12.0 ([#530](https://github.com/bpg/terraform-provider-proxmox/issues/530)) ([e35443a](https://github.com/bpg/terraform-provider-proxmox/commit/e35443a23b9528290952c24db573971d115e9877))
* **deps:** bump github.com/hashicorp/terraform-plugin-sdk/v2 from 2.27.0 to 2.28.0 ([#524](https://github.com/bpg/terraform-provider-proxmox/issues/524)) ([5556b17](https://github.com/bpg/terraform-provider-proxmox/commit/5556b17a1ed1e4e92343d17d534461348d3da30c))

## [0.30.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.30.0...v0.30.1) (2023-08-22)


### Bug Fixes

* **vm:** fix PCI device resource mapping changed ([#517](https://github.com/bpg/terraform-provider-proxmox/issues/517)) ([b1ac87d](https://github.com/bpg/terraform-provider-proxmox/commit/b1ac87df1df96a9172fee7cb4aa5934c6afb4ef1))


### Miscellaneous

* **deps:** bump github.com/golangci/golangci-lint from 1.54.1 to 1.54.2 in /tools ([#514](https://github.com/bpg/terraform-provider-proxmox/issues/514)) ([731dad8](https://github.com/bpg/terraform-provider-proxmox/commit/731dad87945335ebd3f897ff747edfc3e30607c4))
* **deps:** bump github.com/google/uuid from 1.3.0 to 1.3.1 ([#515](https://github.com/bpg/terraform-provider-proxmox/issues/515)) ([79c7f10](https://github.com/bpg/terraform-provider-proxmox/commit/79c7f100f6cfd2ea52d50aa69b92f5c99a0deded))

## [0.30.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.29.0...v0.30.0) (2023-08-21)


### Features

* **ha:** add support for Proxmox High Availability objects ([#498](https://github.com/bpg/terraform-provider-proxmox/issues/498)) ([03c9b36](https://github.com/bpg/terraform-provider-proxmox/commit/03c9b36b86914583c1709e99db305682b7b7dc99))
* **vm:** add support for migration when the node name is modified ([#501](https://github.com/bpg/terraform-provider-proxmox/issues/501)) ([a285360](https://github.com/bpg/terraform-provider-proxmox/commit/a2853606ad294476e9b5f17a994cb230643e9277))
* **vm:** add support for non-default CloudInit interface and CloudInit storage change ([#486](https://github.com/bpg/terraform-provider-proxmox/issues/486)) ([5475936](https://github.com/bpg/terraform-provider-proxmox/commit/547593661f5bcab1141edc9a7203dca65c6b539d))
* **vm:** add support for pool update ([#505](https://github.com/bpg/terraform-provider-proxmox/issues/505)) ([e6c15ec](https://github.com/bpg/terraform-provider-proxmox/commit/e6c15eccc6fd2076afb2f521e28f27976abba892))
* **vm:** fix adding/removing hostpci devices forcing vm recreation ([#504](https://github.com/bpg/terraform-provider-proxmox/issues/504)) ([a038fd3](https://github.com/bpg/terraform-provider-proxmox/commit/a038fd31420fe23963c7d68198ed5f40b6583058))
* **vm:** support PCI device resource mapping ([#500](https://github.com/bpg/terraform-provider-proxmox/issues/500)) ([2697054](https://github.com/bpg/terraform-provider-proxmox/commit/26970541c48495b7b9fd220960c83f54956e8132))


### Bug Fixes

* **vm:** fix CloudInit datastore change support ([#509](https://github.com/bpg/terraform-provider-proxmox/issues/509)) ([73c1294](https://github.com/bpg/terraform-provider-proxmox/commit/73c1294979b956939b755ac05796fb1a68f92f75))
* **vm:** fix index out of range when unmarshalling custompcidevice ([#496](https://github.com/bpg/terraform-provider-proxmox/issues/496)) ([78d6683](https://github.com/bpg/terraform-provider-proxmox/commit/78d668377f383badd8a53a18dbd4cb65e67176c2))
* **vm:** fixed startup / shutdown behaviour on HA clusters ([#508](https://github.com/bpg/terraform-provider-proxmox/issues/508)) ([148a9e0](https://github.com/bpg/terraform-provider-proxmox/commit/148a9e0c9c3f8d78645846b39646ad7d8c78c4a5))
* **vm:** no IP address detection when VM contains bridges ([#493](https://github.com/bpg/terraform-provider-proxmox/issues/493)) ([9fd9d21](https://github.com/bpg/terraform-provider-proxmox/commit/9fd9d211d75e760ef1c7e44d13de9ce8d38bf834))


### Miscellaneous

* **deps:** bump github.com/golangci/golangci-lint from 1.54.0 to 1.54.1 in /tools ([#489](https://github.com/bpg/terraform-provider-proxmox/issues/489)) ([e4f9888](https://github.com/bpg/terraform-provider-proxmox/commit/e4f9888f6f6db835d425e52878631517ef4d5e14))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.3.4 to 1.3.5 ([#512](https://github.com/bpg/terraform-provider-proxmox/issues/512)) ([98ae6a8](https://github.com/bpg/terraform-provider-proxmox/commit/98ae6a8d8f489b98c05d88598594d43c004b6316))
* **deps:** bump github.com/pkg/sftp from 1.13.5 to 1.13.6 ([#488](https://github.com/bpg/terraform-provider-proxmox/issues/488)) ([9045183](https://github.com/bpg/terraform-provider-proxmox/commit/9045183c1dd18ba2ebd3c1afcd7c16e73213bf27))
* **vm:** fix linter errors ([#506](https://github.com/bpg/terraform-provider-proxmox/issues/506)) ([1896ea0](https://github.com/bpg/terraform-provider-proxmox/commit/1896ea08f09ec4e684a886d11a5915c6e573eac1))

## [0.29.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.28.0...v0.29.0) (2023-08-10)


### Features

* **file:** ensure upload of ISO/VSTMPL is completed upon resource creation ([#471](https://github.com/bpg/terraform-provider-proxmox/issues/471)) ([f901e71](https://github.com/bpg/terraform-provider-proxmox/commit/f901e711dd4e8cd59b3a1e34c58a1a03564bd13a))


### Bug Fixes

* **user:** make `password` attribute optional ([#474](https://github.com/bpg/terraform-provider-proxmox/issues/474)) ([244e061](https://github.com/bpg/terraform-provider-proxmox/commit/244e061779f05752bd0760ea6b5a15c869e26505))
* **vm:** default disk cache is not set to `none` if not specified for an existing disk ([#478](https://github.com/bpg/terraform-provider-proxmox/issues/478)) ([8d0b3ed](https://github.com/bpg/terraform-provider-proxmox/commit/8d0b3ed25fa1c2dcc0d319d725aea34f3e18aef8))
* **vm:** ensure startup / shutdown delay is applied when order is not configured ([#479](https://github.com/bpg/terraform-provider-proxmox/issues/479)) ([2cf64b8](https://github.com/bpg/terraform-provider-proxmox/commit/2cf64b88c35991db19f83a1fa69ed41cbceebd32))


### Miscellaneous

* **deps-dev:** bump commonmarker from 0.23.9 to 0.23.10 in /docs ([#472](https://github.com/bpg/terraform-provider-proxmox/issues/472)) ([2e16fbb](https://github.com/bpg/terraform-provider-proxmox/commit/2e16fbb44bf45e58c9296d1e1e28d3fbea9d732c))
* **deps:** bump github.com/golangci/golangci-lint from 1.53.3 to 1.54.0 in /tools ([#482](https://github.com/bpg/terraform-provider-proxmox/issues/482)) ([390f03c](https://github.com/bpg/terraform-provider-proxmox/commit/390f03c1590725d7f89a1f38c3848269bbe4c402))
* **deps:** bump github.com/goreleaser/goreleaser from 1.19.2 to 1.20.0 in /tools ([#481](https://github.com/bpg/terraform-provider-proxmox/issues/481)) ([eb3d847](https://github.com/bpg/terraform-provider-proxmox/commit/eb3d8473acd593ef0e876b711c3ffc3441fc4b54))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.3.3 to 1.3.4 ([#466](https://github.com/bpg/terraform-provider-proxmox/issues/466)) ([8a5a533](https://github.com/bpg/terraform-provider-proxmox/commit/8a5a53301b3e2e7ecad9322c80f2700726ea0504))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework-validators from 0.10.0 to 0.11.0 ([#467](https://github.com/bpg/terraform-provider-proxmox/issues/467)) ([7c9e3ed](https://github.com/bpg/terraform-provider-proxmox/commit/7c9e3ed1afaa3bf50b78be1aefd77cc76fc3d06d))
* **deps:** bump golang.org/x/crypto from 0.11.0 to 0.12.0 ([#465](https://github.com/bpg/terraform-provider-proxmox/issues/465)) ([185e98f](https://github.com/bpg/terraform-provider-proxmox/commit/185e98fe802119ab0de53bb2eeb34d7510517475))
* **deps:** bump goreleaser/goreleaser-action from 4.3.0 to 4.4.0 ([#480](https://github.com/bpg/terraform-provider-proxmox/issues/480)) ([a7047da](https://github.com/bpg/terraform-provider-proxmox/commit/a7047dac7269143ce833da1310ca6f03646ccbf1))

## [0.28.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.27.0...v0.28.0) (2023-08-06)


### Features

* **vm:** add support for SMBIOS settings ([#454](https://github.com/bpg/terraform-provider-proxmox/issues/454)) ([85ff60d](https://github.com/bpg/terraform-provider-proxmox/commit/85ff60d4bd928880eebeb6bbd9440a65a3e2cc9d))


### Bug Fixes

* **api:** remove HTTP client timeout ([#464](https://github.com/bpg/terraform-provider-proxmox/issues/464)) ([824e51c](https://github.com/bpg/terraform-provider-proxmox/commit/824e51c6508fe0e5905b143ef6d8dd161b1acbfe))
* **user:** make `password` attribute optional ([#463](https://github.com/bpg/terraform-provider-proxmox/issues/463)) ([5a3b1cc](https://github.com/bpg/terraform-provider-proxmox/commit/5a3b1ccaf703db260ba25e564c04506ea0de6247))
* **vm:** give `cache` the correct default value ([#450](https://github.com/bpg/terraform-provider-proxmox/issues/450)) ([0d3227a](https://github.com/bpg/terraform-provider-proxmox/commit/0d3227a890b4df12ecb71fbd3215e5f1d4babff8))


### Miscellaneous

* **doc:** add all-contributors to README.md ([#455](https://github.com/bpg/terraform-provider-proxmox/issues/455)) ([d885e64](https://github.com/bpg/terraform-provider-proxmox/commit/d885e643728c1da30deca3f26150a57ba75593db))
* **doc:** add existing contributors ([#459](https://github.com/bpg/terraform-provider-proxmox/issues/459)) ([cb71d73](https://github.com/bpg/terraform-provider-proxmox/commit/cb71d731f1903ec9fbfa2eb5d4b78c53c961f86f))
* **doc:** cleanup readme ([#461](https://github.com/bpg/terraform-provider-proxmox/issues/461)) ([368b133](https://github.com/bpg/terraform-provider-proxmox/commit/368b133427e14753b287469b814591141126913d))

## [0.27.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.26.0...v0.27.0) (2023-07-30)


### Features

* **vm:** add support for disk `cache` option ([#443](https://github.com/bpg/terraform-provider-proxmox/issues/443)) ([cfe3d96](https://github.com/bpg/terraform-provider-proxmox/commit/cfe3d96576b521cb294f217fb3f7caf45347e58e))
* **vm:** add support for start/shutdown order configuration ([#445](https://github.com/bpg/terraform-provider-proxmox/issues/445)) ([b045746](https://github.com/bpg/terraform-provider-proxmox/commit/b045746a94d2717b69fc48234b9ece101b53bdcd))


### Bug Fixes

* **vm:** cloned VM with `efi_disk` got re-created at re-apply ([#447](https://github.com/bpg/terraform-provider-proxmox/issues/447)) ([c1e7cea](https://github.com/bpg/terraform-provider-proxmox/commit/c1e7cea21ed7d49375de8850f9cd3737d485c3d2))


### Miscellaneous

* update dependencies, cleanup docs ([#446](https://github.com/bpg/terraform-provider-proxmox/issues/446)) ([a3b95c8](https://github.com/bpg/terraform-provider-proxmox/commit/a3b95c80536c7b69ab5b4c10e434d410ec5e05e5))

## [0.26.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.25.0...v0.26.0) (2023-07-29)


### Features

* **core:** migrate `version` datasource to TF plugin framework ([#440](https://github.com/bpg/terraform-provider-proxmox/issues/440)) ([a9a7329](https://github.com/bpg/terraform-provider-proxmox/commit/a9a7329d9fef42466f6fe2a7eeff9645100459c6))


### Miscellaneous

* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.3.2 to 1.3.3 ([#439](https://github.com/bpg/terraform-provider-proxmox/issues/439)) ([d82a08d](https://github.com/bpg/terraform-provider-proxmox/commit/d82a08dcb434e3b2aa0241332aeb3b43eac372d1))
* **docs:** Update README.md  ([#442](https://github.com/bpg/terraform-provider-proxmox/issues/442)) ([8e2d180](https://github.com/bpg/terraform-provider-proxmox/commit/8e2d18053f0fca807ecd81cbf2c4a3b5169f0d49))

## [0.25.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.24.2...v0.25.0) (2023-07-20)


### Features

* **lxc:** add support for lxc mount points ([#394](https://github.com/bpg/terraform-provider-proxmox/issues/394)) ([beef9b1](https://github.com/bpg/terraform-provider-proxmox/commit/beef9b1219dc078cc7a3adeae9e6162235c603f8))


### Bug Fixes

* **vm:** Don't add an extra efi_disk entry ([#435](https://github.com/bpg/terraform-provider-proxmox/issues/435)) ([6781c03](https://github.com/bpg/terraform-provider-proxmox/commit/6781c03ca1eb794ed9e5ab322e1b73d57969b721))
* **vm:** fix for the api call upon empty disks ([#436](https://github.com/bpg/terraform-provider-proxmox/issues/436)) ([aea9846](https://github.com/bpg/terraform-provider-proxmox/commit/aea9846c6f5399d721458f21e94f253922103432))


### Miscellaneous

* cleanup resource validators & utility code ([#438](https://github.com/bpg/terraform-provider-proxmox/issues/438)) ([b2a27f3](https://github.com/bpg/terraform-provider-proxmox/commit/b2a27f3ccfa6e318d2243bae2c855f47e5523240))
* **deps:** bump github.com/hashicorp/terraform-plugin-mux from 0.11.1 to 0.11.2 ([#432](https://github.com/bpg/terraform-provider-proxmox/issues/432)) ([4324b29](https://github.com/bpg/terraform-provider-proxmox/commit/4324b294239bca04de550027402deabe1e6f1615))
* **deps:** bump github.com/skeema/knownhosts from 1.1.1 to 1.2.0 ([#433](https://github.com/bpg/terraform-provider-proxmox/issues/433)) ([b9ee3ae](https://github.com/bpg/terraform-provider-proxmox/commit/b9ee3ae10d942b3700fa057553471c9ed47ce4d4))

## [0.24.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.24.1...v0.24.2) (2023-07-16)


### Bug Fixes

* **vm:** do not reboot VM on config change if it is not running ([#430](https://github.com/bpg/terraform-provider-proxmox/issues/430)) ([0281bc8](https://github.com/bpg/terraform-provider-proxmox/commit/0281bc83e2d64fdfe2782feb6f21395706dbcc32))

## [0.24.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.24.0...v0.24.1) (2023-07-16)


### Bug Fixes

* **firewall:** add VM / container ID validation to firewall rules ([#424](https://github.com/bpg/terraform-provider-proxmox/issues/424)) ([6a3bc03](https://github.com/bpg/terraform-provider-proxmox/commit/6a3bc034706cef4190651118bfc2e8f62de8aecd))
* **vm:** add `interface` argument to `cdrom` block ([#429](https://github.com/bpg/terraform-provider-proxmox/issues/429)) ([b86fa23](https://github.com/bpg/terraform-provider-proxmox/commit/b86fa239ddd29f0cfc60d66ac4cede39b0167985))
* **vm:** add missing unmarshal for vm custom startup order ([#428](https://github.com/bpg/terraform-provider-proxmox/issues/428)) ([e59b06e](https://github.com/bpg/terraform-provider-proxmox/commit/e59b06e5195da90da837f5b660e6b76cca9fd632))

## [0.24.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.23.0...v0.24.0) (2023-07-09)


### Features

* add import support for a lot of resources ([#390](https://github.com/bpg/terraform-provider-proxmox/issues/390)) ([4147ff6](https://github.com/bpg/terraform-provider-proxmox/commit/4147ff6a29500dd47cd905a0239abdc28cffc596))
* **vm:** add more valid cpu types ([#411](https://github.com/bpg/terraform-provider-proxmox/issues/411)) ([e9a9fd7](https://github.com/bpg/terraform-provider-proxmox/commit/e9a9fd76dae22be24767cdf44cb9668f96c9ea90))


### Bug Fixes

* **firewall:** ignore non-existent rules at read/delete ([#415](https://github.com/bpg/terraform-provider-proxmox/issues/415)) ([fc3bbc3](https://github.com/bpg/terraform-provider-proxmox/commit/fc3bbc3d92466fc069db69619b5f1a7f338fc391))
* **node:** fix error when listing network interfaces of a node ([#412](https://github.com/bpg/terraform-provider-proxmox/issues/412)) ([16ee6a9](https://github.com/bpg/terraform-provider-proxmox/commit/16ee6a9f955f0452b80ba4ee88667edd4bd34fde))
* **node:** ignore field `bridge_fd` when listing network interfaces of a node ([#414](https://github.com/bpg/terraform-provider-proxmox/issues/414)) ([01a8456](https://github.com/bpg/terraform-provider-proxmox/commit/01a845636ae7242ea78b52365468f496fc52372b))


### Miscellaneous

* **deps:** bump github.com/goreleaser/goreleaser from 1.18.2 to 1.19.1 in /tools ([#403](https://github.com/bpg/terraform-provider-proxmox/issues/403)) ([0597217](https://github.com/bpg/terraform-provider-proxmox/commit/059721741ac5508bb98a1ca50b83a67e6a86c206))
* **deps:** bump github.com/goreleaser/goreleaser from 1.19.1 to 1.19.2 in /tools ([#417](https://github.com/bpg/terraform-provider-proxmox/issues/417)) ([7240715](https://github.com/bpg/terraform-provider-proxmox/commit/72407157614179f4368698235f957ead68dd51b1))
* **deps:** bump github.com/hashicorp/terraform-plugin-docs from 0.15.0 to 0.16.0 in /tools ([#418](https://github.com/bpg/terraform-provider-proxmox/issues/418)) ([6a309ac](https://github.com/bpg/terraform-provider-proxmox/commit/6a309ac4abec72e54529a84e17a360763110dfaa))
* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.3.1 to 1.3.2 ([#401](https://github.com/bpg/terraform-provider-proxmox/issues/401)) ([908713a](https://github.com/bpg/terraform-provider-proxmox/commit/908713a08493e46796438c7bc5585efab25fc4e0))
* **deps:** bump github.com/hashicorp/terraform-plugin-go from 0.16.0 to 0.17.0 ([#399](https://github.com/bpg/terraform-provider-proxmox/issues/399)) ([24ee318](https://github.com/bpg/terraform-provider-proxmox/commit/24ee318cc33a0faad76045644ac03394a13c7605))
* **deps:** bump github.com/hashicorp/terraform-plugin-go from 0.17.0 to 0.18.0 ([#408](https://github.com/bpg/terraform-provider-proxmox/issues/408)) ([f494525](https://github.com/bpg/terraform-provider-proxmox/commit/f49452543c6c88f90fb46d245b39ea9942eca5ea))
* **deps:** bump github.com/hashicorp/terraform-plugin-mux from 0.10.0 to 0.11.1 ([#400](https://github.com/bpg/terraform-provider-proxmox/issues/400)) ([1a6cfb2](https://github.com/bpg/terraform-provider-proxmox/commit/1a6cfb2cf1039694e594b45cb79ac5bba7810383))
* **deps:** bump github.com/hashicorp/terraform-plugin-sdk/v2 from 2.26.1 to 2.27.0 ([#402](https://github.com/bpg/terraform-provider-proxmox/issues/402)) ([af56c4b](https://github.com/bpg/terraform-provider-proxmox/commit/af56c4b2a75b6611e6dbcddc755a00ccddfd5248))
* **deps:** bump golang.org/x/crypto from 0.10.0 to 0.11.0 ([#416](https://github.com/bpg/terraform-provider-proxmox/issues/416)) ([5e173e0](https://github.com/bpg/terraform-provider-proxmox/commit/5e173e0bc9d2d7219e385e8b64ae82b3fcfdb42f))
* **refactoring:** remove accidentally added `types2` import alias ([#409](https://github.com/bpg/terraform-provider-proxmox/issues/409)) ([feac6b0](https://github.com/bpg/terraform-provider-proxmox/commit/feac6b0128520a16c4ecd4850d4f73e311ec1f7b))

## [0.23.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.22.0...v0.23.0) (2023-07-03)


### Features

* **vm:** efi disk, cpu numa ([#384](https://github.com/bpg/terraform-provider-proxmox/issues/384)) ([e9a74e9](https://github.com/bpg/terraform-provider-proxmox/commit/e9a74e90374570dee4af93fed4454209157bcbb7))


### Bug Fixes

* **docs:** minor firewall options page improvement ([#396](https://github.com/bpg/terraform-provider-proxmox/issues/396)) ([b0b5fa1](https://github.com/bpg/terraform-provider-proxmox/commit/b0b5fa153253102ecf4bcae896426296188f83be))
* **file:** spurious unsupported content type warning ([#395](https://github.com/bpg/terraform-provider-proxmox/issues/395)) ([4da2b68](https://github.com/bpg/terraform-provider-proxmox/commit/4da2b682de1f2c7f456c6f7c7bc06048881cb8b9))
* **lxc:** add support for 'nixos' ([#387](https://github.com/bpg/terraform-provider-proxmox/issues/387)) ([23a5194](https://github.com/bpg/terraform-provider-proxmox/commit/23a519475d2eddf2f2145166ff2593c60c807f53))
* **provider:** better handling of root@pam token ([#386](https://github.com/bpg/terraform-provider-proxmox/issues/386)) ([03eaf72](https://github.com/bpg/terraform-provider-proxmox/commit/03eaf72767082ca4b5642538f64730dc9c4e34aa))
* **provider:** config environment variables handling caused "rpc error" ([#397](https://github.com/bpg/terraform-provider-proxmox/issues/397)) ([d748a7d](https://github.com/bpg/terraform-provider-proxmox/commit/d748a7de7b16fd792e6e3d8d6b60a951f6031ac3))
* **vm:** do not error on `read` at state refresh if VM is missing ([#398](https://github.com/bpg/terraform-provider-proxmox/issues/398)) ([253a59e](https://github.com/bpg/terraform-provider-proxmox/commit/253a59ece6c8f505362d7cd40f62a076b7caa590))
* **vm:** search for vm in cluster resources before calling node api ([#393](https://github.com/bpg/terraform-provider-proxmox/issues/393)) ([99fda9c](https://github.com/bpg/terraform-provider-proxmox/commit/99fda9cbcdbd2f254cd4c8e48559a0f7ce7a3b01))


### Miscellaneous

* **deps:** bump github.com/hashicorp/terraform-plugin-framework from 1.3.0 to 1.3.1 ([#381](https://github.com/bpg/terraform-provider-proxmox/issues/381)) ([c1219ec](https://github.com/bpg/terraform-provider-proxmox/commit/c1219ecd3c5bb3ef3c728b479056f5309a02b6a8))
* **deps:** bump github.com/hashicorp/terraform-plugin-go from 0.15.0 to 0.16.0 ([#380](https://github.com/bpg/terraform-provider-proxmox/issues/380)) ([9146703](https://github.com/bpg/terraform-provider-proxmox/commit/91467037d56bcf612c32648c0fcb5ceb2df547df))

## [0.22.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.21.1...v0.22.0) (2023-06-24)


### Features

* **vm:** add network device resources ([#376](https://github.com/bpg/terraform-provider-proxmox/issues/376)) ([343e804](https://github.com/bpg/terraform-provider-proxmox/commit/343e8045c125a4e216443855be3fc794e56399cd))
* **vm:** add support for meta-data in cloud-init ([#378](https://github.com/bpg/terraform-provider-proxmox/issues/378)) ([7aa25b8](https://github.com/bpg/terraform-provider-proxmox/commit/7aa25b8d058ae6f1807252fb731fab0aec3a4814))


### Bug Fixes

* **file:** add check for supported content types when uploading file to a storage ([#379](https://github.com/bpg/terraform-provider-proxmox/issues/379)) ([4e1ce30](https://github.com/bpg/terraform-provider-proxmox/commit/4e1ce30619ccf7db141874f4daa5873ca9f012f1))


### Miscellaneous

* **deps:** bump github.com/golangci/golangci-lint from 1.53.2 to 1.53.3 in /tools ([#375](https://github.com/bpg/terraform-provider-proxmox/issues/375)) ([2863aa6](https://github.com/bpg/terraform-provider-proxmox/commit/2863aa6e2d1a472259c8f60bd63a934c0161f598))
* **deps:** bump golang.org/x/crypto from 0.9.0 to 0.10.0 ([#374](https://github.com/bpg/terraform-provider-proxmox/issues/374)) ([f6e20bd](https://github.com/bpg/terraform-provider-proxmox/commit/f6e20bd787977b99b9d934bb6ba4d7d06244ef42))
* **deps:** bump goreleaser/goreleaser-action from 4.2.0 to 4.3.0 ([#371](https://github.com/bpg/terraform-provider-proxmox/issues/371)) ([e3a62d7](https://github.com/bpg/terraform-provider-proxmox/commit/e3a62d79ad0fc319d4f57c9ae12cfae14f8e25f6))

## [0.21.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.21.0...v0.21.1) (2023-06-07)


### Bug Fixes

* **core:** Do not limit cluster size to 1 in provider's `ssh` config ([#369](https://github.com/bpg/terraform-provider-proxmox/issues/369)) ([926382c](https://github.com/bpg/terraform-provider-proxmox/commit/926382c155169f1be07cba26b3fda0572fdc1002))
* **doc:** Update documentation for resource `proxmox_virtual_environment_firewall_ipset` ([#366](https://github.com/bpg/terraform-provider-proxmox/issues/366)) ([0aa33f0](https://github.com/bpg/terraform-provider-proxmox/commit/0aa33f0929c4b9588cce8bcde67d297137c4ddc0))
* **firewall:** Improve firewall resources argument validation ([#359](https://github.com/bpg/terraform-provider-proxmox/issues/359)) ([8c1f246](https://github.com/bpg/terraform-provider-proxmox/commit/8c1f246b5a6288195dce25ab2417ae5218b7888d))
* **vm:** fix incorrect disk interface ref when reading VM info from PVE ([#365](https://github.com/bpg/terraform-provider-proxmox/issues/365)) ([de3935d](https://github.com/bpg/terraform-provider-proxmox/commit/de3935d462cd074ae8f1bfa2ead655efec8256b7))
* **vm:** Make `vm_id` computed ([#367](https://github.com/bpg/terraform-provider-proxmox/issues/367)) ([2a5abb1](https://github.com/bpg/terraform-provider-proxmox/commit/2a5abb10fc43603d2c786ad806cba056886c7f29))


### Miscellaneous

* **deps:** bump github.com/golangci/golangci-lint from 1.52.2 to 1.53.2 in /tools ([#363](https://github.com/bpg/terraform-provider-proxmox/issues/363)) ([a546a82](https://github.com/bpg/terraform-provider-proxmox/commit/a546a8292803d9645bdba48e2aa2d6c845c70a0a))
* **deps:** bump github.com/hashicorp/terraform-plugin-log from 0.8.0 to 0.9.0 ([#362](https://github.com/bpg/terraform-provider-proxmox/issues/362)) ([170ec8a](https://github.com/bpg/terraform-provider-proxmox/commit/170ec8ad924cc4bb9683ec87cbd39d8f1e8a1ee3))
* **deps:** bump github.com/stretchr/testify from 1.8.3 to 1.8.4 ([#361](https://github.com/bpg/terraform-provider-proxmox/issues/361)) ([46e0f8f](https://github.com/bpg/terraform-provider-proxmox/commit/46e0f8f6e79ba0c859507aee97aaf3be931640cd))
* **doc:** project documentation update ([#356](https://github.com/bpg/terraform-provider-proxmox/issues/356)) ([9587c63](https://github.com/bpg/terraform-provider-proxmox/commit/9587c6383c37be894f6ca5a8d8f3edbb1826c219))

## [0.21.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.20.1...v0.21.0) (2023-06-01)


### Features

* API client cleanup and refactoring ([#323](https://github.com/bpg/terraform-provider-proxmox/issues/323)) ([1f006aa](https://github.com/bpg/terraform-provider-proxmox/commit/1f006aa82bc79125a63543dbbf765629692b7b38))
* **core:** Add ability to override node IP used for SSH connection ([80c94a5](https://github.com/bpg/terraform-provider-proxmox/commit/80c94a51262df7c5cd49a938f58c7fd09a1a3540))
* **core:** Add API Token authentication ([#350](https://github.com/bpg/terraform-provider-proxmox/issues/350)) ([ab54aa1](https://github.com/bpg/terraform-provider-proxmox/commit/ab54aa1092534c323b85c46571de33bee80ae950))


### Bug Fixes

* **vm:** Make mac_address computed, fix [#339](https://github.com/bpg/terraform-provider-proxmox/issues/339) ([#354](https://github.com/bpg/terraform-provider-proxmox/issues/354)) ([e15c4a6](https://github.com/bpg/terraform-provider-proxmox/commit/e15c4a678409a378ce10ed47fb73051e9dcdae61))


### Miscellaneous

* **deps:** bump github.com/goreleaser/nfpm/v2 from 2.28.0 to 2.29.0 in /tools ([#347](https://github.com/bpg/terraform-provider-proxmox/issues/347)) ([2358557](https://github.com/bpg/terraform-provider-proxmox/commit/23585570ab379948edab12fff85542a8aadf1792))
* **deps:** bump github.com/sigstore/rekor from 1.1.1 to 1.2.0 in /tools ([#349](https://github.com/bpg/terraform-provider-proxmox/issues/349)) ([6e59360](https://github.com/bpg/terraform-provider-proxmox/commit/6e593607bb40419d27cfeebfc3d7c11ea1061828))

## [0.20.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.20.0...v0.20.1) (2023-05-23)


### Bug Fixes

* **vm:** Regression: wait for 'net.IsGlobalUnicast' IP address  ([#100](https://github.com/bpg/terraform-provider-proxmox/issues/100)) ([#345](https://github.com/bpg/terraform-provider-proxmox/issues/345)) ([20131b0](https://github.com/bpg/terraform-provider-proxmox/commit/20131b0ffcad256835256fb28bf177c20d344482))

## [0.20.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.19.1...v0.20.0) (2023-05-22)


### Features

* bump Go to 1.20 to resolve MacOS DNS resolution issues ([#342](https://github.com/bpg/terraform-provider-proxmox/issues/342)) ([1c920de](https://github.com/bpg/terraform-provider-proxmox/commit/1c920de71d4e07bd7a29700cdffd4e6b319f95c3))
* SSH-Agent Support ([#306](https://github.com/bpg/terraform-provider-proxmox/issues/306)) ([9fa9242](https://github.com/bpg/terraform-provider-proxmox/commit/9fa92423b5b3960ee7f46fb66fc18d12fcc8af29))


### Miscellaneous

* **deps:** bump github.com/skeema/knownhosts from 1.1.0 to 1.1.1 ([#336](https://github.com/bpg/terraform-provider-proxmox/issues/336)) ([0d8e6d3](https://github.com/bpg/terraform-provider-proxmox/commit/0d8e6d31584b418677c5e8579d9e41649e9790a7))
* **deps:** bump github.com/stretchr/testify from 1.8.2 to 1.8.3 ([#343](https://github.com/bpg/terraform-provider-proxmox/issues/343)) ([fc1e03f](https://github.com/bpg/terraform-provider-proxmox/commit/fc1e03f0949ee730a8c14cf2346a053d8f1a28e2))
* **deps:** bump golang.org/x/crypto from 0.8.0 to 0.9.0 ([#337](https://github.com/bpg/terraform-provider-proxmox/issues/337)) ([b1cb49c](https://github.com/bpg/terraform-provider-proxmox/commit/b1cb49cf7a829a6112ce6e7d363e7bf537e5c52c))

## [0.19.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.19.0...v0.19.1) (2023-05-14)


### Bug Fixes

* **vm:** Regression: cannot create disks larger than 99G ([#335](https://github.com/bpg/terraform-provider-proxmox/issues/335)) ([79e5a8e](https://github.com/bpg/terraform-provider-proxmox/commit/79e5a8ebb07d9c7858a32dbef280dfab5e78c19e))


### Miscellaneous

* **deps:** bump github.com/docker/distribution from 2.8.1+incompatible to 2.8.2+incompatible in /tools ([#331](https://github.com/bpg/terraform-provider-proxmox/issues/331)) ([37a1234](https://github.com/bpg/terraform-provider-proxmox/commit/37a1234bb05cb57229d276ec568096043c2073e0))

## [0.19.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.18.2...v0.19.0) (2023-05-11)


### Features

* **vm,lxc:** Improved support for different disk size units ([#326](https://github.com/bpg/terraform-provider-proxmox/issues/326)) ([4be9914](https://github.com/bpg/terraform-provider-proxmox/commit/4be9914757cb9fee38f1c2c08772daca364b1ac9))


### Bug Fixes

* **vm,lxc:** Add validation for non-empty tags ([#330](https://github.com/bpg/terraform-provider-proxmox/issues/330)) ([8359c03](https://github.com/bpg/terraform-provider-proxmox/commit/8359c03aa8069d8816e0802e41fb36a220040673))


### Miscellaneous

* **deps:** bump github.com/goreleaser/goreleaser from 1.17.2 to 1.18.1 in /tools ([#324](https://github.com/bpg/terraform-provider-proxmox/issues/324)) ([aea079e](https://github.com/bpg/terraform-provider-proxmox/commit/aea079e0b11e2f1a07b734ed1edde3c468518429))
* **deps:** bump github.com/goreleaser/goreleaser from 1.18.1 to 1.18.2 in /tools ([#327](https://github.com/bpg/terraform-provider-proxmox/issues/327)) ([d94a4ce](https://github.com/bpg/terraform-provider-proxmox/commit/d94a4ce7cf86974b93987904d430130108d9984c))

## [0.18.2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.18.1...v0.18.2) (2023-05-05)


### Bug Fixes

* **vm,lxc:** Fix tags reordering on plan re-apply ([#322](https://github.com/bpg/terraform-provider-proxmox/issues/322)) ([f0b88e3](https://github.com/bpg/terraform-provider-proxmox/commit/f0b88e336c48d76f5119fba78af9ce8b087d240e))
* **vm:** Fix IPv6 handling ([#319](https://github.com/bpg/terraform-provider-proxmox/issues/319)) ([97ca22a](https://github.com/bpg/terraform-provider-proxmox/commit/97ca22abbba4bf50895b56324ce3c3e693b46e2f))


### Miscellaneous

* **deps:** bump github.com/goreleaser/goreleaser from 1.17.1 to 1.17.2 in /tools ([#313](https://github.com/bpg/terraform-provider-proxmox/issues/313)) ([2a03818](https://github.com/bpg/terraform-provider-proxmox/commit/2a03818d4034a6ae9a0ca9153fdb2d3012cd4b97))
* **deps:** bump github.com/sigstore/rekor from 1.0.1 to 1.1.1 in /tools ([#320](https://github.com/bpg/terraform-provider-proxmox/issues/320)) ([b8184e4](https://github.com/bpg/terraform-provider-proxmox/commit/b8184e47c1af12423202385aeb7eb456e98bb42d))
* **make:** Add `lint`, `release-build` targets ([#317](https://github.com/bpg/terraform-provider-proxmox/issues/317)) ([aa99290](https://github.com/bpg/terraform-provider-proxmox/commit/aa9929066491765cfe421a7f3ede163b74473149))

## [0.18.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.18.0...v0.18.1) (2023-04-23)


### Bug Fixes

* **file:** fix SSH file upload on Windows ([#308](https://github.com/bpg/terraform-provider-proxmox/issues/308)) ([7c9505d](https://github.com/bpg/terraform-provider-proxmox/commit/7c9505d11f7cc99f6052e814f549004fe97e8b49))
* **firewall:** use correct default value for firewall ([#312](https://github.com/bpg/terraform-provider-proxmox/issues/312)) ([496bda4](https://github.com/bpg/terraform-provider-proxmox/commit/496bda4edcab1e52a3877581828080f62ef525d7))

## [0.18.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.17.1...v0.18.0) (2023-04-18)


### Features

* **vm:** Wait for the VM creation task to complete ([#305](https://github.com/bpg/terraform-provider-proxmox/issues/305)) ([8addb1d](https://github.com/bpg/terraform-provider-proxmox/commit/8addb1d1d547197ab7502b33105a17737c06788a))


### Miscellaneous

* **deps:** bump commonmarker from 0.23.8 to 0.23.9 in /docs ([#298](https://github.com/bpg/terraform-provider-proxmox/issues/298)) ([fc4a6e8](https://github.com/bpg/terraform-provider-proxmox/commit/fc4a6e8ace24db9a44102b878f09bd5d30329bd8))
* **deps:** bump github.com/goreleaser/goreleaser from 1.16.2 to 1.17.1 in /tools ([#303](https://github.com/bpg/terraform-provider-proxmox/issues/303)) ([d24f60a](https://github.com/bpg/terraform-provider-proxmox/commit/d24f60aaa22867d536a35712a0f7d8209a7d1ac2))
* **deps:** bump golang.org/x/crypto from 0.7.0 to 0.8.0 ([#296](https://github.com/bpg/terraform-provider-proxmox/issues/296)) ([a896b50](https://github.com/bpg/terraform-provider-proxmox/commit/a896b5051ec6103cd8449234102917d9f17a1011))
* **deps:** bump nokogiri from 1.14.2 to 1.14.3 in /docs ([#299](https://github.com/bpg/terraform-provider-proxmox/issues/299)) ([6722492](https://github.com/bpg/terraform-provider-proxmox/commit/672249246f921eaba7ffa5020c0427bf95c3ed29))

## [0.17.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.17.0...v0.17.1) (2023-04-10)


### Bug Fixes

* **core:** Error when open SSH session on Windows ([#293](https://github.com/bpg/terraform-provider-proxmox/issues/293)) ([be3995e](https://github.com/bpg/terraform-provider-proxmox/commit/be3995e969e16eac08c3e1d0fbaadb60244a5576))
* **file:** "Permission denied" error when creating a file by a non-root user ([#291](https://github.com/bpg/terraform-provider-proxmox/issues/291)) ([401b397](https://github.com/bpg/terraform-provider-proxmox/commit/401b39782f857382b30ab71b3e49a8ab44fbac48))
* **firewall:** Add support for `firewall` flag for LXC/VM net adapters ([#295](https://github.com/bpg/terraform-provider-proxmox/issues/295)) ([f4783f8](https://github.com/bpg/terraform-provider-proxmox/commit/f4783f8cda701b6800403d50840240da6469fd38))

## [0.17.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.17.0-rc2...v0.17.0) (2023-04-07)


### Features

* **vm:** add support for `boot_order` argument for VM ([#219](https://github.com/bpg/terraform-provider-proxmox/issues/219)) ([f9e263a](https://github.com/bpg/terraform-provider-proxmox/commit/f9e263ad5edf47fb12f5321af0090d928da50d42))


### Bug Fixes

* **provider:** Deprecate `virtual_environment` block ([#288](https://github.com/bpg/terraform-provider-proxmox/issues/288)) ([ed3dfea](https://github.com/bpg/terraform-provider-proxmox/commit/ed3dfeae9907757f42c0cce63fe1f00a4e2ec0a2))


### Miscellaneous

* cleanup and fix linter errors ([#290](https://github.com/bpg/terraform-provider-proxmox/issues/290)) ([2fa9229](https://github.com/bpg/terraform-provider-proxmox/commit/2fa922930f6c3b6c1e0c32789b44ef6ab9189e6d))

## [0.17.0-rc2](https://github.com/bpg/terraform-provider-proxmox/compare/v0.17.0-rc1...v0.17.0-rc2) (2023-04-04)


### Bug Fixes

* **firewall:** fw controls bugfixes ([#287](https://github.com/bpg/terraform-provider-proxmox/issues/287)) ([1bfc29e](https://github.com/bpg/terraform-provider-proxmox/commit/1bfc29e2cc3342699f491d0225da474078220ecd))


### Miscellaneous

* **deps:** bump activesupport from 7.0.4.2 to 7.0.4.3 in /docs ([#285](https://github.com/bpg/terraform-provider-proxmox/issues/285)) ([fc08e19](https://github.com/bpg/terraform-provider-proxmox/commit/fc08e19f867ef652ae7597e89fd49fb3ecc3a9a8))

## [0.17.0-rc1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.16.0...v0.17.0-rc1) (2023-04-02)


### Features

* Add firewall resources ([#246](https://github.com/bpg/terraform-provider-proxmox/issues/246)) ([98e1cff](https://github.com/bpg/terraform-provider-proxmox/commit/98e1cff7fef0f24d932933bcba56ebc5b6ca7548))

## [0.16.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.15.0...v0.16.0) (2023-04-02)


### Features

* Update to Go 1.19 ([#280](https://github.com/bpg/terraform-provider-proxmox/issues/280)) ([8edfe9c](https://github.com/bpg/terraform-provider-proxmox/commit/8edfe9c7c54c9554adca52ffcf31c091f1fce11f))
* **vm:** Add scsi_hardware field ([#282](https://github.com/bpg/terraform-provider-proxmox/issues/282)) ([f0f31ee](https://github.com/bpg/terraform-provider-proxmox/commit/f0f31eee470dc954fdd5d1c952ea3067a2a68f1b))


### Miscellaneous

* add missing docs ([#283](https://github.com/bpg/terraform-provider-proxmox/issues/283)) ([db7afe2](https://github.com/bpg/terraform-provider-proxmox/commit/db7afe2e4a93ae3f97c0533dba0adaf82123c49f))
* **deps:** bump actions/stale from 7 to 8 ([#276](https://github.com/bpg/terraform-provider-proxmox/issues/276)) ([edd9685](https://github.com/bpg/terraform-provider-proxmox/commit/edd96857e64f73b041ed76a9c1818a864b4a0cca))
* **deps:** bump github.com/golangci/golangci-lint from 1.52.1 to 1.52.2 in /tools ([#278](https://github.com/bpg/terraform-provider-proxmox/issues/278)) ([d8c1fb3](https://github.com/bpg/terraform-provider-proxmox/commit/d8c1fb3573de553bc2eb26d8e37cdcfe8a78f384))
* **deps:** bump github.com/hashicorp/terraform-plugin-sdk/v2 from 2.25.0 to 2.26.1 ([#277](https://github.com/bpg/terraform-provider-proxmox/issues/277)) ([b403a49](https://github.com/bpg/terraform-provider-proxmox/commit/b403a4940fd31eacef90deaa11f2696fa7c03910))

## [0.15.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.14.1...v0.15.0) (2023-03-25)


### Features

* **vm:** Add bare minimum VM datasource ([#268](https://github.com/bpg/terraform-provider-proxmox/issues/268)) ([c2d3f46](https://github.com/bpg/terraform-provider-proxmox/commit/c2d3f46474fc0d0603c34596eb81b82c06713b17))


### Bug Fixes

* **vm:** Prevent `file_format` override with default `qcow2` in TF state ([#275](https://github.com/bpg/terraform-provider-proxmox/issues/275)) ([17dca98](https://github.com/bpg/terraform-provider-proxmox/commit/17dca987eb240454dbd980ed8f0c4a939e327ff0))


### Miscellaneous

* **deps:** bump actions/setup-go from 3 to 4 ([#269](https://github.com/bpg/terraform-provider-proxmox/issues/269)) ([fdb9dc7](https://github.com/bpg/terraform-provider-proxmox/commit/fdb9dc7714f12a1682f47e57ab319753fc18e4f4))
* **deps:** bump github.com/golangci/golangci-lint from 1.51.2 to 1.52.1 in /tools ([#274](https://github.com/bpg/terraform-provider-proxmox/issues/274)) ([1150163](https://github.com/bpg/terraform-provider-proxmox/commit/1150163b4b66249b79e446cf20f9df54fc204f7c))
* **deps:** bump github.com/goreleaser/goreleaser from 1.16.1 to 1.16.2 in /tools ([#271](https://github.com/bpg/terraform-provider-proxmox/issues/271)) ([7a0e1db](https://github.com/bpg/terraform-provider-proxmox/commit/7a0e1db6c4a117e0599b4899df781eb3c3fe600f))

## [0.14.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.14.0...v0.14.1) (2023-03-19)


### Bug Fixes

* authentication error logging in API client ([#267](https://github.com/bpg/terraform-provider-proxmox/issues/267)) ([763527e](https://github.com/bpg/terraform-provider-proxmox/commit/763527e53584e8121b1138830ad97e8e89780322))
* **build:** Fix make example-init for TF 1.4 ([#262](https://github.com/bpg/terraform-provider-proxmox/issues/262)) ([914631f](https://github.com/bpg/terraform-provider-proxmox/commit/914631f58b40ceb25248727ac23a6400df0264a3))


### Miscellaneous

* **deps:** bump activesupport from 6.1.7.1 to 6.1.7.3 in /docs ([#263](https://github.com/bpg/terraform-provider-proxmox/issues/263)) ([ce8bd30](https://github.com/bpg/terraform-provider-proxmox/commit/ce8bd3008bc65745eb62e17dc4849d3a4b3f740a))
* **docs:** Minor documentation Improvements ([#266](https://github.com/bpg/terraform-provider-proxmox/issues/266)) ([696ecb0](https://github.com/bpg/terraform-provider-proxmox/commit/696ecb05d8796540dc21d62dce930c4a2c2d8246))

## [0.14.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.13.1...v0.14.0) (2023-03-14)


### Features

* **lxc:** Add option for nested container feature ([4d44739](https://github.com/bpg/terraform-provider-proxmox/commit/4d447390e684a90c9672528f4bdc22aa1433296b))
* **vm:** Add custom CPU models support ([82016fc](https://github.com/bpg/terraform-provider-proxmox/commit/82016fc8ff018867783839c916dce686cb38d1b6))


### Bug Fixes

* **vm:** Fix `file_format` setting for new empty disks ([#259](https://github.com/bpg/terraform-provider-proxmox/issues/259)) ([d29fd97](https://github.com/bpg/terraform-provider-proxmox/commit/d29fd97babab9a8f217b6ea0ffd89511c55624eb))


### Miscellaneous

* **deps:** bump github.com/goreleaser/goreleaser from 1.15.2 to 1.16.1 in /tools ([#258](https://github.com/bpg/terraform-provider-proxmox/issues/258)) ([9afca3b](https://github.com/bpg/terraform-provider-proxmox/commit/9afca3b88caade184e536450534666431f2c00d5))

## [0.13.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.13.0...v0.13.1) (2023-03-07)


### Miscellaneous

* **deps:** bump dependencies ([#242](https://github.com/bpg/terraform-provider-proxmox/issues/242)) ([890fb53](https://github.com/bpg/terraform-provider-proxmox/commit/890fb536846d2582cbf025f2045be3c5f903fc0a))
* **deps:** bump github.com/golangci/golangci-lint from 1.51.1 to 1.51.2 in /tools ([#244](https://github.com/bpg/terraform-provider-proxmox/issues/244)) ([e01844a](https://github.com/bpg/terraform-provider-proxmox/commit/e01844a0d73750d0ce65c76e9eaae0b3b952c206))
* **deps:** bump github.com/stretchr/testify from 1.8.1 to 1.8.2 ([#245](https://github.com/bpg/terraform-provider-proxmox/issues/245)) ([6cca133](https://github.com/bpg/terraform-provider-proxmox/commit/6cca13383527a1f33a30e5766bb520c0a575793a))
* **deps:** bump golang.org/x/crypto from 0.6.0 to 0.7.0 ([#248](https://github.com/bpg/terraform-provider-proxmox/issues/248)) ([1aa668e](https://github.com/bpg/terraform-provider-proxmox/commit/1aa668e03bcb15333772575029a07c2134d8e291))

## [0.13.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.12.1...v0.13.0) (2023-02-17)


### Features

* **vm:** update VM disc import logic ([#241](https://github.com/bpg/terraform-provider-proxmox/issues/241)) ([fcf9810](https://github.com/bpg/terraform-provider-proxmox/commit/fcf98102522821c9dfb4534731747233bd627d38))


### Bug Fixes

* **vm:** `proxmox_virtual_environment_file.changed` stored as `true` at file creation ([#240](https://github.com/bpg/terraform-provider-proxmox/issues/240)) ([197c9e5](https://github.com/bpg/terraform-provider-proxmox/commit/197c9e5152fd6524c82977001a759c36c644f8e5))


### Miscellaneous

* **deps:** bump activesupport from 6.0.6.1 to 6.1.7.1 in /docs ([#235](https://github.com/bpg/terraform-provider-proxmox/issues/235)) ([ffa39c1](https://github.com/bpg/terraform-provider-proxmox/commit/ffa39c13e0d8283da51980532c83919edcf1cbc6))
* **deps:** bump github.com/goreleaser/goreleaser from 1.15.1 to 1.15.2 in /tools ([#237](https://github.com/bpg/terraform-provider-proxmox/issues/237)) ([80dfceb](https://github.com/bpg/terraform-provider-proxmox/commit/80dfceba8433379a64a1ff86d174447e229325ab))
* **deps:** bump github.com/hashicorp/terraform-plugin-log from 0.7.0 to 0.8.0 ([#239](https://github.com/bpg/terraform-provider-proxmox/issues/239)) ([dbe26ed](https://github.com/bpg/terraform-provider-proxmox/commit/dbe26ed58f1ed668e5a059f9659bd12fd6b1a54c))
* **deps:** bump golang.org/x/crypto from 0.5.0 to 0.6.0 ([#238](https://github.com/bpg/terraform-provider-proxmox/issues/238)) ([2b99349](https://github.com/bpg/terraform-provider-proxmox/commit/2b99349f1fe89e804fb45c439470bd2474068f1c))

## [0.12.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.12.0...v0.12.1) (2023-02-07)


### Bug Fixes

* **build:** trailing space in provider's version ([#233](https://github.com/bpg/terraform-provider-proxmox/issues/233)) ([f97407d](https://github.com/bpg/terraform-provider-proxmox/commit/f97407dc00c425b8d015abf72488b5a4fd31f043))
* **vm:** ignore ssd disk flag with virtio interface ([#231](https://github.com/bpg/terraform-provider-proxmox/issues/231)) ([1de9294](https://github.com/bpg/terraform-provider-proxmox/commit/1de92947666d45fdcae881e3a6bd651bfea493a4))


### Miscellaneous

* **deps:** bump github.com/golangci/golangci-lint from 1.50.1 to 1.51.1 in /tools ([#229](https://github.com/bpg/terraform-provider-proxmox/issues/229)) ([f1022a5](https://github.com/bpg/terraform-provider-proxmox/commit/f1022a5cae0c99696292421edb28b3007d3bbb51))
* **deps:** bump github.com/goreleaser/goreleaser from 1.14.1 to 1.15.1 in /tools ([#230](https://github.com/bpg/terraform-provider-proxmox/issues/230)) ([722003e](https://github.com/bpg/terraform-provider-proxmox/commit/722003ee5ac23c4946af2257eaeb6f91028f879d))

## [0.12.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.11.0...v0.12.0) (2023-02-06)


### Features

* **core:** Add known hosts callback check for ssh connections ([#217](https://github.com/bpg/terraform-provider-proxmox/issues/217)) ([598c628](https://github.com/bpg/terraform-provider-proxmox/commit/598c62864d0a8a4e1b7dcda0cb7a3d5e380a5863))
* **lxc:** Add unprivileged option ([#225](https://github.com/bpg/terraform-provider-proxmox/issues/225)) ([1918561](https://github.com/bpg/terraform-provider-proxmox/commit/19185611b37c85a071ac4d3fd0c9a6b865b7c28d))


### Bug Fixes

* **vm:** Don't add an extra hostpci entry ([#223](https://github.com/bpg/terraform-provider-proxmox/issues/223)) ([346c92b](https://github.com/bpg/terraform-provider-proxmox/commit/346c92b2734caed90b30df423ac8019cf08c5900))
* **vm:** Fix handling of empty kvm arguments ([#228](https://github.com/bpg/terraform-provider-proxmox/issues/228)) ([e2802d0](https://github.com/bpg/terraform-provider-proxmox/commit/e2802d0654f0d6d5e99bef4987a84862e3ffbde7))


### Miscellaneous

* **deps:** bump commonmarker from 0.23.6 to 0.23.7 in /docs ([#220](https://github.com/bpg/terraform-provider-proxmox/issues/220)) ([cef0227](https://github.com/bpg/terraform-provider-proxmox/commit/cef0227ef59df55388632e775b34cc3f4644075f))
* **deps:** bump gem dependencies in /docs ([#221](https://github.com/bpg/terraform-provider-proxmox/issues/221)) ([e0864c0](https://github.com/bpg/terraform-provider-proxmox/commit/e0864c098a2e5a9d1da1c133ebaeee8650ceb4e0))
* **deps:** bump goreleaser/goreleaser-action from 4.1.0 to 4.2.0 ([#222](https://github.com/bpg/terraform-provider-proxmox/issues/222)) ([11fe9e5](https://github.com/bpg/terraform-provider-proxmox/commit/11fe9e539c56101360e5be0f5bb042f5318a4d4c))
* disable code coverage ([#227](https://github.com/bpg/terraform-provider-proxmox/issues/227)) ([a72fd27](https://github.com/bpg/terraform-provider-proxmox/commit/a72fd27a13395b9d061cdc450f68e171f1b30cbe))

## [0.11.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.10.0...v0.11.0) (2023-01-24)


### Features

* **lxc:** Add support for container tags ([#212](https://github.com/bpg/terraform-provider-proxmox/issues/212)) ([5c8ae3c](https://github.com/bpg/terraform-provider-proxmox/commit/5c8ae3c3f826969f70d5af79cfca00c0c49da418))


### Miscellaneous

* **ci:** set up code coverage ([06bd5ae](https://github.com/bpg/terraform-provider-proxmox/commit/06bd5aef0f0aac54e412e475ccdc85f8f61398d9))
* **deps:** bump dependencies ([#216](https://github.com/bpg/terraform-provider-proxmox/issues/216)) ([f157e3b](https://github.com/bpg/terraform-provider-proxmox/commit/f157e3bd532bd3b0fa728478f44986b1ef5f245b))

## [0.10.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.9.1...v0.10.0) (2023-01-18)


### Features

* **lxc:** Add option to customize RootFS size at LXC creation ([#207](https://github.com/bpg/terraform-provider-proxmox/issues/207)) ([dd9ffe1](https://github.com/bpg/terraform-provider-proxmox/commit/dd9ffe190cd9eaee7ac6a9e2c830eee45b4b69df))
* **vm:** add support for "args" flag for VM ([#205](https://github.com/bpg/terraform-provider-proxmox/issues/205)) ([8bd3fd7](https://github.com/bpg/terraform-provider-proxmox/commit/8bd3fd7b1d71e37eeee2c222e4896b857a01cabf))


### Bug Fixes

* **vm:** Add parser for CustomEFIDisk ([#208](https://github.com/bpg/terraform-provider-proxmox/issues/208)) ([b539aab](https://github.com/bpg/terraform-provider-proxmox/commit/b539aab22851817aea981727eb27a8da73edcc43))

## [0.9.1](https://github.com/bpg/terraform-provider-proxmox/compare/v0.9.0...v0.9.1) (2023-01-02)


### Bug Fixes

* **vm:** Make so that on_boot can be changed with update ([#199](https://github.com/bpg/terraform-provider-proxmox/issues/199)) ([496ab32](https://github.com/bpg/terraform-provider-proxmox/commit/496ab322be7f12257f562d53a9920377cded8aa5))

## [0.9.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.8.0...v0.9.0) (2023-01-01)


### Features

* **vm:** Add cloud-init network-config support ([#197](https://github.com/bpg/terraform-provider-proxmox/issues/197)) ([79a2101](https://github.com/bpg/terraform-provider-proxmox/commit/79a2101933d6001cb843050a83076a39cd503db8))
* **vm:** Add hostpci support ([01d2050](https://github.com/bpg/terraform-provider-proxmox/commit/01d20504a1924552611a92dd3f718bad270a7309))
* **vm:** Deletion of VM should also purge all storages and configs ([13080b4](https://github.com/bpg/terraform-provider-proxmox/commit/13080b44dcb08fbeabd0b20501631f52e022e46d))
* **vm:** OnBoot: change default to `true` ([#191](https://github.com/bpg/terraform-provider-proxmox/issues/191)) ([60a6818](https://github.com/bpg/terraform-provider-proxmox/commit/60a68184cf7c6239eb5cc540c746f11e2a78c240))

## [0.8.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.7.0...v0.8.0) (2022-12-13)


### Features

* add support for "ssd" disk flag for VM ([#181](https://github.com/bpg/terraform-provider-proxmox/issues/181)) ([2907346](https://github.com/bpg/terraform-provider-proxmox/commit/290734655ce28306ae910b76b8de5fedbd3b4bb8))
* add support for network_device MTU ([#176](https://github.com/bpg/terraform-provider-proxmox/issues/176)) ([3c02cb1](https://github.com/bpg/terraform-provider-proxmox/commit/3c02cb13895f7095ef0b0aaf58fe799e396a0715))
* add support for VM tags ([#169](https://github.com/bpg/terraform-provider-proxmox/issues/169)) ([ade1d49](https://github.com/bpg/terraform-provider-proxmox/commit/ade1d49117f5390e5ee58ddeadef0adf02143d33))
* add the ability to clone to non-shared storage on different nodes ([#178](https://github.com/bpg/terraform-provider-proxmox/issues/178)) ([0df14f9](https://github.com/bpg/terraform-provider-proxmox/commit/0df14f9d6aa139cb6478317da7ff6b632242b02d))


### Bug Fixes

* Check if any interface has global unicast address instead of all interfaces ([#182](https://github.com/bpg/terraform-provider-proxmox/issues/182)) ([722e010](https://github.com/bpg/terraform-provider-proxmox/commit/722e01053bdb51c038a7bd86d4018465417ea6fb))
* handling `datastore_id` in LXC template ([#180](https://github.com/bpg/terraform-provider-proxmox/issues/180)) ([63dc5cb](https://github.com/bpg/terraform-provider-proxmox/commit/63dc5cb8f6dbb6d273bd519c7768893df02a3b97))
* Remove cloned ide2 before creating new one ([#174](https://github.com/bpg/terraform-provider-proxmox/issues/174)) ([#175](https://github.com/bpg/terraform-provider-proxmox/issues/175)) ([2766555](https://github.com/bpg/terraform-provider-proxmox/commit/27665554de4a35ec678f5c63b529ccaa7d99bc74))

## [0.7.0](https://github.com/bpg/terraform-provider-proxmox/compare/v0.6.4...v0.7.0) (2022-11-18)


### Features

* Add support for custom cloud-init vendor data file ([#162](https://github.com/bpg/terraform-provider-proxmox/issues/162)) ([9e34dfb](https://github.com/bpg/terraform-provider-proxmox/commit/9e34dfb36213fc524957921e2d5b07cdf3585491))


### Bug Fixes

* linter issues ([#158](https://github.com/bpg/terraform-provider-proxmox/issues/158)) ([0fad160](https://github.com/bpg/terraform-provider-proxmox/commit/0fad160ed61cf763ce294a76e35b8c0f56cd33e8))

## [0.6.4](https://github.com/bpg/terraform-provider-proxmox/compare/v0.6.3...v0.6.4) (2022-10-17)


### Bug Fixes

* bump vulnerable dependencies ([#143](https://github.com/bpg/terraform-provider-proxmox/issues/143)) ([f9f357e](https://github.com/bpg/terraform-provider-proxmox/commit/f9f357e200681d56500316d204ed3c2dc836b551))

## [v0.6.3](https://github.com/bpg/terraform-provider-proxmox/compare/v0.6.2...v0.6.3) (2022-10-17)


### Bug Fixes

* Non-default VM disk format is not preserved in TF state ([#134](https://github.com/bpg/terraform-provider-proxmox/issues/134)) ([b09389f](https://github.com/bpg/terraform-provider-proxmox/commit/b09389f0a9c65f8f6ab82ae989d29951dd643ed2))

## [v0.6.2](https://github.com/bpg/terraform-provider-proxmox/tree/v0.6.2) (2022-09-28)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.6.1...v0.6.2)

ENHANCEMENTS:

- Add discard option to vm disk creation [\#122](https://github.com/bpg/terraform-provider-proxmox/issues/122)

**Merged pull requests:**

- Add support for "discard" disk option for VM [\#128](https://github.com/bpg/terraform-provider-proxmox/pull/128) ([bpg](https://github.com/bpg))

## [v0.6.1](https://github.com/bpg/terraform-provider-proxmox/tree/v0.6.1) (2022-08-15)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.6.0...v0.6.1)

BUG FIXES:

- Waiting for proxmox\_virtual\_environment\_vm's ipv4\_addresses does not really work [\#100](https://github.com/bpg/terraform-provider-proxmox/issues/100)

## [v0.6.0](https://github.com/bpg/terraform-provider-proxmox/tree/v0.6.0) (2022-08-09)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.5.3...v0.6.0)

BREAKING CHANGES:

- Upgrade the provider codebase to use Terraform SDK v2 [\#91](https://github.com/bpg/terraform-provider-proxmox/pull/91) ([bpg](https://github.com/bpg))

ENHANCEMENTS:

- Add support for "iothread" disk option for VM [\#87](https://github.com/bpg/terraform-provider-proxmox/issues/87)

BUG FIXES:

- Powered off VM breaks plan/apply [\#105](https://github.com/bpg/terraform-provider-proxmox/issues/105)
- Disk resize causes reboot [\#102](https://github.com/bpg/terraform-provider-proxmox/issues/102)
- Typing error - dvResourceVirtualEnvironmentVMAgentEnabled instead of dvResourceVirtualEnvironmentVMAgentTrim [\#101](https://github.com/bpg/terraform-provider-proxmox/issues/101)
- Error creating VM with multiple disks on different storages [\#88](https://github.com/bpg/terraform-provider-proxmox/issues/88)

**Merged pull requests:**

- Fixed Typo  [\#107](https://github.com/bpg/terraform-provider-proxmox/pull/107) ([PrajwalBorkar](https://github.com/PrajwalBorkar))
- Avoid reboot when resizing disks. [\#104](https://github.com/bpg/terraform-provider-proxmox/pull/104) ([otopetrik](https://github.com/otopetrik))
- Add support for "iothread" disk option for VM [\#97](https://github.com/bpg/terraform-provider-proxmox/pull/97) ([bpg](https://github.com/bpg))
- Fix disk import when VM template has multiple disks [\#96](https://github.com/bpg/terraform-provider-proxmox/pull/96) ([bpg](https://github.com/bpg))

## [v0.5.3](https://github.com/bpg/terraform-provider-proxmox/tree/v0.5.3) (2022-06-02)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.5.2...v0.5.3)

**Merged pull requests:**

- Bump hashicorp/go-getter for CVE-2022-30323 fix [\#82](https://github.com/bpg/terraform-provider-proxmox/pull/82) ([bpg](https://github.com/bpg))
- Update docs [\#57](https://github.com/bpg/terraform-provider-proxmox/pull/57) ([bpg](https://github.com/bpg))

## [v0.5.2](https://github.com/bpg/terraform-provider-proxmox/tree/v0.5.2) (2022-05-10)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.5.1...v0.5.2)

**Closed issues:**

- proxmox\_virtual\_environment\_file json unmarshalling type issue [\#41](https://github.com/bpg/terraform-provider-proxmox/issues/41)

## [v0.5.1](https://github.com/bpg/terraform-provider-proxmox/tree/v0.5.1) (2022-03-22)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.5.0...v0.5.1)

BUG FIXES:

- Version mismatch in the code [\#44](https://github.com/bpg/terraform-provider-proxmox/issues/44)
- virtual\_environment\_datastores.go: Update remote command to get datasource path [\#49](https://github.com/bpg/terraform-provider-proxmox/pull/49) ([mattburchett](https://github.com/mattburchett))

## [v0.5.0](https://github.com/bpg/terraform-provider-proxmox/tree/v0.5.0) (2021-11-06)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.4.6...v0.5.0)

BREAKING CHANGES:

- Bump provider version to 0.5.0 [\#32](https://github.com/bpg/terraform-provider-proxmox/pull/32) ([bpg](https://github.com/bpg))

## [v0.4.6](https://github.com/bpg/terraform-provider-proxmox/tree/v0.4.6) (2021-09-10)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.4.5...v0.4.6)

BUG FIXES:

- JSON unmarshal error when deploying LCX container [\#15](https://github.com/bpg/terraform-provider-proxmox/issues/15)
- \[BUG\] SIGSEGV if cloned VM disk is in the different storage [\#2](https://github.com/bpg/terraform-provider-proxmox/issues/2)
- fix `make test` error [\#1](https://github.com/bpg/terraform-provider-proxmox/pull/1) ([bpg](https://github.com/bpg))

## [v0.4.5](https://github.com/bpg/terraform-provider-proxmox/tree/v0.4.5) (2021-07-16)

[Full Changelog](https://github.com/bpg/terraform-provider-proxmox/compare/v0.4.4...v0.4.5)

## v0.4.4

BUG FIXES:

* resource/virtual_environment_vm: Fix watchdog deserialization issue

## v0.4.3

BUG FIXES:

* resource/virtual_environment_container: Fix IP initialization issue

## v0.4.2

BUG FIXES:

* resource/virtual_environment_vm: Fix `disk.file_id` diff issue
* resource/virtual_environment_vm: Fix disk resizing issue

OTHER:

* provider/example: Remove support for Terraform v0.11 and older
* provider/makefile: Update to use plugin caching to support local builds

## v0.4.1

OTHER:

* provider/docs: Fix issue with navigational link titles in Terraform Registry

## v0.4.0

FEATURES:

* **New Data Source:** `proxmox_virtual_environment_time`
* **New Resource:** `proxmox_virtual_environment_time`

BREAKING CHANGES:

* resource/virtual_environment_vm: `interface` is now required to create disks

    ```
      disk {
        datastore_id = "local-lvm"
        file_id      = "${proxmox_virtual_environment_file.ubuntu_cloud_image.id}"
        interface    = "scsi0"
      }
    ```

ENHANCEMENTS:

* provider/configuration: Add `virtual_environment.otp` argument for TOTP support
* resource/virtual_environment_vm: Clone supports resize and datastore_id for moving disks
* resource/virtual_environment_vm: Bulk clones can now use retries as argument to try multiple times to create a clone.
* resource/virtual_environment_vm: `on_boot` parameter can be used to start a VM after the Node has been rebooted.
* resource/virtual_environment_vm: `reboot` parameter can be used to reboot a VM after creation
* resource/virtual_environment_vm: Has now multiple new parameters to set timeouts for the vm creation/cloning `timeout_clone`, `timeout_move_disk`, `timeout_reboot`, `timeout_shutdown_vm`, `timeout_start_vm`, `timeout_stop_vm`

BUG FIXES:

* library/virtual_environment_nodes: Fix node IP address format
* library/virtual_environment_nodes: Fix WaitForNodeTask now detects errors correctly
* library/virtual_environment_vm: Fix CloneVM now waits for the task to be finished and detect errors.
* resource/virtual_environment_container: Fix VM ID collision when `vm_id` is not specified
* resource/virtual_environment_vm: Fix VM ID collision when `vm_id` is not specified
* resource/virtual_environment_vm: Fix disk import issue when importing from directory-based datastores
* resource/virtual_environment_vm: Fix handling of storage name - correct handling of `-`

WORKAROUNDS:

* resource/virtual_environment_vm: Ignore default value for `cpu.architecture` when the root account is not being used

## 0.3.0

ENHANCEMENTS:

* resource/virtual_environment_container: Add `clone` argument
* resource/virtual_environment_container: Add `disk` argument
* resource/virtual_environment_container: Add `template` argument
* resource/virtual_environment_vm: Add `agent.timeout` argument
* resource/virtual_environment_vm: Add `audio_device` argument
* resource/virtual_environment_vm: Add `clone` argument
* resource/virtual_environment_vm: Add `initialization.datastore_id` argument
* resource/virtual_environment_vm: Add `serial_device` argument
* resource/virtual_environment_vm: Add `template` argument

BUG FIXES:

* resource/virtual_environment_container: Fix `network_interface` deletion issue
* resource/virtual_environment_vm: Fix `network_device` deletion issue
* resource/virtual_environment_vm: Fix slow refresh when VM is stopped and agent is enabled
* resource/virtual_environment_vm: Fix crash caused by assuming IP addresses are always reported by the QEMU agent
* resource/virtual_environment_vm: Fix timeout issue while waiting for IP addresses to be reported by the QEMU agent

OTHER:

* provider/docs: Add HTML documentation powered by GitHub Pages

## 0.2.0

BREAKING CHANGES:

* resource/virtual_environment_vm: Rename `cloud_init` argument to `initialization`
* resource/virtual_environment_vm: Rename `os_type` argument to `operating_system.type`

FEATURES:

* **New Data Source:** `proxmox_virtual_environment_dns`
* **New Data Source:** `proxmox_virtual_environment_hosts`
* **New Resource:** `proxmox_virtual_environment_certificate`
* **New Resource:** `proxmox_virtual_environment_container`
* **New Resource:** `proxmox_virtual_environment_dns`
* **New Resource:** `proxmox_virtual_environment_hosts`

ENHANCEMENTS:

* resource/virtual_environment_vm: Add `acpi` argument
* resource/virtual_environment_vm: Add `bios` argument
* resource/virtual_environment_vm: Add `cpu.architecture`, `cpu.flags`, `cpu.type` and `cpu.units` arguments
* resource/virtual_environment_vm: Add `tablet_device` argument
* resource/virtual_environment_vm: Add `vga` argument

## 0.1.0

FEATURES:

* **New Data Source:** `proxmox_virtual_environment_datastores`
* **New Data Source:** `proxmox_virtual_environment_group`
* **New Data Source:** `proxmox_virtual_environment_groups`
* **New Data Source:** `proxmox_virtual_environment_nodes`
* **New Data Source:** `proxmox_virtual_environment_pool`
* **New Data Source:** `proxmox_virtual_environment_pools`
* **New Data Source:** `proxmox_virtual_environment_role`
* **New Data Source:** `proxmox_virtual_environment_roles`
* **New Data Source:** `proxmox_virtual_environment_user`
* **New Data Source:** `proxmox_virtual_environment_users`
* **New Data Source:** `proxmox_virtual_environment_version`
* **New Resource:** `proxmox_virtual_environment_file`
* **New Resource:** `proxmox_virtual_environment_group`
* **New Resource:** `proxmox_virtual_environment_pool`
* **New Resource:** `proxmox_virtual_environment_role`
* **New Resource:** `proxmox_virtual_environment_user`
* **New Resource:** `proxmox_virtual_environment_vm`


\* *This Changelog was automatically generated by [github_changelog_generator](https://github.com/github-changelog-generator/github-changelog-generator)*
`````

## File: CODE_OF_CONDUCT.md
`````markdown
# Contributor Covenant Code of Conduct

## Our Pledge

We, as contributors and maintainers, pledge to foster an open and welcoming environment. We are committed to making participation in our project and community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contribute to a positive environment include:

- Using welcoming and inclusive language
- Being respectful of differing viewpoints and experiences
- Gracefully accepting constructive criticism
- Focusing on what is best for the community
- Showing empathy towards other community members

Examples of unacceptable behavior include:

- The use of sexualized language or imagery and unwelcome sexual attention or advances
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or electronic address, without explicit permission
- Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned with this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <bpg.github.com.tn75g@passmail.net>. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at <https://www.contributor-covenant.org/version/1/4/code-of-conduct.html>.

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see <https://www.contributor-covenant.org/faq>.
`````

## File: CONTRIBUTING.md
`````markdown
# How to contribute

**First:** if you're unsure or afraid of _anything_, ask for help! You can
submit a work in progress (WIP) pull request, or file an issue with the parts
you know. We'll do our best to guide you in the right direction, and let you
know if there are guidelines we will need to follow. We want people to be able
to participate without fear of doing the wrong thing.

Below are our expectations for contributors. Following these guidelines gives us
the best opportunity to work with you, by making sure we have the things we need
in order to make it happen. Doing your best to follow it will speed up our
ability to merge PRs and respond to issues.

## Build the provider

> [!TIP]
> `$GOPATH` is the path to your Go workspace. If undefined, it defaults to `$HOME/go` on Linux and macOS, and `%USERPROFILE%\go` on Windows.

> [!NOTE]
> The provider requires Go 1.24 or later to build.

- Clone the repository to: `$GOPATH/src/github.com/bpg/terraform-provider-proxmox`:

  ```sh
  mkdir -p "${GOPATH}/src/github.com/bpg"
  cd "${GOPATH}/src/github.com/bpg"
  git clone git@github.com:bpg/terraform-provider-proxmox
  ```

- Enter the provider directory and build it:

  ```sh
  cd "${GOPATH}/src/github.com/bpg/terraform-provider-proxmox"
  make build
  ```

- To cross-compile the provider for all supported platforms:

  ```sh
  make build-all
  ```

  The compiled binaries will be placed in the `dist` directory.

A portion of the documentation is generated from the source code. To update the documentation, run:

```sh
make docs
```

## IDE support

If you are using VS Code, feel free to copy `settings.json` from `.vscode/settings.example.json`.

## Devcontainer support

Prerequisites:

- Docker (or Docker Desktop) installed on your machine  
- [VS Code Remote - Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)

To launch the devcontainer:

1. Open the project in VS Code.  
2. Run **Remote-Containers: Open Folder in Container** from the Command Palette.  

See [Developing inside a Container](https://code.visualstudio.com/docs/devcontainers/containers) for more details.

## Testing

### Unit Tests

The project has a test suite that must pass for contributions to be accepted. When making changes:

1. Run all tests with:

   ```sh
   make test
   ```

2. Add or modify test cases to cover your changes
3. Ensure all tests pass before submitting your PR

### Acceptance Tests

Acceptance tests run against a real Proxmox instance and verify the provider's functionality end-to-end. These tests are located in the `fwprovider/tests` directory.

#### Prerequisites

1. A running Proxmox instance (see [Setup Proxmox for Tests](docs/guides/setup-proxmox-for-tests.md))
2. Create a `testacc.env` file in the project root with:

```env
TF_ACC=1
PROXMOX_VE_API_TOKEN="root@pam!<token name>=<token value>"
PROXMOX_VE_ENDPOINT="https://<pve instance>:8006/"
PROXMOX_VE_SSH_AGENT="true"
PROXMOX_VE_SSH_USERNAME="root"
```

Optional configuration:

```env
# Override default node name and SSH settings
PROXMOX_VE_ACC_NODE_NAME="pve1"
PROXMOX_VE_ACC_NODE_SSH_ADDRESS="10.0.0.11"
PROXMOX_VE_ACC_NODE_SSH_PORT="22"
PROXMOX_VE_ACC_IFACE_NAME="enp1s0"
```

#### Running Acceptance Tests

Run the acceptance test suite with:

```sh
make testacc
```

If you want to run a single test or a group of tests, use the helper script:

```sh
./testacc <test_name>
```

For example, to run all VM-related tests: `./testacc.sh TestAccResourceVM.*`

> [!NOTE]
>
> - Acceptance test coverage is still in development
> - Only some resources and data sources are currently tested
> - Some tests may require specific Proxmox configuration

### Manual Testing

You can test the provider locally before submitting changes:

1. Create a provider override configuration in one of these locations:

   **Linux/macOS** (`$HOME/.terraformrc`):

   ```hcl
   provider_installation {
     dev_overrides {
       "bpg/proxmox" = "/home/user/go/bin/"  # Replace with your $GOPATH/bin
     }
     direct {}
   }
   ```

   **Windows** (`%APPDATA%/terraform.rc`):

   ```hcl
   provider_installation {
     dev_overrides {
       "bpg/proxmox" = "C:\\Users\\user\\go\\bin"  # Replace with your %GOPATH%/bin
     }
     direct {}
   }
   ```

2. Build and install the provider:

   ```sh
   go install .
   ```

3. Test your changes:

   ```sh
   terraform plan   # Preview changes
   terraform apply  # Apply changes
   ```

> [!TIP]
> After the initial setup, you only need to run `go install .` when rebuilding the provider.

## Coding conventions

We expect all code contributions to follow these guidelines:

1. Code must be formatted using `gofmt`
   - Run `make fmt` to format your code

2. Code must be linted using `golangci-lint`
   - Run `make lint` to lint your code

## Commit message conventions

We follow the [Conventional Commits](https://www.conventionalcommits.org/) specification. Please use the following types for your commits:

- `feat`: New features
- `fix`: Bug fixes
- `chore`: Maintenance tasks

These types are used to automatically generate the changelog. Other types will be ignored.

Use the `scope` field to indicate the area of the codebase being changed:

- `vm` - Virtual Machine resources
- `lxc` - Container resources
- `provider` - Provider configuration and resources
- `core` - Core libraries and utilities
- `docs` - Documentation
- `ci` - Continuous Integration / Actions / GitHub Workflows

Guidelines:

- Use lowercase for descriptions
- Do not end descriptions with a period
- Keep the first line under 72 characters

Example:

```commit
feat(vm): add support for the `clone` operation
```

### Developer Certificate of Origin (DCO)

All contributions must be signed off according to the Developer Certificate of Origin (DCO). The DCO is a lightweight way of certifying that you wrote or have the right to submit the code you are contributing. You can find the full text [here](https://developercertificate.org).

To sign off your commits, add a `Signed-off-by` line to your commit message:

```commit
feat(vm): add support for the `clone` operation

Signed-off-by: Random Developer <random@developer.example.org>
```

> [!NOTE]
>
> - Use your real name and a valid email address
> - You can use GitHub's `noreply` email address for privacy (see [GitHub docs](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-email-preferences/setting-your-commit-email-address#setting-your-commit-email-address-on-github))
> - If your Git config has `user.name` and `user.email` set, use `git commit -s` to automatically add the sign-off

For more details about the DCO checker, see the [DCO app repo](https://github.com/dcoapp/app).

## Submitting changes

1. Create a new PR against the `main` branch using the project's [pull request template](.github/PULL_REQUEST_TEMPLATE.md)
2. Ensure your PR title follows the Conventional Commits specification (we use this as the squash commit message)
3. All commits in a PR are typically squashed on merge

## Releasing

We use [release-please](https://github.com/googleapis/release-please) GitHub Action for automated release management. The process works as follows:

1. The action creates a release PR based on commit messages
2. The PR includes an auto-generated changelog and version bump
3. Maintainers review and merge the release PR
4. The release is automatically published to:
   - GitHub Releases
   - Terraform Registry

We aim to release new versions every 1-2 weeks.
`````

## File: CONTRIBUTORS.md
`````markdown
## Contributors

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://danitso.com/"><img src="https://avatars.githubusercontent.com/u/7096448?v=4?s=100" width="100px;" alt="Dan R. Petersen"/><br /><sub><b>Dan R. Petersen</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=danitso-dp" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/bpg"><img src="https://avatars.githubusercontent.com/u/627562?v=4?s=100" width="100px;" alt="Pavel Boldyrev"/><br /><sub><b>Pavel Boldyrev</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=bpg" title="Code">üíª</a> <a href="#maintenance-bpg" title="Maintenance">üöß</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/luhahn"><img src="https://avatars.githubusercontent.com/u/61747797?v=4?s=100" width="100px;" alt="Lucas Hahn"/><br /><sub><b>Lucas Hahn</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=luhahn" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/blz-ea"><img src="https://avatars.githubusercontent.com/u/19339605?v=4?s=100" width="100px;" alt="Alex Kulikovskikh"/><br /><sub><b>Alex Kulikovskikh</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=blz-ea" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/otopetrik"><img src="https://avatars.githubusercontent.com/u/972298?v=4?s=100" width="100px;" alt="Oto Pet≈ô√≠k"/><br /><sub><b>Oto Pet≈ô√≠k</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=otopetrik" title="Code">üíª</a> <a href="#question-otopetrik" title="Answering Questions">üí¨</a> <a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aotopetrik" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=otopetrik" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://www.patreon.com/boik"><img src="https://avatars.githubusercontent.com/u/6451933?v=4?s=100" width="100px;" alt="Boik"/><br /><sub><b>Boik</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=qazbnm456" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/abdo-farag"><img src="https://avatars.githubusercontent.com/u/10170837?v=4?s=100" width="100px;" alt="Abdelfadeel Farag"/><br /><sub><b>Abdelfadeel Farag</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=abdo-farag" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/kugo12"><img src="https://avatars.githubusercontent.com/u/15050771?v=4?s=100" width="100px;" alt="Szczepan Wi≈õniowski"/><br /><sub><b>Szczepan Wi≈õniowski</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=kugo12" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/xonvanetta"><img src="https://avatars.githubusercontent.com/u/11271952?v=4?s=100" width="100px;" alt="Fabian Heib"/><br /><sub><b>Fabian Heib</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=xonvanetta" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/kaje783"><img src="https://avatars.githubusercontent.com/u/120482249?v=4?s=100" width="100px;" alt="kaje783"/><br /><sub><b>kaje783</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=kaje783" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/michalg91"><img src="https://avatars.githubusercontent.com/u/63045346?v=4?s=100" width="100px;" alt="michalg91"/><br /><sub><b>michalg91</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=michalg91" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/1-cameron"><img src="https://avatars.githubusercontent.com/u/68611194?v=4?s=100" width="100px;" alt="Cameron"/><br /><sub><b>Cameron</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=1-cameron" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://christopherjones.us/"><img src="https://avatars.githubusercontent.com/u/115515?v=4?s=100" width="100px;" alt="Chris Jones"/><br /><sub><b>Chris Jones</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=magikid" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://dominik.wombacher.cc/"><img src="https://avatars.githubusercontent.com/u/16312366?v=4?s=100" width="100px;" alt="Dominik Wombacher"/><br /><sub><b>Dominik Wombacher</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=wombelix" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="http://frank.villaro-dixon.eu/"><img src="https://avatars.githubusercontent.com/u/17879459?v=4?s=100" width="100px;" alt="Frank Villaro-Dixon"/><br /><sub><b>Frank Villaro-Dixon</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Frankkkkk" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/groggemans"><img src="https://avatars.githubusercontent.com/u/11381284?v=4?s=100" width="100px;" alt="Gertjan Roggemans"/><br /><sub><b>Gertjan Roggemans</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=groggemans" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/HenriAW"><img src="https://avatars.githubusercontent.com/u/24527359?v=4?s=100" width="100px;" alt="Henri Williams"/><br /><sub><b>Henri Williams</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=HenriAW" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/zeddD1abl0"><img src="https://avatars.githubusercontent.com/u/8335605?v=4?s=100" width="100px;" alt="Jordan Keith"/><br /><sub><b>Jordan Keith</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=zeddD1abl0" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/shortmann"><img src="https://avatars.githubusercontent.com/u/20142334?v=4?s=100" width="100px;" alt="Kai Kahllund"/><br /><sub><b>Kai Kahllund</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=shortmann" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/kevinglasson"><img src="https://avatars.githubusercontent.com/u/22187575?v=4?s=100" width="100px;" alt="Kevin"/><br /><sub><b>Kevin</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=kevinglasson" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/krzysztof-magosa"><img src="https://avatars.githubusercontent.com/u/6112411?v=4?s=100" width="100px;" alt="Krzysztof Magosa"/><br /><sub><b>Krzysztof Magosa</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=krzysztof-magosa" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://burchett.dev/"><img src="https://avatars.githubusercontent.com/u/783042?v=4?s=100" width="100px;" alt="Matt Burchett"/><br /><sub><b>Matt Burchett</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=mattburchett" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/moyiz"><img src="https://avatars.githubusercontent.com/u/8603313?v=4?s=100" width="100px;" alt="Moyiz"/><br /><sub><b>Moyiz</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=moyiz" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/pescobar"><img src="https://avatars.githubusercontent.com/u/103797?v=4?s=100" width="100px;" alt="Pablo Escobar Lopez"/><br /><sub><b>Pablo Escobar Lopez</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=pescobar" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://hrmny.sh/"><img src="https://avatars.githubusercontent.com/u/8845940?v=4?s=100" width="100px;" alt="Leah"/><br /><sub><b>Leah</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ForsakenHarmony" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/wbpascal"><img src="https://avatars.githubusercontent.com/u/9532590?v=4?s=100" width="100px;" alt="Pascal Wiedenbeck"/><br /><sub><b>Pascal Wiedenbeck</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=wbpascal" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Patricol"><img src="https://avatars.githubusercontent.com/u/13428020?v=4?s=100" width="100px;" alt="Patrick Collins"/><br /><sub><b>Patrick Collins</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Patricol" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://prajwal-portfolio.netlify.app/"><img src="https://avatars.githubusercontent.com/u/48290911?v=4?s=100" width="100px;" alt="Prajwal"/><br /><sub><b>Prajwal</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=PrajwalBorkar" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/rafsaf"><img src="https://avatars.githubusercontent.com/u/51059348?v=4?s=100" width="100px;" alt="Rafa≈Ç Safin"/><br /><sub><b>Rafa≈Ç Safin</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=rafsaf" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=rafsaf" title="Documentation">üìñ</a> <a href="#ideas-rafsaf" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/RemkoMolier"><img src="https://avatars.githubusercontent.com/u/16520301?v=4?s=100" width="100px;" alt="Remko Molier"/><br /><sub><b>Remko Molier</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=RemkoMolier" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://www.tuomassalmi.com/"><img src="https://avatars.githubusercontent.com/u/3398165?v=4?s=100" width="100px;" alt="Tuomas Salmi"/><br /><sub><b>Tuomas Salmi</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Tumetsu" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ikiris"><img src="https://avatars.githubusercontent.com/u/4852950?v=4?s=100" width="100px;" alt="ikiris"/><br /><sub><b>ikiris</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ikiris" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/mleone87"><img src="https://avatars.githubusercontent.com/u/807457?v=4?s=100" width="100px;" alt="mleone87"/><br /><sub><b>mleone87</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=mleone87" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://thiscute.world/en/"><img src="https://avatars.githubusercontent.com/u/22363274?v=4?s=100" width="100px;" alt="Ryan Yin"/><br /><sub><b>Ryan Yin</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ryan4yin" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/zoop-btc"><img src="https://avatars.githubusercontent.com/u/101409458?v=4?s=100" width="100px;" alt="zoop"/><br /><sub><b>zoop</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=zoop-btc" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://www.si458.co.uk"><img src="https://avatars.githubusercontent.com/u/765314?v=4?s=100" width="100px;" alt="Simon Smith"/><br /><sub><b>Simon Smith</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Asi458" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=si458" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/grzeg1"><img src="https://avatars.githubusercontent.com/u/8179857?v=4?s=100" width="100px;" alt="grzeg1"/><br /><sub><b>grzeg1</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Agrzeg1" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/moustafab"><img src="https://avatars.githubusercontent.com/u/27738648?v=4?s=100" width="100px;" alt="Moustafa Baiou"/><br /><sub><b>Moustafa Baiou</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Amoustafab" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=moustafab" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/dandaolrian"><img src="https://avatars.githubusercontent.com/u/86479955?v=4?s=100" width="100px;" alt="dandaolrian"/><br /><sub><b>dandaolrian</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=dandaolrian" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=dandaolrian" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/yoshikakbudto"><img src="https://avatars.githubusercontent.com/u/10331946?v=4?s=100" width="100px;" alt="Dmitry"/><br /><sub><b>Dmitry</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Ayoshikakbudto" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://michael.franzl.name"><img src="https://avatars.githubusercontent.com/u/72123?v=4?s=100" width="100px;" alt="Michael Franzl"/><br /><sub><b>Michael Franzl</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Amichaelfranzl" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=michaelfranzl" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=michaelfranzl" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://www.ebenoit.info"><img src="https://avatars.githubusercontent.com/u/1409844?v=4?s=100" width="100px;" alt="Emmanuel Beno√Æt"/><br /><sub><b>Emmanuel Beno√Æt</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=tseeker" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Atseeker" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=tseeker" title="Tests">‚ö†Ô∏è</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/mandrav"><img src="https://avatars.githubusercontent.com/u/1273530?v=4?s=100" width="100px;" alt="mandrav"/><br /><sub><b>mandrav</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=mandrav" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Amandrav" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/michaelze"><img src="https://avatars.githubusercontent.com/u/673902?v=4?s=100" width="100px;" alt="Michael Iseli"/><br /><sub><b>Michael Iseli</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=michaelze" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Amichaelze" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/zharalim"><img src="https://avatars.githubusercontent.com/u/1004061?v=4?s=100" width="100px;" alt="Risto Oikarinen"/><br /><sub><b>Risto Oikarinen</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=zharalim" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/dawidole"><img src="https://avatars.githubusercontent.com/u/37155335?v=4?s=100" width="100px;" alt="dawidole"/><br /><sub><b>dawidole</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Adawidole" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://www.krupa.me.uk/"><img src="https://avatars.githubusercontent.com/u/5756726?v=4?s=100" width="100px;" alt="Gerard Krupa"/><br /><sub><b>Gerard Krupa</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=GJKrupa" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://simoncaron.com"><img src="https://avatars.githubusercontent.com/u/8635747?v=4?s=100" width="100px;" alt="Simon Caron"/><br /><sub><b>Simon Caron</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=simoncaron" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ishioni"><img src="https://avatars.githubusercontent.com/u/50323052?v=4?s=100" width="100px;" alt="Piotr Maksymiuk"/><br /><sub><b>Piotr Maksymiuk</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aishioni" title="Bug reports">üêõ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/0xinterface"><img src="https://avatars.githubusercontent.com/u/890207?v=4?s=100" width="100px;" alt="Kristopher"/><br /><sub><b>Kristopher</b></sub></a><br /><a href="#ideas-0xinterface" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/mritalian"><img src="https://avatars.githubusercontent.com/u/15789014?v=4?s=100" width="100px;" alt="Eric B"/><br /><sub><b>Eric B</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=mritalian" title="Tests">‚ö†Ô∏è</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=mritalian" title="Documentation">üìñ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Amritalian" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/2b"><img src="https://avatars.githubusercontent.com/u/829041?v=4?s=100" width="100px;" alt="2b"/><br /><sub><b>2b</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3A2b" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/TheNotary"><img src="https://avatars.githubusercontent.com/u/799247?v=4?s=100" width="100px;" alt="TheNotary"/><br /><sub><b>TheNotary</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=TheNotary" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=TheNotary" title="Tests">‚ö†Ô∏è</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=TheNotary" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/zamrih"><img src="https://avatars.githubusercontent.com/u/1061718?v=4?s=100" width="100px;" alt="zamrih"/><br /><sub><b>zamrih</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Azamrih" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=zamrih" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ratiborusx"><img src="https://avatars.githubusercontent.com/u/123507924?v=4?s=100" width="100px;" alt="Ratiborus"/><br /><sub><b>Ratiborus</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aratiborusx" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ratiborusx" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/skleinjung"><img src="https://avatars.githubusercontent.com/u/17599474?v=4?s=100" width="100px;" alt="Sean Kleinjung"/><br /><sub><b>Sean Kleinjung</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Askleinjung" title="Bug reports">üêõ</a> <a href="#financial-skleinjung" title="Financial">üíµ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/muhlba91"><img src="https://avatars.githubusercontent.com/u/653739?v=4?s=100" width="100px;" alt="Daniel M√ºhlbachler-Pietrzykowski"/><br /><sub><b>Daniel M√ºhlbachler-Pietrzykowski</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=muhlba91" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/windowsrefund"><img src="https://avatars.githubusercontent.com/u/512222?v=4?s=100" width="100px;" alt="windowsrefund"/><br /><sub><b>windowsrefund</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=windowsrefund" title="Tests">‚ö†Ô∏è</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=windowsrefund" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Fabiosilvero"><img src="https://avatars.githubusercontent.com/u/22865938?v=4?s=100" width="100px;" alt="Fabiosilvero"/><br /><sub><b>Fabiosilvero</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Fabiosilvero" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://danielhabenicht.github.io/"><img src="https://avatars.githubusercontent.com/u/13590797?v=4?s=100" width="100px;" alt="DanielHabenicht"/><br /><sub><b>DanielHabenicht</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3ADanielHabenicht" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=DanielHabenicht" title="Documentation">üìñ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=DanielHabenicht" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/dark-vex"><img src="https://avatars.githubusercontent.com/u/2905124?v=4?s=100" width="100px;" alt="Daniele De Lorenzi"/><br /><sub><b>Daniele De Lorenzi</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=dark-vex" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://www.simplysoft.ch"><img src="https://avatars.githubusercontent.com/u/1588210?v=4?s=100" width="100px;" alt="simplysoft"/><br /><sub><b>simplysoft</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=simplysoft" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://ruilopes.com"><img src="https://avatars.githubusercontent.com/u/43356?v=4?s=100" width="100px;" alt="Rui Lopes"/><br /><sub><b>Rui Lopes</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=rgl" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://soundcloud.com/midoriiro"><img src="https://avatars.githubusercontent.com/u/2159328?v=4?s=100" width="100px;" alt="Alexis Bekhdadi"/><br /><sub><b>Alexis Bekhdadi</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Amidoriiro" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/geoshapka"><img src="https://avatars.githubusercontent.com/u/32462387?v=4?s=100" width="100px;" alt="geoshapka"/><br /><sub><b>geoshapka</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Ageoshapka" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=geoshapka" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/tarik02"><img src="https://avatars.githubusercontent.com/u/12175048?v=4?s=100" width="100px;" alt="Taras"/><br /><sub><b>Taras</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=tarik02" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/redpimpernel"><img src="https://avatars.githubusercontent.com/u/50511476?v=4?s=100" width="100px;" alt="redpimpernel"/><br /><sub><b>redpimpernel</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=redpimpernel" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/dylanbegin"><img src="https://avatars.githubusercontent.com/u/64234261?v=4?s=100" width="100px;" alt="Dylan Begin"/><br /><sub><b>Dylan Begin</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Adylanbegin" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=dylanbegin" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ActualTrash"><img src="https://avatars.githubusercontent.com/u/31072505?v=4?s=100" width="100px;" alt="Chase H"/><br /><sub><b>Chase H</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ActualTrash" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/zmingxie"><img src="https://avatars.githubusercontent.com/u/1136583?v=4?s=100" width="100px;" alt="Ming Xie"/><br /><sub><b>Ming Xie</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=zmingxie" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=zmingxie" title="Documentation">üìñ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/frostyfab"><img src="https://avatars.githubusercontent.com/u/140175283?v=4?s=100" width="100px;" alt="frostyfab"/><br /><sub><b>frostyfab</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=frostyfab" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/joek-office"><img src="https://avatars.githubusercontent.com/u/124031385?v=4?s=100" width="100px;" alt="joek-office"/><br /><sub><b>joek-office</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Ajoek-office" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://opnsrc.dev"><img src="https://avatars.githubusercontent.com/u/2036998?v=4?s=100" width="100px;" alt="Mahesh K."/><br /><sub><b>Mahesh K.</b></sub></a><br /><a href="#financial-mkopnsrc" title="Financial">üíµ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/bitchecker"><img src="https://avatars.githubusercontent.com/u/11056930?v=4?s=100" width="100px;" alt="bitchecker"/><br /><sub><b>bitchecker</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=bitchecker" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/olemathias"><img src="https://avatars.githubusercontent.com/u/891048?v=4?s=100" width="100px;" alt="Ole Mathias Aa. Heggem"/><br /><sub><b>Ole Mathias Aa. Heggem</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aolemathias" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/scibi"><img src="https://avatars.githubusercontent.com/u/703860?v=4?s=100" width="100px;" alt="scibi"/><br /><sub><b>scibi</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Ascibi" title="Bug reports">üêõ</a> <a href="#ideas-scibi" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/LEI"><img src="https://avatars.githubusercontent.com/u/4112243?v=4?s=100" width="100px;" alt="Guillaume"/><br /><sub><b>Guillaume</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=LEI" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://loganmancuso.github.io/"><img src="https://avatars.githubusercontent.com/u/18329590?v=4?s=100" width="100px;" alt="Logan Mancuso"/><br /><sub><b>Logan Mancuso</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aloganmancuso" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/benbouillet"><img src="https://avatars.githubusercontent.com/u/15980664?v=4?s=100" width="100px;" alt="Ben Bouillet"/><br /><sub><b>Ben Bouillet</b></sub></a><br /><a href="#financial-benbouillet" title="Financial">üíµ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/CppBunny"><img src="https://avatars.githubusercontent.com/u/7388307?v=4?s=100" width="100px;" alt="CppBunny"/><br /><sub><b>CppBunny</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=CppBunny" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/srautiai"><img src="https://avatars.githubusercontent.com/u/1098080?v=4?s=100" width="100px;" alt="Sakari Rautiainen"/><br /><sub><b>Sakari Rautiainen</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Asrautiai" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://tomstok.es"><img src="https://avatars.githubusercontent.com/u/1216926?v=4?s=100" width="100px;" alt="Tom Stokes"/><br /><sub><b>Tom Stokes</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=tomstokes" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/jkossis"><img src="https://avatars.githubusercontent.com/u/1247832?v=4?s=100" width="100px;" alt="Jason Kossis"/><br /><sub><b>Jason Kossis</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=jkossis" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/lfelicetti-softatnet"><img src="https://avatars.githubusercontent.com/u/138860955?v=4?s=100" width="100px;" alt="lfelicetti-softatnet"/><br /><sub><b>lfelicetti-softatnet</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Alfelicetti-softatnet" title="Bug reports">üêõ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://thegeeklab.de"><img src="https://avatars.githubusercontent.com/u/3391958?v=4?s=100" width="100px;" alt="Robert Kaussow"/><br /><sub><b>Robert Kaussow</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=xoxys" title="Code">üíª</a> <a href="#ideas-xoxys" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/laktosterror"><img src="https://avatars.githubusercontent.com/u/55037659?v=4?s=100" width="100px;" alt="laktosterror"/><br /><sub><b>laktosterror</b></sub></a><br /><a href="#ideas-laktosterror" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/jtamas96"><img src="https://avatars.githubusercontent.com/u/25171705?v=4?s=100" width="100px;" alt="J√°nosi Tam√°s"/><br /><sub><b>J√°nosi Tam√°s</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Ajtamas96" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://starless.one"><img src="https://avatars.githubusercontent.com/u/41077433?v=4?s=100" width="100px;" alt="romner"/><br /><sub><b>romner</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aromner-set" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://jayden-lind.github.io"><img src="https://avatars.githubusercontent.com/u/70465314?v=4?s=100" width="100px;" alt="Jayden Lind"/><br /><sub><b>Jayden Lind</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Jayden-Lind" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Eusebius1920"><img src="https://avatars.githubusercontent.com/u/8429638?v=4?s=100" width="100px;" alt="Eusebius1920"/><br /><sub><b>Eusebius1920</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3AEusebius1920" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Eusebius1920" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/kvangent"><img src="https://avatars.githubusercontent.com/u/10712294?v=4?s=100" width="100px;" alt="kvangent"/><br /><sub><b>kvangent</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Akvangent" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=kvangent" title="Tests">‚ö†Ô∏è</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ecanuto"><img src="https://avatars.githubusercontent.com/u/55260?v=4?s=100" width="100px;" alt="Everaldo Canuto"/><br /><sub><b>Everaldo Canuto</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ecanuto" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Dr-Shadow"><img src="https://avatars.githubusercontent.com/u/5308086?v=4?s=100" width="100px;" alt="Dr-Shadow"/><br /><sub><b>Dr-Shadow</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3ADr-Shadow" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/FabFaeb"><img src="https://avatars.githubusercontent.com/u/10672940?v=4?s=100" width="100px;" alt="Fabian Franz"/><br /><sub><b>Fabian Franz</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=FabFaeb" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/s-vincent"><img src="https://avatars.githubusercontent.com/u/745464?v=4?s=100" width="100px;" alt="Sebastien Vincent"/><br /><sub><b>Sebastien Vincent</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3As-vincent" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/jackhodgkiss"><img src="https://avatars.githubusercontent.com/u/52131498?v=4?s=100" width="100px;" alt="Jack Hodgkiss"/><br /><sub><b>Jack Hodgkiss</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=jackhodgkiss" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/marvkos"><img src="https://avatars.githubusercontent.com/u/87067609?v=4?s=100" width="100px;" alt="marvkos"/><br /><sub><b>marvkos</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=marvkos" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Koloss5421"><img src="https://avatars.githubusercontent.com/u/26049477?v=4?s=100" width="100px;" alt="Koloss5421"/><br /><sub><b>Koloss5421</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Koloss5421" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://sa.m-h.ug/"><img src="https://avatars.githubusercontent.com/u/171470?v=4?s=100" width="100px;" alt="Sam Hug"/><br /><sub><b>Sam Hug</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=samhug" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/dyadMisha"><img src="https://avatars.githubusercontent.com/u/37950256?v=4?s=100" width="100px;" alt="dyadMisha"/><br /><sub><b>dyadMisha</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=dyadMisha" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/msdnna"><img src="https://avatars.githubusercontent.com/u/11697271?v=4?s=100" width="100px;" alt="msdnna"/><br /><sub><b>msdnna</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=msdnna" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/soubinan"><img src="https://avatars.githubusercontent.com/u/20760371?v=4?s=100" width="100px;" alt="Soubinan KACOU"/><br /><sub><b>Soubinan KACOU</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Asoubinan" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=soubinan" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/sergelogvinov"><img src="https://avatars.githubusercontent.com/u/5407715?v=4?s=100" width="100px;" alt="Serge"/><br /><sub><b>Serge</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=sergelogvinov" title="Code">üíª</a> <a href="#financial-sergelogvinov" title="Financial">üíµ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/batonogov"><img src="https://avatars.githubusercontent.com/u/52496117?v=4?s=100" width="100px;" alt="Fedor Batonogov"/><br /><sub><b>Fedor Batonogov</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Abatonogov" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://devminer.xyz"><img src="https://avatars.githubusercontent.com/u/29845135?v=4?s=100" width="100px;" alt="DevMiner"/><br /><sub><b>DevMiner</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=TheDevMinerTV" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/tyxieblub"><img src="https://avatars.githubusercontent.com/u/5111464?v=4?s=100" width="100px;" alt="joris"/><br /><sub><b>joris</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=tyxieblub" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://www.nordtheme.com"><img src="https://avatars.githubusercontent.com/u/13448100?v=4?s=100" width="100px;" alt="Sven Greb"/><br /><sub><b>Sven Greb</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=svengreb" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/niektoniekde"><img src="https://avatars.githubusercontent.com/u/271951?v=4?s=100" width="100px;" alt="Jaroslav Petras"/><br /><sub><b>Jaroslav Petras</b></sub></a><br /><a href="#financial-niektoniekde" title="Financial">üíµ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://nankeen.me"><img src="https://avatars.githubusercontent.com/u/6895854?v=4?s=100" width="100px;" alt="Kai"/><br /><sub><b>Kai</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=nankeen" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Sparta142"><img src="https://avatars.githubusercontent.com/u/2008922?v=4?s=100" width="100px;" alt="Brian"/><br /><sub><b>Brian</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Sparta142" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://kiljaeden.net"><img src="https://avatars.githubusercontent.com/u/15212835?v=4?s=100" width="100px;" alt="Kil'jaeden"/><br /><sub><b>Kil'jaeden</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=AtaLuZiK" title="Tests">‚ö†Ô∏è</a> <a href="#ideas-AtaLuZiK" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://www.linkedin.com/in/rudolf-tammekivi/"><img src="https://avatars.githubusercontent.com/u/1191779?v=4?s=100" width="100px;" alt="Rudolf Tammekivi"/><br /><sub><b>Rudolf Tammekivi</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3ABlefish" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Blefish" title="Code">üíª</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/karliemeads"><img src="https://avatars.githubusercontent.com/u/68717336?v=4?s=100" width="100px;" alt="Karlie Meads"/><br /><sub><b>Karlie Meads</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=karliemeads" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://www.linkedin.com/in/charles-rodrigues-313ba9179/"><img src="https://avatars.githubusercontent.com/u/56375916?v=4?s=100" width="100px;" alt="Charles Rodrigues"/><br /><sub><b>Charles Rodrigues</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=chrodrigues" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://www.linkedin.com/in/connor-creek-318a86107/"><img src="https://avatars.githubusercontent.com/u/33628343?v=4?s=100" width="100px;" alt="Connor Creek"/><br /><sub><b>Connor Creek</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=CCreek96" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://blog.lucid.net.au"><img src="https://avatars.githubusercontent.com/u/1295960?v=4?s=100" width="100px;" alt="Jason Lingohr"/><br /><sub><b>Jason Lingohr</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=lingfish" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/simonebenati"><img src="https://avatars.githubusercontent.com/u/102557087?v=4?s=100" width="100px;" alt="Simone Benati"/><br /><sub><b>Simone Benati</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Asimonebenati" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=simonebenati" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/konstantin-kornienko"><img src="https://avatars.githubusercontent.com/u/50887992?v=4?s=100" width="100px;" alt="Konstantin Kornienko"/><br /><sub><b>Konstantin Kornienko</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=konstantin-kornienko" title="Code">üíª</a> <a href="#ideas-konstantin-kornienko" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/KingKeithC"><img src="https://avatars.githubusercontent.com/u/23621671?v=4?s=100" width="100px;" alt="Keith"/><br /><sub><b>Keith</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=KingKeithC" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=KingKeithC" title="Tests">‚ö†Ô∏è</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ZauberNerd"><img src="https://avatars.githubusercontent.com/u/249542?v=4?s=100" width="100px;" alt="Bj√∂rn Brauer"/><br /><sub><b>Bj√∂rn Brauer</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=ZauberNerd" title="Code">üíª</a> <a href="#ideas-ZauberNerd" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Diskoteket"><img src="https://avatars.githubusercontent.com/u/69105072?v=4?s=100" width="100px;" alt="Tim Wetterek"/><br /><sub><b>Tim Wetterek</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Diskoteket" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://a-w.io"><img src="https://avatars.githubusercontent.com/u/159919?v=4?s=100" width="100px;" alt="Andreas Wolf"/><br /><sub><b>Andreas Wolf</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Aandreaswolf" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://jordangarside.com/"><img src="https://avatars.githubusercontent.com/u/6321824?v=4?s=100" width="100px;" alt="Jordan Garside"/><br /><sub><b>Jordan Garside</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=jordangarside" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://vanillasprinkles.com/"><img src="https://avatars.githubusercontent.com/u/577861?v=4?s=100" width="100px;" alt="vanillaSprinkles"/><br /><sub><b>vanillaSprinkles</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=vanillaSprinkles" title="Code">üíª</a> <a href="#ideas-vanillaSprinkles" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/seankoneill"><img src="https://avatars.githubusercontent.com/u/35414430?v=4?s=100" width="100px;" alt="Sean O'Neill"/><br /><sub><b>Sean O'Neill</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=seankoneill" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/nrsmac"><img src="https://avatars.githubusercontent.com/u/8288816?v=4?s=100" width="100px;" alt="Noah Schill"/><br /><sub><b>Noah Schill</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=nrsmac" title="Documentation">üìñ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/camaeel"><img src="https://avatars.githubusercontent.com/u/12999736?v=4?s=100" width="100px;" alt="Kamil Krzywicki"/><br /><sub><b>Kamil Krzywicki</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Acamaeel" title="Bug reports">üêõ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://stackoverflow.com/users/7487335/josh-correia"><img src="https://avatars.githubusercontent.com/u/86431308?v=4?s=100" width="100px;" alt="joshmcorreia"/><br /><sub><b>joshmcorreia</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=joshmcorreia" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Mrton0121"><img src="https://avatars.githubusercontent.com/u/60232434?v=4?s=100" width="100px;" alt="Mrton0121"/><br /><sub><b>Mrton0121</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Mrton0121" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="http://dagi3d.net"><img src="https://avatars.githubusercontent.com/u/11283?v=4?s=100" width="100px;" alt="dagi3d"/><br /><sub><b>dagi3d</b></sub></a><br /><a href="#financial-dagi3d" title="Financial">üíµ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/QlemWasTaken"><img src="https://avatars.githubusercontent.com/u/73081296?v=4?s=100" width="100px;" alt="Qlem"/><br /><sub><b>Qlem</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=QlemWasTaken" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://tarasa24.dev"><img src="https://avatars.githubusercontent.com/u/20138731?v=4?s=100" width="100px;" alt="Petr Gajdosik"/><br /><sub><b>Petr Gajdosik</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Tarasa24" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Tarasa24" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://dhimas.net"><img src="https://avatars.githubusercontent.com/u/4391866?v=4?s=100" width="100px;" alt="Gifary Dhimas Fadhillah"/><br /><sub><b>Gifary Dhimas Fadhillah</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=gifff" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3Agifff" title="Bug reports">üêõ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/h3krn"><img src="https://avatars.githubusercontent.com/u/13312478?v=4?s=100" width="100px;" alt="H3Krn"/><br /><sub><b>H3Krn</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=h3krn" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://cgeopapa.github.io/"><img src="https://avatars.githubusercontent.com/u/12190384?v=4?s=100" width="100px;" alt="cgeopapa"/><br /><sub><b>cgeopapa</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=cgeopapa" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/fulsiram"><img src="https://avatars.githubusercontent.com/u/79424365?v=4?s=100" width="100px;" alt="fulsiram"/><br /><sub><b>fulsiram</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=fulsiram" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/nakamorichi"><img src="https://avatars.githubusercontent.com/u/36138?v=4?s=100" width="100px;" alt="Mikael Nakajima"/><br /><sub><b>Mikael Nakajima</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=nakamorichi" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Nemesees"><img src="https://avatars.githubusercontent.com/u/75946990?v=4?s=100" width="100px;" alt="Nemesees"/><br /><sub><b>Nemesees</b></sub></a><br /><a href="#financial-Nemesees" title="Financial">üíµ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://149segolte.dev"><img src="https://avatars.githubusercontent.com/u/37300847?v=4?s=100" width="100px;" alt="Shreyansh Nayak"/><br /><sub><b>Shreyansh Nayak</b></sub></a><br /><a href="#ideas-149segolte" title="Ideas, Planning, & Feedback">ü§î</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/techuser9182"><img src="https://avatars.githubusercontent.com/u/130158571?v=4?s=100" width="100px;" alt="techuser9182"/><br /><sub><b>techuser9182</b></sub></a><br /><a href="#financial-techuser9182" title="Financial">üíµ</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/pileus-lines"><img src="https://avatars.githubusercontent.com/u/74184010?v=4?s=100" width="100px;" alt="pileus-lines"/><br /><sub><b>pileus-lines</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=pileus-lines" title="Documentation">üìñ</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/CaptaiNiveau"><img src="https://avatars.githubusercontent.com/u/79282544?v=4?s=100" width="100px;" alt="CaptaiNiveau"/><br /><sub><b>CaptaiNiveau</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=CaptaiNiveau" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/TomaszDom"><img src="https://avatars.githubusercontent.com/u/9348532?v=4?s=100" width="100px;" alt="TomaszDom"/><br /><sub><b>TomaszDom</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3ATomaszDom" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=TomaszDom" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Guldoman"><img src="https://avatars.githubusercontent.com/u/2798487?v=4?s=100" width="100px;" alt="Guldoman"/><br /><sub><b>Guldoman</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/issues?q=author%3AGuldoman" title="Bug reports">üêõ</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Guldoman" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/felinira"><img src="https://avatars.githubusercontent.com/u/121945?v=4?s=100" width="100px;" alt="Fina"/><br /><sub><b>Fina</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=felinira" title="Code">üíª</a> <a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=felinira" title="Tests">‚ö†Ô∏è</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/antoniacobaeus"><img src="https://avatars.githubusercontent.com/u/46004494?v=4?s=100" width="100px;" alt="Anton Iacobaeus"/><br /><sub><b>Anton Iacobaeus</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=antoniacobaeus" title="Code">üíª</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Bartosz-lab"><img src="https://avatars.githubusercontent.com/u/73119351?v=4?s=100" width="100px;" alt="Bartosz Cie≈õlik"/><br /><sub><b>Bartosz Cie≈õlik</b></sub></a><br /><a href="https://github.com/bpg/terraform-provider-proxmox/commits?author=Bartosz-lab" title="Code">üíª</a></td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td align="center" size="13px" colspan="7">
        <img src="https://raw.githubusercontent.com/all-contributors/all-contributors-cli/1b8533af435da9854653492b1327a23a4dbd0a10/assets/logo-small.svg">
          <a href="https://all-contributors.js.org/docs/en/bot/usage">Add your contributions</a>
        </img>
      </td>
    </tr>
  </tfoot>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->
`````

## File: example.tfrc
`````
provider_installation {
   dev_overrides {
     "bpg/proxmox" = "../build"
   }
  direct {}
}
`````

## File: go.mod
`````
module github.com/bpg/terraform-provider-proxmox

go 1.24

tool github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs

require (
	github.com/Microsoft/go-winio v0.6.2
	github.com/avast/retry-go/v4 v4.6.1
	github.com/brianvoe/gofakeit/v7 v7.2.1
	github.com/google/go-cmp v0.7.0
	github.com/google/go-querystring v1.1.0
	github.com/google/uuid v1.6.0
	github.com/hashicorp/go-cty v1.5.0
	github.com/hashicorp/terraform-plugin-framework v1.15.0
	github.com/hashicorp/terraform-plugin-framework-timeouts v0.5.0
	github.com/hashicorp/terraform-plugin-framework-validators v0.18.0
	github.com/hashicorp/terraform-plugin-go v0.28.0
	github.com/hashicorp/terraform-plugin-log v0.9.0
	github.com/hashicorp/terraform-plugin-mux v0.20.0
	github.com/hashicorp/terraform-plugin-sdk/v2 v2.37.0
	github.com/hashicorp/terraform-plugin-testing v1.13.1
	github.com/pkg/sftp v1.13.9
	github.com/rogpeppe/go-internal v1.14.1
	github.com/skeema/knownhosts v1.3.1
	github.com/stretchr/testify v1.10.0
	golang.org/x/crypto v0.39.0
	golang.org/x/net v0.41.0
)

require (
	github.com/BurntSushi/toml v1.4.1-0.20240526193622-a339e1f7089c // indirect
	github.com/Kunde21/markdownfmt/v3 v3.1.0 // indirect
	github.com/Masterminds/goutils v1.1.1 // indirect
	github.com/Masterminds/semver/v3 v3.3.0 // indirect
	github.com/Masterminds/sprig/v3 v3.2.3 // indirect
	github.com/ProtonMail/go-crypto v1.1.6 // indirect
	github.com/agext/levenshtein v1.2.3 // indirect
	github.com/apparentlymart/go-textseg/v15 v15.0.0 // indirect
	github.com/armon/go-radix v1.0.0 // indirect
	github.com/bgentry/speakeasy v0.1.0 // indirect
	github.com/bmatcuk/doublestar/v4 v4.8.1 // indirect
	github.com/cloudflare/circl v1.6.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fatih/color v1.18.0 // indirect
	github.com/golang/protobuf v1.5.4 // indirect
	github.com/hashicorp/cli v1.1.7 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-checkpoint v0.5.0 // indirect
	github.com/hashicorp/go-cleanhttp v0.5.2 // indirect
	github.com/hashicorp/go-hclog v1.6.3 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/hashicorp/go-plugin v1.6.3 // indirect
	github.com/hashicorp/go-retryablehttp v0.7.7 // indirect
	github.com/hashicorp/go-uuid v1.0.3 // indirect
	github.com/hashicorp/go-version v1.7.0 // indirect
	github.com/hashicorp/hc-install v0.9.2 // indirect
	github.com/hashicorp/hcl/v2 v2.23.0 // indirect
	github.com/hashicorp/logutils v1.0.0 // indirect
	github.com/hashicorp/terraform-exec v0.23.0 // indirect
	github.com/hashicorp/terraform-json v0.25.0 // indirect
	github.com/hashicorp/terraform-plugin-docs v0.21.0 // indirect
	github.com/hashicorp/terraform-registry-address v0.2.5 // indirect
	github.com/hashicorp/terraform-svchost v0.1.1 // indirect
	github.com/hashicorp/yamux v0.1.1 // indirect
	github.com/huandu/xstrings v1.3.3 // indirect
	github.com/imdario/mergo v0.3.15 // indirect
	github.com/kr/fs v0.1.0 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/copystructure v1.2.0 // indirect
	github.com/mitchellh/go-testing-interface v1.14.1 // indirect
	github.com/mitchellh/go-wordwrap v1.0.1 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/mitchellh/reflectwalk v1.0.2 // indirect
	github.com/oklog/run v1.1.0 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/posener/complete v1.2.3 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/shopspring/decimal v1.3.1 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/vmihailenco/msgpack v4.0.4+incompatible // indirect
	github.com/vmihailenco/msgpack/v5 v5.4.1 // indirect
	github.com/vmihailenco/tagparser/v2 v2.0.0 // indirect
	github.com/yuin/goldmark v1.7.7 // indirect
	github.com/yuin/goldmark-meta v1.1.0 // indirect
	github.com/zclconf/go-cty v1.16.2 // indirect
	go.abhg.dev/goldmark/frontmatter v0.2.0 // indirect
	golang.org/x/exp v0.0.0-20240909161429-701f63a606c0 // indirect
	golang.org/x/mod v0.25.0 // indirect
	golang.org/x/sync v0.15.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/text v0.26.0 // indirect
	golang.org/x/tools v0.33.0 // indirect
	google.golang.org/appengine v1.6.8 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250218202821-56aae31c358a // indirect
	google.golang.org/grpc v1.72.1 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
`````

## File: HISTORY.md
`````markdown
## v0.4.4

BUG FIXES:

* resource/virtual_environment_vm: Fix watchdog deserialization issue

## v0.4.3

BUG FIXES:

* resource/virtual_environment_container: Fix IP initialization issue

## v0.4.2

BUG FIXES:

* resource/virtual_environment_vm: Fix `disk.file_id` diff issue
* resource/virtual_environment_vm: Fix disk resizing issue

OTHER:

* provider/example: Remove support for Terraform v0.11 and older
* provider/makefile: Update to use plugin caching to support local builds

## v0.4.1

OTHER:

* provider/docs: Fix issue with navigational link titles in Terraform Registry

## v0.4.0

FEATURES:

* **New Data Source:** `proxmox_virtual_environment_time`
* **New Resource:** `proxmox_virtual_environment_time`

BREAKING CHANGES:

* resource/virtual_environment_vm: `interface` is now required to create disks

    ```
      disk {
        datastore_id = "local-lvm"
        file_id      = "${proxmox_virtual_environment_file.ubuntu_cloud_image.id}"
        interface    = "scsi0"
      }
    ```

ENHANCEMENTS:

* provider/configuration: Add `virtual_environment.otp` argument for TOTP support
* resource/virtual_environment_vm: Clone supports resize and datastore_id for moving disks
* resource/virtual_environment_vm: Bulk clones can now use retries as argument to try multiple times to create a clone.
* resource/virtual_environment_vm: `on_boot` parameter can be used to start a VM after the Node has been rebooted.
* resource/virtual_environment_vm: `reboot` parameter can be used to reboot a VM after creation
* resource/virtual_environment_vm: Has now multiple new parameters to set timeouts for the vm creation/cloning `timeout_clone`, `timeout_move_disk`, `timeout_reboot`, `timeout_shutdown_vm`, `timeout_start_vm`, `timeout_stop_vm`

BUG FIXES:

* library/virtual_environment_nodes: Fix node IP address format
* library/virtual_environment_nodes: Fix WaitForNodeTask now detects errors correctly
* library/virtual_environment_vm: Fix CloneVM now waits for the task to be finished and detect errors.
* resource/virtual_environment_container: Fix VM ID collision when `vm_id` is not specified
* resource/virtual_environment_vm: Fix VM ID collision when `vm_id` is not specified
* resource/virtual_environment_vm: Fix disk import issue when importing from directory-based datastores
* resource/virtual_environment_vm: Fix handling of storage name - correct handling of `-`

WORKAROUNDS:

* resource/virtual_environment_vm: Ignore default value for `cpu.architecture` when the root account is not being used

## 0.3.0

ENHANCEMENTS:

* resource/virtual_environment_container: Add `clone` argument
* resource/virtual_environment_container: Add `disk` argument
* resource/virtual_environment_container: Add `template` argument
* resource/virtual_environment_vm: Add `agent.timeout` argument
* resource/virtual_environment_vm: Add `audio_device` argument
* resource/virtual_environment_vm: Add `clone` argument
* resource/virtual_environment_vm: Add `initialization.datastore_id` argument
* resource/virtual_environment_vm: Add `serial_device` argument
* resource/virtual_environment_vm: Add `template` argument

BUG FIXES:

* resource/virtual_environment_container: Fix `network_interface` deletion issue
* resource/virtual_environment_vm: Fix `network_device` deletion issue
* resource/virtual_environment_vm: Fix slow refresh when VM is stopped and agent is enabled
* resource/virtual_environment_vm: Fix crash caused by assuming IP addresses are always reported by the QEMU agent
* resource/virtual_environment_vm: Fix timeout issue while waiting for IP addresses to be reported by the QEMU agent

OTHER:

* provider/docs: Add HTML documentation powered by GitHub Pages

## 0.2.0

BREAKING CHANGES:

* resource/virtual_environment_vm: Rename `cloud_init` argument to `initialization`
* resource/virtual_environment_vm: Rename `os_type` argument to `operating_system.type`

FEATURES:

* **New Data Source:** `proxmox_virtual_environment_dns`
* **New Data Source:** `proxmox_virtual_environment_hosts`
* **New Resource:** `proxmox_virtual_environment_certificate`
* **New Resource:** `proxmox_virtual_environment_container`
* **New Resource:** `proxmox_virtual_environment_dns`
* **New Resource:** `proxmox_virtual_environment_hosts`

ENHANCEMENTS:

* resource/virtual_environment_vm: Add `acpi` argument
* resource/virtual_environment_vm: Add `bios` argument
* resource/virtual_environment_vm: Add `cpu.architecture`, `cpu.flags`, `cpu.type` and `cpu.units` arguments
* resource/virtual_environment_vm: Add `tablet_device` argument
* resource/virtual_environment_vm: Add `vga` argument

## 0.1.0

FEATURES:

* **New Data Source:** `proxmox_virtual_environment_datastores`
* **New Data Source:** `proxmox_virtual_environment_group`
* **New Data Source:** `proxmox_virtual_environment_groups`
* **New Data Source:** `proxmox_virtual_environment_nodes`
* **New Data Source:** `proxmox_virtual_environment_pool`
* **New Data Source:** `proxmox_virtual_environment_pools`
* **New Data Source:** `proxmox_virtual_environment_role`
* **New Data Source:** `proxmox_virtual_environment_roles`
* **New Data Source:** `proxmox_virtual_environment_user`
* **New Data Source:** `proxmox_virtual_environment_users`
* **New Data Source:** `proxmox_virtual_environment_version`
* **New Resource:** `proxmox_virtual_environment_file`
* **New Resource:** `proxmox_virtual_environment_group`
* **New Resource:** `proxmox_virtual_environment_pool`
* **New Resource:** `proxmox_virtual_environment_role`
* **New Resource:** `proxmox_virtual_environment_user`
* **New Resource:** `proxmox_virtual_environment_vm`
`````

## File: LICENSE
`````
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.
`````

## File: main.go
`````go
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package main

import (
	"context"
	"flag"
	"log"

	"github.com/hashicorp/terraform-plugin-framework/providerserver"
	"github.com/hashicorp/terraform-plugin-go/tfprotov5"
	"github.com/hashicorp/terraform-plugin-go/tfprotov6"
	"github.com/hashicorp/terraform-plugin-go/tfprotov6/tf6server"
	"github.com/hashicorp/terraform-plugin-mux/tf5to6server"
	"github.com/hashicorp/terraform-plugin-mux/tf6muxserver"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/bpg/terraform-provider-proxmox/fwprovider"
	"github.com/bpg/terraform-provider-proxmox/proxmoxtf/provider"
)

// Format Terraform code for use in documentation.
// If you do not have Terraform installed, you can remove the formatting command, but it is suggested
// to ensure the documentation is formatted properly.
//go:generate terraform fmt -recursive ./examples/
// Generate documentation.
//go:generate go tool github.com/hashicorp/terraform-plugin-docs/cmd/tfplugindocs generate --provider-dir ./ --rendered-website-dir ./build/docs-gen --provider-name "terraform-provider-proxmox" --rendered-provider-name "terraform-provider-proxmox" //nolint:lll

// Temporary: while migrating to the TF framework, we need to copy the generated docs to the right place
// for the resources / data sources that have been migrated.
//go:generate cp -R ./build/docs-gen/guides/. ./docs/guides/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_acme_account.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_acme_accounts.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_acme_plugin.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_acme_plugins.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_apt_repository.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_apt_standard_repository.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_datastores.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_hagroup.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_hagroups.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_hardware_mapping_dir.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_hardware_mapping_pci.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_hardware_mapping_usb.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_hardware_mappings.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_haresource.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_haresources.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_version.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_vm2.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/data-sources/virtual_environment_metrics_server.md ./docs/data-sources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_acl.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_acme_account.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_acme_dns_plugin.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_apt_repository.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_apt_standard_repository.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_cluster_options.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_download_file.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_hagroup.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_hardware_mapping_dir.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_hardware_mapping_pci.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_hardware_mapping_usb.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_haresource.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_network_linux_bridge.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_network_linux_vlan.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_user_token.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_vm2.md ./docs/resources/
//go:generate cp ./build/docs-gen/resources/virtual_environment_metrics_server.md ./docs/resources/

// these will be set by the goreleaser configuration
// to appropriate values for the compiled binary.
var version = "dev"

func main() {
	ctx := context.Background()

	var debug bool

	flag.BoolVar(&debug, "debug", false, "set to true to run the provider with support for debuggers like delve")
	flag.Parse()

	upgradedSdkServer, err := tf5to6server.UpgradeServer(
		ctx,
		func() tfprotov5.ProviderServer {
			return schema.NewGRPCProviderServer(
				provider.ProxmoxVirtualEnvironment(),
			)
		},
	)
	if err != nil {
		log.Fatal(err)
	}

	providers := []func() tfprotov6.ProviderServer{
		providerserver.NewProtocol6(fwprovider.New(version)()),
		func() tfprotov6.ProviderServer {
			return upgradedSdkServer
		},
	}

	muxServer, err := tf6muxserver.NewMuxServer(ctx, providers...)
	if err != nil {
		log.Fatal(err)
	}

	var serveOpts []tf6server.ServeOpt

	if debug {
		serveOpts = append(serveOpts, tf6server.WithManagedDebug())
	}

	// Remove any date and time prefix in log package function output to
	// prevent duplicate timestamp and incorrect log level setting
	log.SetFlags(log.Flags() &^ (log.Ldate | log.Ltime))

	err = tf6server.Serve(
		"registry.terraform.io/bpg/proxmox",
		muxServer.ProviderServer,
		serveOpts...,
	)
	if err != nil {
		log.Fatal(err)
	}
}
`````

## File: Makefile
`````
NAME=terraform-provider-proxmox
TARGETS=darwin linux windows
TERRAFORM_PLUGIN_EXTENSION=
VERSION=0.78.1# x-release-please-version

GOLANGCI_LINT_VERSION=2.1.6# renovate: depName=golangci/golangci-lint datasource=github-releases

# check if opentofu is installed and use it if it is,
# otherwise use terraform
ifeq ($(shell tofu -version 2>/dev/null),)
	TERRAFORM_EXECUTABLE=terraform
else
	TERRAFORM_EXECUTABLE=tofu
endif

ifeq ($(OS),Windows_NT)
	TERRAFORM_PLATFORM=windows_amd64
	TERRAFORM_PLUGIN_CACHE_DIRECTORY=$$(cygpath -u "$(shell pwd -P)")/cache/plugins
	TERRAFORM_PLUGIN_EXTENSION=.exe
else
	TERRAFORM_PLATFORM=$$($(TERRAFORM_EXECUTABLE) -version | awk 'FNR == 2 {print $$2}')
	TERRAFORM_PLUGIN_CACHE_DIRECTORY=$(shell pwd -P)/cache/plugins
endif

TERRAFORM_PLUGIN_OUTPUT_DIRECTORY=./build
TERRAFORM_PLUGIN_EXECUTABLE=$(TERRAFORM_PLUGIN_OUTPUT_DIRECTORY)/$(NAME)_v$(VERSION)$(TERRAFORM_PLUGIN_EXTENSION)
TERRAFORM_PLUGIN_EXECUTABLE_EXAMPLE=$(TERRAFORM_PLUGIN_OUTPUT_DIRECTORY)/$(NAME)$(TERRAFORM_PLUGIN_EXTENSION)

default: build

.PHONY: clean
clean:
	rm -rf ./dist
	rm -rf ./cache
	rm -rf ./build
	rm -f ./example/test-api-creds-auth/outs_cred-tester__expect_*

.PHONY: build
build:
	mkdir -p "$(TERRAFORM_PLUGIN_OUTPUT_DIRECTORY)" "$(TERRAFORM_PLUGIN_CACHE_DIRECTORY)"
	rm -f "$(TERRAFORM_PLUGIN_EXECUTABLE)"
	go build -o "$(TERRAFORM_PLUGIN_EXECUTABLE)"

.PHONY: example
example: example-build example-init example-apply example-destroy

.PHONY: example-apply
example-apply:
	export TF_CLI_CONFIG_FILE="$(shell pwd -P)/example.tfrc" \
		&& export TF_DISABLE_CHECKPOINT="true" \
		&& export TF_PLUGIN_CACHE_DIR="$(TERRAFORM_PLUGIN_CACHE_DIRECTORY)" \
		&& cd ./example \
		&& $(TERRAFORM_EXECUTABLE) apply -auto-approve

.PHONY: example-build
example-build:
	mkdir -p "$(TERRAFORM_PLUGIN_OUTPUT_DIRECTORY)"
	rm -rf "$(TERRAFORM_PLUGIN_EXECUTABLE_EXAMPLE)"
	go build -o "$(TERRAFORM_PLUGIN_EXECUTABLE_EXAMPLE)"

.PHONY: example-destroy
example-destroy:
	export TF_CLI_CONFIG_FILE="$(shell pwd -P)/example.tfrc" \
		&& export TF_DISABLE_CHECKPOINT="true" \
		&& export TF_PLUGIN_CACHE_DIR="$(TERRAFORM_PLUGIN_CACHE_DIRECTORY)" \
		&& cd ./example \
		&& $(TERRAFORM_EXECUTABLE) destroy -auto-approve

.PHONY: example-init
example-init:
	export TF_CLI_CONFIG_FILE="$(shell pwd -P)/example.tfrc" \
		&& export TF_DISABLE_CHECKPOINT="true" \
		&& export TF_PLUGIN_CACHE_DIR="$(TERRAFORM_PLUGIN_CACHE_DIRECTORY)" \
		&& cd ./example \
		&& rm -f .terraform.lock.hcl \
		&& $(TERRAFORM_EXECUTABLE) init

.PHONY: example-plan
example-plan:
	export TF_CLI_CONFIG_FILE="$(shell pwd -P)/example.tfrc" \
		&& export TF_DISABLE_CHECKPOINT="true" \
		&& export TF_PLUGIN_CACHE_DIR="$(TERRAFORM_PLUGIN_CACHE_DIRECTORY)" \
		&& cd ./example \
		&& $(TERRAFORM_EXECUTABLE) plan

.PHONY: test-api-creds-auth
test-api-creds-auth:
	rm -f ./example/test-api-creds-auth/outs_cred-tester__expect_*
	export TF_CLI_CONFIG_FILE="$(shell pwd -P)/example/test-api-creds-auth/example.tfrc" \
		&& export TF_DISABLE_CHECKPOINT="true" \
		&& export TF_PLUGIN_CACHE_DIR="$(TERRAFORM_PLUGIN_CACHE_DIRECTORY)" \
		&& cd ./example/test-api-creds-auth \
		&& ./api-creds-tester.sh $(TERRAFORM_EXECUTABLE)

.PHONY: fmt
fmt:
	gofmt -s -w $$(find . -name '*.go')

.PHONY: init
init:
	go get ./...

.PHONY: test
test:
	go test ./...

.PHONY: testacc
testacc:
	@# explicitly add TF_ACC=1 to trigger the acceptance tests, `testacc.env` might be missing or incomplete
	@TF_ACC=1 env $$(cat testacc.env | xargs) go test --timeout=30m --tags=acceptance -count=1 -v github.com/bpg/terraform-provider-proxmox/fwprovider/...

.PHONY: lint
lint: ensure-golangci-lint
	# NOTE: This target is for local runs only. For linting in CI see .github/workflows/golangci-lint.yml
	golangci-lint fmt
	golangci-lint run --fix

.PHONY: ensure-golangci-lint
 ensure-golangci-lint:
	@CURRENT_VERSION=$$(golangci-lint version --short 2>/dev/null | sed 's/^v//' || echo "not installed"); \
 	if [ "$$CURRENT_VERSION" != "$(GOLANGCI_LINT_VERSION)" ]; then \
 		echo "Installing golangci-lint $(GOLANGCI_LINT_VERSION) (current: $$CURRENT_VERSION)"; \
 		curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $$(go env GOPATH)/bin v$(GOLANGCI_LINT_VERSION); \
 	fi

.PHONY: release-build
release-build:
	goreleaser build --clean --skip=validate

.PHONY: docs
docs:
	@mkdir -p ./build/docs-gen
	@go generate main.go

.PHONY: targets
targets: $(TARGETS)

.PHONY: $(TARGETS)
$(TARGETS):
	GOOS=$@ GOARCH=amd64 CGO_ENABLED=0 go build \
		-o "dist/$@/$(NAME)_v$(VERSION)-custom" \
		-a -ldflags '-extldflags "-static"'
	zip \
		-j "dist/$(NAME)_v$(VERSION)-custom_$@_amd64.zip" \
		"dist/$@/$(NAME)_v$(VERSION)-custom"
`````

## File: qodana.yaml
`````yaml
version: "1.0"
linter: jetbrains/qodana-go:2025.1
profile:
  name: qodana.recommended
exclude:
  - name: All
    paths:
      - CONTRIBUTORS.md
      - README.md
  - name: GoMixedReceiverTypes
  - name: CheckDependencyLicenses
include:
  - name: VulnerableLibrariesGlobal
`````

## File: README.md
`````markdown
# Terraform / OpenTofu Provider for Proxmox VE

[![GitHub release (latest by date)](https://img.shields.io/github/v/release/bpg/terraform-provider-proxmox)](https://github.com/bpg/terraform-provider-proxmox/releases/latest)
[![GitHub Release Date](https://img.shields.io/github/release-date/bpg/terraform-provider-proxmox)](https://github.com/bpg/terraform-provider-proxmox/releases/latest)
[![GitHub stars](https://img.shields.io/github/stars/bpg/terraform-provider-proxmox?style=flat)](https://github.com/bpg/terraform-provider-proxmox/stargazers)
[![All Contributors](https://img.shields.io/github/all-contributors/bpg/terraform-provider-proxmox)](#contributors)
[![Go Report Card](https://goreportcard.com/badge/github.com/bpg/terraform-provider-proxmox)](https://goreportcard.com/report/github.com/bpg/terraform-provider-proxmox)
[![Conventional Commits](https://img.shields.io/badge/conventional%20commits-v1.0.0-ff69b4)](https://www.conventionalcommits.org/en/v1.0.0/)
[![CodeRabbit Pull Request Reviews](https://img.shields.io/coderabbit/prs/github/bpg/terraform-provider-proxmox?utm_source=oss&utm_medium=github&utm_campaign=bpg%2Fterraform-provider-proxmox&color=FF570A&link=https%3A%2F%2Fcoderabbit.ai&label=CodeRabbit+Reviews)](https://www.coderabbit.ai/)

A Terraform / OpenTofu Provider that adds support for Proxmox Virtual Environment.

This repository is a fork of <https://github.com/danitso/terraform-provider-proxmox> which is no longer maintained.

## Disclaimer

This project is a personal open-source initiative and is not affiliated with, endorsed by, or associated with any of my current or former employers. All opinions, code, and documentation are solely those of myself and the individual contributors.

The project is not affiliated with [Proxmox Server Solutions GmbH](https://www.proxmox.com/en/about/about-us/company) or any of its subsidiaries. The use of the Proxmox name and/or logo is for informational purposes only and does not imply any endorsement or affiliation with the Proxmox project.

## Compatibility Promise

This provider is compatible with Proxmox VE 8.x (currently **8.4**).

> [!IMPORTANT]
> Proxmox VE 7.x is NOT supported. While some features might work with 7.x, we do not test against it, and issues specific to 7.x will not be addressed.

While the provider is on version 0.x, it is not guaranteed to be backward compatible with all previous minor versions.
However, we will try to maintain backward compatibility between provider versions as much as possible.

## Requirements

### Production Requirements

- [Proxmox Virtual Environment](https://www.proxmox.com/en/proxmox-virtual-environment/) 8.x
- TLS 1.3 for the Proxmox API endpoint (legacy TLS 1.2 is optionally supported)
- [Terraform](https://www.terraform.io/downloads.html) 1.5+ or [OpenTofu](https://opentofu.org) 1.6+

### Development Requirements

- [Go](https://golang.org/doc/install) 1.24 (to build the provider plugin)
- [Docker](https://www.docker.com/products/docker-desktop/) (optional, for running dev tools)

## Using the Provider

You can find the latest release and its documentation in the [Terraform Registry](https://registry.terraform.io/providers/bpg/proxmox/latest) or [OpenTofu Registry](https://search.opentofu.org/provider/bpg/proxmox/latest).

For manual provider installation, you can download the binaries from the [Releases](https://github.com/bpg/terraform-provider-proxmox/releases) page.
You also can use `gh` tool to verify the binaries provenance, see more details [here](https://github.com/bpg/terraform-provider-proxmox/attestations/).

## Testing the Provider

To test the provider, simply run `make test`.

```sh
make test
```

Tests are limited to regression tests, ensuring backward compatibility.

A limited number of acceptance tests are available in the `proxmoxtf/test` directory, mostly for "new" functionality implemented using the Terraform Provider Framework.
These tests are not run by default, as they require a Proxmox VE environment to be available.
They can be run using `make testacc`. The Proxmox connection can be configured using environment variables; see the provider documentation for details.

## Deploying the Example Resources

There are a number of TF examples in the `example` directory, which can be used to deploy a Container, VM, or other Proxmox resources in your test Proxmox environment.

### Prerequisites

The following assumptions are made about the test environment:

- It has one node named `pve`
- The node has local storages named `local` and `local-lvm`
- The "Snippets" content type is enabled in the `local` storage
- Default Linux Bridge "vmbr0" is VLAN aware (datacenter -> pve -> network -> edit & apply)

Create `example/terraform.tfvars` with the following variables:

```sh
virtual_environment_endpoint                 = "https://pve.example.doc:8006/"
virtual_environment_ssh_username             = "terraform"
virtual_environment_api_token                = "root@pam!terraform=00000000-0000-0000-0000-000000000000"
```

Then run `make example` to deploy the example resources.

If you don't have a free Proxmox cluster to play with, there is a dedicated [how-to tutorial](docs/guides/setup-proxmox-for-tests.md) on how to set up Proxmox inside a VM and run `make example` on it.

## Future Work

The provider is using the [Terraform SDKv2](https://developer.hashicorp.com/terraform/plugin/sdkv2), which is considered legacy and is in maintenance mode.
Work has started to migrate the provider to the new [Terraform Plugin Framework](https://developer.hashicorp.com/terraform/plugin/framework), with the aim of releasing it as a new major version **1.0**.

## Known Issues

### HA VMs / containers

If a VM or container resource is created with the provider but managed by an HA cluster, it might be migrated to a different node without the provider being aware of the change.
This causes a "configuration drift" and the provider will report an error when managing the resource.
You would need to manually reconcile the resource state stored in the backend to match the actual state of the resource, or remove the resource from the provider management.

### Serial Device Required for Debian 12 / Ubuntu VMs

Debian 12 and Ubuntu VMs throw kernel panic when resizing a cloud image boot disk, as they require a serial device configured.
Add the following block to your VM config:

```hcl
  serial_device {
    device = "socket"
  }
```

For more context, see #1639 and #1770.

### Disk Images Cannot Be Imported by Non-PAM Accounts

Due to limitations in the Proxmox VE API, certain actions need to be performed using SSH. This requires the use of a PAM account (standard Linux account).

### Disk Images from VMware Cannot Be Uploaded or Imported

Proxmox VE does not currently support VMware disk images directly.
However, you can still use them as disk images by using this workaround:

```hcl
resource "proxmox_virtual_environment_file" "vmdk_disk_image" {
  content_type = "iso"
  datastore_id = "datastore-id"
  node_name    = "node-name"

  source_file {
    # We must override the file extension to bypass the validation code
    # in the Proxmox VE API.
    file_name = "vmdk-file-name.img"
    path      = "path-to-vmdk-file"
  }
}

resource "proxmox_virtual_environment_vm" "example" {
  //...

  disk {
    datastore_id = "datastore-id"
    # We must tell the provider that the file format is vmdk instead of qcow2.
    file_format  = "vmdk"
    file_id      = "${proxmox_virtual_environment_file.vmdk_disk_image.id}"
  }

  //...
}
```

### Snippets Cannot Be Uploaded by Non-PAM Accounts

Due to limitations in the Proxmox VE API, certain files (snippets, backups) need to be uploaded using SFTP.
This requires the use of a PAM account (standard Linux account).

### Cluster Hardware Mappings Cannot Be Created by Non-PAM Accounts

Due to limitations in the Proxmox VE API, cluster hardware mappings must be created using the `root` PAM account (standard Linux account) due to [IOMMU](https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit#Virtualization) interactions.
Hardware mappings allow the use of [PCI "passthrough"](https://pve.proxmox.com/wiki/PCI_Passthrough) and [map physical USB ports](https://pve.proxmox.com/wiki/USB_Physical_Port_Mapping).

## Contributors

See [CONTRIBUTORS.md](CONTRIBUTORS.md) for a list of contributors to this project.

## Repository Metrics

<picture>
  <img src="https://gist.githubusercontent.com/bpg/2cc44ead81225542ed1ef0303d8f9eb9/raw/metrics.svg" alt="Metrics">
</picture>

## Sponsorship

‚ù§Ô∏è This project is sponsored by:

- [Elias Alvord](https://github.com/elias314)
- [laktosterror](https://github.com/laktosterror)
- [Greg Brant](https://github.com/gregbrant2)
- [Serge](https://github.com/sergelogvinov)
- [Daniel Brennand](https://github.com/dbrennand)
- [Brian King](https://github.com/inflatador)
- [Rados≈Çaw Szamszur](https://github.com/rszamszur)

Thanks again for your continuous support, it is much appreciated! üôè

## Acknowledgements

This project has been developed with **GoLand** IDE under the [JetBrains Open Source license](https://www.jetbrains.com/community/opensource/#support), generously provided by JetBrains s.r.o.

<img src="https://resources.jetbrains.com/storage/products/company/brand/logos/GoLand_icon.png" alt="GoLand logo" width="80">
`````

## File: release-please-config.json
`````json
{
    "$schema": "https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json",
    "signoff":  "Pavel Boldyrev <627562+bpg@users.noreply.github.com>",
    "packages": {
        ".": {
            "changelog-path": "CHANGELOG.md",
            "release-type": "go",
            "skip-github-release": false,
            "bump-minor-pre-major": true,
            "include-v-in-tag": true,
            "draft": false,
            "prerelease": false,
            "extra-files": [
                "Makefile",
                "examples/guides/cloud-image/centos-qcow2/provider.tf",
                "examples/guides/cloud-image/debian-from-storage/provider.tf",
                "examples/guides/cloud-image/ubuntu-img/provider.tf",
                "examples/guides/cloud-init/custom/provider.tf",
                "examples/guides/cloud-init/native/provider.tf",
                "examples/guides/clone-vm/provider.tf"
            ],
            "changelog-sections": [
                {
                    "type": "feat",
                    "section": "Features",
                    "hidden": false
                },
                {
                    "type": "fix",
                    "section": "Bug Fixes",
                    "hidden": false
                },
                {
                    "type": "chore",
                    "section": "Miscellaneous",
                    "hidden": false
                }
            ]
        }
    }
  }
`````

## File: terraform-registry-manifest.json
`````json
{
  "version": 1,
  "metadata": {
    "protocol_versions": [
      "6.0"
    ]
  }
}
`````

## File: testacc
`````
#!/bin/sh

#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#

# shellcheck disable=SC2046
TF_ACC=1 env $(xargs < testacc.env) go test -count 1 --tags=acceptance -timeout 360s -run "$1" github.com/bpg/terraform-provider-proxmox/fwprovider/... $2
`````
